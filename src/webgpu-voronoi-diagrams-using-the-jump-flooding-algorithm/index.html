<!doctype html>
<notebook theme="air">
  <title>WebGPU Voronoi Diagrams using the Jump Flooding Algorithm</title>
  <script id="intro" type="text/markdown">
# GPU Voronoi Diagrams using the Jump Flooding Algorithm

This notebook demonstrates the Jump Flooding Algorithm (JFA) of Rong and Tan applied to 3D rendered geometry. Two interlocking (2,3) torus knots are rendered with an orbiting camera, and object IDs are written to a texture. The JFA computes a distance field from object boundaries, enabling effects like outlines and hover detection.

The algorithm is useful because its speed depends on the number of pixels in the output image rather than the amount or complexity of geometry.

References:

- G. Rong, T.-S. Tan, *[Jump Flooding in GPU with Applications to Voronoi Diagram and Distance Transform](https://www.comp.nus.edu.sg/~tants/jfa/i3d06.pdf)*
- Alan Wolfe, *[Fast Voronoi Diagrams and Distance Field Textures on the GPU With the Jump Flooding Algorithm](https://blog.demofox.org/2016/02/29/fast-voronoi-diagrams-and-distance-dield-textures-on-the-gpu-with-the-jump-flooding-algorithm/)*
- Ryan Kaplan, *[Voronoi Diagrams on the GPU](http://rykap.com/graphics/skew/2016/02/25/voronoi-diagrams/)*
- Claudio Esparança, *[Jump Flooding](https://observablehq.com/@esperanc/jump-flooding)*
  </script>
  <script id="webgpu-setup" type="module">
if (!navigator.gpu) {
  display(html`<p style="color: red;">WebGPU is not supported in this browser.</p>`);
  throw new Error('WebGPU not supported');
}

const adapter = await navigator.gpu.requestAdapter();
if (!adapter) throw new Error('Failed to get WebGPU adapter');

const device = await adapter.requestDevice();
const canvasFormat = navigator.gpu.getPreferredCanvasFormat();

invalidation.then(() => device.destroy());
  </script>
  <script id="canvas" type="module">
const dpr = window.devicePixelRatio || 1;
const canvasWidth = Math.min(800, width);
const canvasHeight = Math.max(Math.floor(canvasWidth * 0.7), 400);

const canvas = document.createElement('canvas');
canvas.id = 'torus-canvas';
canvas.width = Math.floor(canvasWidth * dpr);
canvas.height = Math.floor(canvasHeight * dpr);
canvas.style.width = `${canvasWidth}px`;
canvas.style.height = `${canvasHeight}px`;

const gpuContext = canvas.getContext('webgpu');
gpuContext.configure({
  device,
  format: canvasFormat,
  alphaMode: 'opaque'
});

display(html`<figure style="margin: 0;" id="torus-figure">${canvas}</figure>`);

// Track mouse position
const mouseState = { x: -1, y: -1, hovering: false };

canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  mouseState.x = (e.clientX - rect.left) * dpr;
  mouseState.y = (e.clientY - rect.top) * dpr;
  mouseState.hovering = true;
});

canvas.addEventListener('mouseleave', () => {
  mouseState.hovering = false;
});
  </script>
  <script id="jfa-passes-control" type="module">
const jfaPassesInput = Inputs.range([1, 11], {
  value: 8,
  label: 'JFA passes',
  step: 1
});
const jfaPasses = Generators.input(jfaPassesInput);
display(jfaPassesInput);
  </script>
  <script id="outline-width-control" type="module">
const maxOutlineWidth = Math.pow(2, jfaPasses - 1);
const outlineWidthInput = Inputs.range([1, maxOutlineWidth], {
  value: maxOutlineWidth,
  label: 'Outline width',
  transform: Math.log,
  step: 1
});
const outlineWidth = Generators.input(outlineWidthInput);
display(outlineWidthInput);
  </script>
  <script id="torus-knot-geometry" type="module">
// Generate torus knot geometry using standard parametric equations
// p wraps around the torus p times, q wraps through the hole q times
function createTorusKnot(p, q, radius, tubeRadius, tubularSegments, radialSegments, azimuthalPhase = 0) {
  const positions = [];
  const normals = [];
  const indices = [];

  // Helper to compute point on torus knot curve
  function torusKnotPoint(u) {
    const cu = Math.cos(u + azimuthalPhase);
    const su = Math.sin(u + azimuthalPhase);
    const quOverP = q / p * u;
    const cqu = Math.cos(quOverP);
    const squ = Math.sin(quOverP);
    const r = radius * (2 + cqu);
    return [r * cu, r * su, radius * squ];
  }

  // Helper to compute tangent by finite difference
  function torusKnotTangent(u) {
    const delta = 0.0001;
    const p0 = torusKnotPoint(u - delta);
    const p1 = torusKnotPoint(u + delta);
    const t = [p1[0] - p0[0], p1[1] - p0[1], p1[2] - p0[2]];
    const len = Math.sqrt(t[0]*t[0] + t[1]*t[1] + t[2]*t[2]);
    return [t[0]/len, t[1]/len, t[2]/len];
  }

  function cross(a, b) {
    return [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]];
  }

  function normalize(v) {
    const len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
    return [v[0]/len, v[1]/len, v[2]/len];
  }

  function dot(a, b) {
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
  }

  // Generate vertices
  for (let i = 0; i <= tubularSegments; i++) {
    const u = (i / tubularSegments) * Math.PI * 2 * p;
    const curvePoint = torusKnotPoint(u);
    const T = torusKnotTangent(u);

    // Compute normal frame
    let up = [0, 0, 1];
    if (Math.abs(dot(T, up)) > 0.9) {
      up = [1, 0, 0];
    }
    const N = normalize(cross(T, up));
    const B = cross(T, N);

    for (let j = 0; j <= radialSegments; j++) {
      const theta = (j / radialSegments) * Math.PI * 2;
      const cos_theta = Math.cos(theta);
      const sin_theta = Math.sin(theta);

      // Normal direction on tube surface
      const nx = cos_theta * N[0] + sin_theta * B[0];
      const ny = cos_theta * N[1] + sin_theta * B[1];
      const nz = cos_theta * N[2] + sin_theta * B[2];

      // Position = curve point + tubeRadius * normal
      positions.push(
        curvePoint[0] + tubeRadius * nx,
        curvePoint[1] + tubeRadius * ny,
        curvePoint[2] + tubeRadius * nz
      );
      normals.push(nx, ny, nz);
    }
  }

  // Generate indices
  for (let i = 0; i < tubularSegments; i++) {
    for (let j = 0; j < radialSegments; j++) {
      const a = i * (radialSegments + 1) + j;
      const b = a + radialSegments + 1;
      const c = a + 1;
      const d = b + 1;

      indices.push(a, b, c);
      indices.push(c, b, d);
    }
  }

  return {
    positions: new Float32Array(positions),
    normals: new Float32Array(normals),
    indices: new Uint32Array(indices)
  };
}

// Create two interlocking torus knots
// Phase offset of π/3 shifts the azimuthal angle to create interlocking
const knot1 = createTorusKnot(2, 3, 0.5, 0.15, 128, 24, 0);
const knot2 = createTorusKnot(2, 3, 0.5, 0.15, 128, 24, Math.PI / 3);

console.log('Knot vertices:', knot1.positions.length / 3, 'triangles:', knot1.indices.length / 3);
  </script>
  <script id="geometry-buffers" type="module">
// Create GPU buffers for geometry
function createGeometryBuffers(geometry, label) {
  const positionBuffer = device.createBuffer({
    label: `${label}-positions`,
    size: geometry.positions.byteLength,
    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
  });
  device.queue.writeBuffer(positionBuffer, 0, geometry.positions);

  const normalBuffer = device.createBuffer({
    label: `${label}-normals`,
    size: geometry.normals.byteLength,
    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
  });
  device.queue.writeBuffer(normalBuffer, 0, geometry.normals);

  const indexBuffer = device.createBuffer({
    label: `${label}-indices`,
    size: geometry.indices.byteLength,
    usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST
  });
  device.queue.writeBuffer(indexBuffer, 0, geometry.indices);

  return {
    positionBuffer,
    normalBuffer,
    indexBuffer,
    indexCount: geometry.indices.length
  };
}

const knot1Buffers = createGeometryBuffers(knot1, 'knot1');
const knot2Buffers = createGeometryBuffers(knot2, 'knot2');

invalidation.then(() => {
  knot1Buffers.positionBuffer.destroy();
  knot1Buffers.normalBuffer.destroy();
  knot1Buffers.indexBuffer.destroy();
  knot2Buffers.positionBuffer.destroy();
  knot2Buffers.normalBuffer.destroy();
  knot2Buffers.indexBuffer.destroy();
});
  </script>
  <script id="render-textures" type="module">
// Create textures for:
// 1. Object ID (for JFA input) - rgba32uint
// 2. Depth buffer
// 3. JFA ping-pong textures

function createTextures(w, h) {
  const objectIdTexture = device.createTexture({
    label: 'object-id-texture',
    size: [w, h],
    format: 'rgba32uint',
    usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC
  });

  const depthTexture = device.createTexture({
    label: 'depth-texture',
    size: [w, h],
    format: 'depth24plus',
    usage: GPUTextureUsage.RENDER_ATTACHMENT
  });

  const colorTexture = device.createTexture({
    label: 'color-texture',
    size: [w, h],
    format: 'rgba8unorm',
    usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
  });

  const jfaTextures = [0, 1].map(i => device.createTexture({
    label: `jfa-texture-${i}`,
    size: [w, h],
    format: 'rgba32uint',
    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST
  }));

  return { objectIdTexture, depthTexture, colorTexture, jfaTextures };
}

let textures = createTextures(canvas.width, canvas.height);

invalidation.then(() => {
  textures.objectIdTexture.destroy();
  textures.depthTexture.destroy();
  textures.colorTexture.destroy();
  textures.jfaTextures.forEach(t => t.destroy());
});
  </script>
  <script id="geometry-shader" type="module">
// Shader for rendering geometry with diffuse lighting + object ID output
const geometryShaderCode = /* wgsl */`
struct Uniforms {
  projViewMatrix: mat4x4f,
  modelMatrix: mat4x4f,
  normalMatrix: mat4x4f,
  color: vec3f,
  objectId: u32,
  lightDir: vec3f,
  _pad: f32,
}

@group(0) @binding(0) var<uniform> uniforms: Uniforms;

struct VertexInput {
  @location(0) position: vec3f,
  @location(1) normal: vec3f,
}

struct VertexOutput {
  @builtin(position) position: vec4f,
  @location(0) worldNormal: vec3f,
  @location(1) worldPos: vec3f,
}

@vertex
fn vertexMain(input: VertexInput) -> VertexOutput {
  let worldPos = uniforms.modelMatrix * vec4f(input.position, 1.0);
  let worldNormal = (uniforms.normalMatrix * vec4f(input.normal, 0.0)).xyz;

  var output: VertexOutput;
  output.position = uniforms.projViewMatrix * worldPos;
  output.worldNormal = worldNormal;
  output.worldPos = worldPos.xyz;
  return output;
}

struct FragmentOutput {
  @location(0) color: vec4f,
  @location(1) objectId: vec4u,
}

@fragment
fn fragmentMain(input: VertexOutput) -> FragmentOutput {
  let N = normalize(input.worldNormal);
  let L = normalize(uniforms.lightDir);

  // Simple diffuse + ambient
  let ambient = 0.3;
  let diffuse = max(dot(N, L), 0.0) * 0.7;
  let color = uniforms.color * (ambient + diffuse);

  var output: FragmentOutput;
  output.color = vec4f(color, 1.0);

  // Store object ID and screen position for JFA
  let screenPos = vec2u(input.position.xy);
  output.objectId = vec4u(screenPos.x + 1u, screenPos.y + 1u, uniforms.objectId, 0u);

  return output;
}
`;

const geometryModule = device.createShaderModule({
  label: 'geometry-shader',
  code: geometryShaderCode
});

const geometryPipeline = device.createRenderPipeline({
  label: 'geometry-pipeline',
  layout: 'auto',
  vertex: {
    module: geometryModule,
    entryPoint: 'vertexMain',
    buffers: [
      {
        arrayStride: 12,
        attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x3' }]
      },
      {
        arrayStride: 12,
        attributes: [{ shaderLocation: 1, offset: 0, format: 'float32x3' }]
      }
    ]
  },
  fragment: {
    module: geometryModule,
    entryPoint: 'fragmentMain',
    targets: [
      { format: 'rgba8unorm' },
      { format: 'rgba32uint' }
    ]
  },
  depthStencil: {
    format: 'depth24plus',
    depthWriteEnabled: true,
    depthCompare: 'less'
  },
  primitive: {
    topology: 'triangle-list',
    cullMode: 'none'  // Disable culling for debugging
  }
});

// Debug pipeline - single render target for direct screen output
const debugShaderCode = /* wgsl */`
struct Uniforms {
  projViewMatrix: mat4x4f,
  modelMatrix: mat4x4f,
  normalMatrix: mat4x4f,
  color: vec3f,
  objectId: u32,
  lightDir: vec3f,
  _pad: f32,
}

@group(0) @binding(0) var<uniform> uniforms: Uniforms;

struct VertexInput {
  @location(0) position: vec3f,
  @location(1) normal: vec3f,
}

struct VertexOutput {
  @builtin(position) position: vec4f,
  @location(0) normal: vec3f,
}

@vertex
fn vertexMain(input: VertexInput) -> VertexOutput {
  var output: VertexOutput;
  let worldPos = uniforms.modelMatrix * vec4f(input.position, 1.0);
  output.position = uniforms.projViewMatrix * worldPos;
  output.normal = (uniforms.normalMatrix * vec4f(input.normal, 0.0)).xyz;
  return output;
}

@fragment
fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {
  let N = normalize(input.normal);
  let L = normalize(uniforms.lightDir);
  let diffuse = max(dot(N, L), 0.0) * 0.7 + 0.3;
  return vec4f(uniforms.color * diffuse, 1.0);
}
`;

const debugModule = device.createShaderModule({
  label: 'debug-shader',
  code: debugShaderCode
});

const debugPipeline = device.createRenderPipeline({
  label: 'debug-pipeline',
  layout: 'auto',
  vertex: {
    module: debugModule,
    entryPoint: 'vertexMain',
    buffers: [
      {
        arrayStride: 12,
        attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x3' }]
      },
      {
        arrayStride: 12,
        attributes: [{ shaderLocation: 1, offset: 0, format: 'float32x3' }]
      }
    ]
  },
  fragment: {
    module: debugModule,
    entryPoint: 'fragmentMain',
    targets: [{ format: canvasFormat }]
  },
  depthStencil: {
    format: 'depth24plus',
    depthWriteEnabled: true,
    depthCompare: 'less'
  },
  primitive: {
    topology: 'triangle-list',
    cullMode: 'none'
  }
});


// Uniform buffers for each knot
const uniformBufferSize = 256; // Aligned size for struct with 3 matrices
const knot1UniformBuffer = device.createBuffer({
  label: 'knot1-uniforms',
  size: uniformBufferSize,
  usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
});

const knot2UniformBuffer = device.createBuffer({
  label: 'knot2-uniforms',
  size: uniformBufferSize,
  usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
});

const knot1BindGroup = device.createBindGroup({
  layout: geometryPipeline.getBindGroupLayout(0),
  entries: [{ binding: 0, resource: { buffer: knot1UniformBuffer } }]
});

const knot2BindGroup = device.createBindGroup({
  layout: geometryPipeline.getBindGroupLayout(0),
  entries: [{ binding: 0, resource: { buffer: knot2UniformBuffer } }]
});

invalidation.then(() => {
  knot1UniformBuffer.destroy();
  knot2UniformBuffer.destroy();
});
  </script>
  <script id="jfa-shader" type="module">
// JFA compute shader - propagates closest seed information
const jfaShaderCode = /* wgsl */`
@group(0) @binding(0) var srcTexture: texture_2d<u32>;
@group(0) @binding(1) var dstTexture: texture_storage_2d<rgba32uint, write>;

struct Uniforms {
  resolution: vec2f,
  stepSize: f32,
  _padding: f32,
}
@group(0) @binding(2) var<uniform> uniforms: Uniforms;

@compute @workgroup_size(8, 8)
fn main(@builtin(global_invocation_id) gid: vec3u) {
  let coord = vec2i(gid.xy);
  let resolution = vec2i(uniforms.resolution);

  if (coord.x >= resolution.x || coord.y >= resolution.y) { return; }

  let stepSize = i32(uniforms.stepSize);
  let invRes = 1.0 / max(uniforms.resolution.x, uniforms.resolution.y);

  var bestSeed = vec4u(0u);
  var bestDist = 1e10;

  for (var i = -1; i <= 1; i++) {
    for (var j = -1; j <= 1; j++) {
      let sampleCoord = coord + vec2i(i, j) * stepSize;

      if (sampleCoord.x < 0 || sampleCoord.x >= resolution.x ||
          sampleCoord.y < 0 || sampleCoord.y >= resolution.y) {
        continue;
      }

      let seed = textureLoad(srcTexture, sampleCoord, 0);

      if (seed.x == 0u && seed.y == 0u) { continue; }

      let seedPos = vec2f(f32(seed.x - 1u), f32(seed.y - 1u));
      let currentPos = vec2f(gid.xy);

      let dxy = (seedPos - currentPos) * invRes;
      let dist = dot(dxy, dxy);

      if (dist < bestDist) {
        bestDist = dist;
        bestSeed = seed;
      }
    }
  }

  textureStore(dstTexture, coord, bestSeed);
}
`;

const jfaModule = device.createShaderModule({
  label: 'jfa-shader',
  code: jfaShaderCode
});

const jfaPipeline = device.createComputePipeline({
  label: 'jfa-pipeline',
  layout: 'auto',
  compute: {
    module: jfaModule,
    entryPoint: 'main'
  }
});

// Create uniform buffers for each JFA pass
const maxJfaPasses = 12;
const jfaUniformBuffers = [];
for (let i = 0; i < maxJfaPasses; i++) {
  jfaUniformBuffers.push(device.createBuffer({
    label: `jfa-uniforms-${i}`,
    size: 16,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
  }));
}

invalidation.then(() => {
  jfaUniformBuffers.forEach(b => b.destroy());
});
  </script>
  <script id="composite-shader" type="module">
// Final composite shader - combines color with JFA-based outline
const compositeShaderCode = /* wgsl */`
struct VertexOutput {
  @builtin(position) position: vec4f,
  @location(0) uv: vec2f,
}

@vertex
fn vertexMain(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {
  var pos = array<vec2f, 3>(
    vec2f(-1.0, -1.0),
    vec2f(3.0, -1.0),
    vec2f(-1.0, 3.0)
  );
  var output: VertexOutput;
  output.position = vec4f(pos[vertexIndex], 0.0, 1.0);
  output.uv = (pos[vertexIndex] + 1.0) * 0.5;
  return output;
}

@group(0) @binding(0) var colorTexture: texture_2d<f32>;
@group(0) @binding(1) var jfaTexture: texture_2d<u32>;
@group(0) @binding(2) var objectIdTexture: texture_2d<u32>;

struct Uniforms {
  resolution: vec2f,
  outlineWidth: f32,
  hovering: f32,
  mousePos: vec2f,
  _padding: vec2f,
}
@group(0) @binding(3) var<uniform> uniforms: Uniforms;

@fragment
fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {
  let pixelCoord = vec2i(input.uv * uniforms.resolution);
  let flippedCoord = vec2i(pixelCoord.x, i32(uniforms.resolution.y) - 1 - pixelCoord.y);

  // Sample textures
  let color = textureLoad(colorTexture, flippedCoord, 0);
  let jfaData = textureLoad(jfaTexture, flippedCoord, 0);
  let objectData = textureLoad(objectIdTexture, flippedCoord, 0);

  // Get hovered object ID by sampling JFA texture at mouse position (after expansion)
  // Only select object if mouse is within outline width of that object
  let mouseCoord = vec2i(i32(uniforms.mousePos.x), i32(uniforms.mousePos.y));
  let mouseJfaData = textureLoad(jfaTexture, mouseCoord, 0);
  let mouseObjectData = textureLoad(objectIdTexture, mouseCoord, 0);

  // Check distance from mouse to nearest seed
  var mouseDist = 1e10;
  if (mouseJfaData.x > 0u || mouseJfaData.y > 0u) {
    let mouseSeedPos = vec2f(f32(mouseJfaData.x - 1u), f32(mouseJfaData.y - 1u));
    let mousePos = vec2f(mouseCoord);
    mouseDist = distance(mouseSeedPos, mousePos);
  }

  // Only hover if: directly on object OR within outline width of object
  let mouseOnObject = (mouseObjectData.x > 0u || mouseObjectData.y > 0u);
  let mouseNearObject = mouseDist < uniforms.outlineWidth;
  let hoveredObjectId = select(0u, mouseJfaData.z, uniforms.hovering > 0.5 && (mouseOnObject || mouseNearObject));

  // Get distance to nearest seed
  var dist = 0.0;
  if (jfaData.x > 0u || jfaData.y > 0u) {
    let seedPos = vec2f(f32(jfaData.x - 1u), f32(jfaData.y - 1u));
    let currentPos = vec2f(flippedCoord);
    dist = distance(seedPos, currentPos);
  }

  // Get object IDs
  let currentObjectId = objectData.z;
  let nearestObjectId = jfaData.z;

  // Determine if this is an outline pixel:
  // We're on an outline if we're close to a boundary between different objects
  let isBackground = (objectData.x == 0u && objectData.y == 0u);
  let nearDifferentObject = (currentObjectId != nearestObjectId) && (jfaData.x > 0u || jfaData.y > 0u);

  // Hard cutoff for outline
  let inOutline = nearDifferentObject && dist < uniforms.outlineWidth;

  // Check if this pixel belongs to or is near the hovered object (respecting outline width)
  let isHoveredObject = (currentObjectId == hoveredObjectId) && (hoveredObjectId > 0u);
  let isNearHoveredObject = (nearestObjectId == hoveredObjectId) && (hoveredObjectId > 0u) && (dist < uniforms.outlineWidth);

  // Outline color based on the nearest object
  var outlineColor = vec3f(0.0);
  if (nearestObjectId == 1u) {
    outlineColor = vec3f(0.4, 0.7, 1.0); // Blue outline for knot 1
  } else if (nearestObjectId == 2u) {
    outlineColor = vec3f(1.0, 0.6, 0.3); // Orange outline for knot 2
  }

  // Highlight color for hover (lighter version of the object's color)
  var hoverOutlineColor = vec3f(0.7, 0.85, 1.0); // Light blue default
  if (hoveredObjectId == 1u) {
    hoverOutlineColor = vec3f(0.7, 0.85, 1.0); // Light blue for knot 1
  } else if (hoveredObjectId == 2u) {
    hoverOutlineColor = vec3f(1.0, 0.8, 0.6); // Light orange for knot 2
  }

  // Sawtooth ramp based on distance (creates repeating bands)
  let bandWidth = 32.0; // pixels per band
  let ramp = fract(dist / bandWidth);
  let bandShade = 0.9 + 0.1 * ramp; // gentle variation from 0.85 to 1.0

  // Apply outline with hard cutoff
  var finalColor = color.rgb;
  if (isBackground) {
    finalColor = vec3f(0.95); // Light gray background
    if (inOutline) {
      // Use hover color if this outline belongs to hovered object
      let baseOutline = select(outlineColor, hoverOutlineColor, isNearHoveredObject);
      finalColor = baseOutline * bandShade;
    }
  } else {
    // Darken edges where objects meet
    if (inOutline) {
      finalColor = finalColor * 0.5 * bandShade;
    }
  }

  // Highlight hovered object with a lighter tint of its own color
  if (isHoveredObject) {
    finalColor = mix(finalColor, hoverOutlineColor, 0.3) * 1.15;
  }

  return vec4f(finalColor, 1.0);
}
`;

const compositeModule = device.createShaderModule({
  label: 'composite-shader',
  code: compositeShaderCode
});

const compositePipeline = device.createRenderPipeline({
  label: 'composite-pipeline',
  layout: 'auto',
  vertex: {
    module: compositeModule,
    entryPoint: 'vertexMain'
  },
  fragment: {
    module: compositeModule,
    entryPoint: 'fragmentMain',
    targets: [{ format: canvasFormat }]
  },
  primitive: {
    topology: 'triangle-list'
  }
});

const compositeUniformBuffer = device.createBuffer({
  label: 'composite-uniforms',
  size: 32, // resolution(8) + outlineWidth(4) + hovering(4) + mousePos(8) + padding(8)
  usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
});

invalidation.then(() => {
  compositeUniformBuffer.destroy();
});
  </script>
  <script id="camera" type="module">
// Simple orbiting camera
const camera = {
  distance: 4.0,
  fov: Math.PI / 3,
  near: 0.1,
  far: 100
};

function getProjectionMatrix(aspect) {
  const f = 1.0 / Math.tan(camera.fov / 2);
  const rangeInv = 1 / (camera.near - camera.far);
  return new Float32Array([
    f / aspect, 0, 0, 0,
    0, f, 0, 0,
    0, 0, camera.far * rangeInv, -1,
    0, 0, camera.near * camera.far * rangeInv, 0
  ]);
}

// Write projection matrix into existing buffer (no allocation)
function getProjectionMatrixInto(out, aspect) {
  const f = 1.0 / Math.tan(camera.fov / 2);
  const rangeInv = 1 / (camera.near - camera.far);
  out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
  out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
  out[8] = 0; out[9] = 0; out[10] = camera.far * rangeInv; out[11] = -1;
  out[12] = 0; out[13] = 0; out[14] = camera.near * camera.far * rangeInv; out[15] = 0;
}

function getViewMatrix(time) {
  const out = new Float32Array(16);
  getViewMatrixInto(out, time);
  return out;
}

// Write view matrix into existing buffer (no allocation)
function getViewMatrixInto(out, time) {
  // Orbiting camera - rotates around the scene
  const angle = time * 0.3;
  const elevation = 0.0;
  const eyeX = camera.distance * Math.cos(angle) * Math.cos(elevation);
  const eyeY = camera.distance * Math.sin(elevation);
  const eyeZ = camera.distance * Math.sin(angle) * Math.cos(elevation);

  // Forward = normalize(target - eye), target is origin
  let fx = -eyeX, fy = -eyeY, fz = -eyeZ;
  let flen = Math.sqrt(fx*fx + fy*fy + fz*fz);
  fx /= flen; fy /= flen; fz /= flen;

  // Right = normalize(forward × up), up is [0,1,0]
  let rx = fy * 0 - fz * 1;
  let ry = fz * 0 - fx * 0;
  let rz = fx * 1 - fy * 0;
  let rlen = Math.sqrt(rx*rx + ry*ry + rz*rz);
  rx /= rlen; ry /= rlen; rz /= rlen;

  // Up = right × forward
  const ux = ry * fz - rz * fy;
  const uy = rz * fx - rx * fz;
  const uz = rx * fy - ry * fx;

  // View matrix (column-major)
  out[0] = rx; out[1] = ux; out[2] = -fx; out[3] = 0;
  out[4] = ry; out[5] = uy; out[6] = -fy; out[7] = 0;
  out[8] = rz; out[9] = uz; out[10] = -fz; out[11] = 0;
  out[12] = -(rx*eyeX + ry*eyeY + rz*eyeZ);
  out[13] = -(ux*eyeX + uy*eyeY + uz*eyeZ);
  out[14] = -(-fx*eyeX - fy*eyeY - fz*eyeZ);
  out[15] = 1;
}

function multiplyMatrices(a, b) {
  const result = new Float32Array(16);
  multiplyMatricesInto(result, a, b);
  return result;
}

// Write matrix multiplication result into existing buffer (no allocation)
function multiplyMatricesInto(out, a, b) {
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      let sum = 0;
      for (let k = 0; k < 4; k++) {
        sum += a[i + k*4] * b[k + j*4];
      }
      out[i + j*4] = sum;
    }
  }
}

// Rotation matrices (column-major)
function rotationMatrixX(angle) {
  const c = Math.cos(angle);
  const s = Math.sin(angle);
  return new Float32Array([
    1, 0, 0, 0,
    0, c, s, 0,
    0, -s, c, 0,
    0, 0, 0, 1
  ]);
}

function rotationMatrixY(angle) {
  const c = Math.cos(angle);
  const s = Math.sin(angle);
  return new Float32Array([
    c, 0, -s, 0,
    0, 1, 0, 0,
    s, 0, c, 0,
    0, 0, 0, 1
  ]);
}

function rotationMatrixZ(angle) {
  const c = Math.cos(angle);
  const s = Math.sin(angle);
  return new Float32Array([
    c, s, 0, 0,
    -s, c, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
  ]);
}

// Identity matrix
function identityMatrix() {
  return new Float32Array([
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
  ]);
}
  </script>
  <script id="render-loop" type="module">
import { createFrameLoop } from './lib/frame-loop.js';

outlineWidth; jfaPasses;

// Pre-allocate uniform data
const uniformData = new ArrayBuffer(256);
const uniformF32 = new Float32Array(uniformData);
const uniformU32 = new Uint32Array(uniformData);
const jfaUniformData = new Float32Array(4);
const compositeUniformData = new Float32Array(8);

// Pre-allocate matrix buffers (avoid allocation in render loop)
const projMatrix = new Float32Array(16);
const viewMatrix = new Float32Array(16);
const projViewMatrix = new Float32Array(16);
const identityMat = new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);

// Pre-create texture views (reused every frame)
const colorTextureView = textures.colorTexture.createView();
const objectIdTextureView = textures.objectIdTexture.createView();
const depthTextureView = textures.depthTexture.createView();
const jfaTextureViews = textures.jfaTextures.map(t => t.createView());

// Pre-create JFA bind groups for all passes (both ping-pong directions)
// We create bindings for passes 0..maxJfaPasses-1, for both src=0 and src=1
const jfaBindGroupsPrebuilt = [];
for (let srcIndex = 0; srcIndex < 2; srcIndex++) {
  const groups = [];
  for (let i = 0; i < maxJfaPasses; i++) {
    groups.push(device.createBindGroup({
      layout: jfaPipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: jfaTextureViews[srcIndex] },
        { binding: 1, resource: jfaTextureViews[1 - srcIndex] },
        { binding: 2, resource: { buffer: jfaUniformBuffers[i] } }
      ]
    }));
  }
  jfaBindGroupsPrebuilt.push(groups);
}

// Pre-create composite bind groups (one for each possible JFA result texture)
const compositeBindGroupsPrebuilt = [0, 1].map(jfaResultIndex =>
  device.createBindGroup({
    layout: compositePipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: colorTextureView },
      { binding: 1, resource: jfaTextureViews[jfaResultIndex] },
      { binding: 2, resource: objectIdTextureView },
      { binding: 3, resource: { buffer: compositeUniformBuffer } }
    ]
  })
);

// Pre-compute JFA uniforms (only need to update when jfaPasses changes)
let lastJfaPasses = -1;

const loop = createFrameLoop((timestamp) => {
  const time = timestamp / 1000;
  const encoder = device.createCommandEncoder();

  // Camera matrices (write into pre-allocated buffers)
  const aspect = canvas.width / canvas.height;
  getProjectionMatrixInto(projMatrix, aspect);
  getViewMatrixInto(viewMatrix, time);
  multiplyMatricesInto(projViewMatrix, projMatrix, viewMatrix);

  // Light direction (fixed in world space)
  const lightDir = [0.5, 0.8, 0.3];

  // Update knot 1 uniforms (blue-ish)
  // Struct layout: projViewMatrix(64) + modelMatrix(64) + normalMatrix(64) + color(12) + objectId(4) + lightDir(12) + pad(4) = 224
  uniformF32.set(projViewMatrix, 0);  // projViewMatrix: offset 0
  uniformF32.set(identityMat, 16);    // modelMatrix: offset 64
  uniformF32.set(identityMat, 32);    // normalMatrix: offset 128
  uniformF32[48] = 0.3; uniformF32[49] = 0.5; uniformF32[50] = 0.9; // color: offset 192
  uniformU32[51] = 1; // objectId: offset 204
  uniformF32[52] = lightDir[0]; uniformF32[53] = lightDir[1]; uniformF32[54] = lightDir[2]; // lightDir: offset 208
  device.queue.writeBuffer(knot1UniformBuffer, 0, uniformData, 0, 224);

  // Update knot 2 uniforms (orange-ish)
  uniformF32[48] = 0.9; uniformF32[49] = 0.5; uniformF32[50] = 0.2; // color
  uniformU32[51] = 2; // objectId
  device.queue.writeBuffer(knot2UniformBuffer, 0, uniformData, 0, 224);

  // 1. Render geometry pass (color + object ID)
  const geometryPass = encoder.beginRenderPass({
    colorAttachments: [
      {
        view: colorTextureView,
        loadOp: 'clear',
        storeOp: 'store',
        clearValue: { r: 0.95, g: 0.95, b: 0.95, a: 1.0 }
      },
      {
        view: objectIdTextureView,
        loadOp: 'clear',
        storeOp: 'store',
        clearValue: { r: 0, g: 0, b: 0, a: 0 }
      }
    ],
    depthStencilAttachment: {
      view: depthTextureView,
      depthClearValue: 1.0,
      depthLoadOp: 'clear',
      depthStoreOp: 'store'
    }
  });

  geometryPass.setPipeline(geometryPipeline);

  // Draw knot 1
  geometryPass.setBindGroup(0, knot1BindGroup);
  geometryPass.setVertexBuffer(0, knot1Buffers.positionBuffer);
  geometryPass.setVertexBuffer(1, knot1Buffers.normalBuffer);
  geometryPass.setIndexBuffer(knot1Buffers.indexBuffer, 'uint32');
  geometryPass.drawIndexed(knot1Buffers.indexCount);

  // Draw knot 2
  geometryPass.setBindGroup(0, knot2BindGroup);
  geometryPass.setVertexBuffer(0, knot2Buffers.positionBuffer);
  geometryPass.setVertexBuffer(1, knot2Buffers.normalBuffer);
  geometryPass.setIndexBuffer(knot2Buffers.indexBuffer, 'uint32');
  geometryPass.drawIndexed(knot2Buffers.indexCount);

  geometryPass.end();

  // 2. Copy object ID to JFA texture 0
  encoder.copyTextureToTexture(
    { texture: textures.objectIdTexture },
    { texture: textures.jfaTextures[0] },
    [canvas.width, canvas.height]
  );

  // 3. JFA passes - only update uniforms when jfaPasses changes
  if (jfaPasses !== lastJfaPasses) {
    jfaUniformData[0] = canvas.width;
    jfaUniformData[1] = canvas.height;
    for (let i = 0; i < jfaPasses; i++) {
      const stepSize = Math.pow(2, jfaPasses - 1 - i);
      jfaUniformData[2] = stepSize;
      device.queue.writeBuffer(jfaUniformBuffers[i], 0, jfaUniformData);
    }
    lastJfaPasses = jfaPasses;
  }

  // Use pre-built bind groups, alternating src texture each pass
  let srcIndex = 0;
  for (let i = 0; i < jfaPasses; i++) {
    const jfaPass = encoder.beginComputePass();
    jfaPass.setPipeline(jfaPipeline);
    jfaPass.setBindGroup(0, jfaBindGroupsPrebuilt[srcIndex][i]);
    jfaPass.dispatchWorkgroups(
      Math.ceil(canvas.width / 8),
      Math.ceil(canvas.height / 8)
    );
    jfaPass.end();
    srcIndex = 1 - srcIndex;
  }

  // Determine which texture has the final result
  const jfaResultIndex = srcIndex;

  // 4. Composite pass
  compositeUniformData[0] = canvas.width;
  compositeUniformData[1] = canvas.height;
  compositeUniformData[2] = outlineWidth * dpr;
  compositeUniformData[3] = mouseState.hovering ? 1.0 : 0.0;
  compositeUniformData[4] = mouseState.x;
  compositeUniformData[5] = mouseState.y;
  device.queue.writeBuffer(compositeUniformBuffer, 0, compositeUniformData);

  // Use pre-built bind group based on which JFA texture has the result
  const compositeBindGroup = compositeBindGroupsPrebuilt[jfaResultIndex];

  const compositePass = encoder.beginRenderPass({
    colorAttachments: [{
      view: gpuContext.getCurrentTexture().createView(),
      loadOp: 'clear',
      storeOp: 'store',
      clearValue: { r: 1.0, g: 1.0, b: 1.0, a: 1.0 }
    }]
  });

  compositePass.setPipeline(compositePipeline);
  compositePass.setBindGroup(0, compositeBindGroup);
  compositePass.draw(3);
  compositePass.end();

  device.queue.submit([encoder.finish()]);
});

invalidation.then(() => loop.cancel());
  </script>
  <script type="text/markdown">
## Implementation Details

### Data Flow and Render Passes

The rendering pipeline consists of four stages executed each frame.

1. **Geometry pass.** The two torus knots are rendered into two render targets simultaneously using multiple render target (MRT) output. The fragment shader writes shaded color to an RGBA8 texture and object ID data to an RGBA32UI texture. The object ID texture stores screen-space coordinates in the red and green channels (offset by one to distinguish from empty pixels) and the object identifier in the blue channel.

2. **Texture copy.** The object ID texture is copied to the first of two ping-pong textures. This initializes the JFA with seed pixels wherever geometry was rendered, while background pixels remain zero.

3. **Jump flooding passes.** A series of compute shader passes propagate seed information outward. Each pass reads from one ping-pong texture and writes to the other. The first pass samples neighbors at a large step size (half the maximum outline width), and each subsequent pass halves the step size until reaching one pixel. Each pixel examines its eight neighbors at the current step distance plus itself, keeping whichever seed is nearest. After log2(N) passes, every pixel knows its nearest seed location and which object that seed belongs to.

4. **Composite pass.** A full-screen shader combines the color texture, JFA result, and object ID texture into the final image. For each pixel it computes distance to the nearest seed and determines whether the pixel lies within the outline region. Background pixels inside the outline receive the outline color modulated by a distance-based sawtooth ramp. Object pixels near boundaries between different objects are darkened. Hover detection samples the JFA texture at the mouse position to identify which object the cursor is near, then applies a highlight tint to that object and its outline.

  </script>
</notebook>
