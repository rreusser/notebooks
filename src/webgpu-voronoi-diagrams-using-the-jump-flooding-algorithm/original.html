<!doctype html>
<notebook theme="air">
  <title>GPU Voronoi Diagrams using the Jump Flooding Algorithm</title>
  <script id="0" type="application/vnd.observable.javascript">
    md`# GPU Voronoi Diagrams using the Jump Flooding Algorithm`
  </script>
  <script id="614" type="application/vnd.observable.javascript">
    md`This notebook implements a very minimal version of the Jump Flooding algorithm of Rong and Tan, a raster approach to Voronoi diagrams. It's useful because its speed depends on the number of pixels in the output image rather than the number of points in the input geometry—if they're points at all; the input really only has to be a raster image with something like a color or id. I've tried to document my implementation, but I have not tried to explain the algorithm itself since people have done a perfectly wonderful job elsewhere. You can find a few links below. In addition to a test drive, a goal here was also to ensure it's WebGL 1 and mobile compatible.

    It's not an exact algorithm though. If you set the point count to two and play around with the spiral, you can find corner cases with small errors at the edges, but it mostly works quite well. I was also pleased to see that if you cut off the iterations with the largest step size, it restricts the spatial extent of information quite gracefully.

    References:

    - G. Rong, T.-S. Tan, *[Jump Flooding in GPU with Applications to Voronoi Diagram and Distance Transform](https://www.comp.nus.edu.sg/~tants/jfa/i3d06.pdf)*
    - Alan Wolfe, *[Fast Voronoi Diagrams and Distance Field Textures on the GPU With the Jump Flooding Algorithm](https://blog.demofox.org/2016/02/29/fast-voronoi-diagrams-and-distance-dield-textures-on-the-gpu-with-the-jump-flooding-algorithm/)*
    - Ryan Kaplan, *[Voronoi Diagrams on the GPU](http://rykap.com/graphics/skew/2016/02/25/voronoi-diagrams/)*
    - Claudio Esparança, *[Jump Flooding](https://observablehq.com/@esperanc/jump-flooding)*`
  </script>
  <script id="10" type="application/vnd.observable.javascript">
    viewof regl = {
      const w = size[0];
      const h = size[1];
      const canvas = document.createElement('canvas');
      canvas.width = Math.floor(w * pixelRatio);
      canvas.height = Math.floor(h * pixelRatio);
      canvas.style.width = `${w}px`;
      canvas.style.height = `${h}px`;
      const regl = createREGL({
        canvas,
        pixelRatio,
        extensions: ['OES_texture_float', 'OES_standard_derivatives'],
        optionalExtensions: ['OES_texture_half_float'],
        attributes: {
          preserveDrawingBuffer: true,
          antialias: false
        }
      });
      canvas.value = regl;
      invalidation.then(() => regl.destroy());
      return canvas;
    }
  </script>
  <script id="212" type="application/vnd.observable.javascript">
    viewof n = slider({
      min: 2,
      max: 100,
      step: 1,
      value: 40,
      description: 'Number of points, n'
    })
  </script>
  <script id="1062" type="application/vnd.observable.javascript">
    viewof animate = checkbox({ options: ['animate'] })
  </script>
  <script id="1237" type="application/vnd.observable.javascript">
    md`The algorithm has the nice property that it can be truncated. This may be useful if we use it for picking only within a maximum radius. The full algorithm requires ${passCount} passes. If we use ${selectedPassCount} passes, information travels a maximum of ${Math.pow(
      2,
      selectedPassCount
    )} pixels.`
  </script>
  <script id="1231" type="application/vnd.observable.javascript">
    viewof selectedPassCount = slider({
      min: 2,
      max: passCount,
      step: 1,
      value: passCount - 3,
      description: 'Number of passes'
    })
  </script>
  <script id="1271" type="application/vnd.observable.javascript">
    viewof circularCutoff = checkbox({
      options: ['circular cutoff'],
      value: 'circular cutoff'
    })
  </script>
  <script id="774" type="application/vnd.observable.javascript">
    pixelRatio = devicePixelRatio
  </script>
  <script id="121" type="application/vnd.observable.javascript">
    size = [width, Math.max(Math.floor(width * 0.6), 384)]
  </script>
  <script id="1356" type="application/vnd.observable.javascript">
    viewof mousePosition = {
      const div = document.createElement('div');
      const coords = [-1, -1];
      let eqn = tex`(x, y) = (${coords[0]}, ${coords[1]})`;
      div.appendChild(eqn);
      function onMove(event) {
        const rect = regl._gl.canvas.getBoundingClientRect();
        coords[0] = (event.clientX - rect.left) * pixelRatio;
        coords[1] = (event.clientY - rect.top) * pixelRatio;
        const newEqn = tex`(x, y) = (${coords[0]}, ${coords[1]})`;
        div.replaceChild(newEqn, eqn);
        eqn = newEqn;
        div.dispatchEvent(new CustomEvent('input'));
      }
      function onOut(event) {
        coords[0] = -1;
        coords[1] = -1;
        const newEqn = tex`(x, y) = (${coords[0]}, ${coords[1]})`;
        div.replaceChild(newEqn, eqn);
        eqn = newEqn;
        div.dispatchEvent(new CustomEvent('input'));
      }
      regl._gl.canvas.addEventListener('mousemove', onMove);
      regl._gl.canvas.addEventListener('mouseout', onOut);
      invalidation.then(() => {
        regl._gl.canvas.removeEventListener('mousemove', onMove);
        regl._gl.canvas.removeEventListener('mouseout', onOut);
      });
      div.value = coords;
      return div;
    }
  </script>
  <script id="1312" type="application/vnd.observable.javascript">
    md`## Implementation`
  </script>
  <script id="690" type="application/vnd.observable.javascript">
    md`First, we allocate two floating point framebuffers using \`${colorType}\` precision.`
  </script>
  <script id="119" type="application/vnd.observable.javascript" pinned="">
    fbos = [0, 1].map(() => regl.framebuffer({ colorType }))
  </script>
  <script id="1071" type="application/vnd.observable.javascript">
    md`Next, we implement a command to draw some points onto a framebuffer.`
  </script>
  <script id="150" type="application/vnd.observable.javascript">
    drawPoints = regl({
      vert: `
        precision highp float;
        attribute float t;
        uniform float time, pointSize;
        uniform vec2 resolution, aspect;
        attribute vec3 color;
        varying vec3 vColor;
        void main () {
          vColor = color;

          // A spiral :shrug:
          float theta = sqrt(t) * (100.0 + time);
          vec2 xy = t * vec2(cos(theta), sin(theta)) * aspect;

          gl_Position = vec4(xy, 0, 1);
          gl_PointSize = 1.0;
        }`,
      frag: `
        precision highp float;
        varying vec3 vColor;
        uniform vec2 resolution;
        uniform bool encode;

        ${packColor}

        void main () {
          gl_FragColor = packPositionAndColor(gl_FragCoord.xy, vColor);
        }`,
      attributes: {
        t: new Array(n).fill(0).map((d, i) => i / n),
        color: new Array(n)
          .fill(0)
          .map((d, i) => (Math.PI * 2 * i * Math.E) / n)
          .map(r => [
            Math.pow(0.45 + 0.4 * Math.cos(r), 1 / 2.2),
            Math.pow(0.45 + 0.4 * Math.cos(r - (Math.PI * 2) / 3), 1 / 2.2),
            Math.pow(0.45 + 0.4 * Math.cos(r - (Math.PI * 4) / 3), 1 / 2.2)
          ])
      },
      uniforms: {
        time: regl.prop('time'),
        aspect: ctx =>
          ctx.framebufferWidth > ctx.framebufferHeight
            ? [ctx.framebufferHeight / ctx.framebufferWidth, 1]
            : [1, ctx.framebufferWidth / ctx.framebufferHeight]
      },
      count: n,
      primitive: 'points'
    })
  </script>
  <script id="718" type="application/vnd.observable.javascript">
    md`In the command above, we write the x and y coordinates into the first two channels and use the GLSL functions below to encode the color into the last two channels.

    Note that we get just a little fancy and split the most significant and least significant bits of the color's blue component into two separate channels so that half float precision doesn't run out of bits so easily. For point picking, this would be a great place to very carefully consider how to pack and unapack the bits, perhaps to store an object id.`
  </script>
  <script id="471" type="application/vnd.observable.javascript">
    viewof packColor = glsl`
    vec4 packPositionAndColor (vec2 position, vec3 color) {
      float z = floor(color.z * 255.0);
      return vec4(
        position,
        color.xy + vec2(floor(z / 16.0), mod(z, 16.0))
      );
    }`
  </script>
  <script id="1005" type="application/vnd.observable.javascript">
    viewof unpackPosition = glsl`
    vec2 unpackPosition (vec4 data) {
      return data.xy;
    }`
  </script>
  <script id="487" type="application/vnd.observable.javascript">
    viewof unpackColor = glsl`
    vec3 unpackColor (vec4 data) {
      return vec3(
        fract(data.zw),
        dot(floor(data.zw), vec2(16, 1)) / 255.0
      );
    }`
  </script>
  <script id="698" type="application/vnd.observable.javascript">
    md`Next, we implement a basic command that performs a simple 1:1 map from an input to an output framebuffer.`
  </script>
  <script id="13" type="application/vnd.observable.javascript">
    configureMap = regl({
      vert: `
        precision highp float;
        attribute vec2 xy;
        void main () {
          gl_Position = vec4(xy, 0, 1);
        }
      `,
      attributes: {
        xy: [-4, -4, 4, -4, 0, 4]
      },
      uniforms: {
        resolution: ctx => [ctx.framebufferWidth, ctx.framebufferHeight]
      },
      depth: { enable: false },
      primitive: 'triangle',
      count: 3
    })
  </script>
  <script id="819" type="application/vnd.observable.javascript">
    md`Finally the algorithm. There's not much to it. We iterate over neighbors with the given step size and take the neighbor whose seed coordinate is closest to this particular fragment coordinate.`
  </script>
  <script id="491" type="application/vnd.observable.javascript">
    viewof jumpFloodingGLSL = glsl`
    vec4 jumpFloodingStep (vec2 coord, vec2 resolution, float stepSize) {
      float invRes = 1.0 / max(resolution.x, resolution.y);
      vec4 bestSeed = vec4(0);
      float bestDist = 10000.0;
      for (int i = -1; i <= 1; i++) {
        for (int j = -1; j <= 1; j++) {
          vec4 seed = texture2D(src, (coord + vec2(i, j) * stepSize) / resolution);
          vec2 seedCoord = unpackPosition(seed);

          // This is never identically zero for any valid point since frag coords always
          // have a half-pixel offset.
          if (seedCoord == vec2(0)) continue;

          // Silly optimization; avoid a square root, but make sure we don't overflow
          // float dist = distance(seedCoord, coord);
          vec2 dxy = (seedCoord - coord) * invRes;
          float dist = dot(dxy, dxy);

          if (dist < bestDist) {
            bestDist = dist;
            bestSeed = seed;
          }
        }
      }
      return bestSeed;
    }`
  </script>
  <script id="74" type="application/vnd.observable.javascript" pinned="">
    jfaPass = regl({
      frag: `
        precision highp float;
        uniform sampler2D src;
        uniform float stepSize;
        uniform vec2 resolution;
        ${unpackPosition}
        ${jumpFloodingGLSL}
        void main() {
          gl_FragColor = jumpFloodingStep(gl_FragCoord.xy, resolution, stepSize);
        }`,
      framebuffer: regl.prop('fbos[1]'),
      uniforms: {
        stepSize: regl.prop('stepSize'),
        src: regl.prop('fbos[0]')
      }
    })
  </script>
  <script id="713" type="application/vnd.observable.javascript">
    md`Finally we unpack the color from the result and draw it to the screen.`
  </script>
  <script id="155" type="application/vnd.observable.javascript" pinned="">
    drawToScreen = regl({
      frag: `
        precision highp float;
        #extension GL_OES_standard_derivatives : enable
        uniform sampler2D src;
        uniform float pixelRatio, maxRadius;
        uniform vec2 resolution, activePoint;

        // Draw contour screen-width grid lines of the distance field
        float gridFactor (float parameter, float width, float feather) {
          float w1 = width - feather * 0.5;
          float d = length(vec2(dFdx(parameter), dFdy(parameter)));
          float looped = 0.5 - abs(mod(parameter, 1.0) - 0.5);
          return smoothstep(d * (w1 + feather), d * w1, looped);
        }

        ${unpackColor}
        ${unpackPosition}

        void main () {

          vec4 packedPositionAndColor = texture2D(src, gl_FragCoord.xy / resolution);
          vec3 color = unpackColor(packedPositionAndColor);
          vec2 position = unpackPosition(packedPositionAndColor);
          float dist = distance(position, gl_FragCoord.xy);
          float grid = 0.03 * gridFactor(log2(dist), 0.5 * pixelRatio, 1.0);
          //grid += 0.05 * gridFactor(log2(dist) * 8.0, 0.5 * pixelRatio, 1.0);
          vec3 baseColor = unpackColor(packedPositionAndColor);

          // highlight if it matches the point hovered over
          vec4 activeValue = texture2D(src, vec2(0, 1) + vec2(1, -1) * activePoint / resolution);
          vec2 activePosition = unpackPosition(activeValue);
          vec3 activeColor = unpackColor(activeValue);
          if (activePoint.x >= 0.0 && activePosition != vec2(0) && distance(activeColor, baseColor) < 1e-4) {
             baseColor = vec3(1, 0.4, 0.2);
          }

          // Darken by a grid
          vec3 c = mix(baseColor, vec3(0), grid);

          // Darken the central point
          if (maxRadius > 5.0) {
            c *= smoothstep(1.0, 2.0, dist / pixelRatio);
          }
          // Hide the outside if clipping to a circular region
          c = mix(vec3(1), c, smoothstep(maxRadius, maxRadius - 1.0, dist));

          // Background is white
          if (position == vec2(0)) c = vec3(1);

          gl_FragColor = vec4(c, 1);
        }`,
      uniforms: {
        src: regl.prop('src'),
        pixelRatio: regl.context('pixelRatio'),
        maxRadius: (ctx, props) =>
          props.circularCutoff ? Math.pow(2, selectedPassCount) : 100000,
        activePoint: regl.prop('activePoint')
      }
    })
  </script>
  <script id="1282" type="application/vnd.observable.javascript">
    passCount = Math.ceil(
      Math.log2(Math.max(size[0] * pixelRatio, size[1] * pixelRatio))
    )
  </script>
  <script id="376" type="application/vnd.observable.javascript" pinned="">
    {
      let drawn = false;
      const frame = regl.frame(({ time }) => {
        try {
          if (drawn && !animate) return;
          const t = animate ? time : 0;
          configureMap(({ framebufferWidth, framebufferHeight }) => {
            // Lazily resize only when the size has changed:
            fbos.forEach(fbo => fbo.resize(framebufferWidth, framebufferHeight));

            // Initialize the pattern
            fbos[0].use(() => {
              regl.clear({ color: [0, 0, 16, 16] });
              drawPoints({ time: t });
            });

            // Perform ~log2(size) JFA passes
            for (
              let stepSize = Math.pow(2, selectedPassCount - 1);
              stepSize >= 1;
              stepSize /= 2
            ) {
              jfaPass({ fbos, stepSize });
              swap(fbos);
            }

            // Draw the result to the screen
            drawToScreen({
              src: fbos[0],
              circularCutoff,
              activePoint: mousePosition
            });
            drawn = true;
          });
        } catch (e) {
          frame.cancel();
          throw e;
        }
      });
      invalidation.then(frame.cancel);
    }
  </script>
  <script id="736" type="application/vnd.observable.javascript">
    md`## Imports and definitions`
  </script>
  <script id="185" type="application/vnd.observable.javascript">
    function swap(obj, key1, key2) {
      key1 = key1 === undefined ? 0 : 1;
      key2 = key2 === undefined ? 1 : 0;
      let tmp = obj[key1];
      obj[key1] = obj[key2];
      obj[key2] = tmp;
      return obj;
    }
  </script>
  <script id="5" type="application/vnd.observable.javascript">
    createREGL = require('regl')
  </script>
  <script id="637" type="application/vnd.observable.javascript">
    glsl = {
      const interpolate = (strings, ...args) => {
        let s = '';
        for (let i = 0; i < strings.length; i++) {
          s += strings[i];
          if (i < args.length && args[i]) s += String(args[i]);
        }
        return s;
      };

      return (...args) => {
        let string = interpolate(...args);
        if (!string.startsWith('\n')) string = '\n' + string;
        const el = md`~~~glsl${string}~~~`;
        el.value = string;
        return el;
      };
    }
  </script>
  <script id="945" type="application/vnd.observable.javascript">
    colorType = canWriteToFBOOfType(regl, 'half float')
      ? 'half float'
      : canWriteToFBOOfType(regl, 'float')
      ? 'float'
      : 'invalid'
  </script>
  <script id="935" type="application/vnd.observable.javascript">
    import { canWriteToFBOOfType } from '@rreusser/regl-tools'
  </script>
  <script id="130" type="application/vnd.observable.javascript">
    import { slider, checkbox } from '@jashkenas/inputs'
  </script>
  <script id="761" type="application/vnd.observable.javascript">
    LICENSE = "mit"
  </script>
</notebook>
