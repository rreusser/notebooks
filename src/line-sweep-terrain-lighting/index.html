<!doctype html>
<notebook theme="air">
  <title>Line Sweep Terrain Lighting with WebGPU</title>
  <script id="1" type="text/markdown">
    # Line Sweep Terrain Lighting with WebGPU

    Hierarchical terrain lighting using WebGPU compute shaders. This demonstrates the complete pipeline from tile fetching through parent buffer assembly to GPU-accelerated LSAO computation.

    Below, you'll see each stage of the implementation:
    1. **Tile Hierarchy** - Parent tiles needed for boundary data
    2. **Parent Tile Assembly** - 768×768 buffer for horizon initialization
    3. **Raw Terrain Tile** - Original Mapbox terrain image
    4. **Decoded Elevations** - Height map visualization
    5. **WebGPU Pipeline** - Shader compilation and setup
    6. **Computed Lighting** - Final shaded result with LSAO
  </script>
  <script id="2" type="module">
    import { getTerrainTile, readImageData, decodeTerrainData } from './terrain/main.js';
    import { getTileSet } from './terrain/tile-hierarchy.js';
    import { createWebGPUContext } from './compute/webgpu-context.js';
    import { createLightingPipeline } from './compute/pipeline.js';
    import { computeTileLighting } from './compute/execute.js';
    import { createSimpleLSAOPipeline } from './compute/lsao-simple-pipeline.js';
    import { computeSimpleLSAO } from './compute/lsao-simple-execute.js';
    import { createNormalMapPipeline } from './compute/normal-map-pipeline.js';
    import { computeNormalMap } from './compute/normal-map-execute.js';
  </script>
  <script id="3" type="text/markdown">
    ## 1. Tile Hierarchy
  </script>
  <script id="4" type="module">
    const coords = {x: 795, y: 1594, z: 12};
    coords;
  </script>
  <script id="5" type="module">
    const tiles = getTileSet(coords);

    // Create visual representation
    const container = html`<div style="font-family: monospace; font-size: 13px;">
      <strong>Target tile:</strong> ${coords.z}/${coords.x}/${coords.y}<br>
      <strong>Tiles needed for hierarchical computation:</strong><br>
      <ul style="margin: 8px 0; padding-left: 20px;">
        ${tiles.map(t => html`<li>
          <span style="color: ${t.role === 'target' ? '#ca4747' : '#666'}">
            ${t.role}
          </span>: ${t.z}/${t.x}/${t.y}
        </li>`)}
      </ul>
      <em style="color: #666;">Parent tiles at z-1 provide boundary data for edge handling</em>
    </div>`;

    display(container);
    tiles;
  </script>
  <script id="6" type="text/markdown">
    ## 2. Multi-Level Parent Tile Assembly

    For proper horizon initialization in line-sweep ambient occlusion, we need terrain data from *outside* the target tile. Instead of loading all 8 adjacent tiles at full resolution, we load 4 parent tiles at coarser zoom levels.

    **Coverage formula:** Assembly size = tileSize × (1 + 2^Δz)
    - Δz = -1: 512 × 1.5 = 768 pixels (3×3 tile coverage)
    - Δz = -2: 512 × 1.25 = 640 pixels (5×5 tile coverage)
    - Δz = -3: 512 × 1.125 = 576 pixels (7×7 tile coverage)

    Use the slider below to explore different parent zoom levels:
  </script>
  <script id="7" type="module">
    const maxDeltaZ = Math.min(coords.z, 4); // Can't go below z=0

    const input = Inputs.range([-maxDeltaZ, -1], {
      value: -1,
      step: 1,
      label: "Δz (parent zoom offset)",
    });

    const deltaZ = view(input);
    deltaZ;
  </script>
  <script id="8" type="module">
    import { getParentTilesAtLevel, assembleParentTileBufferMultiLevel } from './terrain/parent-tile-assembly-multi-level.js';

    // Get parent tiles at selected zoom level
    const parentTileCoords = getParentTilesAtLevel(coords, deltaZ);
    const parentZ = coords.z + deltaZ;

    display(html`<div style="font-family: sans-serif; font-size: 13px; color: #666; margin-bottom: 12px;">
      <strong>Parent zoom level:</strong> z${parentZ} (Δz = ${deltaZ})<br>
      <strong>Fetching ${parentTileCoords.length} parent tiles...</strong>
    </div>`);

    const parentTiles = [];
    for (const tileCoords of parentTileCoords) {
      const tile = await getTerrainTile(tileCoords);
      const imageData = readImageData(tile.img);
      const elevations = decodeTerrainData(imageData);
      parentTiles.push({
        data: elevations,
        width: tile.width,
        height: tile.height,
        tileSize: tile.tileSize,
        role: tileCoords.role
      });
    }

    // Assemble parent buffer
    const assembled = assembleParentTileBufferMultiLevel({
      targetTile: coords,
      parentTiles,
      deltaZ,
      tileSize: 512
    });

    const { buffer: parentBuffer, size: parentSize, targetOffset } = assembled;

    ({ parentBuffer, parentSize, targetOffset });
  </script>
  <script id="9" type="module">
    // Visualize parent buffer assembly
    const canvas = document.createElement('canvas');
    canvas.width = parentSize;
    canvas.height = parentSize;
    const ctx = canvas.getContext('2d');
    const imageData = ctx.createImageData(parentSize, parentSize);

    // Recalculate scale and targetSizeAtParent from deltaZ
    const scale = Math.pow(2, Math.abs(deltaZ));
    const targetSizeAtParent = 512 / scale;

    // Find min/max in parent buffer
    let min = Infinity, max = -Infinity;
    for (let i = 0; i < parentBuffer.length; i++) {
      if (parentBuffer[i] < min) min = parentBuffer[i];
      if (parentBuffer[i] > max) max = parentBuffer[i];
    }

    // Render parent buffer
    for (let y = 0; y < parentSize; y++) {
      for (let x = 0; x < parentSize; x++) {
        const idx = y * parentSize + x;
        const normalized = (parentBuffer[idx] - min) / (max - min);

        const r = Math.floor(normalized * 180 + 75);
        const g = Math.floor(normalized * 140 + 80);
        const b = Math.floor((1 - normalized) * 120 + 60);

        imageData.data[idx * 4] = r;
        imageData.data[idx * 4 + 1] = g;
        imageData.data[idx * 4 + 2] = b;
        imageData.data[idx * 4 + 3] = 255;
      }
    }

    ctx.putImageData(imageData, 0, 0);

    // Draw target tile boundary
    ctx.strokeStyle = '#ca4747';
    ctx.lineWidth = 3;
    ctx.strokeRect(targetOffset[0], targetOffset[1], targetSizeAtParent, targetSizeAtParent);

    // Add label
    ctx.fillStyle = '#ca4747';
    ctx.font = 'bold 14px sans-serif';
    ctx.fillText('Target Tile', targetOffset[0] + 5, targetOffset[1] + 20);

    // Calculate coverage
    const tileCoverage = Math.round(parentSize / (512 / scale));

    const container = html`<div>
      <div style="margin-bottom: 8px; font-family: sans-serif; font-size: 13px; color: #666;">
        <strong>Parent Buffer Assembly (${parentSize}×${parentSize} at z${coords.z + deltaZ} resolution)</strong><br>
        Red box shows target tile region (${targetSizeAtParent.toFixed(0)}×${targetSizeAtParent.toFixed(0)} at parent resolution)<br>
        Coverage: ${tileCoverage}×${tileCoverage} tiles at z${coords.z} | Scale: ${scale}:1<br>
        Elevation range: ${min.toFixed(1)}m to ${max.toFixed(1)}m
      </div>
      ${canvas}
      <div style="margin-top: 8px; font-family: sans-serif; font-size: 12px; color: #888;">
        <strong>Key insight:</strong> The ${parentSize}×${parentSize} parent buffer covers a ${tileCoverage}×${tileCoverage} block of z${coords.z} tiles,
        providing terrain context for horizon initialization in all sweep directions.
        As Δz increases (coarser parents), coverage expands but resolution decreases.
      </div>
    </div>`;

    display(container);
  </script>
  <script id="10" type="module">
    // Visualize coordinate mapping
    const diagramCanvas = document.createElement('canvas');
    diagramCanvas.width = 800;
    diagramCanvas.height = 400;
    const ctx = diagramCanvas.getContext('2d');

    // Background
    ctx.fillStyle = '#f9f9f9';
    ctx.fillRect(0, 0, 800, 400);

    // Left side: Parent buffer (768×768)
    ctx.save();
    ctx.translate(50, 50);

    const scale = 300 / 768;
    ctx.fillStyle = '#e0e0e0';
    ctx.fillRect(0, 0, 768 * scale, 768 * scale);

    ctx.strokeStyle = '#999';
    ctx.lineWidth = 1;
    ctx.strokeRect(0, 0, 768 * scale, 768 * scale);

    // Target region in parent
    ctx.fillStyle = 'rgba(202, 71, 71, 0.2)';
    ctx.fillRect(
      targetOffset[0] * scale,
      targetOffset[1] * scale,
      256 * scale,
      256 * scale
    );
    ctx.strokeStyle = '#ca4747';
    ctx.lineWidth = 2;
    ctx.strokeRect(
      targetOffset[0] * scale,
      targetOffset[1] * scale,
      256 * scale,
      256 * scale
    );

    // Labels
    ctx.fillStyle = '#333';
    ctx.font = 'bold 14px sans-serif';
    ctx.fillText('Parent Buffer', 10, -10);
    ctx.font = '12px sans-serif';
    ctx.fillText('768×768 @ z-1', 10, -10 + 18);

    ctx.fillStyle = '#ca4747';
    ctx.font = 'bold 12px sans-serif';
    ctx.fillText(
      'Target',
      targetOffset[0] * scale + 5,
      targetOffset[1] * scale + 20
    );
    ctx.font = '11px sans-serif';
    ctx.fillText(
      `[${targetOffset[0]}, ${targetOffset[1]}]`,
      targetOffset[0] * scale + 5,
      targetOffset[1] * scale + 35
    );

    ctx.restore();

    // Arrow
    ctx.fillStyle = '#666';
    ctx.font = '20px sans-serif';
    ctx.fillText('→', 370, 230);
    ctx.font = '12px sans-serif';
    ctx.fillText('×2 resolution', 350, 250);

    // Right side: Target tile (512×512)
    ctx.save();
    ctx.translate(450, 50);

    const targetScale = 300 / 512;
    ctx.fillStyle = 'rgba(202, 71, 71, 0.3)';
    ctx.fillRect(0, 0, 512 * targetScale, 512 * targetScale);

    ctx.strokeStyle = '#ca4747';
    ctx.lineWidth = 2;
    ctx.strokeRect(0, 0, 512 * targetScale, 512 * targetScale);

    ctx.fillStyle = '#333';
    ctx.font = 'bold 14px sans-serif';
    ctx.fillText('Target Tile', 10, -10);
    ctx.font = '12px sans-serif';
    ctx.fillText(`512×512 @ z${coords.z}`, 10, -10 + 18);

    ctx.restore();

    // Add sweep directions
    ctx.save();
    ctx.translate(50 + 768 * scale / 2, 50 + 768 * scale / 2);

    const arrows = [
      { dx: 1, dy: 0, label: 'E', color: '#e74c3c' },
      { dx: -1, dy: 0, label: 'W', color: '#3498db' },
      { dx: 0, dy: 1, label: 'S', color: '#2ecc71' },
      { dx: 0, dy: -1, label: 'N', color: '#f39c12' }
    ];

    arrows.forEach(({ dx, dy, label, color }) => {
      const len = 40;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(dx * len, dy * len);
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = color;
      ctx.font = 'bold 12px sans-serif';
      ctx.fillText(label, dx * (len + 10) - 5, dy * (len + 10) + 5);
    });

    ctx.restore();

    const container = html`<div>
      <div style="margin-bottom: 8px; font-family: sans-serif; font-size: 13px; color: #666;">
        <strong>Coordinate Mapping & Sweep Directions</strong>
      </div>
      ${diagramCanvas}
      <div style="margin-top: 8px; font-family: sans-serif; font-size: 12px; color: #888;">
        Each sweep starts at the parent buffer edge, builds the horizon through parent terrain,
        then continues through the target tile to compute ambient occlusion.
      </div>
    </div>`;

    display(container);
  </script>
  <script id="11" type="text/markdown">
    ## 3. Raw Terrain Tile
  </script>
  <script id="12" type="module">
    const targetTile = await getTerrainTile(coords);

    const container = html`<div>
      <div style="margin-bottom: 8px; font-family: sans-serif; font-size: 13px; color: #666;">
        Mapbox Terrain RGB encoding: ${targetTile.width}×${targetTile.height}
        (${targetTile.tileSize}×${targetTile.tileSize} + ${targetTile.buffer}px buffer)
      </div>
      ${targetTile.img}
    </div>`;

    display(container);
    targetTile;
  </script>
  <script id="13" type="text/markdown">
    ## 4. Decoded Elevations
  </script>
  <script id="14" type="module">
    const imageData = readImageData(targetTile.img);
    const elevations = decodeTerrainData(imageData);

    // Visualize elevation data as heatmap
    const canvas = document.createElement('canvas');
    canvas.width = targetTile.tileSize;
    canvas.height = targetTile.tileSize;
    const ctx = canvas.getContext('2d');
    const imgData = ctx.createImageData(targetTile.tileSize, targetTile.tileSize);

    // Find min/max for normalization (loop to avoid stack overflow with spread operator)
    let min = Infinity, max = -Infinity;
    for (let i = 0; i < elevations.length; i++) {
      const v = elevations[i];
      if (v < min) min = v;
      if (v > max) max = v;
    }

    // Create heatmap (blue=low, red=high)
    for (let y = 0; y < targetTile.tileSize; y++) {
      for (let x = 0; x < targetTile.tileSize; x++) {
        const srcIdx = (y + targetTile.buffer) * targetTile.width + (x + targetTile.buffer);
        const dstIdx = y * targetTile.tileSize + x;
        const normalized = (elevations[srcIdx] - min) / (max - min);

        // Terrain color scheme
        const r = Math.floor(normalized * 180 + 75);
        const g = Math.floor(normalized * 140 + 80);
        const b = Math.floor((1 - normalized) * 120 + 60);

        imgData.data[dstIdx * 4] = r;
        imgData.data[dstIdx * 4 + 1] = g;
        imgData.data[dstIdx * 4 + 2] = b;
        imgData.data[dstIdx * 4 + 3] = 255;
      }
    }

    ctx.putImageData(imgData, 0, 0);

    const container = html`<div>
      <div style="margin-bottom: 8px; font-family: sans-serif; font-size: 13px; color: #666;">
        Elevation range: ${min.toFixed(1)}m to ${max.toFixed(1)}m
      </div>
      ${canvas}
    </div>`;

    display(container);

    // Prepare buffered data for computation
    const tileSize = 512;
    const buffer = 1;
    const bufferedSize = tileSize + 2 * buffer;
    const bufferedData = new Float32Array(bufferedSize * bufferedSize);

    // Copy target tile to center with edge replication
    for (let y = 0; y < tileSize; y++) {
      for (let x = 0; x < tileSize; x++) {
        const srcIdx = (y + targetTile.buffer) * targetTile.width + (x + targetTile.buffer);
        const dstIdx = (y + buffer) * bufferedSize + (x + buffer);
        bufferedData[dstIdx] = elevations[srcIdx];
      }
    }

    // Replicate edges (TODO: use parent tile data)
    for (let x = 0; x < bufferedSize; x++) {
      bufferedData[x] = bufferedData[bufferedSize + x];
      bufferedData[(bufferedSize - 1) * bufferedSize + x] = bufferedData[(bufferedSize - 2) * bufferedSize + x];
    }
    for (let y = 0; y < bufferedSize; y++) {
      bufferedData[y * bufferedSize] = bufferedData[y * bufferedSize + 1];
      bufferedData[y * bufferedSize + (bufferedSize - 1)] = bufferedData[y * bufferedSize + (bufferedSize - 2)];
    }

    bufferedData;
  </script>
  <script id="15" type="text/markdown">
    ## 5. WebGPU Pipeline Setup
  </script>
  <script id="16" type="module">
    const { device, adapter } = await createWebGPUContext();

    const info = html`<div style="font-family: monospace; font-size: 13px;">
      <strong>WebGPU Context:</strong><br>
      <ul style="margin: 8px 0; padding-left: 20px; list-style: none;">
        <li>✓ Adapter acquired</li>
        <li>✓ Device created</li>
        <li>✓ Ready for compute operations</li>
      </ul>
    </div>`;

    display(info);
    invalidation.then(() => device.destroy());
    device;
  </script>
  <script id="17" type="module">
    const { pipeline, bindGroupLayout } = createLightingPipeline(device, {
      tileSize: 512,
      tileBuffer: 1
    });

    const info = html`<div style="font-family: monospace; font-size: 13px;">
      <strong>Compute Pipeline:</strong><br>
      <ul style="margin: 8px 0; padding-left: 20px; list-style: none;">
        <li>✓ WGSL shader compiled</li>
        <li>✓ Bind group layout created (3 bindings)</li>
        <li>✓ Compute pipeline ready</li>
        <li style="margin-top: 4px; color: #666;">→ Workgroup size: 16×16</li>
        <li style="color: #666;">→ Algorithm: Normal-based directional lighting</li>
      </ul>
    </div>`;

    display(info);
    ({ pipeline, bindGroupLayout });
  </script>
  <script id="18" type="text/markdown">
    ## 6. Computed Lighting
  </script>
  <script id="19" type="module">
    const EARTH_CIRCUMFERENCE = 40075017;
    const pixelSize = EARTH_CIRCUMFERENCE / 512 / Math.pow(2, coords.z);

    const result = await computeTileLighting({
      device,
      pipeline,
      bindGroupLayout,
      terrainData: bufferedData,
      tileSize: 512,
      pixelSize
    });

    // Compute stats without spread operator (avoid stack overflow)
    let min = Infinity, max = -Infinity, sum = 0;
    for (let i = 0; i < result.length; i++) {
      const v = result[i];
      if (v < min) min = v;
      if (v > max) max = v;
      sum += v;
    }
    const stats = { min, max, mean: sum / result.length };

    const info = html`<div style="margin-bottom: 8px; font-family: sans-serif; font-size: 13px; color: #666;">
      Lighting values: min=${stats.min.toFixed(3)}, max=${stats.max.toFixed(3)}, mean=${stats.mean.toFixed(3)}<br>
      Pixel size: ${pixelSize.toFixed(3)}m (zoom ${coords.z})
    </div>`;

    display(info);
    result;
  </script>
  <script id="20" type="module">
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 512;
    const ctx = canvas.getContext('2d');
    const imageData = ctx.createImageData(512, 512);

    for (let i = 0; i < result.length; i++) {
      const value = Math.floor(Math.min(Math.max(result[i], 0), 1) * 255);
      imageData.data[i * 4] = value;
      imageData.data[i * 4 + 1] = value;
      imageData.data[i * 4 + 2] = value;
      imageData.data[i * 4 + 3] = 255;
    }

    ctx.putImageData(imageData, 0, 0);

    const container = html`<div>
      ${canvas}
      <div style="margin-top: 8px; font-family: sans-serif; font-size: 13px; color: #666;">
        <em>Directional lighting from northwest at 45° elevation</em>
      </div>
    </div>`;

    display(container);
  </script>
  <script id="21" type="text/markdown">
    ## 7. Line Sweep Ambient Occlusion (LSAO)

    [Line-Sweep Ambient Occlusion](https://karim.naaji.fr/lsao.html) computes ambient occlusion by sweeping across terrain in multiple directions, tracking visible horizons on a convex hull stack. This provides more realistic shadowing than simple normal-based lighting.

    **Algorithm overview:**
    - Sweep in 4 cardinal directions: East, West, North, South
    - Each GPU invocation processes one complete scanline (row or column)
    - Maintain convex hull stack to track horizon visibility
    - Compute occlusion based on elevation angle to visible horizon
    - Accumulate contributions from all directions

    Below shows the simplified single-tile implementation (edge replication for boundaries).
  </script>
  <script id="22" type="module">
    const { pipeline: lsaoPipeline, bindGroupLayout: lsaoBindGroupLayout } = createSimpleLSAOPipeline(device, {
      tileSize: 512,
      tileBuffer: 1,
      workgroupSize: 128
    });

    const info = html`<div style="font-family: monospace; font-size: 13px;">
      <strong>LSAO Compute Pipeline:</strong><br>
      <ul style="margin: 8px 0; padding-left: 20px; list-style: none;">
        <li>✓ LSAO shader compiled</li>
        <li>✓ Bind group layout created</li>
        <li>✓ Pipeline ready for 4-direction sweep</li>
        <li style="margin-top: 4px; color: #666;">→ Workgroup size: 128 (scanline parallelism)</li>
        <li style="color: #666;">→ Algorithm: Line-sweep horizon tracking</li>
      </ul>
    </div>`;

    display(info);
    ({ lsaoPipeline, lsaoBindGroupLayout });
  </script>
  <script id="23" type="module">
    const EARTH_CIRCUMFERENCE = 40075017;
    const pixelSize = EARTH_CIRCUMFERENCE / 512 / Math.pow(2, coords.z);

    const startTime = performance.now();

    const lsaoResult = await computeSimpleLSAO({
      device,
      pipeline: lsaoPipeline,
      bindGroupLayout: lsaoBindGroupLayout,
      terrainData: bufferedData,
      tileSize: 512,
      pixelSize,
      workgroupSize: 128,
      directions: [[1, 0], [-1, 0], [0, 1], [0, -1]]
    });

    const elapsed = performance.now() - startTime;

    // Compute stats
    let min = Infinity, max = -Infinity, sum = 0;
    for (let i = 0; i < lsaoResult.length; i++) {
      const v = lsaoResult[i];
      if (v < min) min = v;
      if (v > max) max = v;
      sum += v;
    }
    const lsaoStats = { min, max, mean: sum / lsaoResult.length };

    const info = html`<div style="margin-bottom: 8px; font-family: sans-serif; font-size: 13px; color: #666;">
      LSAO values: min=${lsaoStats.min.toFixed(3)}, max=${lsaoStats.max.toFixed(3)}, mean=${lsaoStats.mean.toFixed(3)}<br>
      Computation time: ${elapsed.toFixed(1)}ms (4 direction sweeps)<br>
      Pixel size: ${pixelSize.toFixed(3)}m
    </div>`;

    display(info);
    lsaoResult;
  </script>
  <script id="24" type="module">
    // Normalize LSAO to [0, 1] for display
    const lsaoNormalized = new Float32Array(lsaoResult.length);
    for (let i = 0; i < lsaoResult.length; i++) {
      lsaoNormalized[i] = (lsaoResult[i] - lsaoStats.min) / (lsaoStats.max - lsaoStats.min);
    }

    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 512;
    const ctx = canvas.getContext('2d');
    const imageData = ctx.createImageData(512, 512);

    for (let i = 0; i < lsaoNormalized.length; i++) {
      const value = Math.floor(Math.min(Math.max(lsaoNormalized[i], 0), 1) * 255);
      imageData.data[i * 4] = value;
      imageData.data[i * 4 + 1] = value;
      imageData.data[i * 4 + 2] = value;
      imageData.data[i * 4 + 3] = 255;
    }

    ctx.putImageData(imageData, 0, 0);

    const container = html`<div>
      ${canvas}
      <div style="margin-top: 8px; font-family: sans-serif; font-size: 13px; color: #666;">
        <em>Pure ambient occlusion (normalized for display)</em>
      </div>
    </div>`;

    display(container);
  </script>
  <script id="25" type="text/markdown">
    ### LSAO Combined with Elevation

    Multiply the ambient occlusion by normalized elevation to create a shaded relief map:
  </script>
  <script id="26" type="module">
    // Compute elevation min/max from the elevations data
    let elevMin = Infinity, elevMax = -Infinity;
    for (let i = 0; i < elevations.length; i++) {
      const v = elevations[i];
      if (v < elevMin) elevMin = v;
      if (v > elevMax) elevMax = v;
    }

    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 512;
    const ctx = canvas.getContext('2d');
    const imageData = ctx.createImageData(512, 512);

    for (let y = 0; y < 512; y++) {
      for (let x = 0; x < 512; x++) {
        const idx = y * 512 + x;
        const srcIdx = (y + 1) * targetTile.width + (x + 1);

        // Normalize elevation
        const elevNorm = (elevations[srcIdx] - elevMin) / (elevMax - elevMin);

        // Normalize AO
        const aoNorm = (lsaoResult[idx] - lsaoStats.min) / (lsaoStats.max - lsaoStats.min);

        // Combine: AO × elevation with terrain coloring
        const combined = elevNorm * aoNorm;

        // Terrain color scheme
        const r = Math.floor(combined * 180 + 75);
        const g = Math.floor(combined * 140 + 80);
        const b = Math.floor((1 - combined) * 120 + 60);

        imageData.data[idx * 4] = r;
        imageData.data[idx * 4 + 1] = g;
        imageData.data[idx * 4 + 2] = b;
        imageData.data[idx * 4 + 3] = 255;
      }
    }

    ctx.putImageData(imageData, 0, 0);

    const container = html`<div>
      ${canvas}
      <div style="margin-top: 8px; font-family: sans-serif; font-size: 13px; color: #666;">
        <em>Shaded relief: LSAO × normalized elevation with terrain colors</em>
      </div>
    </div>`;

    display(container);
  </script>
  <script id="27" type="text/markdown">
    ## 8. Final Lighting Map (RGB)

    The final output combines surface normals and ambient occlusion into a single RGB image:

    - **Red channel**: Surface normal Y component (fy = 0.5 + 0.5 × ny)
    - **Green channel**: Ambient occlusion from LSAO
    - **Blue channel**: Surface normal X component (fx = 0.5 - 0.5 × nx)

    The normals are computed with physically-correct Web Mercator (EPSG:3857) scaling, accounting for latitude-dependent distortion. This allows the lighting map to be used for on-the-fly lighting during rendering.
  </script>
  <script id="28" type="module">
    const { pipeline: normalPipeline, bindGroupLayout: normalBindGroupLayout } = createNormalMapPipeline(device, {
      tileSize: 512,
      tileBuffer: 1
    });

    const info = html`<div style="font-family: monospace; font-size: 13px;">
      <strong>Normal Map Pipeline:</strong><br>
      <ul style="margin: 8px 0; padding-left: 20px; list-style: none;">
        <li>✓ Normal map shader compiled</li>
        <li>✓ Web Mercator distortion correction enabled</li>
        <li>✓ Physically-correct normal vectors</li>
        <li style="margin-top: 4px; color: #666;">→ Workgroup size: 16×16</li>
        <li style="color: #666;">→ Output: RGB (R=ny, G=reserved, B=nx)</li>
      </ul>
    </div>`;

    display(info);
    ({ normalPipeline, normalBindGroupLayout });
  </script>
  <script id="29" type="module">
    // Compute normal map
    const normalMapData = await computeNormalMap({
      device,
      pipeline: normalPipeline,
      bindGroupLayout: normalBindGroupLayout,
      terrainData: bufferedData,
      tileX: coords.x,
      tileY: coords.y,
      tileZ: coords.z,
      tileSize: 512
    });

    const info = html`<div style="margin-bottom: 8px; font-family: sans-serif; font-size: 13px; color: #666;">
      Normal map computed (${normalMapData.length / 4} pixels, vec3 per pixel with 16-byte alignment)
    </div>`;

    display(info);
    normalMapData;
  </script>
  <script id="30" type="module">
    // Combine normals (R/B) with LSAO (G) into final RGB image
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 512;
    const ctx = canvas.getContext('2d');
    const imageData = ctx.createImageData(512, 512);

    // Normalize AO to [0, 1]
    for (let i = 0; i < 512 * 512; i++) {
      const aoNorm = (lsaoResult[i] - lsaoStats.min) / (lsaoStats.max - lsaoStats.min);

      // normalMapData has vec3<f32> with 16-byte alignment (stride = 4 floats)
      const r = normalMapData[i * 4 + 0];      // fy (ny component)
      const b = normalMapData[i * 4 + 2];      // fx (nx component)
      const g = aoNorm;                         // AO

      imageData.data[i * 4 + 0] = Math.floor(Math.min(Math.max(r, 0), 1) * 255);
      imageData.data[i * 4 + 1] = Math.floor(Math.min(Math.max(g, 0), 1) * 255);
      imageData.data[i * 4 + 2] = Math.floor(Math.min(Math.max(b, 0), 1) * 255);
      imageData.data[i * 4 + 3] = 255;
    }

    ctx.putImageData(imageData, 0, 0);

    const container = html`<div>
      ${canvas}
      <div style="margin-top: 8px; font-family: sans-serif; font-size: 13px; color: #666;">
        <strong>Final Lighting Map</strong><br>
        R: Normal Y (fy = 0.5 + 0.5×ny) | G: Ambient Occlusion | B: Normal X (fx = 0.5 - 0.5×nx)
      </div>
    </div>`;

    display(container);
  </script>
  <script id="31" type="text/markdown">
    ### Channel Breakdown

    Below shows each channel individually for inspection:
  </script>
  <script id="32" type="module">
    const canvases = [];

    // Red channel (ny) - stride is 4 floats due to vec3 alignment
    const canvasR = document.createElement('canvas');
    canvasR.width = 512;
    canvasR.height = 512;
    let ctx = canvasR.getContext('2d');
    let imgData = ctx.createImageData(512, 512);
    for (let i = 0; i < 512 * 512; i++) {
      const val = Math.floor(normalMapData[i * 4 + 0] * 255);
      imgData.data[i * 4 + 0] = val;
      imgData.data[i * 4 + 1] = val;
      imgData.data[i * 4 + 2] = val;
      imgData.data[i * 4 + 3] = 255;
    }
    ctx.putImageData(imgData, 0, 0);

    // Green channel (AO)
    const canvasG = document.createElement('canvas');
    canvasG.width = 512;
    canvasG.height = 512;
    ctx = canvasG.getContext('2d');
    imgData = ctx.createImageData(512, 512);
    for (let i = 0; i < 512 * 512; i++) {
      const aoNorm = (lsaoResult[i] - lsaoStats.min) / (lsaoStats.max - lsaoStats.min);
      const val = Math.floor(aoNorm * 255);
      imgData.data[i * 4 + 0] = val;
      imgData.data[i * 4 + 1] = val;
      imgData.data[i * 4 + 2] = val;
      imgData.data[i * 4 + 3] = 255;
    }
    ctx.putImageData(imgData, 0, 0);

    // Blue channel (nx) - stride is 4 floats due to vec3 alignment
    const canvasB = document.createElement('canvas');
    canvasB.width = 512;
    canvasB.height = 512;
    ctx = canvasB.getContext('2d');
    imgData = ctx.createImageData(512, 512);
    for (let i = 0; i < 512 * 512; i++) {
      const val = Math.floor(normalMapData[i * 4 + 2] * 255);
      imgData.data[i * 4 + 0] = val;
      imgData.data[i * 4 + 1] = val;
      imgData.data[i * 4 + 2] = val;
      imgData.data[i * 4 + 3] = 255;
    }
    ctx.putImageData(imgData, 0, 0);

    const container = html`<div>
      <div>
        ${canvasR}
        <div style="margin-top: 4px; font-family: sans-serif; font-size: 12px; color: #e74c3c; text-align: center;">
          <strong>Red Channel</strong><br>
          Normal Y (fy)
        </div>
      </div>
      <div>
        ${canvasG}
        <div style="margin-top: 4px; font-family: sans-serif; font-size: 12px; color: #27ae60; text-align: center;">
          <strong>Green Channel</strong><br>
          Ambient Occlusion
        </div>
      </div>
      <div>
        ${canvasB}
        <div style="margin-top: 4px; font-family: sans-serif; font-size: 12px; color: #3498db; text-align: center;">
          <strong>Blue Channel</strong><br>
          Normal X (fx)
        </div>
      </div>
    </div>`;

    display(container);
  </script>
  <script id="33" type="text/markdown">
    ## Summary

    This notebook demonstrates the complete hierarchical terrain lighting pipeline:

    - **Tile Hierarchy**: Identifies parent tiles needed for boundary data
    - **Tile Fetching**: Retrieves Mapbox terrain tiles with RGB elevation encoding
    - **Data Decoding**: Converts RGB values to elevation in meters
    - **WebGPU Compute**: GPU-accelerated normal calculation and lighting
    - **LSAO**: Line-sweep ambient occlusion with 4-direction sweeps
    - **Normal Map**: Physically-correct surface normals with Web Mercator scaling
    - **Final Output**: RGB lighting map (R=ny, G=AO, B=nx) for on-the-fly rendering
    - **LRU Caching**: Manages tile data and GPU buffers efficiently

    The infrastructure supports both browser and Node.js environments with platform-specific implementations.

    **Next steps**: The full LSAO implementation with parent tile support (`lsao-pipeline.js`) uses hierarchical boundary data for seamless multi-tile rendering. The lighting maps can be compressed as WebP and served as tiles for real-time terrain rendering.
  </script>
</notebook>
