<!doctype html>
<notebook theme="air">
  <title>Multi-Level Line Sweep Ambient Occlusion - Algorithm Deep Dive</title>

  <script id="imports" type="module">
    import { getTerrainTile, readImageData, decodeTerrainData } from './terrain/data/main.js';
    import { getParentTilesAtLevel, assembleParentTileBufferMultiLevel } from './terrain/data/parent-tile-assembly-multi-level.js';
    import { computeLSAOCPU } from './terrain/compute/lsao-cpu.ts';
    import { calculateLevelInfo } from './terrain/compute/lsao-pipeline.js';
  </script>

  <script id="intro" type="text/markdown">
    # Multi-Level Line Sweep Ambient Occlusion

    [Line-Sweep Ambient Occlusion (LSAO)](https://karim.naaji.fr/lsao.html) computes ambient occlusion by sweeping across terrain in multiple directions, tracking visible horizons to determine shadowing.

    **This page uses CPU-only execution** to enable detailed debugging and visualization of the algorithm's execution.

    ## Key Concepts

    - **Hierarchical parent tiles**: Instead of loading 8 adjacent tiles at full resolution, we use coarser parent tiles at zoom levels z-1, z-2, etc.
    - **Native resolution sweeps**: Each level is sampled at its own resolution - no wasteful upsampling
    - **Efficient boundary context**: A 512×512 target tile only needs ~768 pixels of sweep distance (not thousands!)
  </script>

  <script id="tile-coords" type="module">
    const coords = {x: 795, y: 1594, z: 12};
    coords;
  </script>

  <script id="num-levels-input" type="module">
    const numLevelsInput = view(Inputs.range([1, 3], {
      value: 1,
      step: 1,
      label: "Number of parent levels",
    }));
    numLevelsInput;
  </script>

  <script id="fetch-terrain" type="module">
    const targetTile = await getTerrainTile(coords);
    const imageData = readImageData(targetTile.img);
    const elevations = decodeTerrainData(imageData);

    // Find elevation range
    let elevMin = Infinity, elevMax = -Infinity;
    for (let i = 0; i < elevations.length; i++) {
      if (elevations[i] < elevMin) elevMin = elevations[i];
      if (elevations[i] > elevMax) elevMax = elevations[i];
    }

    // Prepare buffered data
    const tileSize = 512;
    const buffer = 1;
    const bufferedSize = tileSize + 2 * buffer;
    const bufferedData = new Float32Array(bufferedSize * bufferedSize);

    // Copy target tile with edge replication
    for (let y = 0; y < tileSize; y++) {
      for (let x = 0; x < tileSize; x++) {
        const srcIdx = (y + targetTile.buffer) * targetTile.width + (x + targetTile.buffer);
        const dstIdx = (y + buffer) * bufferedSize + (x + buffer);
        bufferedData[dstIdx] = elevations[srcIdx];
      }
    }

    // Replicate edges
    for (let x = 0; x < bufferedSize; x++) {
      bufferedData[x] = bufferedData[bufferedSize + x];
      bufferedData[(bufferedSize - 1) * bufferedSize + x] = bufferedData[(bufferedSize - 2) * bufferedSize + x];
    }
    for (let y = 0; y < bufferedSize; y++) {
      bufferedData[y * bufferedSize] = bufferedData[y * bufferedSize + 1];
      bufferedData[y * bufferedSize + (bufferedSize - 1)] = bufferedData[y * bufferedSize + (bufferedSize - 2)];
    }

    ({ targetTile, bufferedData, elevations, elevMin, elevMax });
  </script>

  <script id="terrain-header" type="text/markdown">
    ## Terrain Data
  </script>

  <script id="show-terrain" type="module">
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 512;
    const ctx = canvas.getContext('2d');
    const imgData = ctx.createImageData(512, 512);

    for (let y = 0; y < 512; y++) {
      for (let x = 0; x < 512; x++) {
        const srcIdx = (y + targetTile.buffer) * targetTile.width + (x + targetTile.buffer);
        const dstIdx = y * 512 + x;
        const normalized = (elevations[srcIdx] - elevMin) / (elevMax - elevMin);

        const r = Math.floor(normalized * 180 + 75);
        const g = Math.floor(normalized * 140 + 80);
        const b = Math.floor((1 - normalized) * 120 + 60);

        imgData.data[dstIdx * 4] = r;
        imgData.data[dstIdx * 4 + 1] = g;
        imgData.data[dstIdx * 4 + 2] = b;
        imgData.data[dstIdx * 4 + 3] = 255;
      }
    }

    ctx.putImageData(imgData, 0, 0);

    display(html`<div>
      <div style="margin-bottom: 8px; font-family: sans-serif; font-size: 13px; color: #666;">
        Target tile ${coords.z}/${coords.x}/${coords.y} | Elevation: ${elevMin.toFixed(0)}m to ${elevMax.toFixed(0)}m
      </div>
      ${canvas}
    </div>`);
  </script>

  <script id="fetch-parents" type="module">
    // Fetch and assemble parent tiles
    const parentLevelsData = [];
    const levelInfo = [];

    for (let i = 1; i <= numLevelsInput; i++) {
      const deltaZ = -i;
      const parentTileCoords = getParentTilesAtLevel(coords, deltaZ);

      const parentTiles = [];
      for (const tileCoords of parentTileCoords) {
        const tile = await getTerrainTile(tileCoords);
        const imageData = readImageData(tile.img);
        const elevations = decodeTerrainData(imageData);
        parentTiles.push({
          data: elevations,
          width: tile.width,
          height: tile.height,
          tileSize: tile.tileSize,
          role: tileCoords.role
        });
      }

      const assembled = assembleParentTileBufferMultiLevel({
        targetTile: coords,
        parentTiles,
        deltaZ,
        tileSize: 512
      });

      parentLevelsData.push(assembled.buffer);
      levelInfo.push(calculateLevelInfo(deltaZ, 512));
    }

    ({ parentLevelsData, levelInfo });
  </script>

  <script id="parent-viz-header" type="text/markdown">
    ## Parent Tile Assemblies

    Visualizing the parent tile buffers that provide boundary context:
  </script>

  <script id="show-parent-assemblies" type="module">
    const container = html`<div style="display: flex; flex-direction: column; gap: 24px;"></div>`;

    for (let i = 0; i < parentLevelsData.length; i++) {
      const info = levelInfo[i];
      const data = parentLevelsData[i];

      // Find min/max for this level
      let levelMin = Infinity, levelMax = -Infinity;
      for (let j = 0; j < data.length; j++) {
        if (data[j] < levelMin) levelMin = data[j];
        if (data[j] > levelMax) levelMax = data[j];
      }

      // Create canvas
      const canvas = document.createElement('canvas');
      canvas.width = info.bufferSize;
      canvas.height = info.bufferSize;
      const ctx = canvas.getContext('2d');
      const imgData = ctx.createImageData(info.bufferSize, info.bufferSize);

      for (let y = 0; y < info.bufferSize; y++) {
        for (let x = 0; x < info.bufferSize; x++) {
          const idx = y * info.bufferSize + x;
          const normalized = (data[idx] - levelMin) / (levelMax - levelMin);

          const r = Math.floor(normalized * 180 + 75);
          const g = Math.floor(normalized * 140 + 80);
          const b = Math.floor((1 - normalized) * 120 + 60);

          imgData.data[idx * 4] = r;
          imgData.data[idx * 4 + 1] = g;
          imgData.data[idx * 4 + 2] = b;
          imgData.data[idx * 4 + 3] = 255;
        }
      }

      ctx.putImageData(imgData, 0, 0);

      // Draw target tile boundary
      ctx.strokeStyle = '#ca4747';
      ctx.lineWidth = 2;
      ctx.strokeRect(
        info.targetOffset[0],
        info.targetOffset[1],
        512 / info.scale,
        512 / info.scale
      );

      const levelDiv = html`<div>
        <div style="margin-bottom: 8px; font-family: sans-serif; font-size: 13px; color: #666;">
          <strong>Level ${i + 1} (z-${i + 1})</strong>: ${info.bufferSize}×${info.bufferSize} assembly,
          scale ${info.scale}:1 (target shown in red)
        </div>
        ${canvas}
        <div style="margin-top: 8px; font-family: sans-serif; font-size: 12px; color: #888;">
          Target region: ${(512 / info.scale).toFixed(0)}×${(512 / info.scale).toFixed(0)} pixels at this resolution
        </div>
      </div>`;

      container.appendChild(levelDiv);
    }

    display(container);
  </script>

  <script id="compute-lsao-header" type="text/markdown">
    ## Computing LSAO (CPU Implementation)
  </script>

  <script id="compute-lsao" type="module">
    const EARTH_CIRCUMFERENCE = 40075017;
    const pixelSize = EARTH_CIRCUMFERENCE / 512 / Math.pow(2, coords.z);

    const startTime = performance.now();
    const lsaoResult = computeLSAOCPU({
      targetData: bufferedData,
      parentLevels: parentLevelsData,
      levelInfo,
      tileSize: 512,
      pixelSize,
      directions: [[1, 0], [-1, 0], [0, 1], [0, -1]]
    });
    const lsaoTime = performance.now() - startTime;

    // Compute stats
    let min = Infinity, max = -Infinity, sum = 0;
    for (let i = 0; i < lsaoResult.length; i++) {
      min = Math.min(min, lsaoResult[i]);
      max = Math.max(max, lsaoResult[i]);
      sum += lsaoResult[i];
    }
    const lsaoStats = { min, max, mean: sum / lsaoResult.length };

    ({ lsaoResult, lsaoStats, lsaoTime });
  </script>

  <script id="show-lsao" type="module">
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 512;
    const ctx = canvas.getContext('2d');
    const imageData = ctx.createImageData(512, 512);

    for (let i = 0; i < lsaoResult.length; i++) {
      const value = Math.floor(Math.min(Math.max(lsaoResult[i], 0), 1) * 255);
      imageData.data[i * 4] = value;
      imageData.data[i * 4 + 1] = value;
      imageData.data[i * 4 + 2] = value;
      imageData.data[i * 4 + 3] = 255;
    }

    ctx.putImageData(imageData, 0, 0);

    display(html`<div>
      <div style="margin-bottom: 8px; font-family: sans-serif; font-size: 13px; color: #666;">
        <strong>${numLevelsInput} parent level${numLevelsInput > 1 ? 's' : ''}</strong> |
        Range: ${lsaoStats.min.toFixed(3)} to ${lsaoStats.max.toFixed(3)} |
        Mean: ${lsaoStats.mean.toFixed(3)} |
        Time: ${lsaoTime.toFixed(1)}ms (CPU)
      </div>
      ${canvas}
    </div>`);
  </script>

  <script id="algorithm-header" type="text/markdown">
    ## Algorithm Analysis

    ### Current Implementation Issues

    The current algorithm creates a unified sweep space of size `tileSize × (1 + 2^numLevels)`:
    - **1 level**: 512 × 3 = 1536 pixels
    - **2 levels**: 512 × 5 = 2560 pixels
    - **3 levels**: 512 × 9 = 4608 pixels

    **This is fundamentally wrong!** Each sweep should operate at the native resolution of each level.

    ### Correct Approach

    For a west-to-east sweep:
    1. **Parent z-1**: Sweep across 256 pixels (one 256×256 tile at native resolution)
    2. **Target z**: Sweep across 512 pixels (the target tile)
    3. **Total**: 256 + 512 = **768 pixels** (not 1536!)

    For two levels (z-2 and z-1):
    1. **Parent z-2**: 128 pixels (one 128×128 tile at native resolution)
    2. **Parent z-1**: 256 pixels (one 256×256 tile at native resolution)
    3. **Target z**: 512 pixels
    4. **Total**: 128 + 256 + 512 = **896 pixels** (not 2560!)

    ### Why This Matters

    The current implementation:
    - Wastes computation by upsampling parent data to target resolution
    - Creates a massive sweep space that doesn't match the actual data structure
    - Misunderstands how hierarchical tile assemblies work

    The correct implementation should:
    - Step through each level at its own native resolution
    - Build the horizon stack progressively as we move from parent → target
    - Only perform as many steps as there are actual data points
  </script>

  <script id="sweep-analysis" type="module">
    // Calculate actual vs theoretical sweep sizes
    const analysis = [];

    // Current (incorrect) approach
    const currentSweepSize = 512 * (1 + Math.pow(2, numLevelsInput));

    // Correct approach
    let correctSweepSize = 512; // Target tile
    for (let i = 0; i < numLevelsInput; i++) {
      const scale = Math.pow(2, i + 1);
      correctSweepSize += 512 / scale;
    }

    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 300;
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = '#f9f9f9';
    ctx.fillRect(0, 0, 512, 300);

    // Draw comparison bars
    const scale = 400 / Math.max(currentSweepSize, correctSweepSize);

    // Current approach
    ctx.fillStyle = '#e74c3c';
    ctx.fillRect(50, 80, currentSweepSize * scale, 40);
    ctx.fillStyle = '#333';
    ctx.font = '13px sans-serif';
    ctx.fillText(`Current: ${currentSweepSize}px`, 60, 105);

    // Correct approach
    ctx.fillStyle = '#27ae60';
    ctx.fillRect(50, 150, correctSweepSize * scale, 40);
    ctx.fillStyle = '#333';
    ctx.fillText(`Correct: ${correctSweepSize.toFixed(0)}px`, 60, 175);

    // Efficiency gain
    const efficiency = ((currentSweepSize - correctSweepSize) / currentSweepSize * 100).toFixed(1);
    ctx.fillStyle = '#666';
    ctx.font = '14px sans-serif';
    ctx.fillText(`Efficiency improvement: ${efficiency}% fewer pixels to process`, 50, 230);

    display(html`<div>
      <div style="margin-bottom: 8px; font-family: sans-serif; font-size: 13px; color: #666;">
        <strong>Sweep Size Comparison</strong>
      </div>
      ${canvas}
      <div style="margin-top: 8px; font-family: sans-serif; font-size: 12px; color: #888;">
        The current implementation processes ${(currentSweepSize / correctSweepSize).toFixed(2)}× more pixels than necessary!
      </div>
    </div>`);
  </script>

  <script id="next-steps" type="text/markdown">
    ## Next Steps

    To properly visualize and fix the algorithm, we need to:

    1. **Create a step-by-step visualization** showing how the horizon stack builds as we sweep through:
       - Parent level data (at parent resolution)
       - Target level data (at target resolution)

    2. **Instrument the CPU implementation** to capture:
       - Hull state at each step
       - Which level is being sampled
       - Visibility calculations

    3. **Implement the corrected algorithm** that:
       - Doesn't create a unified sweep space
       - Steps through each level at native resolution
       - Builds the horizon progressively

    4. **Compare results** between current and corrected implementations to validate the fix
  </script>
</notebook>
