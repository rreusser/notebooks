<!doctype html>
<notebook theme="air">
  <title>WebGPU Instanced Lines</title>
  <script id="1" type="text/markdown">
    # WebGPU Instanced Lines

    [webgpu-instanced-lines](https://www.npmjs.com/package/webgpu-instanced-lines) is a library for high-performance, customizable line rendering for WebGPU using instanced triangle strips. It is a WebGPU port of [regl-gpu-lines](https://github.com/rreusser/regl-gpu-lines). This notebook is where I originally developed the implementation. The source now lives on [GitHub](https://github.com/rreusser/webgpu-instanced-lines).
  </script>
  <script id="2" type="module">
    // Initialize WebGPU for interactive demo
    if (!navigator.gpu) {
      display(html`<p style="color: red;">WebGPU is not supported in this browser.</p>`);
      throw new Error('WebGPU not supported');
    }

    const adapter = await navigator.gpu.requestAdapter();
    if (!adapter) {
      throw new Error('Failed to get WebGPU adapter');
    }

    const device = await adapter.requestDevice();
    const canvasFormat = navigator.gpu.getPreferredCanvasFormat();

    invalidation.then(() => device.destroy());
  </script>
  <script id="3" type="text/markdown">
    ## Interactive Demo

    Explore the line rendering options with interactive demo below. Drag handles to edit vertices, drag the background to pan, and scroll to zoom. Enable **Debug view** to see the underlying triangle strip structure. Alternating colors indicate separate instances.
  </script>
  <script id="5" type="module">
    import { createElementStack } from './lib/element-stack.js'
    import { createZoomableAxes } from './lib/zoomable-axes.js'
    import { expandable } from './lib/expandable.js'

    const dpr = window.devicePixelRatio || 1;
    const canvasWidth = Math.min(640, width);
    const canvasHeight = 480;

    const stack = createElementStack({
      width: canvasWidth,
      height: canvasHeight,
      layers: [{
        id: 'canvas',
        element: ({ current, width, height }) => {
          const canvas = current || document.createElement('canvas');
          canvas.id = 'lines-canvas';
          canvas.width = Math.floor(width * dpr);
          canvas.height = Math.floor(height * dpr);
          canvas.style.width = `${width}px`;
          canvas.style.height = `${height}px`;
          return canvas;
        }
      }, {
        id: 'svg',
        element: ({ current, width, height }) =>
          (current ? d3.select(current) : d3.create("svg"))
            .attr("width", width)
            .attr("height", height)
            .style("cursor", "grab")
            .node()
      }]
    });

    const canvas = stack.elements.canvas;

    const gpuContext = canvas.getContext('webgpu');
    gpuContext.configure({
      device,
      format: canvasFormat,
      alphaMode: 'premultiplied'
    });

    const renderState = { dirty: true };

    const axes = createZoomableAxes({
      d3,
      element: stack.elements.svg,
      xScale: d3.scaleLinear().domain([-1, 1]).range([0, canvasWidth]),
      yScale: d3.scaleLinear().domain([-1, 1]).range([canvasHeight, 0]),
      aspectRatio: 1,
      onChange: () => {
        renderState.dirty = true;
        stack.dispatchEvent(new CustomEvent('update'));
      }
    });

    const figure = html`<figure style="margin: 0;">
      ${stack.element}
      <figcaption>Drag handles to edit vertices. Drag background to pan, scroll to zoom.</figcaption>
    </figure>`;

    display(expandable(figure, {
      width: canvasWidth,
      height: canvasHeight,
      controls: '.lines-controls',
      onResize(el, w, h) {
        stack.resize(w, h);
        axes.updateScales(
          d3.scaleLinear().domain([-1, 1]).range([0, w]),
          d3.scaleLinear().domain([-1, 1]).range([h, 0])
        );
        renderState.dirty = true;
        stack.dispatchEvent(new CustomEvent('update'));
      }
    }));
  </script>
  <script id="6" type="module">
    const lineWidthInput = Inputs.range([1, 100], { label: 'Line width', value: 50, step: 0.5 });
    const lineWidth = view(lineWidthInput);

    const joinTypeInput = Inputs.select(['bevel', 'miter', 'round'], { label: 'Join type', value: 'miter' });
    const joinType = view(joinTypeInput);

    const capTypeInput = Inputs.select(['round', 'square', 'none'], { label: 'Cap type', value: 'round' });
    const capType = view(capTypeInput);

    const patternInput = Inputs.select(['wave', 'zigzag', 'spiral'], { label: 'Pattern', value: 'zigzag' });
    const pattern = view(patternInput);

    const sdfStrokeWidthInput = Inputs.range([0, 50], { label: 'SDF stroke width', value: 10, step: 0.5 });
    const sdfStrokeWidth = view(sdfStrokeWidthInput);

    const alphaInput = Inputs.range([0, 1], { label: 'Alpha', value: 1, step: 0.01 });
    const alpha = view(alphaInput);

    const lineBreakInput = Inputs.toggle({ label: 'Line break', value: false });
    const lineBreak = view(lineBreakInput);

    const stripesInput = Inputs.toggle({ label: 'Stripes', value: false });
    const stripes = view(stripesInput);

    const varyingWidthInput = Inputs.toggle({ label: 'Varying width', value: false });
    const varyingWidth = view(varyingWidthInput);

    const debugViewInput = Inputs.toggle({ label: 'Debug view', value: 'Debug view' });
    const debugView = view(debugViewInput);
  </script>
  <script id="7" type="module">
    const miterLimitInput = Inputs.range([1, 10], {
      label: 'Miter limit',
      value: 4,
      step: 0.1,
      disabled: joinType !== 'miter'
    });
    const miterLimit = view(miterLimitInput);
  </script>
  <script id="8" type="module">
    const joinResolutionInput = Inputs.range([2, 16], {
      label: 'Round join resolution',
      value: 8,
      step: 1,
      disabled: joinType !== 'round'
    });
    const joinResolution = view(joinResolutionInput);
  </script>
  <script id="9" type="module">
    const capResolutionInput = Inputs.range([2, 16], {
      label: 'Round cap resolution',
      value: 8,
      step: 1,
      disabled: capType !== 'round'
    });
    const capResolution = view(capResolutionInput);
  </script>
  <script id="10" type="module">
    display(html`<div class="lines-controls">
      ${lineWidthInput}
      ${joinTypeInput}
      ${capTypeInput}
      ${patternInput}
      ${miterLimitInput}
      ${joinResolutionInput}
      ${capResolutionInput}
      ${sdfStrokeWidthInput}
      ${alphaInput}
      ${lineBreakInput}
      ${stripesInput}
      ${varyingWidthInput}
      ${debugViewInput}
    </div>`);
  </script>
  <script id="11" type="module">
    import { createGPULines } from 'npm:webgpu-instanced-lines';

    pattern; lineBreak;

    function generatePattern(patternType, insertLineBreak) {
      let basePoints;
      if (patternType === 'zigzag') {
        const n = 6;
        basePoints = [];
        for (let i = 0; i < n; i++) {
          const t = i / (n - 1);
          const x = -0.6 + t * 1.2;
          const y = (i % 2 === 0 ? 0.2 : -0.2);
          basePoints.push({ x, y, z: 0, w: 1 });
        }
      } else if (patternType === 'spiral') {
        const n = 80;
        basePoints = [];
        for (let i = 0; i < n; i++) {
          const t = i / (n - 1);
          const angle = t * Math.PI * 6;
          const r = 0.1 + t * 0.6;
          basePoints.push({ x: r * Math.cos(angle), y: r * Math.sin(angle), z: 0, w: 1 });
        }
      } else {
        const n = 100;
        basePoints = [];
        for (let i = 0; i < n; i++) {
          const t = i / (n - 1);
          const x = -0.8 + t * 1.6;
          const y = 0.3 * Math.sin(t * Math.PI * 4) + 0.2 * Math.cos(t * Math.PI * 7);
          basePoints.push({ x, y, z: 0, w: 1 });
        }
      }

      if (insertLineBreak) {
        const midIndex = Math.floor(basePoints.length / 2);
        basePoints.splice(midIndex, 0, { x: 0, y: 0, z: 0, w: 0 });
      }

      return basePoints;
    }

    const points = generatePattern(pattern, lineBreak);
    const numPoints = points.length;

    function pointsToFloat32Array(pts) {
      const arr = new Float32Array(pts.length * 4);
      for (let i = 0; i < pts.length; i++) {
        arr[i * 4 + 0] = pts[i].x;
        arr[i * 4 + 1] = pts[i].y;
        arr[i * 4 + 2] = pts[i].z;
        arr[i * 4 + 3] = pts[i].w;
      }
      return arr;
    }

    // Compute cumulative distance along the line
    function computeDistances(pts) {
      const distances = new Float32Array(pts.length);
      let cumDist = 0;
      for (let i = 0; i < pts.length; i++) {
        if (pts[i].w === 0) {
          // Line break - reset distance
          cumDist = 0;
        } else if (i > 0 && pts[i - 1].w !== 0) {
          const dx = pts[i].x - pts[i - 1].x;
          const dy = pts[i].y - pts[i - 1].y;
          cumDist += Math.sqrt(dx * dx + dy * dy);
        }
        distances[i] = cumDist;
      }
      return distances;
    }

    const positions = pointsToFloat32Array(points);
    const distances = computeDistances(points);
    const totalDistance = Math.max(...distances);

    const positionBuffer = device.createBuffer({
      label: 'line-positions',
      size: positions.byteLength,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(positionBuffer, 0, positions);

    const distanceBuffer = device.createBuffer({
      label: 'line-distances',
      size: distances.byteLength,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(distanceBuffer, 0, distances);

    const totalDistanceBuffer = device.createBuffer({
      label: 'total-distance',
      size: 4,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(totalDistanceBuffer, 0, new Float32Array([totalDistance]));

    function updateBuffers() {
      const newPositions = pointsToFloat32Array(points);
      const newDistances = computeDistances(points);
      const newTotalDistance = Math.max(...newDistances);
      device.queue.writeBuffer(positionBuffer, 0, newPositions);
      device.queue.writeBuffer(distanceBuffer, 0, newDistances);
      device.queue.writeBuffer(totalDistanceBuffer, 0, new Float32Array([newTotalDistance]));
      renderState.dirty = true;
    }

    invalidation.then(() => {
      positionBuffer.destroy();
      distanceBuffer.destroy();
      totalDistanceBuffer.destroy();
    });
  </script>
  <script id="12" type="module">
    const svg = d3.select(stack.elements.svg);

    const editablePoints = points.map((p, i) => ({ point: p, index: i }))
                                 .filter(d => d.point.w !== 0);

    // Use groups with invisible hit area + visible circle
    const handleGroups = svg.selectAll('g.vertex-handle')
      .data(editablePoints, d => d.index)
      .join('g')
      .attr('class', 'vertex-handle')
      .attr('cursor', 'move')
      .call(d3.drag()
        .on('start', function() {
          d3.select(this).select('circle.visible')
            .attr('stroke', '#0066cc').attr('stroke-width', 2);
        })
        .on('drag', function(event, d) {
          d.point.x = axes.xScale.invert(event.x);
          d.point.y = axes.yScale.invert(event.y);
          d3.select(this).attr('transform', `translate(${event.x},${event.y})`);
          updateBuffers();
        })
        .on('end', function() {
          d3.select(this).select('circle.visible')
            .attr('stroke', '#333').attr('stroke-width', 1.5);
        })
      );

    // Invisible hit area (larger)
    handleGroups.append('circle')
      .attr('class', 'hit-area')
      .attr('r', 20)
      .attr('fill', 'transparent');

    // Visible circle (smaller)
    handleGroups.append('circle')
      .attr('class', 'visible')
      .attr('r', 5)
      .attr('fill', 'white')
      .attr('stroke', '#333')
      .attr('stroke-width', 1.5)
      .attr('pointer-events', 'none');

    function updateHandlePositions() {
      handleGroups.attr('transform', d =>
        `translate(${axes.xScale(d.point.x)},${axes.yScale(d.point.y)})`);
    }

    updateHandlePositions();
    stack.addEventListener('update', updateHandlePositions);
  </script>
  <script id="13" type="module">
    joinType; joinResolution; miterLimit; capType; capResolution; sdfStrokeWidth; alpha; stripes; varyingWidth; debugView; lineWidth;

    const useSdfMode = sdfStrokeWidth > 0;
    const useBlend = useSdfMode || alpha < 1 || debugView;
    const baseWidth = lineWidth * dpr;

    // Vertex shader body with position buffer, distance buffer, and view matrix
    const vertexShaderBody = /* wgsl */`
      @group(1) @binding(0) var<storage, read> positions: array<vec4f>;
      @group(1) @binding(1) var<storage, read> distances: array<f32>;
      @group(1) @binding(2) var<uniform> viewMatrix: mat4x4f;
      @group(1) @binding(3) var<uniform> totalDistance: f32;
      struct DebugUniforms {
        enabled: u32,
        dpr: f32,
      }
      @group(1) @binding(4) var<uniform> debug: DebugUniforms;

      struct Vertex {
        position: vec4f,
        width: f32,
        dist: f32,      // cumulative distance along line
        lineWidth: f32, // interpolated width for fragment shader
      }

      fn getVertex(index: u32) -> Vertex {
        let p = positions[index];
        let d = distances[index];
        let projected = viewMatrix * vec4f(p.xyz, 1.0);
        let normalizedDist = d / totalDistance;
        let w = ${varyingWidth ? `${baseWidth.toFixed(1)} * (0.5 + 1.5 * normalizedDist)` : `${baseWidth.toFixed(1)}`};
        return Vertex(vec4f(projected.xyz, p.w * projected.w), w, d, w);
      }
    `;

    // SDF distance function: round uses length, square uses max(abs)
    const sdfDistFn = capType === 'square'
      ? 'max(abs(lineCoord.x), abs(lineCoord.y))'
      : 'length(lineCoord.xy)';

    // Unified fragment shader handling all modes
    const fragmentShaderBody = /* wgsl */`
      struct DebugUniforms {
        enabled: u32,
        dpr: f32,
      }
      @group(1) @binding(4) var<uniform> debug: DebugUniforms;

      fn linearstep(a: f32, b: f32, x: f32) -> f32 {
        return clamp((x - a) / (b - a), 0.0, 1.0);
      }

      // Unit grid lines for wireframe
      fn grid(parameter: vec3f, width: f32, feather: f32) -> f32 {
        let w1 = width - feather * 0.5;
        let d = fwidth(parameter);
        let looped = 0.5 - abs(parameter % 1.0 - 0.5);
        let a3 = smoothstep(d * w1, d * (w1 + feather), looped);
        return min(min(a3.x, a3.y), a3.z);
      }

      fn getColor(lineCoord: vec2f, dist: f32, lineWidth: f32, instanceID: f32, triStripCoord: vec2f) -> vec4f {
        let strokeWidth = ${sdfStrokeWidth.toFixed(1)} * debug.dpr;
        let baseAlpha = ${alpha.toFixed(2)};

        // Compute SDF values
        let sdf = 0.5 * lineWidth * ${sdfDistFn};
        let aa = select(baseAlpha, linearstep(lineWidth * 0.5, lineWidth * 0.5 - 1.0, sdf) * baseAlpha, strokeWidth > 0.0);
        let strokeMask = select(0.0, linearstep(lineWidth * 0.5 - strokeWidth - 0.5, lineWidth * 0.5 - strokeWidth + 0.5, sdf), strokeWidth > 0.0);

        // Layer 1: Base fill color (debug instance color or normal color)
        var baseColor: vec3f;
        if (debug.enabled == 1u) {
          let iInstanceID = floor(instanceID + 0.5);
          if (iInstanceID < 0.0) {
            baseColor = vec3f(0.8, 0.1, 0.4);  // Red/pink for caps
          } else {
            baseColor = select(vec3f(0.8, 0.1, 0.4), vec3f(0.1, 0.7, 1.0), i32(iInstanceID) % 2 == 0);
          }
        } else {
          baseColor = vec3f(0.1, 0.7, 1.0);
        }

        // Layer 2: Apply stripes on top of base color
        let stripeFreq = 20.0;
        let stripe = step(0.5, fract(dist * stripeFreq));
        let stripeColor = baseColor * 0.4;  // Darker version of base
        var color = ${stripes ? 'mix(baseColor, stripeColor, stripe)' : 'baseColor'};

        // Layer 3: Apply stroke (50% black in debug mode, dark blue in normal mode)
        color = mix(color, vec3f(0.0), strokeMask * 0.7);

        // Layer 4: Wireframe gridlines (debug only)
        if (debug.enabled == 1u) {
          let wire = grid(vec3f(triStripCoord, triStripCoord.x + triStripCoord.y), 0.5 * debug.dpr, 1.0);
          color = mix(vec3f(1.0), color, wire);
        }

        return vec4f(color, aa);
      }
    `;

    const gpuLines = createGPULines(device, {
      colorTargets: [{
        format: canvasFormat,
        blend: useBlend ? {
          color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
          alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' }
        } : undefined
      }],
      join: joinType,
      joinResolution: joinResolution,
      miterLimit: miterLimit,
      cap: capType,
      capResolution: capResolution,
      vertexShaderBody,
      fragmentShaderBody
    });

    // Create view matrix buffer
    const viewMatrixBuffer = device.createBuffer({
      label: 'view-matrix',
      size: 64, // mat4x4f
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    // Create debug uniform buffer (8 bytes: u32 enabled + f32 dpr)
    const debugBuffer = device.createBuffer({
      label: 'debug-uniform',
      size: 8,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    // Create bind group for user data (group 1)
    const dataBindGroup = device.createBindGroup({
      layout: gpuLines.getBindGroupLayout(1),
      entries: [
        { binding: 0, resource: { buffer: positionBuffer } },
        { binding: 1, resource: { buffer: distanceBuffer } },
        { binding: 2, resource: { buffer: viewMatrixBuffer } },
        { binding: 3, resource: { buffer: totalDistanceBuffer } },
        { binding: 4, resource: { buffer: debugBuffer } }
      ]
    });

    invalidation.then(() => {
      gpuLines.destroy();
      viewMatrixBuffer.destroy();
      debugBuffer.destroy();
    });
  </script>
  <script id="14" type="module">
    import { createFrameLoop } from './lib/frame-loop.js';

    lineWidth; debugView; renderState.dirty = true;

    const loop = createFrameLoop(() => {
      if (renderState.dirty) {
        // Update view matrix buffer
        device.queue.writeBuffer(viewMatrixBuffer, 0, axes.view);

        // Update debug uniform (enabled: u32, dpr: f32)
        const debugData = new ArrayBuffer(8);
        new Uint32Array(debugData, 0, 1)[0] = debugView ? 1 : 0;
        new Float32Array(debugData, 4, 1)[0] = dpr;
        device.queue.writeBuffer(debugBuffer, 0, debugData);

        const encoder = device.createCommandEncoder();

        const pass = encoder.beginRenderPass({
          colorAttachments: [{
            view: gpuContext.getCurrentTexture().createView(),
            loadOp: 'clear',
            storeOp: 'store',
            clearValue: { r: 1.0, g: 1.0, b: 1.0, a: 1 }
          }]
        });

        gpuLines.draw(pass, {
          vertexCount: numPoints,
          width: lineWidth * dpr,
          resolution: [canvas.width, canvas.height]
        }, [dataBindGroup]);

        pass.end();
        device.queue.submit([encoder.finish()]);
        renderState.dirty = false;
      }
    });

    invalidation.then(() => loop.cancel());
  </script>
  <script id="15" type="text/markdown">
    ## Rationale

    Drawing lines on the GPU is surprisingly difficult. The hardware primitive `LINE_STRIP` produces lines exactly one pixel wide, which is rarely what you want. To get variable-width lines with proper joins and caps, you need to expand lines into triangles yourself.

    This library takes a pragmatic approach: it uses instanced rendering with triangle strips to draw one segment per instance, including half of each join on either end. This avoids the complexity of full stroke expansion algorithms while still producing good results for most use cases.

    The tradeoff is that the library does not handle self-intersecting lines correctly. For scientific visualization, data plots, and UI elements, this is usually acceptable. For complex vector graphics with many overlapping strokes, you may need a more sophisticated solution.

    The shader interface is designed to be flexible. Rather than prescribing a specific data format, you write a vertex function that fetches positions from wherever you store them (buffers, textures, procedural computation) and returns clip-space coordinates plus any per-vertex data you need. The library handles the geometry expansion, and your fragment shader receives a `lineCoord` varying that makes it easy to implement SDF-based anti-aliasing and stroke effects.

    For background on GPU line rendering, see Matt DesLauriers' [Drawing Lines is Hard](https://mattdesl.svbtle.com/drawing-lines-is-hard) and Rye Terrell's [Instanced Line Rendering](https://wwwtyro.net/2019/11/18/instanced-lines.html).
  </script>
</notebook>
