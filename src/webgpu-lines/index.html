<!doctype html>
<notebook theme="air">
  <title>WebGPU Lines</title>
  <script id="1" type="text/markdown">
    # WebGPU Lines

    This notebook implements GPU-accelerated line rendering using WebGPU, based on the techniques from [regl-gpu-lines](https://github.com/rreusser/regl-gpu-lines).

    Key features:
    - Instanced rendering with triangle strips
    - Screen-space line width (constant pixel width regardless of zoom)
    - Bevel, miter, and round joins
    - Integer index-based geometry generation in the vertex shader
  </script>
  <script id="2" type="module">
    // Initialize WebGPU
    if (!navigator.gpu) {
      display(html`<p style="color: red;">WebGPU is not supported in this browser.</p>`);
      throw new Error('WebGPU not supported');
    }

    const adapter = await navigator.gpu.requestAdapter();
    if (!adapter) {
      throw new Error('Failed to get WebGPU adapter');
    }

    const device = await adapter.requestDevice();
    const canvasFormat = navigator.gpu.getPreferredCanvasFormat();

    invalidation.then(() => device.destroy());
  </script>
  <script id="3" type="module">
    import { createElementStack } from './lib/element-stack.js'
    import { createZoomableAxes } from './lib/zoomable-axes.js'

    // Create canvas and configure WebGPU context
    const dpr = window.devicePixelRatio || 1;
    const canvasWidth = Math.min(640, width);
    const canvasHeight = 480;

    // Create element stack with WebGPU canvas and SVG overlay for zoom
    const stack = createElementStack({
      width: canvasWidth,
      height: canvasHeight,
      layers: [{
        id: 'canvas',
        element: ({ current, width, height }) => {
          const canvas = current || document.createElement('canvas');
          canvas.id = 'lines-canvas';
          canvas.width = Math.floor(width * dpr);
          canvas.height = Math.floor(height * dpr);
          canvas.style.width = `${width}px`;
          canvas.style.height = `${height}px`;
          return canvas;
        }
      }, {
        id: 'svg',
        element: ({ current, width, height }) =>
          (current ? d3.select(current) : d3.create("svg"))
            .attr("width", width)
            .attr("height", height)
            .style("cursor", "grab")
            .node()
      }]
    });

    const canvas = stack.elements.canvas;

    const gpuContext = canvas.getContext('webgpu');
    gpuContext.configure({
      device,
      format: canvasFormat,
      alphaMode: 'premultiplied'
    });

    // Render state (mutable object to allow cross-cell updates)
    const renderState = { dirty: true };

    // Set up zoomable axes with aspect ratio 1 (square pixels)
    const axes = createZoomableAxes({
      d3,
      element: stack.elements.svg,
      xScale: d3.scaleLinear().domain([-1, 1]).range([0, canvasWidth]),
      yScale: d3.scaleLinear().domain([-1, 1]).range([canvasHeight, 0]),
      aspectRatio: 1,
      onChange: () => { renderState.dirty = true; }
    });

    const figure = html`<figure style="margin: 0;">
      ${stack.element}
      <figcaption>Drag to pan, scroll to zoom.</figcaption>
    </figure>`;
    figure.style.border = '1px solid #ccc';
    figure.style.display = 'inline-block';

    display(figure);
  </script>
  <script id="4" type="module">
    // Controls
    const lineWidthInput = Inputs.range([1, 50], { label: 'Line width', value: 50, step: 0.5 });
    const lineWidth = view(lineWidthInput);

    const joinTypeInput = Inputs.select(['bevel', 'miter', 'round'], { label: 'Join type', value: 'miter' });
    const joinType = view(joinTypeInput);

    const patternInput = Inputs.select(['wave', 'zigzag', 'spiral'], { label: 'Pattern', value: 'zigzag' });
    const pattern = view(patternInput);

    const miterLimitInput = Inputs.range([1, 10], { label: 'Miter limit', value: 1, step: 0.1 });
    const miterLimit = view(miterLimitInput);

    const joinResolutionInput = Inputs.range([2, 16], { label: 'Round join resolution', value: 8, step: 1 });
    const joinResolution = view(joinResolutionInput);

    const capTypeInput = Inputs.select(['round', 'square', 'none'], { label: 'Cap type', value: 'round' });
    const capType = view(capTypeInput);

    const capResolutionInput = Inputs.range([2, 16], { label: 'Round cap resolution', value: 8, step: 1 });
    const capResolution = view(capResolutionInput);

    const sdfModeInput = Inputs.toggle({ label: 'SDF stroke outline', value: false });
    const sdfMode = view(sdfModeInput);

    const borderWidthInput = Inputs.range([1, 10], { label: 'Border width', value: 4, step: 0.5 });
    const borderWidth = view(borderWidthInput);

    const lineBreakInput = Inputs.toggle({ label: 'Line break', value: false });
    const lineBreak = view(lineBreakInput);

    display(html`<div style="display: flex; gap: 20px; flex-wrap: wrap;">
      ${lineWidthInput}
      ${joinTypeInput}
      ${capTypeInput}
      ${patternInput}
      ${miterLimitInput}
      ${joinResolutionInput}
      ${capResolutionInput}
      ${sdfModeInput}
      ${borderWidthInput}
      ${lineBreakInput}
    </div>`);
  </script>
  <script id="5" type="module">
    import { createGPULines } from './webgpu-lines.js';

    // Regenerate line data when pattern or lineBreak changes
    pattern; lineBreak;

    function generatePattern(patternType, insertLineBreak) {
      // Generate base points first
      let basePoints;
      if (patternType === 'zigzag') {
        const n = 6;
        basePoints = [];
        for (let i = 0; i < n; i++) {
          const t = i / (n - 1);
          const x = -0.6 + t * 1.2;
          const y = (i % 2 === 0 ? 0.2 : -0.2);
          basePoints.push([x, y, 0, 1]);
        }
      } else if (patternType === 'spiral') {
        const n = 80;
        basePoints = [];
        for (let i = 0; i < n; i++) {
          const t = i / (n - 1);
          const angle = t * Math.PI * 6;
          const r = 0.1 + t * 0.6;
          basePoints.push([r * Math.cos(angle), r * Math.sin(angle), 0, 1]);
        }
      } else {
        // Wave pattern (default)
        const n = 100;
        basePoints = [];
        for (let i = 0; i < n; i++) {
          const t = i / (n - 1);
          const x = -0.8 + t * 1.6;
          const y = 0.3 * Math.sin(t * Math.PI * 4) + 0.2 * Math.cos(t * Math.PI * 7);
          basePoints.push([x, y, 0, 1]);
        }
      }

      // Insert line break sentinel (w=0) in the middle if requested
      if (insertLineBreak) {
        const midIndex = Math.floor(basePoints.length / 2);
        basePoints.splice(midIndex, 0, [0, 0, 0, 0]); // sentinel: w=0
      }

      // Convert to Float32Array
      const numPoints = basePoints.length;
      const positions = new Float32Array(numPoints * 4);
      for (let i = 0; i < numPoints; i++) {
        positions[i * 4 + 0] = basePoints[i][0];
        positions[i * 4 + 1] = basePoints[i][1];
        positions[i * 4 + 2] = basePoints[i][2];
        positions[i * 4 + 3] = basePoints[i][3];
      }

      return { positions, numPoints };
    }

    const { positions, numPoints } = generatePattern(pattern, lineBreak);

    // Create position buffer
    const positionBuffer = device.createBuffer({
      label: 'line-positions',
      size: positions.byteLength,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(positionBuffer, 0, positions);

    invalidation.then(() => positionBuffer.destroy());
  </script>
  <script id="6" type="module">
    // Recreate pipeline when join/cap type, resolution, or SDF mode changes
    // Note: lineWidth is included because SDF shader embeds width value
    joinType; joinResolution; miterLimit; capType; capResolution; sdfMode; borderWidth; lineWidth;

    // Standard fragment shader - solid color with edge darkening
    const standardFragmentShader = /* wgsl */`
      fn getColor(lineCoord: vec3f) -> vec4f {
        // lineCoord.x: along the line (for dashes)
        // lineCoord.y: across the line (-1 to 1, 0 at center)
        // lineCoord.z: 1 if outside main segment (in join extrapolation) or cap

        // Simple solid color with slight edge darkening
        let edge = 1.0 - 0.3 * abs(lineCoord.y);
        return vec4f(0.2 * edge, 0.5 * edge, 0.9 * edge, 1.0);
      }
    `;

    // SDF fragment shader - stroke outline using signed distance field
    const sdfFragmentShader = /* wgsl */`
      fn linearstep(a: f32, b: f32, x: f32) -> f32 {
        return clamp((x - a) / (b - a), 0.0, 1.0);
      }
      fn getColor(lineCoord: vec3f) -> vec4f {
        let width = ${lineWidth.toFixed(1)};
        let border = ${borderWidth.toFixed(1)};

        // SDF: distance from center in screen pixels
        let sdf = 0.5 * width * length(lineCoord.xy);

        // Anti-aliased edge
        let aa = linearstep(width * 0.5, width * 0.5 - 1.0, sdf);

        // Border region (starts at border pixels from edge)
        let borderMask = linearstep(width * 0.5 - border - 0.5, width * 0.5 - border + 0.5, sdf);

        // Fill color (light blue) with darker border
        let fillColor = vec3f(0.4, 0.7, 1.0);
        let borderColor = vec3f(0.1, 0.3, 0.6);
        let color = mix(fillColor, borderColor, borderMask);

        return vec4f(color, aa);
      }
    `;

    const gpuLines = createGPULines(device, {
      format: canvasFormat,
      join: joinType,
      joinResolution: joinResolution,
      miterLimit: miterLimit,
      cap: capType,
      capResolution: capResolution,
      vertexShaderBody: '',
      fragmentShaderBody: sdfMode ? sdfFragmentShader : standardFragmentShader,
      // Alpha blending for SDF mode
      blend: sdfMode ? {
        color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
        alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' }
      } : null
    });

    invalidation.then(() => gpuLines.destroy());
  </script>
  <script id="7" type="module">
    // Mark dirty when controls change
    lineWidth; renderState.dirty = true;

    // Render loop
    let frameId = null;

    const drawProps = {
      positionBuffer,
      vertexCount: numPoints,
      width: lineWidth,
      resolution: [canvas.width, canvas.height],
      viewMatrix: axes.view
    };

    function render() {
      if (renderState.dirty) {
        drawProps.width = lineWidth;
        drawProps.viewMatrix = axes.view;

        const encoder = device.createCommandEncoder();

        // Run compute passes for endpoint detection (must be before render pass)
        gpuLines.prepareFrame(encoder, drawProps);

        const pass = encoder.beginRenderPass({
          colorAttachments: [{
            view: gpuContext.getCurrentTexture().createView(),
            loadOp: 'clear',
            storeOp: 'store',
            clearValue: { r: 0.95, g: 0.95, b: 0.95, a: 1 }
          }]
        });

        gpuLines.draw(pass, drawProps);

        pass.end();
        device.queue.submit([encoder.finish()]);

        renderState.dirty = false;
      }

      frameId = requestAnimationFrame(render);
    }

    frameId = requestAnimationFrame(render);

    invalidation.then(() => {
      if (frameId !== null) {
        cancelAnimationFrame(frameId);
      }
    });
  </script>
  <script id="8" type="text/markdown">
    ## How it works

    The line renderer uses instanced rendering where each instance draws one segment of the line. For a line with N points, there are N-3 instances (since each instance needs a 4-point window: previous, start, end, next).

    The vertex shader generates geometry using only a vertex index (0 to ~10 for bevel joins, more for round joins). This index determines:
    1. Which half of the join we're drawing (first half at start, or mirrored second half at end)
    2. Whether this vertex is on the outer edge, inner edge, or miter point of the join
    3. The position along the segment

    All geometry is computed in screen space to ensure consistent line width regardless of projection.
  </script>
</notebook>
