<!doctype html>
<notebook theme="air">
  <title>WebGPU Instanced Lines</title>
  <script id="0" type="module">
    const link = html`<a href="https://github.com/rreusser/webgpu-instanced-lines" target="_blank" style="
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: #24292e;
      color: white;
      border-radius: 6px;
      text-decoration: none;
      font-size: 14px;
      font-weight: 500;
      float: right;
      margin: 0 0 10px 10px;
    ">
      <svg height="20" width="20" viewBox="0 0 16 16" fill="currentColor">
        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
      </svg>
      View on GitHub
    </a>`;
    display(link);
  </script>
  <script id="1" type="text/markdown">
    # WebGPU Instanced Lines

    [webgpu-instanced-lines](https://www.npmjs.com/package/webgpu-instanced-lines) is a library for high-performance, customizable line rendering for WebGPU using instanced triangle strips. It is a WebGPU port of [regl-gpu-lines](https://github.com/rreusser/regl-gpu-lines). This notebook is where I originally developed the implementation. The source now lives on [GitHub](https://github.com/rreusser/webgpu-instanced-lines).

    ## Interactive Demo

    Explore the line rendering options with interactive demo below. Drag handles to edit vertices, drag the background to pan, and scroll to zoom. Enable **Debug view** to see the underlying triangle strip structure. Alternating colors indicate separate instances.
  </script>
  <script id="2" type="module">
    // Initialize WebGPU for interactive demo
    if (!navigator.gpu) {
      display(html`<p style="color: red;">WebGPU is not supported in this browser.</p>`);
      throw new Error('WebGPU not supported');
    }

    const adapter = await navigator.gpu.requestAdapter();
    if (!adapter) {
      throw new Error('Failed to get WebGPU adapter');
    }

    const device = await adapter.requestDevice();
    const canvasFormat = navigator.gpu.getPreferredCanvasFormat();

    invalidation.then(() => device.destroy());
  </script>
  <script id="5" type="module">
    import { createElementStack } from './lib/element-stack.js'
    import { createZoomableAxes } from './lib/zoomable-axes.js'
    import { expandable } from './lib/expandable.js'

    const dpr = window.devicePixelRatio || 1;
    const canvasWidth = Math.min(640, width);
    const canvasHeight = 480;

    const stack = createElementStack({
      width: canvasWidth,
      height: canvasHeight,
      layers: [{
        id: 'canvas',
        element: ({ current, width, height }) => {
          const canvas = current || document.createElement('canvas');
          canvas.id = 'lines-canvas';
          canvas.width = Math.floor(width * dpr);
          canvas.height = Math.floor(height * dpr);
          canvas.style.width = `${width}px`;
          canvas.style.height = `${height}px`;
          canvas.style.border = '1px solid rgba(0,0,0,0.2)';
          return canvas;
        }
      }, {
        id: 'svg',
        element: ({ current, width, height }) =>
          (current ? d3.select(current) : d3.create("svg"))
            .attr("width", width)
            .attr("height", height)
            .style("cursor", "grab")
            .node()
      }]
    });

    const canvas = stack.elements.canvas;

    const gpuContext = canvas.getContext('webgpu');
    gpuContext.configure({
      device,
      format: canvasFormat,
      alphaMode: 'premultiplied'
    });

    const renderState = { dirty: true };

    const axes = createZoomableAxes({
      d3,
      element: stack.elements.svg,
      xScale: d3.scaleLinear().domain([-1, 1]).range([0, canvasWidth]),
      yScale: d3.scaleLinear().domain([-1, 1]).range([canvasHeight, 0]),
      aspectRatio: 1,
      onChange: () => {
        renderState.dirty = true;
        stack.dispatchEvent(new CustomEvent('update'));
      }
    });

    const figure = html`<figure style="margin: 0;">
      ${stack.element}
      <figcaption style="margin-top:5px">Drag handles to edit vertices. Drag background to pan, scroll to zoom.</figcaption>
    </figure>`;

    display(expandable(figure, {
      width: canvasWidth,
      height: canvasHeight,
      controls: '.lines-controls',
      onResize(el, w, h) {
        stack.resize(w, h);
        axes.updateScales(
          d3.scaleLinear().domain([-1, 1]).range([0, w]),
          d3.scaleLinear().domain([-1, 1]).range([h, 0])
        );
        renderState.dirty = true;
        stack.dispatchEvent(new CustomEvent('update'));
      }
    }));
  </script>
  <script id="6" type="module">
    const lineWidthInput = Inputs.range([1, 100], { label: 'Line width', value: 70, step: 0.5 });
    const lineWidth = view(lineWidthInput);

    const joinTypeInput = Inputs.select(['bevel', 'miter', 'round'], { label: 'Join type', value: 'miter' });
    const joinType = view(joinTypeInput);

    const capTypeInput = Inputs.select(['round', 'square', 'butt'], { label: 'Cap type', value: 'round' });
    const capType = view(capTypeInput);

    const patternInput = Inputs.select(['wave', 'zigzag', 'spiral'], { label: 'Pattern', value: 'zigzag' });
    const pattern = view(patternInput);

    const sdfStrokeWidthInput = Inputs.range([0, 50], { label: 'SDF stroke width', value: 10, step: 0.5 });
    const sdfStrokeWidth = view(sdfStrokeWidthInput);

    const alphaInput = Inputs.range([0, 1], { label: 'Alpha', value: 1, step: 0.01 });
    const alpha = view(alphaInput);

    const lineBreakInput = Inputs.toggle({ label: 'Line break', value: false });
    const lineBreak = view(lineBreakInput);

    const stripesInput = Inputs.toggle({ label: 'Stripes', value: false });
    const stripes = view(stripesInput);

    const varyingWidthInput = Inputs.toggle({ label: 'Varying width', value: false });
    const varyingWidth = view(varyingWidthInput);

    const debugViewInput = Inputs.toggle({ label: 'Debug view', value: 'Debug view' });
    const debugView = view(debugViewInput);

    const depthTestInput = Inputs.toggle({ label: 'Depth test' });
    const depthTest = view(depthTestInput);

    const cullBackFacesInput = Inputs.toggle({ label: 'Cull back faces' });
    const cullBackFaces = view(cullBackFacesInput);
  </script>
  <script id="7" type="module">
    const miterLimitInput = Inputs.range([1, 10], {
      label: 'Miter limit',
      value: 4,
      step: 0.1,
      disabled: joinType !== 'miter'
    });
    const miterLimit = view(miterLimitInput);
  </script>
  <script id="8" type="module">
    const joinResolutionInput = Inputs.range([2, 16], {
      label: 'Round join resolution',
      value: 8,
      step: 1,
      disabled: joinType !== 'round'
    });
    const joinResolution = view(joinResolutionInput);
  </script>
  <script id="9" type="module">
    const capResolutionInput = Inputs.range([2, 16], {
      label: 'Round cap resolution',
      value: 8,
      step: 1,
      disabled: capType !== 'round'
    });
    const capResolution = view(capResolutionInput);

    const downloadButtonInput = Inputs.button('Download PNG');
    const downloadButton = view(downloadButtonInput);
  </script>
  <script id="10" type="module">
    display(html`<div class="lines-controls">
      ${lineWidthInput}
      ${joinTypeInput}
      ${capTypeInput}
      ${patternInput}
      ${miterLimitInput}
      ${joinResolutionInput}
      ${capResolutionInput}
      ${sdfStrokeWidthInput}
      ${alphaInput}
      ${lineBreakInput}
      ${stripesInput}
      ${varyingWidthInput}
      ${debugViewInput}
      ${depthTestInput}
      ${cullBackFacesInput}
      ${downloadButtonInput}
    </div>`);
  </script>
  <script id="11" type="module">
    import { createGPULines } from 'npm:webgpu-instanced-lines';

    pattern; lineBreak;

    function generatePattern(patternType, insertLineBreak) {
      let basePoints;
      if (patternType === 'zigzag') {
        const n = 6;
        basePoints = [];
        for (let i = 0; i < n; i++) {
          const t = i / (n - 1);
          const x = -0.6 + t * 1.2;
          const y = (i % 2 === 0 ? 0.2 : -0.2);
          basePoints.push({ x, y, z: 0, w: 1 });
        }
      } else if (patternType === 'spiral') {
        const n = 80;
        basePoints = [];
        for (let i = 0; i < n; i++) {
          const t = i / (n - 1);
          const angle = t * Math.PI * 6;
          const r = 0.1 + t * 0.6;
          basePoints.push({ x: r * Math.cos(angle), y: r * Math.sin(angle), z: 0, w: 1 });
        }
      } else {
        const n = 100;
        basePoints = [];
        for (let i = 0; i < n; i++) {
          const t = i / (n - 1);
          const x = -0.8 + t * 1.6;
          const y = 0.3 * Math.sin(t * Math.PI * 4) + 0.2 * Math.cos(t * Math.PI * 7);
          basePoints.push({ x, y, z: 0, w: 1 });
        }
      }

      if (insertLineBreak) {
        const midIndex = Math.floor(basePoints.length / 2);
        basePoints.splice(midIndex, 0, { x: 0, y: 0, z: 0, w: 0 });
      }

      return basePoints;
    }

    const points = generatePattern(pattern, lineBreak);
    const numPoints = points.length;

    function pointsToFloat32Array(pts) {
      const arr = new Float32Array(pts.length * 4);
      for (let i = 0; i < pts.length; i++) {
        arr[i * 4 + 0] = pts[i].x;
        arr[i * 4 + 1] = pts[i].y;
        arr[i * 4 + 2] = pts[i].z;
        arr[i * 4 + 3] = pts[i].w;
      }
      return arr;
    }

    // Compute cumulative distance along the line
    function computeDistances(pts) {
      const distances = new Float32Array(pts.length);
      let cumDist = 0;
      for (let i = 0; i < pts.length; i++) {
        if (pts[i].w === 0) {
          // Line break - reset distance
          cumDist = 0;
        } else if (i > 0 && pts[i - 1].w !== 0) {
          const dx = pts[i].x - pts[i - 1].x;
          const dy = pts[i].y - pts[i - 1].y;
          cumDist += Math.sqrt(dx * dx + dy * dy);
        }
        distances[i] = cumDist;
      }
      return distances;
    }

    const positions = pointsToFloat32Array(points);
    const distances = computeDistances(points);
    const totalDistance = Math.max(...distances);

    const positionBuffer = device.createBuffer({
      label: 'line-positions',
      size: positions.byteLength,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(positionBuffer, 0, positions);

    const distanceBuffer = device.createBuffer({
      label: 'line-distances',
      size: distances.byteLength,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(distanceBuffer, 0, distances);

    const totalDistanceBuffer = device.createBuffer({
      label: 'total-distance',
      size: 4,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(totalDistanceBuffer, 0, new Float32Array([totalDistance]));

    function updateBuffers() {
      const newPositions = pointsToFloat32Array(points);
      const newDistances = computeDistances(points);
      const newTotalDistance = Math.max(...newDistances);
      device.queue.writeBuffer(positionBuffer, 0, newPositions);
      device.queue.writeBuffer(distanceBuffer, 0, newDistances);
      device.queue.writeBuffer(totalDistanceBuffer, 0, new Float32Array([newTotalDistance]));
      renderState.dirty = true;
    }

    invalidation.then(() => {
      positionBuffer.destroy();
      distanceBuffer.destroy();
      totalDistanceBuffer.destroy();
    });
  </script>
  <script id="12" type="module">
    const svg = d3.select(stack.elements.svg);

    const editablePoints = points.map((p, i) => ({ point: p, index: i }))
                                 .filter(d => d.point.w !== 0);

    // Use groups with invisible hit area + visible circle
    const handleGroups = svg.selectAll('g.vertex-handle')
      .data(editablePoints, d => d.index)
      .join('g')
      .attr('class', 'vertex-handle')
      .attr('cursor', 'move')
      .call(d3.drag()
        .on('start', function() {
          d3.select(this).select('circle.visible')
            .attr('stroke', '#0066cc').attr('stroke-width', 2);
        })
        .on('drag', function(event, d) {
          d.point.x = axes.xScale.invert(event.x);
          d.point.y = axes.yScale.invert(event.y);
          d3.select(this).attr('transform', `translate(${event.x},${event.y})`);
          updateBuffers();
        })
        .on('end', function() {
          d3.select(this).select('circle.visible')
            .attr('stroke', '#333').attr('stroke-width', 1.5);
        })
      );

    // Invisible hit area (larger)
    handleGroups.append('circle')
      .attr('class', 'hit-area')
      .attr('r', 20)
      .attr('fill', 'transparent');

    // Visible circle (smaller)
    handleGroups.append('circle')
      .attr('class', 'visible')
      .attr('r', 5)
      .attr('fill', 'white')
      .attr('stroke', '#333')
      .attr('stroke-width', 1.5)
      .attr('pointer-events', 'none');

    function updateHandlePositions() {
      handleGroups.attr('transform', d =>
        `translate(${axes.xScale(d.point.x)},${axes.yScale(d.point.y)})`);
    }

    updateHandlePositions();
    stack.addEventListener('update', updateHandlePositions);
  </script>
  <script id="13" type="module">
    // Only depend on shader-affecting parameters (join/cap type, shader options)
    // Resolution and miterLimit are now runtime parameters passed to draw()
    joinType; capType; sdfStrokeWidth; alpha; stripes; varyingWidth; debugView; depthTest; cullBackFaces;

    const useSdfMode = sdfStrokeWidth > 0;
    const useBlend = useSdfMode || alpha < 1 || debugView;
    const depthFormat = depthTest ? 'depth24plus' : null;

    // Vertex shader body with position buffer, distance buffer, and view matrix
    const vertexShaderBody = /* wgsl */`
      @group(1) @binding(0) var<storage, read> positions: array<vec4f>;
      @group(1) @binding(1) var<storage, read> distances: array<f32>;
      @group(1) @binding(2) var<uniform> viewMatrix: mat4x4f;
      @group(1) @binding(3) var<uniform> totalDistance: f32;
      struct DebugUniforms {
        enabled: u32,
        dpr: f32,
      }
      @group(1) @binding(4) var<uniform> debug: DebugUniforms;
      @group(1) @binding(5) var<uniform> lineWidthUniform: f32;

      struct Vertex {
        position: vec4f,
        width: f32,
        dist: f32,      // cumulative distance along line
        lineWidth: f32, // interpolated width for fragment shader
      }

      fn getVertex(index: u32) -> Vertex {
        let p = positions[index];
        let d = distances[index];
        let projected = viewMatrix * vec4f(p.xyz, 1.0);
        // Reference totalDistance to ensure it's included in bind group layout
        let normalizedDist = d / totalDistance;
        let w = ${varyingWidth ? 'lineWidthUniform * (0.5 + 1.5 * normalizedDist)' : 'lineWidthUniform'};
        return Vertex(vec4f(projected.xyz, p.w * projected.w), w, d, w);
      }
    `;

    // SDF distance function: round uses length, square uses max(abs)
    const sdfDistFn = capType === 'square'
      ? 'max(abs(lineCoord.x), abs(lineCoord.y))'
      : 'length(lineCoord.xy)';

    // Unified fragment shader handling all modes
    const fragmentShaderBody = /* wgsl */`
      struct DebugUniforms {
        enabled: u32,
        dpr: f32,
      }
      @group(1) @binding(4) var<uniform> debug: DebugUniforms;

      fn linearstep(a: f32, b: f32, x: f32) -> f32 {
        return clamp((x - a) / (b - a), 0.0, 1.0);
      }

      // Unit grid lines for wireframe
      fn grid(parameter: vec3f, width: f32, feather: f32) -> f32 {
        let w1 = width - feather * 0.5;
        let d = fwidth(parameter);
        let looped = 0.5 - abs(parameter % 1.0 - 0.5);
        let a3 = smoothstep(d * w1, d * (w1 + feather), looped);
        return min(min(a3.x, a3.y), a3.z);
      }

      fn getColor(lineCoord: vec2f, dist: f32, lineWidth: f32, instanceID: f32, triStripCoord: vec2f) -> vec4f {
        let strokeWidth = ${sdfStrokeWidth.toFixed(1)} * debug.dpr;
        let baseAlpha = ${alpha.toFixed(2)};

        // Compute SDF values
        let sdf = 0.5 * lineWidth * ${sdfDistFn};
        let aa = select(baseAlpha, linearstep(lineWidth * 0.5, lineWidth * 0.5 - 1.0, sdf) * baseAlpha, strokeWidth > 0.0);
        let strokeMask = select(0.0, linearstep(lineWidth * 0.5 - strokeWidth - 0.5, lineWidth * 0.5 - strokeWidth + 0.5, sdf), strokeWidth > 0.0);

        // Layer 1: Base fill color (debug instance color or normal color)
        var baseColor: vec3f;
        if (debug.enabled == 1u) {
          // instanceID encodes: non-negative = segment index, negative = cap with index (-id - 1)
          let isCap = instanceID < 0.0;
          let segmentIndex = select(instanceID, -instanceID - 1.0, isCap);
          let iSegmentIndex = i32(floor(segmentIndex + 0.5));
          baseColor = select(vec3f(0.8, 0.1, 0.4), vec3f(0.1, 0.7, 1.0), iSegmentIndex % 2 == 0);
        } else {
          baseColor = vec3f(0.1, 0.7, 1.0);
        }

        // Layer 2: Apply stripes on top of base color
        let stripeFreq = 20.0;
        let stripe = step(0.5, fract(dist * stripeFreq));
        let stripeColor = baseColor * 0.4;  // Darker version of base
        var color = ${stripes ? 'mix(baseColor, stripeColor, stripe)' : 'baseColor'};

        // Layer 2.5: Tint caps - green for start cap (x < 0), purple for end cap (x > 0)
        // Only show in debug mode
        if (debug.enabled == 1u) {
          let green = vec3f(0.2, 0.9, 0.3);
          let purple = vec3f(0.8, 0.3, 0.9);
          let isStart = step(lineCoord.x, -0.01);  // 1 if x < -0.01
          let isEnd = step(0.01, lineCoord.x);     // 1 if x > 0.01
          color = mix(color, green, isStart * 0.5);
          color = mix(color, purple, isEnd * 0.5);
        }

        // Layer 3: Apply stroke (50% black in debug mode, dark blue in normal mode)
        color = mix(color, vec3f(0.0), strokeMask * 0.7);

        // Layer 4: Wireframe gridlines (debug only)
        if (debug.enabled == 1u) {
          let wire = grid(vec3f(triStripCoord, triStripCoord.x + triStripCoord.y), 0.5 * debug.dpr, 1.0);
          color = mix(vec3f(1.0), color, wire);
        }

        return vec4f(color, aa);
      }
    `;

    // Use max resolutions at init time to allow runtime adjustment up to these values
    // Runtime values (miterLimit, joinResolution, capResolution) are passed to draw()
    const blend = useBlend ? {
      color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
      alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' }
    } : undefined;

    const gpuLines = createGPULines(device, {
      colorTargets: blend ? { format: canvasFormat, blend } : { format: canvasFormat },
      depthStencil: depthFormat ? {
        format: depthFormat,
        depthWriteEnabled: true,
        depthCompare: 'less'
      } : undefined,
      primitive: { cullMode: cullBackFaces ? 'back' : 'none' },
      join: joinType,
      maxJoinResolution: 16,  // Allow up to 16 at runtime
      maxCapResolution: 16,   // Allow up to 16 at runtime
      cap: capType,
      vertexShaderBody,
      fragmentShaderBody,
    });

    // Create view matrix buffer
    const viewMatrixBuffer = device.createBuffer({
      label: 'view-matrix',
      size: 64, // mat4x4f
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    // Create debug uniform buffer (8 bytes: u32 enabled + f32 dpr)
    const debugBuffer = device.createBuffer({
      label: 'debug-uniform',
      size: 8,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    // Create line width uniform buffer
    const lineWidthBuffer = device.createBuffer({
      label: 'line-width-uniform',
      size: 4,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    // Create bind group for user data (group 1)
    const dataBindGroup = device.createBindGroup({
      layout: gpuLines.getBindGroupLayout(1),
      entries: [
        { binding: 0, resource: { buffer: positionBuffer } },
        { binding: 1, resource: { buffer: distanceBuffer } },
        { binding: 2, resource: { buffer: viewMatrixBuffer } },
        { binding: 3, resource: { buffer: totalDistanceBuffer } },
        { binding: 4, resource: { buffer: debugBuffer } },
        { binding: 5, resource: { buffer: lineWidthBuffer } }
      ]
    });

    invalidation.then(() => {
      gpuLines.destroy();
      viewMatrixBuffer.destroy();
      lineWidthBuffer.destroy();
      debugBuffer.destroy();
    });
  </script>
  <script id="14" type="module">
    import { createFrameLoop } from './lib/frame-loop.js';

    // Depend on runtime parameters that don't require pipeline recreation
    lineWidth; debugView; miterLimit; joinResolution; capResolution; renderState.dirty = true;

    // Depth texture for depth testing (created lazily, resized as needed)
    let depthTexture = null;
    let depthTextureWidth = 0;
    let depthTextureHeight = 0;

    const loop = createFrameLoop(() => {
      if (renderState.dirty) {
        // Update view matrix buffer
        device.queue.writeBuffer(viewMatrixBuffer, 0, axes.view);

        // Update debug uniform (enabled: u32, dpr: f32)
        const debugData = new ArrayBuffer(8);
        new Uint32Array(debugData, 0, 1)[0] = debugView ? 1 : 0;
        new Float32Array(debugData, 4, 1)[0] = dpr;
        device.queue.writeBuffer(debugBuffer, 0, debugData);

        // Update line width uniform
        device.queue.writeBuffer(lineWidthBuffer, 0, new Float32Array([lineWidth * dpr]));

        // Create/resize depth texture if depth testing is enabled
        if (depthFormat) {
          if (!depthTexture || depthTextureWidth !== canvas.width || depthTextureHeight !== canvas.height) {
            if (depthTexture) depthTexture.destroy();
            depthTexture = device.createTexture({
              size: [canvas.width, canvas.height],
              format: depthFormat,
              usage: GPUTextureUsage.RENDER_ATTACHMENT
            });
            depthTextureWidth = canvas.width;
            depthTextureHeight = canvas.height;
          }
        }

        const encoder = device.createCommandEncoder();

        const renderPassDescriptor = {
          colorAttachments: [{
            view: gpuContext.getCurrentTexture().createView(),
            loadOp: 'clear',
            storeOp: 'store',
            clearValue: { r: 0, g: 0, b: 0, a: 0 }
          }]
        };

        // Add depth attachment if depth testing is enabled
        if (depthFormat && depthTexture) {
          renderPassDescriptor.depthStencilAttachment = {
            view: depthTexture.createView(),
            depthClearValue: 1.0,
            depthLoadOp: 'clear',
            depthStoreOp: 'store'
          };
        }

        const pass = encoder.beginRenderPass(renderPassDescriptor);

        // Pass runtime parameters (miterLimit, joinResolution, capResolution)
        // These update uniforms without recreating the pipeline
        gpuLines.draw(pass, {
          vertexCount: numPoints,
          resolution: [canvas.width, canvas.height],
          miterLimit: miterLimit,
          joinResolution: joinResolution,
          capResolution: capResolution
        }, [dataBindGroup]);

        pass.end();
        device.queue.submit([encoder.finish()]);
        renderState.dirty = false;
      }
    });

    invalidation.then(() => {
      loop.cancel();
      if (depthTexture) depthTexture.destroy();
    });
  </script>
  <script id="14a" type="module">
    if (downloadButton > 0) {
      function downloadURI(uri, filename) {
        const link = document.createElement("a");
        link.target = '_blank';
        link.download = filename;
        link.href = uri;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      // Force a render
      renderState.dirty = true;

      // Wait for the render to complete
      await new Promise(resolve => requestAnimationFrame(resolve));
      await device.queue.onSubmittedWorkDone();

      // Capture the canvas
      const uri = canvas.toDataURL('image/png');
      downloadURI(uri, 'webgpu-lines-demo.png');
    }
  </script>
  <script id="15" type="text/markdown">
    ## Rationale

    Drawing lines on the GPU is surprisingly difficult. The hardware primitive `LINE_STRIP` produces lines exactly one pixel wide, which is rarely what you want. To get variable-width lines with proper joins and caps, you need to expand lines into triangles yourself.

    This library takes a pragmatic approach: it uses instanced rendering with triangle strips to draw one segment per instance, including half of each join on either end. This avoids the complexity of full stroke expansion algorithms while still producing good results for most use cases.

    The tradeoff is that the library does not handle self-intersecting lines correctly. For scientific visualization, data plots, and UI elements, this is usually acceptable. For complex vector graphics with many overlapping strokes, you may need a more sophisticated solution.

    The shader interface is designed to be flexible. Rather than prescribing a specific data format, you write a vertex function that fetches positions from wherever you store them (buffers, textures, procedural computation) and returns clip-space coordinates plus any per-vertex data you need. The library handles the geometry expansion, and your fragment shader receives a `lineCoord` varying that makes it easy to implement SDF-based anti-aliasing and stroke effects.

    For background on GPU line rendering, see Matt DesLauriers' [Drawing Lines is Hard](https://mattdesl.svbtle.com/drawing-lines-is-hard) and Rye Terrell's [Instanced Line Rendering](https://wwwtyro.net/2019/11/18/instanced-lines.html).
  </script>
</notebook>
