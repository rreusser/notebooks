<!doctype html>
<notebook theme="air">
  <title>WebGPU Lines</title>
  <script id="1" type="text/markdown">
    # WebGPU Lines

    This notebook implements GPU-accelerated line rendering using WebGPU, based on the techniques from [regl-gpu-lines](https://github.com/rreusser/regl-gpu-lines).

    Key features:
    - Instanced rendering with triangle strips
    - Screen-space line width (constant pixel width regardless of zoom)
    - Bevel, miter, and round joins
    - Integer index-based geometry generation in the vertex shader
  </script>
  <script id="2" type="module">
    // Initialize WebGPU
    if (!navigator.gpu) {
      display(html`<p style="color: red;">WebGPU is not supported in this browser.</p>`);
      throw new Error('WebGPU not supported');
    }

    const adapter = await navigator.gpu.requestAdapter();
    if (!adapter) {
      throw new Error('Failed to get WebGPU adapter');
    }

    const device = await adapter.requestDevice();
    const canvasFormat = navigator.gpu.getPreferredCanvasFormat();

    invalidation.then(() => device.destroy());
  </script>
  <script id="3" type="module">
    import { createElementStack } from './lib/element-stack.js'
    import { createZoomableAxes } from './lib/zoomable-axes.js'

    // Create canvas and configure WebGPU context
    const dpr = window.devicePixelRatio || 1;
    const canvasWidth = Math.min(640, width);
    const canvasHeight = 480;

    // Create element stack with WebGPU canvas and SVG overlay for zoom
    const stack = createElementStack({
      width: canvasWidth,
      height: canvasHeight,
      layers: [{
        id: 'canvas',
        element: ({ current, width, height }) => {
          const canvas = current || document.createElement('canvas');
          canvas.id = 'lines-canvas';
          canvas.width = Math.floor(width * dpr);
          canvas.height = Math.floor(height * dpr);
          canvas.style.width = `${width}px`;
          canvas.style.height = `${height}px`;
          return canvas;
        }
      }, {
        id: 'svg',
        element: ({ current, width, height }) =>
          (current ? d3.select(current) : d3.create("svg"))
            .attr("width", width)
            .attr("height", height)
            .style("cursor", "grab")
            .node()
      }]
    });

    const canvas = stack.elements.canvas;

    const gpuContext = canvas.getContext('webgpu');
    gpuContext.configure({
      device,
      format: canvasFormat,
      alphaMode: 'premultiplied'
    });

    // Render state (mutable object to allow cross-cell updates)
    const renderState = { dirty: true };

    // Set up zoomable axes with aspect ratio 1 (square pixels)
    const axes = createZoomableAxes({
      d3,
      element: stack.elements.svg,
      xScale: d3.scaleLinear().domain([-1, 1]).range([0, canvasWidth]),
      yScale: d3.scaleLinear().domain([-1, 1]).range([canvasHeight, 0]),
      aspectRatio: 1,
      onChange: () => {
        renderState.dirty = true;
        stack.dispatchEvent(new CustomEvent('update'));
      }
    });

    const figure = html`<figure style="margin: 0;">
      ${stack.element}
      <figcaption>Drag handles to edit vertices. Drag background to pan, scroll to zoom.</figcaption>
    </figure>`;
    figure.style.border = '1px solid #ccc';
    figure.style.display = 'inline-block';

    display(figure);
  </script>
  <script id="4" type="module">
    // Controls
    const lineWidthInput = Inputs.range([1, 50], { label: 'Line width', value: 50, step: 0.5 });
    const lineWidth = view(lineWidthInput);

    const joinTypeInput = Inputs.select(['bevel', 'miter', 'round'], { label: 'Join type', value: 'miter' });
    const joinType = view(joinTypeInput);

    const patternInput = Inputs.select(['wave', 'zigzag', 'spiral'], { label: 'Pattern', value: 'zigzag' });
    const pattern = view(patternInput);

    const miterLimitInput = Inputs.range([1, 10], { label: 'Miter limit', value: 1, step: 0.1 });
    const miterLimit = view(miterLimitInput);

    const joinResolutionInput = Inputs.range([2, 16], { label: 'Round join resolution', value: 8, step: 1 });
    const joinResolution = view(joinResolutionInput);

    const capTypeInput = Inputs.select(['round', 'square', 'none'], { label: 'Cap type', value: 'round' });
    const capType = view(capTypeInput);

    const capResolutionInput = Inputs.range([2, 16], { label: 'Round cap resolution', value: 8, step: 1 });
    const capResolution = view(capResolutionInput);

    const sdfStrokeWidthInput = Inputs.range([0, 15], { label: 'SDF stroke width', value: 0, step: 0.5 });
    const sdfStrokeWidth = view(sdfStrokeWidthInput);

    const lineBreakInput = Inputs.toggle({ label: 'Line break', value: false });
    const lineBreak = view(lineBreakInput);

    display(html`<div style="display: flex; gap: 20px; flex-wrap: wrap;">
      ${lineWidthInput}
      ${joinTypeInput}
      ${capTypeInput}
      ${patternInput}
      ${miterLimitInput}
      ${joinResolutionInput}
      ${capResolutionInput}
      ${sdfStrokeWidthInput}
      ${lineBreakInput}
    </div>`);
  </script>
  <script id="5" type="module">
    import { createGPULines } from './webgpu-lines.js';

    // Regenerate line data when pattern or lineBreak changes
    pattern; lineBreak;

    function generatePattern(patternType, insertLineBreak) {
      // Generate base points first
      let basePoints;
      if (patternType === 'zigzag') {
        const n = 6;
        basePoints = [];
        for (let i = 0; i < n; i++) {
          const t = i / (n - 1);
          const x = -0.6 + t * 1.2;
          const y = (i % 2 === 0 ? 0.2 : -0.2);
          basePoints.push({ x, y, z: 0, w: 1 });
        }
      } else if (patternType === 'spiral') {
        const n = 80;
        basePoints = [];
        for (let i = 0; i < n; i++) {
          const t = i / (n - 1);
          const angle = t * Math.PI * 6;
          const r = 0.1 + t * 0.6;
          basePoints.push({ x: r * Math.cos(angle), y: r * Math.sin(angle), z: 0, w: 1 });
        }
      } else {
        // Wave pattern (default)
        const n = 100;
        basePoints = [];
        for (let i = 0; i < n; i++) {
          const t = i / (n - 1);
          const x = -0.8 + t * 1.6;
          const y = 0.3 * Math.sin(t * Math.PI * 4) + 0.2 * Math.cos(t * Math.PI * 7);
          basePoints.push({ x, y, z: 0, w: 1 });
        }
      }

      // Insert line break sentinel (w=0) in the middle if requested
      if (insertLineBreak) {
        const midIndex = Math.floor(basePoints.length / 2);
        basePoints.splice(midIndex, 0, { x: 0, y: 0, z: 0, w: 0 }); // sentinel: w=0
      }

      return basePoints;
    }

    // Generate points as mutable objects
    const points = generatePattern(pattern, lineBreak);
    const numPoints = points.length;

    // Create Float32Array from points
    function pointsToFloat32Array(pts) {
      const arr = new Float32Array(pts.length * 4);
      for (let i = 0; i < pts.length; i++) {
        arr[i * 4 + 0] = pts[i].x;
        arr[i * 4 + 1] = pts[i].y;
        arr[i * 4 + 2] = pts[i].z;
        arr[i * 4 + 3] = pts[i].w;
      }
      return arr;
    }

    const positions = pointsToFloat32Array(points);

    // Create position buffer
    const positionBuffer = device.createBuffer({
      label: 'line-positions',
      size: positions.byteLength,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(positionBuffer, 0, positions);

    // Function to update GPU buffer when points change
    function updatePositionBuffer() {
      const newPositions = pointsToFloat32Array(points);
      device.queue.writeBuffer(positionBuffer, 0, newPositions);
      renderState.dirty = true;
    }

    invalidation.then(() => positionBuffer.destroy());
  </script>
  <script id="5b" type="module">
    // SVG handles for vertex editing
    const svg = d3.select(stack.elements.svg);

    // Filter out sentinel points (w=0) for display
    const editablePoints = points.map((p, i) => ({ point: p, index: i }))
                                 .filter(d => d.point.w !== 0);

    // Create circles for each editable vertex
    const circles = svg.selectAll('circle.vertex-handle')
      .data(editablePoints, d => d.index)
      .join('circle')
      .attr('class', 'vertex-handle')
      .attr('r', 5)
      .attr('fill', 'white')
      .attr('stroke', '#333')
      .attr('stroke-width', 1.5)
      .attr('cursor', 'move')
      .call(d3.drag()
        .on('start', function() {
          d3.select(this).attr('stroke', '#0066cc').attr('stroke-width', 2);
        })
        .on('drag', function(event, d) {
          // Convert screen coords to data coords
          d.point.x = axes.xScale.invert(event.x);
          d.point.y = axes.yScale.invert(event.y);
          // Update circle position
          d3.select(this)
            .attr('cx', event.x)
            .attr('cy', event.y);
          // Update GPU buffer
          updatePositionBuffer();
        })
        .on('end', function() {
          d3.select(this).attr('stroke', '#333').attr('stroke-width', 1.5);
        })
      );

    // Update circle positions (for zoom/pan and initial render)
    function updateHandlePositions() {
      circles
        .attr('cx', d => axes.xScale(d.point.x))
        .attr('cy', d => axes.yScale(d.point.y));
    }

    updateHandlePositions();
    stack.addEventListener('update', updateHandlePositions);
  </script>
  <script id="6" type="module">
    // Recreate pipeline when join/cap type, resolution, or SDF stroke width changes
    // Note: lineWidth is included because SDF shader embeds width value
    joinType; joinResolution; miterLimit; capType; capResolution; sdfStrokeWidth; lineWidth;

    // SDF mode is enabled when stroke width > 0
    const useSdfMode = sdfStrokeWidth > 0;

    // Standard fragment shader - solid color with edge darkening
    const standardFragmentShader = /* wgsl */`
      fn getColor(lineCoord: vec3f) -> vec4f {
        // lineCoord.x: along the line (for dashes)
        // lineCoord.y: across the line (-1 to 1, 0 at center)
        // lineCoord.z: 1 if outside main segment (in join extrapolation) or cap

        // Simple solid color with slight edge darkening
        let edge = 1.0 - 0.3 * abs(lineCoord.y);
        return vec4f(0.2 * edge, 0.5 * edge, 0.9 * edge, 1.0);
      }
    `;

    // SDF fragment shader - stroke outline using signed distance field
    const sdfFragmentShader = /* wgsl */`
      fn linearstep(a: f32, b: f32, x: f32) -> f32 {
        return clamp((x - a) / (b - a), 0.0, 1.0);
      }
      fn getColor(lineCoord: vec3f) -> vec4f {
        let width = ${lineWidth.toFixed(1)};
        let strokeWidth = ${sdfStrokeWidth.toFixed(1)};

        // SDF: distance from center in screen pixels
        let sdf = 0.5 * width * length(lineCoord.xy);

        // Anti-aliased edge
        let aa = linearstep(width * 0.5, width * 0.5 - 1.0, sdf);

        // Stroke region (starts at strokeWidth pixels from edge)
        let strokeMask = linearstep(width * 0.5 - strokeWidth - 0.5, width * 0.5 - strokeWidth + 0.5, sdf);

        // Fill color (light blue) with darker stroke
        let fillColor = vec3f(0.4, 0.7, 1.0);
        let strokeColor = vec3f(0.1, 0.3, 0.6);
        let color = mix(fillColor, strokeColor, strokeMask);

        return vec4f(color, aa);
      }
    `;

    const gpuLines = createGPULines(device, {
      format: canvasFormat,
      join: joinType,
      joinResolution: joinResolution,
      miterLimit: miterLimit,
      cap: capType,
      capResolution: capResolution,
      vertexShaderBody: '',
      fragmentShaderBody: useSdfMode ? sdfFragmentShader : standardFragmentShader,
      // Alpha blending for SDF mode
      blend: useSdfMode ? {
        color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
        alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' }
      } : null
    });

    invalidation.then(() => gpuLines.destroy());
  </script>
  <script id="7" type="module">
    // Mark dirty when controls change
    lineWidth; renderState.dirty = true;

    // Render loop
    let frameId = null;

    const drawProps = {
      positionBuffer,
      vertexCount: numPoints,
      width: lineWidth,
      resolution: [canvas.width, canvas.height],
      viewMatrix: axes.view
    };

    function render() {
      if (renderState.dirty) {
        drawProps.width = lineWidth;
        drawProps.viewMatrix = axes.view;

        const encoder = device.createCommandEncoder();

        // Run compute passes for endpoint detection (must be before render pass)
        gpuLines.prepareFrame(encoder, drawProps);

        const pass = encoder.beginRenderPass({
          colorAttachments: [{
            view: gpuContext.getCurrentTexture().createView(),
            loadOp: 'clear',
            storeOp: 'store',
            clearValue: { r: 0.95, g: 0.95, b: 0.95, a: 1 }
          }]
        });

        gpuLines.draw(pass, drawProps);

        pass.end();
        device.queue.submit([encoder.finish()]);

        renderState.dirty = false;
      }

      frameId = requestAnimationFrame(render);
    }

    frameId = requestAnimationFrame(render);

    invalidation.then(() => {
      if (frameId !== null) {
        cancelAnimationFrame(frameId);
      }
    });
  </script>
  <script id="8" type="text/markdown">
    ## How it works

    The line renderer uses instanced rendering where each instance draws one segment of the line. For a line with N points, there are N-3 instances (since each instance needs a 4-point window: previous, start, end, next).

    The vertex shader generates geometry using only a vertex index (0 to ~10 for bevel joins, more for round joins). This index determines:
    1. Which half of the join we're drawing (first half at start, or mirrored second half at end)
    2. Whether this vertex is on the outer edge, inner edge, or miter point of the join
    3. The position along the segment

    All geometry is computed in screen space to ensure consistent line width regardless of projection.
  </script>
</notebook>
