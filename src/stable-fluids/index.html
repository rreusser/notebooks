<!doctype html>
<notebook theme="air">
  <title>Fluid Instability with Stable Fluids</title>
  <script id="23" type="text/markdown">
    # Fluid Instability with Stable Fluids
  </script>
  <script id="1" type="text/markdown">
    This page came about after an online discussion of what Claude Code was capable of, or perhaps not capable of. I feared it might actually do an alright job of implementing [Stable Fluids](https://www.dgp.toronto.edu/public_user/stam/reality/Research/pdf/ns.pdf), so I pretty blindly threw Claude Code at the task, giving it the `pdftotext`-extracted text of the Stable Fluids paper and access to the internet. I connected my [mcp-observable-notebookkit-debug](https://github.com/rreusser/mcp-observable-notebookkit-debug) tool so that it would be able to interact with the simulation and analyze the `<canvas>` content. After some finagling over parameter calibration to get things in the ballpark, I asked that it implement some initial conditions for fluid instabilities and sharpen things up a little with the monotonic cubic interpolation scheme from Fedkiw, Stam, and Jensen’s [Visual Simulation of Smoke](https://web.stanford.edu/class/cs237d/smoke.pdf). To instruct it about the method, I took a screenshot of the Appendix of the paper and dropped it into the terminal window.
  </script>
  <script id="24" type="text/markdown">
    I want to reject AI, but I politely decline to be religious about it, either supporting it unconditionally or rejecting it out of hat. I view it as a tool, nothing more, nothing less. You can produce good things with it, and you can produce bad things with it. Honestly it seems to have done a decent job here. The FFT isn’t an appropriate fit given our application of walls, so the boundaries leak fluid as a result of the projection step. Memory usage could be optimized. I think I’d have organized the shaders a little differently, maybe consolidating some force computation or something. I think the FFT could be reworked to perform better. But gosh overall it’s just not terrible.
  </script>
  <script id="22" type="text/markdown">
    ---
  </script>
  <script id="21" type="text/markdown">
    A WebGPU implementation of Jos Stam's classic [Stable Fluids](https://www.dgp.toronto.edu/public_user/stam/reality/Research/pdf/ns.pdf) algorithm (SIGGRAPH 1999). The method solves the incompressible Navier-Stokes equations using an unconditionally stable semi-Lagrangian advection scheme and FFT-based pressure projection.

    Click and drag to add velocity to the fluid, or select an initial condition to observe classic fluid instabilities:

    - **Interactive**: Start with a blank canvas and add velocity/dye with mouse interaction
    - **Rayleigh-Taylor**: Dense fluid (dye) on top falls into lighter fluid below, forming characteristic mushroom patterns
    - **Kelvin-Helmholtz**: Two layers moving in opposite directions create shear at the interface, forming rolling wave patterns
  </script>
  <script id="2" type="module">
    import { createWebGPUContext } from './webgpu-context.js';

    const context = await createWebGPUContext();
    const device = context.device;
    const canvasFormat = navigator.gpu.getPreferredCanvasFormat();

    invalidation.then(() => device.destroy());
  </script>
  <script id="3" type="module">
    const resolutionInput = Inputs.select([64, 128, 256, 512, 1024, 2048], {
      value: 512,
      label: 'Resolution',
      format: x => `${x}×${x}`
    });
    const resolution = view(resolutionInput);
  </script>
  <script id="4" type="module">
    const N = resolution;
    const vec2Size = N * N * 2 * 4; // Complex numbers (vec2<f32>)
    const vec4Size = N * N * 4 * 4; // Velocity pairs (vec4<f32>)
    const workgroups = Math.ceil(N / 16);
    const dx = 1.0 / N;
  </script>
  <script id="5" type="module">
    import { createFluidPipelines } from './pipeline.js';
    import { executeFFT2D } from './lib/webgpu-fft/fft.js';

    const pipelines = await createFluidPipelines(device, canvasFormat, N);

    function runFFT2D(input, output, tempBuffers, forward) {
      executeFFT2D({
        device,
        pipelines: pipelines.fft,
        input,
        output,
        temp: tempBuffers,
        N,
        forward,
        splitNormalization: true
      });
    }
  </script>
  <script id="6" type="module">
    // Velocity field: stored as vec4 = (u_re, u_im, v_re, v_im) for FFT compatibility
    // In spatial domain, imaginary parts are zero
    const bufferUsage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;

    // Velocity buffers (vec4: u_re, u_im, v_re, v_im)
    const velocity = device.createBuffer({ label: 'velocity', size: vec4Size, usage: bufferUsage });
    const velocityTemp = device.createBuffer({ label: 'velocityTemp', size: vec4Size, usage: bufferUsage });

    // Separate buffers for FFT (vec2 each for u and v components)
    const uBuffer = device.createBuffer({ label: 'u', size: vec2Size, usage: bufferUsage });
    const vBuffer = device.createBuffer({ label: 'v', size: vec2Size, usage: bufferUsage });
    const uHat = device.createBuffer({ label: 'uHat', size: vec2Size, usage: bufferUsage });
    const vHat = device.createBuffer({ label: 'vHat', size: vec2Size, usage: bufferUsage });

    // FFT temp buffers
    const fftTemp = [0, 1].map(i => device.createBuffer({
      label: `fftTemp[${i}]`,
      size: vec2Size,
      usage: bufferUsage
    }));

    // Dye/density field for visualization (vec2: re, im)
    const dye = device.createBuffer({ label: 'dye', size: vec2Size, usage: bufferUsage });
    const dyeTemp = device.createBuffer({ label: 'dyeTemp', size: vec2Size, usage: bufferUsage });

    // Vorticity buffer (scalar field)
    const vorticitySize = N * N * 4;  // f32 per cell
    const vorticityBuffer = device.createBuffer({ label: 'vorticity', size: vorticitySize, usage: bufferUsage });
  </script>
  <script id="7" type="module">
    // Uniform buffers
    const simParamsBuffer = device.createBuffer({
      label: 'simParams',
      size: 32,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    const forceParamsBuffer = device.createBuffer({
      label: 'forceParams',
      size: 48,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    const projectParamsBuffer = device.createBuffer({
      label: 'projectParams',
      size: 16,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(projectParamsBuffer, 0, new Uint32Array([N, N]));

    const visParamsBuffer = device.createBuffer({
      label: 'visParams',
      size: 24,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    const vorticityParamsBuffer = device.createBuffer({
      label: 'vorticityParams',
      size: 16,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    const boundaryParamsBuffer = device.createBuffer({
      label: 'boundaryParams',
      size: 24,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    const buoyancyParamsBuffer = device.createBuffer({
      label: 'buoyancyParams',
      size: 16,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
  </script>
  <script id="8" type="module">
    // Controls
    const viscosityInput = Inputs.range([0.00001, 0.01], {
      step: 0.00001,
      value: 0.00015,
      transform: Math.log,
      label: 'Viscosity'
    });
    const viscosity = view(viscosityInput);

    const dyeDecayInput = Inputs.range([0.9, 1.0], {
      step: 0.001,
      value: 0.99,
      label: 'Dye persistence'
    });
    const dyeDecay = view(dyeDecayInput);

    const forceRadiusInput = Inputs.range([0.01, 0.15], {
      step: 0.005,
      value: 0.03,
      label: 'Force radius'
    });
    const forceRadius = view(forceRadiusInput);

    const forceDampingInput = Inputs.range([0, 1], {
      step: 0.01,
      value: 0.5,
      label: 'Force damping'
    });
    const forceDamping = view(forceDampingInput);

    const vorticityInput = Inputs.range([0, 50], {
      step: 0.1,
      value: 20,
      label: 'Vorticity confinement'
    });
    const vorticityConfinement = view(vorticityInput);

    const buoyancyInput = Inputs.range([-5, 5], {
      step: 0.01,
      value: 5,
      label: 'Buoyancy'
    });
    const buoyancy = view(buoyancyInput);

    const wallThicknessInput = Inputs.range([0, 10], {
      step: 1,
      value: 5,
      label: 'Wall thickness (cells)'
    });
    const wallThickness = view(wallThicknessInput);

    const wallsEnabledInput = Inputs.checkbox(
      ['Top/bottom', 'Left/right'],
      { label: 'Walls' }
    );
    const wallsEnabled = view(wallsEnabledInput);

    const timestepInput = Inputs.range([0.001, 0.05], {
      step: 0.001,
      value: 1.0 / 60.0,
      label: 'Timestep (dt)'
    });
    const timestep = view(timestepInput);

    const initialConditionInput = Inputs.select(
      ['Interactive', 'Rayleigh-Taylor', 'Kelvin-Helmholtz'],
      { value: 'Rayleigh-Taylor', label: 'Initial conditions' }
    );
    const initialCondition = view(initialConditionInput);

    const perturbationPeriodsInput = Inputs.range([1, 16], {
      step: 1,
      value: 8,
      label: 'Perturbation periods'
    });
    const perturbationPeriods = view(perturbationPeriodsInput);

    const perturbationAmplitudeInput = Inputs.range([0.001, 0.05], {
      step: 0.001,
      value: 0.005,
      label: 'Perturbation amplitude'
    });
    const perturbationAmplitude = view(perturbationAmplitudeInput);

    const restartInput = Inputs.button('Restart');
    const restart = view(restartInput);

    const simulateInput = Inputs.toggle({ label: 'Simulate', value: true });
    const simulate = view(simulateInput);

    const stopTimeInput = Inputs.range([0, 60], {
      step: 0.1,
      value: 0,
      label: 'Stop at time (0 = never)'
    });
    const stopTime = view(stopTimeInput);

    const interpolationInput = Inputs.select(
      ['Monotonic cubic', 'Linear'],
      { value: 'Monotonic cubic', label: 'Interpolation' }
    );
    const interpolation = view(interpolationInput);
  </script>
  <script id="9" type="module">
    display(html`<div id="fluid-controls">
      ${resolutionInput}
      ${initialConditionInput}
      ${perturbationPeriodsInput}
      ${perturbationAmplitudeInput}
      ${stopTimeInput}
      ${viscosityInput}
      ${dyeDecayInput}
      ${timestepInput}
      ${forceRadiusInput}
      ${forceDampingInput}
      ${vorticityInput}
      ${buoyancyInput}
      ${wallThicknessInput}
      ${wallsEnabledInput}
      ${interpolationInput}
      ${simulateInput}
      ${restartInput}
    </div>`);
  </script>
  <script id="10" type="module">
    // Canvas setup
    const canvasSize = Math.min(width, 640);
    const canvas = html`<canvas
      id="fluid-canvas"
      width="${canvasSize * window.devicePixelRatio}"
      height="${canvasSize * window.devicePixelRatio}"
      style="width: ${canvasSize}px; height: ${canvasSize}px; cursor: crosshair;">
    </canvas>`;

    const gpuContext = canvas.getContext('webgpu');
    gpuContext.configure({
      device,
      format: canvasFormat,
      alphaMode: 'opaque',
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
    });

    display(canvas);
  </script>
  <script id="11" type="module">
    // Mouse interaction state
    const mouseState = {
      down: false,
      x: 0,
      y: 0,
      prevX: 0,
      prevY: 0,
      dx: 0,
      dy: 0
    };

    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (e.clientX - rect.left) / rect.width,
        y: (e.clientY - rect.top) / rect.height // Y-down to match grid
      };
    }

    canvas.addEventListener('pointerdown', (e) => {
      mouseState.down = true;
      const pos = getMousePos(e);
      mouseState.x = pos.x;
      mouseState.y = pos.y;
      mouseState.prevX = pos.x;
      mouseState.prevY = pos.y;
      canvas.setPointerCapture(e.pointerId);
    });

    canvas.addEventListener('pointermove', (e) => {
      const pos = getMousePos(e);
      mouseState.prevX = mouseState.x;
      mouseState.prevY = mouseState.y;
      mouseState.x = pos.x;
      mouseState.y = pos.y;
      if (mouseState.down) {
        mouseState.dx = mouseState.x - mouseState.prevX;
        mouseState.dy = mouseState.y - mouseState.prevY;
      }
    });

    canvas.addEventListener('pointerup', (e) => {
      mouseState.down = false;
      mouseState.dx = 0;
      mouseState.dy = 0;
      canvas.releasePointerCapture(e.pointerId);
    });

    canvas.addEventListener('pointerleave', () => {
      mouseState.down = false;
      mouseState.dx = 0;
      mouseState.dy = 0;
    });

    // Prevent default touch behavior (scrolling) so pointer events work properly
    canvas.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
    canvas.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
  </script>
  <script id="12" type="module">
    // Simulation parameters
    const simParams = {
      viscosity: 0.00005,
      dyeDecay: 0.998,
      forceRadius: 0.03,
      forceDamping: 0.15,
      vorticityConfinement: 2,
      buoyancy: 5,
      wallThicknessX: 0,
      wallThicknessY: 0,
      dt: 1.0 / 60.0,
      useLinearInterp: 0,  // 0 = monotonic cubic, 1 = linear
      time: 0,             // Current simulation time
      stopTime: 0          // Stop at this time (0 = never)
    };
  </script>
  <script id="13" type="module">
    // Update simParams when controls change
    viscosity; dyeDecay; forceRadius; forceDamping; vorticityConfinement; buoyancy; wallThickness; wallsEnabled; timestep; interpolation; stopTime;
    simParams.viscosity = viscosity;
    simParams.dyeDecay = dyeDecay;
    simParams.dt = timestep;
    simParams.forceRadius = forceRadius;
    simParams.forceDamping = forceDamping;
    simParams.vorticityConfinement = vorticityConfinement;
    simParams.buoyancy = buoyancy;
    // Compute wall thicknesses from checkbox state
    simParams.wallThicknessX = wallsEnabled.includes('Left/right') ? wallThickness : 0;
    simParams.wallThicknessY = wallsEnabled.includes('Top/bottom') ? wallThickness : 0;
    simParams.useLinearInterp = interpolation === 'Linear' ? 1 : 0;
    simParams.stopTime = stopTime;
  </script>
  <script id="14" type="module">
    // Configure parameters when initial condition changes (not on restart)
    initialCondition;

    // Only set structural parameters (walls, dye decay), not physics (buoyancy)
    // so users have full control over the driving forces
    if (initialCondition === 'Rayleigh-Taylor') {
      // Wall boundaries on top/bottom only (periodic horizontally)
      wallThicknessInput.value = 5;
      wallThicknessInput.dispatchEvent(new Event('input'));
      wallsEnabledInput.value = ['Top/bottom'];
      wallsEnabledInput.dispatchEvent(new Event('input'));
      // No dye decay
      dyeDecayInput.value = 1.0;
      dyeDecayInput.dispatchEvent(new Event('input'));
      // Initial buoyancy
      buoyancyInput.value = 0.5;
      buoyancyInput.dispatchEvent(new Event('input'));
    } else if (initialCondition === 'Kelvin-Helmholtz') {
      // Top/bottom walls only, periodic horizontally for shear flow
      wallThicknessInput.value = 5;
      wallThicknessInput.dispatchEvent(new Event('input'));
      wallsEnabledInput.value = ['Top/bottom'];
      wallsEnabledInput.dispatchEvent(new Event('input'));
      // No dye decay
      dyeDecayInput.value = 1.0;
      dyeDecayInput.dispatchEvent(new Event('input'));
      // No buoyancy - K-H is driven by shear, not density differences
      buoyancyInput.value = 0;
      buoyancyInput.dispatchEvent(new Event('input'));
    }
  </script>
  <script id="15" type="module">
    // Initialize/restart simulation data
    restart; initialCondition; perturbationPeriods; perturbationAmplitude;

    // Reset simulation time
    simParams.time = 0;

    // Create data arrays
    const velocityData = new Float32Array(N * N * 4);  // vec4: u_re, u_im, v_re, v_im
    const dyeData = new Float32Array(N * N * 2);       // vec2: re, im

    if (initialCondition === 'Interactive') {
      // Zero initial state - user will add dye/velocity with mouse
      velocityData.fill(0);
      dyeData.fill(0);

    } else if (initialCondition === 'Rayleigh-Taylor') {
      // Heavy fluid on top, light on bottom
      // Empirically: low y = top of screen, high y = bottom of screen
      // Interface centered at y = 0.5 with sinusoidal perturbation
      const interfaceY0 = 0.5;  // Centered interface

      for (let j = 0; j < N; j++) {
        for (let i = 0; i < N; i++) {
          const idx = j * N + i;
          const x = i / N;
          const y = j / N;

          // Interface position with sinusoidal perturbation
          const interfaceY = interfaceY0 + perturbationAmplitude * Math.sin(2 * Math.PI * perturbationPeriods * x);

          // Dye above interface (low y = top of screen, heavy fluid that will sink)
          if (y < interfaceY) {
            // Smooth transition at interface
            const dist = (interfaceY - y) / 0.03;
            const dyeAmount = Math.min(1.0, dist);
            dyeData[idx * 2] = dyeAmount;
            dyeData[idx * 2 + 1] = 0;
          } else {
            dyeData[idx * 2] = 0;
            dyeData[idx * 2 + 1] = 0;
          }

          // Zero initial velocity - let buoyancy drive the motion
          velocityData[idx * 4] = 0;
          velocityData[idx * 4 + 1] = 0;
          velocityData[idx * 4 + 2] = 0;
          velocityData[idx * 4 + 3] = 0;
        }
      }

    } else if (initialCondition === 'Kelvin-Helmholtz') {
      // Two layers moving in opposite horizontal directions
      // Interface at y = 0.5 with sinusoidal perturbation
      const shearVelocity = 0.5;  // Magnitude of horizontal velocity
      const interfaceThickness = 0.1;  // Thickness of the shear layer

      for (let j = 0; j < N; j++) {
        for (let i = 0; i < N; i++) {
          const idx = j * N + i;
          const x = i / N;
          const y = j / N;

          // Interface at y = 0.5 with perturbation
          const interfaceY = 0.5 + perturbationAmplitude * Math.sin(2 * Math.PI * perturbationPeriods * x);

          // Smooth tanh transition for velocity
          const transitionY = (y - interfaceY) / interfaceThickness;
          const velocityProfile = Math.tanh(transitionY) * shearVelocity;

          velocityData[idx * 4] = velocityProfile;  // u_re (horizontal velocity)
          velocityData[idx * 4 + 1] = 0;            // u_im
          // Small vertical perturbation to trigger instability
          velocityData[idx * 4 + 2] = perturbationAmplitude * Math.sin(2 * Math.PI * perturbationPeriods * x) *
                                       Math.exp(-transitionY * transitionY);  // v_re
          velocityData[idx * 4 + 3] = 0;            // v_im

          // Dye in top half (low y = top of screen), similar to R-T
          if (y < interfaceY) {
            // Smooth transition at interface
            const dist = (interfaceY - y) / 0.03;
            const dyeAmount = Math.min(1.0, dist);
            dyeData[idx * 2] = dyeAmount;
            dyeData[idx * 2 + 1] = 0;
          } else {
            dyeData[idx * 2] = 0;
            dyeData[idx * 2 + 1] = 0;
          }
        }
      }
    }

    // Write data to GPU buffers
    device.queue.writeBuffer(velocity, 0, velocityData);
    device.queue.writeBuffer(velocityTemp, 0, velocityData);
    device.queue.writeBuffer(dye, 0, dyeData);
    device.queue.writeBuffer(dyeTemp, 0, dyeData);
  </script>
  <script id="16" type="module">
    // Update uniform buffers
    function updateSimUniforms() {
      const data = new ArrayBuffer(32);
      new Uint32Array(data, 0, 2).set([N, N]);
      new Float32Array(data, 8, 1).set([simParams.dt]);
      new Float32Array(data, 12, 1).set([simParams.viscosity]);
      new Float32Array(data, 16, 1).set([simParams.dyeDecay]);
      new Float32Array(data, 20, 1).set([simParams.wallThicknessX]);
      new Float32Array(data, 24, 1).set([simParams.wallThicknessY]);
      new Uint32Array(data, 28, 1).set([simParams.useLinearInterp]);
      device.queue.writeBuffer(simParamsBuffer, 0, data);
    }

    function updateForceUniforms() {
      // Convert mouse velocity to simulation units
      // Mouse delta is in [0,1] normalized coords per frame
      // Simulation velocity: vel * N * dt = displacement in grid cells
      // To match mouse: targetVel = mouseDelta / dt
      const targetVelX = mouseState.dx / simParams.dt;
      const targetVelY = -mouseState.dy / simParams.dt;  // Flip Y to match screen coords

      const data = new ArrayBuffer(48);
      new Uint32Array(data, 0, 2).set([N, N]);
      new Float32Array(data, 8, 2).set([mouseState.x, 1.0 - mouseState.y]);  // Flip Y
      new Float32Array(data, 16, 2).set([targetVelX, targetVelY]);
      new Float32Array(data, 24, 1).set([simParams.forceRadius]);
      new Float32Array(data, 28, 1).set([mouseState.down ? 1.0 : 0.0]);
      new Float32Array(data, 32, 1).set([simParams.forceDamping]);
      // padding at 36
      device.queue.writeBuffer(forceParamsBuffer, 0, data);
    }

    function updateVisUniforms() {
      const data = new ArrayBuffer(24);
      new Uint32Array(data, 0, 2).set([N, N]);
      new Float32Array(data, 8, 1).set([1.0]); // scale
      new Float32Array(data, 12, 1).set([0.0]); // floorHeight (unused, kept for padding)
      new Float32Array(data, 16, 1).set([simParams.wallThicknessX]);
      new Float32Array(data, 20, 1).set([simParams.wallThicknessY]);
      device.queue.writeBuffer(visParamsBuffer, 0, data);
    }

    function updateVorticityUniforms() {
      const data = new ArrayBuffer(16);
      new Uint32Array(data, 0, 2).set([N, N]);
      new Float32Array(data, 8, 1).set([simParams.vorticityConfinement]);
      new Float32Array(data, 12, 1).set([simParams.dt]);
      device.queue.writeBuffer(vorticityParamsBuffer, 0, data);
    }

    function updateBoundaryUniforms() {
      const data = new ArrayBuffer(24);
      new Uint32Array(data, 0, 2).set([N, N]);
      new Float32Array(data, 8, 1).set([0.0]); // floorHeight (unused, kept for padding)
      new Float32Array(data, 12, 1).set([simParams.wallThicknessX]);
      new Float32Array(data, 16, 1).set([simParams.wallThicknessY]);
      device.queue.writeBuffer(boundaryParamsBuffer, 0, data);
    }

    function updateBuoyancyUniforms() {
      const data = new ArrayBuffer(16);
      new Uint32Array(data, 0, 2).set([N, N]);
      new Float32Array(data, 8, 1).set([simParams.buoyancy]);
      new Float32Array(data, 12, 1).set([simParams.dt]);
      device.queue.writeBuffer(buoyancyParamsBuffer, 0, data);
    }
  </script>
  <script id="17" type="module">
    // Helper to enforce boundary conditions
    function enforceBoundaries() {
      if (simParams.wallThicknessX > 0 || simParams.wallThicknessY > 0) {
        updateBoundaryUniforms();

        const bindGroup = device.createBindGroup({
          layout: pipelines.bindGroupLayouts.enforceBoundary,
          entries: [
            { binding: 0, resource: { buffer: velocity } },
            { binding: 1, resource: { buffer: dye } },
            { binding: 2, resource: { buffer: boundaryParamsBuffer } }
          ]
        });

        const enc = device.createCommandEncoder();
        const pass = enc.beginComputePass();
        pass.setPipeline(pipelines.enforceBoundary);
        pass.setBindGroup(0, bindGroup);
        pass.dispatchWorkgroups(workgroups, workgroups);
        pass.end();
        device.queue.submit([enc.finish()]);
      }
    }

    // Main simulation step
    async function step() {
      updateSimUniforms();
      updateForceUniforms();

      // Enforce boundaries at start of step
      enforceBoundaries();

      // 1. Add forces from mouse
      {
        const bindGroup = device.createBindGroup({
          layout: pipelines.bindGroupLayouts.addForce,
          entries: [
            { binding: 0, resource: { buffer: velocity } },
            { binding: 1, resource: { buffer: dye } },
            { binding: 2, resource: { buffer: forceParamsBuffer } }
          ]
        });

        const enc = device.createCommandEncoder();
        const pass = enc.beginComputePass();
        pass.setPipeline(pipelines.addForce);
        pass.setBindGroup(0, bindGroup);
        pass.dispatchWorkgroups(workgroups, workgroups);
        pass.end();
        device.queue.submit([enc.finish()]);
      }

      // 2. Advect velocity (semi-Lagrangian)
      {
        const bindGroup = device.createBindGroup({
          layout: pipelines.bindGroupLayouts.advect,
          entries: [
            { binding: 0, resource: { buffer: velocity } },
            { binding: 1, resource: { buffer: velocity } },
            { binding: 2, resource: { buffer: velocityTemp } },
            { binding: 3, resource: { buffer: simParamsBuffer } }
          ]
        });

        const enc = device.createCommandEncoder();
        const pass = enc.beginComputePass();
        pass.setPipeline(pipelines.advectVelocity);
        pass.setBindGroup(0, bindGroup);
        pass.dispatchWorkgroups(workgroups, workgroups);
        pass.end();
        device.queue.submit([enc.finish()]);
      }

      // Swap velocity buffers (copy temp back to velocity)
      {
        const enc = device.createCommandEncoder();
        enc.copyBufferToBuffer(velocityTemp, 0, velocity, 0, vec4Size);
        device.queue.submit([enc.finish()]);
      }

      // Enforce boundaries after advection
      enforceBoundaries();

      // 3. Advect dye
      {
        const bindGroup = device.createBindGroup({
          layout: pipelines.bindGroupLayouts.advectScalar,
          entries: [
            { binding: 0, resource: { buffer: velocity } },
            { binding: 1, resource: { buffer: dye } },
            { binding: 2, resource: { buffer: dyeTemp } },
            { binding: 3, resource: { buffer: simParamsBuffer } }
          ]
        });

        const enc = device.createCommandEncoder();
        const pass = enc.beginComputePass();
        pass.setPipeline(pipelines.advectScalar);
        pass.setBindGroup(0, bindGroup);
        pass.dispatchWorkgroups(workgroups, workgroups);
        pass.end();
        device.queue.submit([enc.finish()]);
      }

      // Swap dye buffers
      {
        const enc = device.createCommandEncoder();
        enc.copyBufferToBuffer(dyeTemp, 0, dye, 0, vec2Size);
        device.queue.submit([enc.finish()]);
      }

      // 4. Project velocity to be divergence-free using FFT
      // First, split velocity into separate u and v buffers for FFT
      {
        const bindGroup = device.createBindGroup({
          layout: pipelines.bindGroupLayouts.splitVelocity,
          entries: [
            { binding: 0, resource: { buffer: velocity } },
            { binding: 1, resource: { buffer: uBuffer } },
            { binding: 2, resource: { buffer: vBuffer } },
            { binding: 3, resource: { buffer: projectParamsBuffer } }
          ]
        });

        const enc = device.createCommandEncoder();
        const pass = enc.beginComputePass();
        pass.setPipeline(pipelines.splitVelocity);
        pass.setBindGroup(0, bindGroup);
        pass.dispatchWorkgroups(workgroups, workgroups);
        pass.end();
        device.queue.submit([enc.finish()]);
      }

      // Forward FFT on u and v
      runFFT2D(uBuffer, uHat, fftTemp, true);
      runFFT2D(vBuffer, vHat, fftTemp, true);

      // Project in frequency domain and apply diffusion
      {
        const bindGroup = device.createBindGroup({
          layout: pipelines.bindGroupLayouts.projectFFT,
          entries: [
            { binding: 0, resource: { buffer: uHat } },
            { binding: 1, resource: { buffer: vHat } },
            { binding: 2, resource: { buffer: simParamsBuffer } }
          ]
        });

        const enc = device.createCommandEncoder();
        const pass = enc.beginComputePass();
        pass.setPipeline(pipelines.projectFFT);
        pass.setBindGroup(0, bindGroup);
        pass.dispatchWorkgroups(workgroups, workgroups);
        pass.end();
        device.queue.submit([enc.finish()]);
      }

      // Inverse FFT
      runFFT2D(uHat, uBuffer, fftTemp, false);
      runFFT2D(vHat, vBuffer, fftTemp, false);

      // Merge back into velocity buffer
      {
        const bindGroup = device.createBindGroup({
          layout: pipelines.bindGroupLayouts.mergeVelocity,
          entries: [
            { binding: 0, resource: { buffer: uBuffer } },
            { binding: 1, resource: { buffer: vBuffer } },
            { binding: 2, resource: { buffer: velocity } },
            { binding: 3, resource: { buffer: projectParamsBuffer } }
          ]
        });

        const enc = device.createCommandEncoder();
        const pass = enc.beginComputePass();
        pass.setPipeline(pipelines.mergeVelocity);
        pass.setBindGroup(0, bindGroup);
        pass.dispatchWorkgroups(workgroups, workgroups);
        pass.end();
        device.queue.submit([enc.finish()]);
      }

      // Enforce boundaries after FFT projection (FFT assumes periodic, so it can reintroduce wall velocity)
      enforceBoundaries();

      // 5. Vorticity confinement
      if (simParams.vorticityConfinement > 0) {
        updateVorticityUniforms();

        // Compute vorticity
        {
          const bindGroup = device.createBindGroup({
            layout: pipelines.bindGroupLayouts.computeVorticity,
            entries: [
              { binding: 0, resource: { buffer: velocity } },
              { binding: 1, resource: { buffer: vorticityBuffer } },
              { binding: 2, resource: { buffer: vorticityParamsBuffer } }
            ]
          });

          const enc = device.createCommandEncoder();
          const pass = enc.beginComputePass();
          pass.setPipeline(pipelines.computeVorticity);
          pass.setBindGroup(0, bindGroup);
          pass.dispatchWorkgroups(workgroups, workgroups);
          pass.end();
          device.queue.submit([enc.finish()]);
        }

        // Apply vorticity confinement force
        {
          const bindGroup = device.createBindGroup({
            layout: pipelines.bindGroupLayouts.applyVorticity,
            entries: [
              { binding: 0, resource: { buffer: velocity } },
              { binding: 1, resource: { buffer: vorticityBuffer } },
              { binding: 2, resource: { buffer: vorticityParamsBuffer } }
            ]
          });

          const enc = device.createCommandEncoder();
          const pass = enc.beginComputePass();
          pass.setPipeline(pipelines.applyVorticity);
          pass.setBindGroup(0, bindGroup);
          pass.dispatchWorkgroups(workgroups, workgroups);
          pass.end();
          device.queue.submit([enc.finish()]);
        }
      }

      // 6. Buoyancy (positive = upward, negative = downward for Rayleigh-Taylor)
      if (simParams.buoyancy !== 0) {
        updateBuoyancyUniforms();

        const bindGroup = device.createBindGroup({
          layout: pipelines.bindGroupLayouts.applyBuoyancy,
          entries: [
            { binding: 0, resource: { buffer: velocity } },
            { binding: 1, resource: { buffer: dye } },
            { binding: 2, resource: { buffer: buoyancyParamsBuffer } }
          ]
        });

        const enc = device.createCommandEncoder();
        const pass = enc.beginComputePass();
        pass.setPipeline(pipelines.applyBuoyancy);
        pass.setBindGroup(0, bindGroup);
        pass.dispatchWorkgroups(workgroups, workgroups);
        pass.end();
        device.queue.submit([enc.finish()]);
      }

      // 7. Final boundary enforcement
      enforceBoundaries();
    }

    // Render
    function render() {
      updateVisUniforms();

      const bindGroup = device.createBindGroup({
        layout: pipelines.bindGroupLayouts.visualize,
        entries: [
          { binding: 0, resource: { buffer: velocity } },
          { binding: 1, resource: { buffer: dye } },
          { binding: 2, resource: { buffer: visParamsBuffer } }
        ]
      });

      const enc = device.createCommandEncoder();
      const pass = enc.beginRenderPass({
        colorAttachments: [{
          view: gpuContext.getCurrentTexture().createView(),
          loadOp: 'clear',
          storeOp: 'store',
          clearValue: { r: 0, g: 0, b: 0, a: 1 }
        }]
      });
      pass.setPipeline(pipelines.visualize);
      pass.setBindGroup(0, bindGroup);
      pass.draw(6);
      pass.end();
      device.queue.submit([enc.finish()]);
    }
  </script>
  <script id="18" type="module">
    // Animation loop
    step; render; canvas; simulate;

    // Time display element
    const timeDisplay = html`<div id="time-display" style="font-family: monospace; margin-top: 0.5em;">t = 0.000</div>`;
    display(timeDisplay);

    let animFrameId = null;
    let hasError = false;

    async function animationLoop() {
      if (hasError) return;

      try {
        // Check if we should stop
        const shouldSimulate = simulate &&
          (simParams.stopTime <= 0 || simParams.time < simParams.stopTime);

        if (shouldSimulate) {
          await step();
          simParams.time += simParams.dt;

          // Auto-stop at target time
          if (simParams.stopTime > 0 && simParams.time >= simParams.stopTime) {
            simulateInput.value = false;
            simulateInput.dispatchEvent(new Event('input'));
          }
        }
        render();

        // Update time display
        timeDisplay.textContent = `t = ${simParams.time.toFixed(3)}`;

        // Reset mouse velocity after applying
        mouseState.dx = 0;
        mouseState.dy = 0;

        animFrameId = requestAnimationFrame(animationLoop);
      } catch (e) {
        hasError = true;
        console.error('Animation loop error:', e);
      }
    }

    animFrameId = requestAnimationFrame(animationLoop);

    invalidation.then(() => {
      hasError = true;
      if (animFrameId !== null) {
        cancelAnimationFrame(animFrameId);
        animFrameId = null;
      }
    });
  </script>
  <script id="18b" type="module">
    // Download button with WebGPU readback
    render; canvas; gpuContext; device; canvasFormat; interpolation; simParams;

    const downloadButton = Inputs.button('Download PNG');
    display(downloadButton);

    downloadButton.addEventListener('click', async () => {
      const pixelWidth = canvas.width;
      const pixelHeight = canvas.height;

      // Bytes per row must be aligned to 256
      const bytesPerPixel = 4;
      const unalignedBytesPerRow = pixelWidth * bytesPerPixel;
      const alignedBytesPerRow = Math.ceil(unalignedBytesPerRow / 256) * 256;

      // Create staging buffer
      const bufferSize = alignedBytesPerRow * pixelHeight;
      const stagingBuffer = device.createBuffer({
        size: bufferSize,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
      });

      // Render one more frame to ensure we have the latest
      render();

      // Copy texture to buffer
      const encoder = device.createCommandEncoder();
      encoder.copyTextureToBuffer(
        { texture: gpuContext.getCurrentTexture() },
        { buffer: stagingBuffer, bytesPerRow: alignedBytesPerRow },
        { width: pixelWidth, height: pixelHeight }
      );
      device.queue.submit([encoder.finish()]);

      // Map and read
      await stagingBuffer.mapAsync(GPUMapMode.READ);
      const data = new Uint8Array(stagingBuffer.getMappedRange());

      // Create ImageData (handle row alignment)
      const imageData = new ImageData(pixelWidth, pixelHeight);
      for (let y = 0; y < pixelHeight; y++) {
        const srcOffset = y * alignedBytesPerRow;
        const dstOffset = y * pixelWidth * 4;
        for (let x = 0; x < pixelWidth; x++) {
          const s = srcOffset + x * 4;
          const d = dstOffset + x * 4;
          // BGRA to RGBA conversion (WebGPU uses BGRA on some platforms)
          if (canvasFormat === 'bgra8unorm') {
            imageData.data[d + 0] = data[s + 2]; // R <- B
            imageData.data[d + 1] = data[s + 1]; // G
            imageData.data[d + 2] = data[s + 0]; // B <- R
            imageData.data[d + 3] = 255;
          } else {
            imageData.data[d + 0] = data[s + 0];
            imageData.data[d + 1] = data[s + 1];
            imageData.data[d + 2] = data[s + 2];
            imageData.data[d + 3] = 255;
          }
        }
      }

      stagingBuffer.unmap();
      stagingBuffer.destroy();

      // Draw to offscreen canvas and download
      const offscreen = new OffscreenCanvas(pixelWidth, pixelHeight);
      const ctx = offscreen.getContext('2d');
      ctx.putImageData(imageData, 0, 0);

      const blob = await offscreen.convertToBlob({ type: 'image/png' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = `stable-fluids-${interpolation.toLowerCase().replace(' ', '-')}-t${simParams.time.toFixed(2)}.png`;
      a.click();

      URL.revokeObjectURL(url);
    });
  </script>
  <script id="19" type="text/markdown">
    ## Algorithm

    The Stable Fluids algorithm solves the incompressible Navier-Stokes equations:

    ${tex.block`\frac{\partial \mathbf{u}}{\partial t} = -(\mathbf{u} \cdot \nabla)\mathbf{u} + \nu \nabla^2 \mathbf{u} - \nabla p + \mathbf{f}`}

    subject to the incompressibility constraint ${tex`\nabla \cdot \mathbf{u} = 0`}.

    Each timestep consists of four stages:

    1. **Add forces**: Apply external forces (mouse input) to the velocity field
    2. **Advect**: Move the velocity field along itself using semi-Lagrangian advection
    3. **Diffuse**: Apply viscous diffusion (done in frequency domain as multiplication)
    4. **Project**: Make velocity divergence-free by subtracting the gradient of pressure

    The key insight is that projection can be done efficiently in frequency domain. The velocity ${tex`\hat{\mathbf{u}}(\mathbf{k})`} is decomposed into components parallel and perpendicular to the wavenumber ${tex`\mathbf{k}`}. The divergence-free projection removes the parallel component:

    ${tex.block`\hat{\mathbf{u}}_{\perp} = \hat{\mathbf{u}} - \mathbf{k}\frac{\mathbf{k} \cdot \hat{\mathbf{u}}}{|\mathbf{k}|^2}`}

    This makes the algorithm unconditionally stable regardless of timestep size.
  </script>
  <script id="20" type="text/markdown">
    ## Implementation Details

    ### Grid Layout

    Velocities are **cell-centered** (collocated), not staggered. Cell ${tex`(i,j)`} stores both velocity components ${tex`(u, v)`} at physical position ${tex`(i+0.5, j+0.5)`}. Velocity is stored as `vec4<f32>` with layout `(u_re, u_im, v_re, v_im)` to accommodate FFT operations. In the spatial domain, the imaginary parts are zero.

    ### Simulation Loop

    Each timestep executes these stages in order:

    1. **Add forces** (mouse interaction)
    2. **Advect velocity** (semi-Lagrangian)
    3. **Advect dye**
    4. **Project + diffuse** (FFT-based)
    5. **Vorticity confinement**
    6. **Buoyancy**
    7. **Boundary enforcement**

    ### FFT-Based Projection and Diffusion

    The FFT is used to efficiently solve the pressure projection and diffusion in frequency domain:

    1. **Split** the interleaved velocity into separate ${tex`u`} and ${tex`v`} complex buffers
    2. **Forward FFT** on both components
    3. **Project and diffuse** in frequency domain:
       - Compute wavenumber ${tex`\mathbf{k}`} with frequencies ${tex`0, 1, \ldots, N/2-1, -N/2, \ldots, -1`} scaled by ${tex`2\pi`}
       - Remove component parallel to ${tex`\mathbf{k}`}: ${tex.block`\hat{u} \leftarrow \hat{u} - k_x \frac{\mathbf{k} \cdot \hat{\mathbf{u}}}{|\mathbf{k}|^2}, \quad \hat{v} \leftarrow \hat{v} - k_y \frac{\mathbf{k} \cdot \hat{\mathbf{u}}}{|\mathbf{k}|^2}`}
       - Apply implicit diffusion by multiplying by ${tex`\frac{1}{1 + \nu |\mathbf{k}|^2 \Delta t}`}
       - Zero the DC component (${tex`\mathbf{k} = 0`})
    4. **Inverse FFT** to return to spatial domain
    5. **Merge** back into interleaved velocity buffer

    ### Forcing Model

    The force uses a **velocity-matching model** rather than direct impulse injection:

    ${tex.block`\mathbf{f} = (\mathbf{v}_{\text{target}} - \mathbf{v}) \cdot \text{damping} \cdot \text{falloff}`}

    where ${tex`\mathbf{v}_{\text{target}} = \Delta\mathbf{x}_{\text{mouse}} / \Delta t`} is computed from mouse velocity, and the falloff is Gaussian: ${tex`\exp(-r^2 / 2\sigma^2)`}.

    Dye injection uses a **hard circle** (step function) rather than Gaussian for sharper smoke edges.

    ### Semi-Lagrangian Advection

    For each grid cell, trace backward through the velocity field to find the departure point:

    ${tex.block`\mathbf{x}_{\text{back}} = \mathbf{x} - \mathbf{u}(\mathbf{x}) \cdot N \cdot \Delta t`}

    Then sample the source field at ${tex`\mathbf{x}_{\text{back}}`} using **monotone cubic interpolation** (Fedkiw et al., "Visual Simulation of Smoke", SIGGRAPH 2001). The factor of ${tex`N`} converts velocity from normalized to grid units.

    The monotone cubic interpolation uses Hermite interpolation with slope limiting to prevent overshoot:

    ${tex.block`f(t) = a_3 t^3 + a_2 t^2 + a_1 t + a_0`}

    where the slopes ${tex`d_k = (f_{k+1} - f_{k-1})/2`} are set to zero when they differ in sign from ${tex`\Delta_k = f_{k+1} - f_k`}. This preserves monotonicity and eliminates spurious oscillations that can arise with standard cubic interpolation.

    ### Vorticity Confinement

    Two-pass process to counteract numerical dissipation of rotational motion:

    **Pass 1**: Compute vorticity (curl) using central differences:
    ${tex.block`\omega = \frac{\partial v}{\partial x} - \frac{\partial u}{\partial y}`}

    **Pass 2**: Apply confinement force in the direction perpendicular to the vorticity gradient:
    ${tex.block`\mathbf{N} = \frac{\nabla|\omega|}{|\nabla|\omega||}, \quad \mathbf{f} = \varepsilon (\mathbf{N} \times \omega)`}

    In 2D, the cross product gives ${tex`\mathbf{f} = \varepsilon (N_y \omega, -N_x \omega)`}. This force points toward vortex centers, amplifying rotational structures.
  </script>
</notebook>
