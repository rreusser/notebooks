<!doctype html>
<notebook theme="air">
  <title>Denali Terrain</title>

  <script id="dataset-selector" type="module">
    import { TILE_URL_TERRAIN, TILE_URL_SENTINEL, TILE_URL_TAHOE, TILE_URL_TAHOE_SENTINEL } from './tile-urls.js';

    const datasets = {
      'Denali': {
        sources: {
          'arctic-dem': {
            type: 'terrain',
            tiles: [TILE_URL_TERRAIN],
            minzoom: 4,
            maxzoom: 13,
            bounds: [-152.9, 62.2, -148.8, 64.0],
            attribution: '<a href="https://www.pgc.umn.edu/data/arcticdem/" target="_blank" rel="noopener">ArcticDEM</a> | <a href="https://catalog.data.gov/dataset/srtm30-global-1-km-digital-elevation-model-dem-version-11-land-surface" target="_blank" rel="noopener">SRTM30</a>',
          },
          'sentinel': {
            type: 'raster',
            tiles: [TILE_URL_SENTINEL],
            minzoom: 4,
            maxzoom: 11,
            bounds: [-152.9, 62.2, -148.8, 64.0],
            attribution: '<a href="https://dataspace.copernicus.eu/" target="_blank" rel="noopener">Copernicus Sentinel-2</a>',
          },
          'peaks': {
            type: 'geojson',
            data: 'osm/peaks.geojson',
            attribution: '<a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener">OpenStreetMap</a>',
          },
          'fkt': {
            type: 'geojson',
            data: 'strava/fkt.geojson',
            simplify: 0.0001,
            attribution: '<a href="https://www.strava.com/activities/9223277277" target="_blank" rel="noopener">Strava</a>',
          },
        },
        camera: {
          center: [0.08005793958567985, 0.00021365516506647512, 0.27291423467021114],
          distance: 0.0004971889617079275,
          phi: 2.4972122538258654,
          theta: 0.13580281526641474,
        },
        base: [
          { id: 'satellite', source: 'sentinel', blend: 'source-over' },
        ],
        features: [
          {
            id: 'ski-tracks',
            type: 'line',
            source: 'fkt',
            paint: {
              'line-color': '#ff8800',
              'line-width': 5,
              'line-border-color': '#331100',
              'line-border-width': 2,
              'atmosphere-opacity': 0.5
            }
          },
          {
            id: 'peak-circles',
            type: 'circle',
            source: 'peaks',
            paint: {
              'circle-radius': 3,
              'circle-color': '#000000',
              'circle-stroke-color': '#ffffff',
              'circle-stroke-width': 1.5,
              'atmosphere-opacity': 0.5
            }
          },
          {
            id: 'peak-labels',
            type: 'text',
            source: 'peaks',
            paint: {
              'text-field': 'name',
              'text-size': 16,
              'text-color': '#000000',
              'text-halo-color': '#ffffff',
              'text-halo-width': 1.25,
              'atmosphere-opacity': 0.5
            }
          },
        ],
      },
      'Lake Tahoe': {
        sources: {
          'tahoe-terrain': {
            type: 'terrain',
            tiles: [TILE_URL_TAHOE],
            minzoom: 0,
            maxzoom: 13,
            bounds: [-120.87, 38.80, -119.68, 39.85],
            attribution: '<a href="https://spacedata.copernicus.eu/collections/copernicus-digital-elevation-model" target="_blank" rel="noopener">Copernicus DEM</a>',
          },
          'tahoe-sentinel': {
            type: 'raster',
            tiles: [TILE_URL_TAHOE_SENTINEL],
            minzoom: 8,
            maxzoom: 12,
            bounds: [-120.87, 38.80, -119.68, 39.85],
            attribution: '<a href="https://dataspace.copernicus.eu/" target="_blank" rel="noopener">Copernicus Sentinel-2</a>',
          },
          'tahoe-landmarks': {
            type: 'geojson',
            data: 'osm/tahoe-landmarks.geojson',
            attribution: '<a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener">OpenStreetMap</a>',
          },
        },
        camera: {
          center: [0.16590, 0.0, 0.38101],
          distance: 0.0006,
          phi: Math.PI / 2,
          theta: 0.4,
        },
        base: [
          { id: 'satellite', source: 'tahoe-sentinel', blend: 'source-over' },
        ],
        features: [
          {
            id: 'landmark-circles',
            type: 'circle',
            source: 'tahoe-landmarks',
            paint: {
              'circle-radius': 3,
              'circle-color': '#000000',
              'circle-stroke-color': '#ffffff',
              'circle-stroke-width': 1.5,
              'atmosphere-opacity': 0.5
            }
          },
          {
            id: 'landmark-labels',
            type: 'text',
            source: 'tahoe-landmarks',
            paint: {
              'text-field': 'name',
              'text-size': 16,
              'text-color': '#000000',
              'text-halo-color': '#ffffff',
              'text-halo-width': 1.25,
              'atmosphere-opacity': 0.5
            }
          },
        ],
      },
    };

    const datasetName = view(Inputs.select(Object.keys(datasets), { label: "Dataset", value: 'Lake Tahoe' }));
  </script>

  <script id="viewer" type="module">
    import { TerrainMap } from './mapviewer/terrain-viewer.js';
    import { createGPULines } from 'npm:webgpu-instanced-lines';
    import simplify from 'npm:simplify-js';
    import { expandable } from './lib/expandable.js';
    import { ElevationProfile } from './mapviewer/elevation-profile.js';
    import { gpx as gpxToGeoJSON } from 'npm:@tmcw/togeojson';

    const config = datasets[datasetName];

    // Clear stale camera hash when switching datasets (but not on initial page load)
    if (window._lastDataset && window._lastDataset !== datasetName) {
      history.replaceState(null, '', window.location.pathname);
    }
    window._lastDataset = datasetName;

    const canvas = document.createElement('canvas');
    canvas.className = 'terrain';

    const viewer = await TerrainMap.create(canvas, {
      ...config,
      font: {
        atlas: './mapviewer/fonts/roboto-regular.png',
        metadata: './mapviewer/fonts/roboto-regular.json',
      },
      createGPULines,
      simplifyFn: simplify,
    });

    const slopeLegend = html`<div class="slope-legend" style="display: none">
      <div class="slope-legend-title">Slope angle</div>
      <div class="slope-legend-blocks">
        <div style="background: rgb(255, 199, 0)"></div>
        <div style="background: rgb(255, 140, 0)"></div>
        <div style="background: rgb(255, 77, 0)"></div>
        <div style="background: rgb(191, 0, 0)"></div>
        <div style="background: rgb(102, 0, 153)"></div>
        <div style="background: rgb(0, 51, 204)"></div>
        <div style="background: rgb(0, 0, 0)"></div>
      </div>
      <div class="slope-legend-labels">
        <span>26-29°</span>
        <span>30-31°</span>
        <span>32-34°</span>
        <span>35-45°</span>
        <span>46-50°</span>
        <span>51-59°</span>
        <span>60°+</span>
      </div>
    </div>`;
    viewer._slopeLegend = slopeLegend;

    const elevationLabel = html`<div class="elevation-label"></div>`;

    canvas.addEventListener('mousemove', (e) => {
      const hit = viewer.raycast(e.clientX, e.clientY);
      if (hit) {
        const elev = viewer.queryElevationMercator(hit.worldPos[0], hit.worldPos[2]);
        if (elev != null) {
          const feet = Math.round(elev * 3.28084);
          elevationLabel.textContent = `${feet.toLocaleString()} ft`;
          elevationLabel.style.opacity = '1';
        } else {
          elevationLabel.style.opacity = '0';
        }
      } else {
        elevationLabel.style.opacity = '0';
      }
    });
    canvas.addEventListener('mouseleave', () => {
      elevationLabel.style.opacity = '0';
    });

    const elevationProfile = new ElevationProfile();
    const profilePanel = elevationProfile.createDOM();

    viewer.onElevationRefine = () => {
      const activeId = elevationProfile.activeLayerId;
      if (!activeId) return;
      // Auto-close if layer was removed
      if (!viewer._lineLayers.find(e => e.id === activeId)) {
        elevationProfile.hide();
        return;
      }
      const data = viewer.getLayerElevationProfile(activeId);
      if (data) elevationProfile.update(data);
    };

    const container = html`<div style="position: relative">`;
    container.appendChild(canvas);
    container.appendChild(elevationLabel);
    container.appendChild(slopeLegend);
    container.appendChild(viewer.attribution);
    container.appendChild(profilePanel);

    const dropOverlay = html`<div class="drop-overlay" style="display:none">Drop GeoJSON or GPX file</div>`;
    container.appendChild(dropOverlay);

    // Compass rose: shows current bearing, click to orient north
    const compassBtn = html`<button class="compass-rose" title="Orient north">
      <svg viewBox="0 0 28 28" width="24" height="24" style="display:block">
        <path d="M14 4L17.5 14L14 12L10.5 14Z" fill="#D32F2F"/>
        <path d="M14 24L10.5 14L14 16L17.5 14Z" fill="#9E9E9E"/>
      </svg>
    </button>`;
    container.appendChild(compassBtn);

    const compassSvg = compassBtn.querySelector('svg');
    function updateCompass() {
      if (!compassBtn.isConnected) return;
      const deg = 90 - viewer.camera.state.phi * 180 / Math.PI;
      compassSvg.style.transform = `rotate(${deg}deg)`;
      requestAnimationFrame(updateCompass);
    }
    requestAnimationFrame(updateCompass);

    compassBtn.addEventListener('click', () => {
      const target = Math.PI / 2;
      const start = viewer.camera.state.phi;
      let diff = target - start;
      diff -= Math.round(diff / (2 * Math.PI)) * 2 * Math.PI;
      const t0 = performance.now();
      function animate(now) {
        const t = Math.min(1, (now - t0) / 300);
        const ease = t * t * (3 - 2 * t);
        viewer.camera.state.phi = start + diff * ease;
        viewer.camera.taint();
        if (t < 1) requestAnimationFrame(animate);
      }
      requestAnimationFrame(animate);
    });

    display(expandable(container, {
      wide: true,
      width: 640,
      height: 600,
      toggleOffset: [-12, -12],
      controls: '.terrain-controls',
      onResize(el, w, h, expanded) {
        if (expanded) {
          canvas.style.width = `${w}px`;
          canvas.style.height = `${h}px`;
        } else {
          canvas.style.width = '';
          canvas.style.height = '';
        }
        viewer.camera.taint();
      }
    }));

    invalidation.then(() => { elevationProfile.destroy(); viewer.destroy(); });
  </script>

  <script id="controls" type="module">
    import SunCalc from 'npm:suncalc';

    const controlsContainer = html`<div class="terrain-controls"></div>`;

    const sunState = { date: new Date(), timeOfDay: 14, utcOffset: -8 };
    const location = viewer._location;

    function formatTime(decimal) {
      const h = Math.floor(decimal) % 24;
      const m = Math.round((decimal % 1) * 60);
      return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
    }

    function updateSunDirection() {
      const tod = sunState.timeOfDay;
      const d = sunState.date;
      const sunDate = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate(), Math.floor(tod) - sunState.utcOffset, (tod % 1) * 60, 0));
      const sunPos = SunCalc.getPosition(sunDate, location.lat, location.lon);
      const alt = sunPos.altitude;
      const az = sunPos.azimuth;
      viewer.settings.sunDirection = [
        -Math.cos(alt) * Math.sin(az),
        Math.sin(alt),
        Math.cos(alt) * Math.cos(az)
      ];
    }
    updateSunDirection();

    function addControl(parent, input, onInput) {
      parent.appendChild(input);
      input.addEventListener('input', () => onInput(input.value));
    }

    function createSection(title, { open = false, trailing = null } = {}) {
      const section = html`<div class="ctrl-section"></div>`;
      const header = html`<div class="ctrl-section-header"></div>`;
      const chevron = html`<span class="ctrl-chevron">&#9654;</span>`;
      header.appendChild(chevron);
      header.appendChild(html`<span class="ctrl-section-title">${title}</span>`);
      if (trailing) header.appendChild(trailing);
      section.appendChild(header);
      const body = html`<div class="ctrl-section-body"></div>`;
      if (!open) body.style.display = 'none';
      else section.classList.add('open');
      section.appendChild(body);
      header.addEventListener('click', (e) => {
        if (e.target.closest('button')) return;
        const isOpen = section.classList.toggle('open');
        body.style.display = isOpen ? '' : 'none';
      });
      return { section, body };
    }

    // Layer panel
    const drawBtn = html`<button class="draw-path-btn" title="Draw a path on the terrain">Draw path</button>`;
    const { section: layerPanel, body: layerList } = createSection('Layers', { open: true, trailing: drawBtn });
    controlsContainer.appendChild(layerPanel);

    const eyeOpenSVG = `<svg viewBox="0 0 20 20" width="16" height="16" style="display:block"><path d="M10 4C4.5 4 1 10 1 10s3.5 6 9 6 9-6 9-6-3.5-6-9-6z" fill="none" stroke="currentColor" stroke-width="1.5"/><circle cx="10" cy="10" r="3" fill="none" stroke="currentColor" stroke-width="1.5"/></svg>`;
    const eyeClosedSVG = `<svg viewBox="0 0 20 20" width="16" height="16" style="display:block"><path d="M10 4C4.5 4 1 10 1 10s3.5 6 9 6 9-6 9-6-3.5-6-9-6z" fill="none" stroke="currentColor" stroke-width="1.5" opacity="0.35"/><circle cx="10" cy="10" r="3" fill="none" stroke="currentColor" stroke-width="1.5" opacity="0.35"/><line x1="4" y1="16" x2="16" y2="4" stroke="currentColor" stroke-width="1.5"/></svg>`;

    function hexFromColor(rgba) {
      if (!rgba) return '#ff8800';
      return '#' + [rgba[0], rgba[1], rgba[2]].map(c => Math.round(c * 255).toString(16).padStart(2, '0')).join('');
    }

    function addColorProp(container, label, currentColor, onChange) {
      const row = html`<div class="layer-prop"><label>${label}</label><input type="color" class="layer-color" value="${hexFromColor(currentColor)}"></div>`;
      row.querySelector('input').addEventListener('input', (e) => onChange(e.target.value));
      container.appendChild(row);
    }

    function addRangeProp(container, label, value, min, max, step, onChange) {
      const row = html`<div class="layer-prop"><label>${label}</label><input type="range" min="${min}" max="${max}" step="${step}" value="${value}"><span class="layer-prop-value">${value}</span></div>`;
      const input = row.querySelector('input');
      const span = row.querySelector('.layer-prop-value');
      input.addEventListener('input', () => { span.textContent = input.value; onChange(Number(input.value)); });
      container.appendChild(row);
    }

    function rebuildLayerPanel() {
      layerList.innerHTML = '';

      // Imagery row (no expandable props, just eye toggle)
      const imgRow = html`<div class="layer-row">
        <button class="layer-eye" title="Toggle visibility"></button>
        <span class="layer-name">Imagery</span>
      </div>`;
      const imgEye = imgRow.querySelector('.layer-eye');
      imgEye.innerHTML = viewer.settings.showImagery ? eyeOpenSVG : eyeClosedSVG;
      imgEye.addEventListener('click', function() {
        viewer.settings.showImagery = !viewer.settings.showImagery;
        this.innerHTML = viewer.settings.showImagery ? eyeOpenSVG : eyeClosedSVG;
      });
      layerList.appendChild(imgRow);

      // Feature layers
      const allEntries = [
        ...viewer._lineLayers.map(e => ({ ...e, kind: 'line' })),
        ...viewer._circleLayers.map(e => ({ ...e, kind: 'circle' })),
        ...viewer._textLayers.map(e => ({ ...e, kind: 'text' })),
      ];
      for (const entry of allEntries) {
        const item = html`<div class="layer-item"></div>`;
        const row = html`<div class="layer-row"></div>`;

        const eyeBtn = html`<button class="layer-eye" title="Toggle visibility"></button>`;
        eyeBtn.innerHTML = entry.visible ? eyeOpenSVG : eyeClosedSVG;
        eyeBtn.addEventListener('click', () => {
          entry.visible = !entry.visible;
          viewer.setLayerVisibility(entry.id, entry.visible);
          eyeBtn.innerHTML = entry.visible ? eyeOpenSVG : eyeClosedSVG;
        });
        row.appendChild(eyeBtn);

        const chevron = html`<span class="layer-chevron">&#9654;</span>`;
        row.appendChild(chevron);

        row.appendChild(html`<span class="layer-name">${entry.id}</span>`);

        const del = html`<button class="layer-delete" title="Remove layer">&times;</button>`;
        del.addEventListener('click', () => {
          viewer.removeLayer(entry.id);
          rebuildLayerPanel();
        });
        row.appendChild(del);
        item.appendChild(row);

        // Expandable properties
        const props = html`<div class="layer-props" style="display:none"></div>`;
        const id = entry.id;

        if (entry.kind === 'line') {
          addColorProp(props, 'Color', entry.layer._lineColor, v => viewer.setLayerPaint(id, 'line-color', v));
          addColorProp(props, 'Border', entry.layer._borderColor, v => viewer.setLayerPaint(id, 'line-border-color', v));
          addRangeProp(props, 'Width', entry.layer._lineWidth, 1, 12, 0.5, v => viewer.setLayerPaint(id, 'line-width', v));
          addRangeProp(props, 'Border width', entry.layer._borderWidth, 0, 6, 0.5, v => viewer.setLayerPaint(id, 'line-border-width', v));
          const dlBtn = html`<button class="layer-download-btn">Download GeoJSON</button>`;
          dlBtn.addEventListener('click', () => {
            const geojson = viewer.getLayerGeoJSON(id);
            if (!geojson) return;
            const blob = new Blob([JSON.stringify(geojson, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${id}.geojson`;
            a.click();
            URL.revokeObjectURL(url);
          });
          props.appendChild(dlBtn);
          const profBtn = html`<button class="layer-download-btn">Elevation profile</button>`;
          profBtn.addEventListener('click', () => {
            const data = viewer.getLayerElevationProfile(id);
            if (!data) return;
            elevationProfile.show(id, entry.id, data, entry.layer._lineColor);
          });
          props.appendChild(profBtn);
        } else if (entry.kind === 'circle') {
          addColorProp(props, 'Fill', entry.layer._fillColor, v => viewer.setLayerPaint(id, 'circle-color', v));
          addColorProp(props, 'Stroke', entry.layer._strokeColor, v => viewer.setLayerPaint(id, 'circle-stroke-color', v));
          addRangeProp(props, 'Radius', entry.layer._radius, 1, 12, 0.5, v => viewer.setLayerPaint(id, 'circle-radius', v));
          addRangeProp(props, 'Stroke width', entry.layer._strokeWidth, 0, 6, 0.5, v => viewer.setLayerPaint(id, 'circle-stroke-width', v));
        } else if (entry.kind === 'text') {
          addColorProp(props, 'Color', entry.layer._color, v => viewer.setLayerPaint(id, 'text-color', v));
          addColorProp(props, 'Halo', entry.layer._strokeColor, v => viewer.setLayerPaint(id, 'text-halo-color', v));
          addRangeProp(props, 'Halo width', entry.layer._strokeWidth, 0, 4, 0.25, v => viewer.setLayerPaint(id, 'text-halo-width', v));
        }

        item.appendChild(props);

        // Toggle expand/collapse on chevron or name click
        chevron.addEventListener('click', () => {
          const open = item.classList.toggle('open');
          props.style.display = open ? '' : 'none';
        });
        row.querySelector('.layer-name').addEventListener('click', () => {
          const open = item.classList.toggle('open');
          props.style.display = open ? '' : 'none';
        });
        row.querySelector('.layer-name').style.cursor = 'pointer';

        layerList.appendChild(item);
      }

    }
    rebuildLayerPanel();
    drawBtn.addEventListener('click', () => enterDrawMode());

    // Pen drawing tool
    const drawState = { active: false, points: [], previewEntry: null, nextLayerId: 1, drawItem: null, pointCount: null };

    const drawOverlay = html`<div class="draw-overlay" style="display:none">Click to add points. Double-click or Enter to finish. Esc to cancel. ⌘Z to undo.</div>`;
    viewer.canvas.parentElement.appendChild(drawOverlay);

    function enterDrawMode() {
      const pendingId = `drawn-path-${drawState.nextLayerId}`;
      drawState.active = true;
      drawState.points = [];
      drawState.previewEntry = null;
      viewer.canvas.classList.add('drawing');
      drawOverlay.style.display = '';

      // Add in-progress layer item to the panel
      const item = html`<div class="layer-item draw-active"></div>`;
      const row = html`<div class="layer-row"></div>`;
      row.appendChild(html`<span class="layer-name" style="flex:1">${pendingId}</span>`);
      drawState.pointCount = html`<span class="draw-point-count">0 pts</span>`;
      row.appendChild(drawState.pointCount);
      const undoBtn = html`<button class="draw-action-btn" title="Undo last point"></button>`;
      undoBtn.innerHTML = `<svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7h7a3 3 0 0 1 0 6H8"/><path d="M6 10L3 7l3-3"/></svg>`;
      undoBtn.addEventListener('click', async () => {
        if (drawState.points.length > 0) {
          drawState.points.pop();
          updateDrawItemCount();
          await updatePreview();
        }
      });
      row.appendChild(undoBtn);
      const doneBtn = html`<button class="draw-action-btn draw-done-btn" title="Finish path"></button>`;
      doneBtn.innerHTML = `<svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 8.5l3.5 3.5 6.5-8"/></svg>`;
      doneBtn.addEventListener('click', () => finishDrawing());
      row.appendChild(doneBtn);
      const cancelBtn = html`<button class="draw-action-btn" title="Cancel"></button>`;
      cancelBtn.innerHTML = `<svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4l8 8M12 4l-8 8"/></svg>`;
      cancelBtn.addEventListener('click', () => cancelDrawing());
      row.appendChild(cancelBtn);
      item.appendChild(row);
      drawState.drawItem = item;

      // Insert before the draw button (last child of layerList)
      layerList.appendChild(item);
    }

    function updateDrawItemCount() {
      if (drawState.pointCount) {
        drawState.pointCount.textContent = `${drawState.points.length} pts`;
      }
    }

    function exitDrawMode() {
      drawState.active = false;
      drawState.points = [];
      viewer.canvas.classList.remove('drawing');
      drawOverlay.style.display = 'none';
      if (drawState.drawItem) {
        drawState.drawItem.remove();
        drawState.drawItem = null;
        drawState.pointCount = null;
      }
    }

    async function updatePreview() {
      if (drawState.previewEntry) {
        viewer.removeLineLayer(drawState.previewEntry.id);
        drawState.previewEntry = null;
      }
      if (drawState.points.length >= 2) {
        const geojson = {
          type: 'FeatureCollection',
          features: [{
            type: 'Feature',
            geometry: {
              type: 'LineString',
              coordinates: drawState.points.map(p => [p.lon, p.lat, p.elev]),
            },
            properties: {},
          }],
        };
        drawState.previewEntry = await viewer.addLineLayer('__draw_preview', geojson, {
          'line-color': '#2196F3',
          'line-width': 4,
          'line-border-color': '#0D47A1',
          'line-border-width': 1.5,
          'atmosphere-opacity': 0.5,
        });
      }
    }

    async function finishDrawing() {
      if (drawState.previewEntry) {
        viewer.removeLineLayer('__draw_preview');
        drawState.previewEntry = null;
      }
      if (drawState.points.length >= 2) {
        const id = `drawn-path-${drawState.nextLayerId++}`;
        const geojson = {
          type: 'FeatureCollection',
          features: [{
            type: 'Feature',
            geometry: {
              type: 'LineString',
              coordinates: drawState.points.map(p => [p.lon, p.lat, p.elev]),
            },
            properties: {},
          }],
        };
        await viewer.addLineLayer(id, geojson, {
          'line-color': '#2196F3',
          'line-width': 4,
          'line-border-color': '#0D47A1',
          'line-border-width': 1.5,
          'atmosphere-opacity': 0.5,
        });
        rebuildLayerPanel();
      }
      exitDrawMode();
    }

    function cancelDrawing() {
      if (drawState.previewEntry) {
        viewer.removeLineLayer('__draw_preview');
        drawState.previewEntry = null;
      }
      exitDrawMode();
    }

    // Point placement via pointer events
    let pointerDownPos = null;
    viewer.canvas.addEventListener('pointerdown', (e) => {
      if (!drawState.active) return;
      pointerDownPos = { x: e.clientX, y: e.clientY };
    });

    viewer.canvas.addEventListener('pointerup', async (e) => {
      if (!drawState.active || !pointerDownPos) return;
      const dx = e.clientX - pointerDownPos.x;
      const dy = e.clientY - pointerDownPos.y;
      pointerDownPos = null;
      if (Math.sqrt(dx * dx + dy * dy) > 5) return; // was a drag

      const hit = viewer.raycast(e.clientX, e.clientY);
      if (!hit) return;

      const mx = hit.worldPos[0];
      const mz = hit.worldPos[2];
      // Convert Mercator back to lon/lat
      const lon = (mx - 0.5) * 360;
      const lat = (2 * Math.atan(Math.exp(Math.PI * (1 - 2 * mz))) - Math.PI / 2) * 180 / Math.PI;
      const elev = viewer.queryElevationMercator(mx, mz) || 0;

      drawState.points.push({ lon, lat, elev, mx, mz });
      updateDrawItemCount();
      await updatePreview();
    });

    viewer.canvas.addEventListener('dblclick', async (e) => {
      if (!drawState.active) return;
      e.preventDefault();
      // The dblclick fires after two pointerup events, so we have a duplicate last point
      if (drawState.points.length > 1) drawState.points.pop();
      await finishDrawing();
    });

    document.addEventListener('keydown', async (e) => {
      if (!drawState.active) return;
      if (e.key === 'Escape') {
        cancelDrawing();
      } else if (e.key === 'Enter') {
        await finishDrawing();
      } else if (e.key === 'z' && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        if (drawState.points.length > 0) {
          drawState.points.pop();
          await updatePreview();
        }
      }
    });
    // Drag-and-drop file import
    let dragCounter = 0;
    container.addEventListener('dragover', (e) => {
      e.preventDefault();
    });
    container.addEventListener('dragenter', (e) => {
      e.preventDefault();
      dragCounter++;
      dropOverlay.style.display = '';
    });
    container.addEventListener('dragleave', (e) => {
      dragCounter--;
      if (dragCounter <= 0) {
        dragCounter = 0;
        dropOverlay.style.display = 'none';
      }
    });
    container.addEventListener('drop', async (e) => {
      e.preventDefault();
      dragCounter = 0;
      dropOverlay.style.display = 'none';
      const file = e.dataTransfer.files[0];
      if (!file) return;
      const text = await file.text();
      const name = file.name;
      const ext = name.split('.').pop().toLowerCase();
      let geojson;
      if (ext === 'gpx') {
        const doc = new DOMParser().parseFromString(text, 'text/xml');
        geojson = gpxToGeoJSON(doc);
      } else if (ext === 'geojson' || ext === 'json') {
        geojson = JSON.parse(text);
      } else {
        return;
      }
      const id = name.replace(/\.[^.]+$/, '').replace(/[^a-zA-Z0-9_-]/g, '-');
      await viewer.addLineLayer(id, geojson, {
        'line-color': '#4CAF50',
        'line-width': 4,
        'line-border-color': '#1B5E20',
        'line-border-width': 1.5,
        'atmosphere-opacity': 0.5,
      });
      rebuildLayerPanel();
    });

    // Analysis section
    const { section: analysis, body: analysisContent } = createSection('Analysis', { open: true });
    controlsContainer.appendChild(analysis);

    addControl(analysisContent,
      Inputs.range([0.0, 2], { value: viewer.settings.verticalExaggeration, step: 0.01, label: "Vertical exaggeration" }),
      v => { viewer.settings.verticalExaggeration = v; }
    );
    addControl(analysisContent,
      Inputs.range([0, 1], { value: viewer.settings.hillshadeOpacity, step: 0.01, label: "Hillshade opacity" }),
      v => { viewer.settings.hillshadeOpacity = v; }
    );
    addControl(analysisContent,
      Inputs.range([0, 1], { value: viewer.settings.contourOpacity, step: 0.01, label: "Contour opacity" }),
      v => { viewer.settings.contourOpacity = v; }
    );
    addControl(analysisContent,
      Inputs.range([0, 1], { value: viewer.settings.slopeAngleOpacity, step: 0.01, label: "Slope angle opacity" }),
      v => {
        viewer.settings.slopeAngleOpacity = v;
        viewer._slopeLegend.style.display = v > 0 ? '' : 'none';
      }
    );
    addControl(analysisContent,
      Inputs.range([0, 1], { value: viewer.settings.slopeAspectOpacity, step: 0.01, label: "Slope aspect opacity" }),
      v => { viewer.settings.slopeAspectOpacity = v; }
    );

    // Slope aspect rose: concentric rings for Above/Near/Below treeline
    {
      const ns = 'http://www.w3.org/2000/svg';
      const size = 180;
      const cx = size / 2, cy = 80;
      const dirs = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
      const rings = [
        { key: 'slopeAspectMaskAbove', label: 'Above', rInner: 0, rOuter: 18 },
        { key: 'slopeAspectMaskNear', label: 'Near', rInner: 18, rOuter: 36 },
        { key: 'slopeAspectMaskBelow', label: 'Below', rInner: 36, rOuter: 54 },
      ];
      const labelR = 68;
      const masks = { slopeAspectMaskAbove: 0, slopeAspectMaskNear: 0, slopeAspectMaskBelow: 0 };

      const svg = document.createElementNS(ns, 'svg');
      svg.setAttribute('viewBox', `0 0 ${size} ${size}`);
      svg.setAttribute('width', size);
      svg.setAttribute('height', size);
      svg.style.display = 'block';
      svg.style.margin = '0 auto';

      for (const ring of rings) {
        for (let i = 0; i < 8; i++) {
          const a0 = (i * 45 - 22.5 - 90) * Math.PI / 180;
          const a1 = (i * 45 + 22.5 - 90) * Math.PI / 180;

          const path = document.createElementNS(ns, 'path');
          let d;
          if (ring.rInner === 0) {
            const x0 = cx + ring.rOuter * Math.cos(a0);
            const y0 = cy + ring.rOuter * Math.sin(a0);
            const x1 = cx + ring.rOuter * Math.cos(a1);
            const y1 = cy + ring.rOuter * Math.sin(a1);
            d = `M${cx},${cy}L${x0.toFixed(1)},${y0.toFixed(1)}L${x1.toFixed(1)},${y1.toFixed(1)}Z`;
          } else {
            const ix0 = cx + ring.rInner * Math.cos(a0), iy0 = cy + ring.rInner * Math.sin(a0);
            const ox0 = cx + ring.rOuter * Math.cos(a0), oy0 = cy + ring.rOuter * Math.sin(a0);
            const ix1 = cx + ring.rInner * Math.cos(a1), iy1 = cy + ring.rInner * Math.sin(a1);
            const ox1 = cx + ring.rOuter * Math.cos(a1), oy1 = cy + ring.rOuter * Math.sin(a1);
            d = `M${ix0.toFixed(1)},${iy0.toFixed(1)}L${ox0.toFixed(1)},${oy0.toFixed(1)}L${ox1.toFixed(1)},${oy1.toFixed(1)}L${ix1.toFixed(1)},${iy1.toFixed(1)}Z`;
          }

          path.setAttribute('d', d);
          path.setAttribute('fill', '#fff');
          path.setAttribute('stroke', '#333');
          path.setAttribute('stroke-width', '0.5');
          path.style.cursor = 'pointer';
          path.style.transition = 'fill 0.1s';

          const ringKey = ring.key;
          const bit = i;
          path.addEventListener('click', () => {
            masks[ringKey] ^= (1 << bit);
            path.setAttribute('fill', (masks[ringKey] & (1 << bit)) ? '#59D91A' : '#fff');
            viewer.settings[ringKey] = masks[ringKey];
          });
          path.addEventListener('mouseenter', () => {
            if (!(masks[ringKey] & (1 << bit))) path.setAttribute('fill', '#eee');
          });
          path.addEventListener('mouseleave', () => {
            if (!(masks[ringKey] & (1 << bit))) path.setAttribute('fill', '#fff');
          });

          svg.appendChild(path);
        }
      }

      for (let i = 0; i < 8; i++) {
        const la = (i * 45 - 90) * Math.PI / 180;
        const text = document.createElementNS(ns, 'text');
        text.setAttribute('x', (cx + labelR * Math.cos(la)).toFixed(1));
        text.setAttribute('y', (cy + labelR * Math.sin(la)).toFixed(1));
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('dominant-baseline', 'central');
        text.setAttribute('font-size', '10');
        text.setAttribute('font-family', 'system-ui, sans-serif');
        text.setAttribute('fill', '#333');
        text.setAttribute('pointer-events', 'none');
        text.textContent = dirs[i];
        svg.appendChild(text);
      }

      // Legend below the rose, inside the SVG
      const legendY = 168;
      const legendItems = rings.map(r => r.label);
      const legendSpacing = 60;
      const legendStartX = cx - (legendItems.length - 1) * legendSpacing / 2;
      for (let i = 0; i < legendItems.length; i++) {
        const lx = legendStartX + i * legendSpacing;
        const rect = document.createElementNS(ns, 'rect');
        rect.setAttribute('x', lx - 16);
        rect.setAttribute('y', legendY - 4);
        rect.setAttribute('width', 8);
        rect.setAttribute('height', 8);
        rect.setAttribute('fill', '#fff');
        rect.setAttribute('stroke', '#333');
        rect.setAttribute('stroke-width', '0.5');
        svg.appendChild(rect);
        const text = document.createElementNS(ns, 'text');
        text.setAttribute('x', lx - 4);
        text.setAttribute('y', legendY);
        text.setAttribute('dominant-baseline', 'central');
        text.setAttribute('font-size', '9');
        text.setAttribute('font-family', 'system-ui, sans-serif');
        text.setAttribute('fill', '#555');
        text.textContent = legendItems[i];
        svg.appendChild(text);
      }

      const wrapper = html`<div class="aspect-rose"></div>`;
      const label = html`<label style="font-size: 12px; font-weight: 500; font-family: system-ui, sans-serif; color: #555;">Slope aspect</label>`;
      wrapper.appendChild(label);
      wrapper.appendChild(svg);
      analysisContent.appendChild(wrapper);
    }
    addControl(analysisContent,
      Inputs.range([0, 13000], { value: viewer.settings.treelineLower, step: 50, label: "Lower treeline (ft)" }),
      v => { viewer.settings.treelineLower = v; }
    );
    addControl(analysisContent,
      Inputs.range([0, 13000], { value: viewer.settings.treelineUpper, step: 50, label: "Upper treeline (ft)" }),
      v => { viewer.settings.treelineUpper = v; }
    );

    // Environment section
    const { section: environment, body: envContent } = createSection('Environment');
    controlsContainer.appendChild(environment);

    addControl(envContent,
      Inputs.date({ value: sunState.date, label: "Date" }),
      v => { if (v) { sunState.date = v; updateSunDirection(); } }
    );

    const timeInput = Inputs.range([0, 24], { value: sunState.timeOfDay, step: 1 / 60, label: "Time of day" });
    const timeOutput = timeInput.querySelector('output');
    if (timeOutput) timeOutput.textContent = formatTime(sunState.timeOfDay);
    addControl(envContent, timeInput, v => {
      sunState.timeOfDay = v;
      if (timeOutput) timeOutput.textContent = formatTime(v);
      updateSunDirection();
    });

    const tzOptions = [
      { label: 'AKST (UTC−9)', offset: -9 },
      { label: 'AKDT (UTC−8)', offset: -8 },
      { label: 'PST (UTC−8)', offset: -8 },
      { label: 'PDT (UTC−7)', offset: -7 },
      { label: 'MST (UTC−7)', offset: -7 },
      { label: 'MDT (UTC−6)', offset: -6 },
      { label: 'CST (UTC−6)', offset: -6 },
      { label: 'CDT (UTC−5)', offset: -5 },
      { label: 'EST (UTC−5)', offset: -5 },
      { label: 'EDT (UTC−4)', offset: -4 },
    ];
    const defaultTz = location.lat > 55 ? 'AKDT (UTC−8)' : 'PDT (UTC−7)';
    const tzSelect = Inputs.select(tzOptions.map(t => t.label), { value: defaultTz, label: "Time zone" });
    addControl(envContent, tzSelect, v => {
      const tz = tzOptions.find(t => t.label === v);
      if (tz) sunState.utcOffset = tz.offset;
      updateSunDirection();
    });
    // Apply default
    const defaultTzEntry = tzOptions.find(t => t.label === defaultTz);
    if (defaultTzEntry) sunState.utcOffset = defaultTzEntry.offset;
    updateSunDirection();

    // Astronomical times display
    const sunTimesEl = html`<div class="sun-times"></div>`;
    envContent.appendChild(sunTimesEl);

    function utcToLocal(date) {
      return date.getTime() / 3600000 + sunState.utcOffset;
    }

    function updateSunTimes() {
      const d = sunState.date;
      const utcDate = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate(), 12, 0, 0));
      const times = SunCalc.getTimes(utcDate, location.lat, location.lon);
      const events = [
        ['Sunrise', times.sunrise],
        ['AM golden', times.goldenHourEnd],
        ['Noon', times.solarNoon],
        ['PM golden', times.goldenHour],
        ['Sunset', times.sunset],
      ];
      sunTimesEl.innerHTML = '';
      for (const [label, date] of events) {
        const localHrs = utcToLocal(date);
        const hrs = ((localHrs % 24) + 24) % 24;
        const btn = html`<button class="sun-time-btn"><span class="sun-time-label">${label}</span><span class="sun-time-value">${formatTime(hrs)}</span></button>`;
        btn.addEventListener('click', () => {
          sunState.timeOfDay = hrs;
          timeInput.value = hrs;
          timeInput.dispatchEvent(new Event('input', { bubbles: true }));
        });
        sunTimesEl.appendChild(btn);
      }
    }
    updateSunTimes();

    // Re-derive sun times when date or timezone changes
    const origDateHandler = sunState._onDateChange;
    const dateInput = envContent.querySelector('input[type="date"]');
    if (dateInput) dateInput.addEventListener('input', () => setTimeout(updateSunTimes, 0));
    tzSelect.addEventListener('input', () => setTimeout(updateSunTimes, 0));

    addControl(envContent,
      Inputs.range([0.05, 1], { value: viewer.settings.atmosphereDensity, step: 0.01, label: "Atmosphere density" }),
      v => { viewer.settings.atmosphereDensity = v; }
    );

    const { section: debug, body: debugContent } = createSection('Debug');
    controlsContainer.appendChild(debug);

    addControl(debugContent,
      Inputs.range([10, 90], { value: Math.round(viewer.camera.state.fov * 180 / Math.PI), step: 1, label: "FOV (degrees)" }),
      v => { viewer.camera.state.fov = v * Math.PI / 180; viewer.camera.taint(); }
    );
    addControl(debugContent,
      Inputs.range([1, 5], { value: viewer.settings.densityThreshold, step: 0.1, label: "Tile scale", transform: Math.log }),
      v => { viewer.settings.densityThreshold = v; }
    );
    addControl(debugContent,
      Inputs.toggle({ label: "Show tile borders" }),
      v => { viewer.settings.showTileBorders = v; }
    );
    addControl(debugContent,
      Inputs.toggle({ label: "Show wireframe" }),
      v => { viewer.settings.showWireframe = v; }
    );
    addControl(debugContent,
      Inputs.toggle({ label: "Freeze coverage" }),
      v => { viewer.settings.freezeCoverage = v; }
    );
    addControl(debugContent,
      Inputs.toggle({ label: "Show collision boxes" }),
      v => { viewer.settings.showCollisionBoxes = v; }
    );

    display(controlsContainer);
  </script>

  <script id="intro" type="text/markdown">
This notebook implements an interactive 3D terrain viewer from scratch using [WebGPU](https://developer.mozilla.org/en-US/docs/Web/API/WebGPU_API). It renders elevation data for the Denali region of Alaska, composited with satellite imagery and OpenStreetMap feature labels.

The elevation data comes from the [ArcticDEM](https://www.pgc.umn.edu/data/arcticdem/) mosaic with [SRTM30](https://catalog.data.gov/dataset/srtm30-global-1-km-digital-elevation-model-dem-version-11-land-surface) as a base layer to fill in gaps in ArcticDEM coverage. Satellite imagery is from [Copernicus Sentinel-2](https://dataspace.copernicus.eu/). Peak locations are sourced from [OpenStreetMap](https://www.openstreetmap.org/copyright). The tile pipeline uses [STAC](https://stacspec.org/) APIs for data discovery, [GDAL](https://gdal.org/) for reprojection, and [rio-tiler](https://github.com/cogeotiff/rio-tiler) for slicing and mosaicking Cloud-Optimized GeoTIFFs into map tiles. The route shown is the standard West Buttress route, traced from [Jack Kuenzle's 2023 FKT](https://www.strava.com/activities/9223277277).

The renderer implements terrain mesh rendering, imagery compositing, basic GeoJSON features (no vector tiles!), and single-scattering atmospheric fog. The atmosphere uses Rayleigh and Mie scattering, inspired by [wwwtyro/glsl-atmosphere](https://github.com/wwwtyro/glsl-atmosphere) and [GPU Gems 2, Chapter 16](https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering).

I mean, let's be clear. This is a totally half-baked one-off ad hoc renderer. It uses way too much data for the (remarkably!) high resolution terrain. At the top of my list is to lower the terrain resolution and precompute the hillshading, rather than relying on full-resolution terrain for the shading.
  </script>

  <script id="controls-help" type="text/markdown">
| Input | Action |
|---|---|
| Drag | Pan |
| ⌘+Drag / Right-drag | Orbit |
| Ctrl+Drag | Pivot (look around) |
| ⌥+Drag | Zoom |
| Shift+Drag | Pan (camera plane) |
| Scroll | Zoom |
  </script>

  <script id="styles" type="text/html">
    <style>
      canvas.terrain {
        width: 100%;
        min-width: 0;
        height: 600px;
        display: block;
        border-radius: 4px;
        cursor: grab;
      }
      .expandable-controls-panel {
        width: 340px;
      }
      .status {
        font-family: monospace;
        font-size: 12px;
        color: #666;
      }

      .compass-rose {
        position: absolute;
        top: 50px;
        right: 10px;
        width: 36px;
        height: 36px;
        background: rgba(255, 255, 255, 0.85);
        backdrop-filter: blur(4px);
        border: none;
        border-radius: 50%;
        cursor: pointer;
        padding: 0;
        box-shadow: 0 1px 3px rgba(0,0,0,0.15);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2;
      }
      .compass-rose:hover {
        background: rgba(255, 255, 255, 1);
      }

      .slope-legend {
        position: absolute;
        bottom: 28px;
        right: 10px;
        background: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(4px);
        border-radius: 4px;
        padding: 4px 8px 4px;
        pointer-events: none;
        font-size: 11px;
        line-height: 1;
        font-family: system-ui, sans-serif;
      }
      .slope-legend-title {
        font-weight: 600;
        margin-bottom: 6px;
        color: #333;
      }
      .slope-legend-blocks {
        display: flex;
        gap: 1px;
        width: 240px;
      }
      .slope-legend-blocks > div {
        flex: 1;
        height: 14px;
      }
      .slope-legend-blocks > div:first-child {
        border-radius: 2px 0 0 2px;
      }
      .slope-legend-blocks > div:last-child {
        border-radius: 0 2px 2px 0;
      }
      .slope-legend-labels {
        display: flex;
        gap: 1px;
        width: 240px;
        margin-top: 3px;
      }
      .slope-legend-labels span {
        flex: 1;
        text-align: center;
        font-size: 9px;
        color: #555;
        white-space: nowrap;
      }

      .elevation-label {
        position: absolute;
        bottom: 10px;
        left: 10px;
        pointer-events: none;
        font-family: system-ui, sans-serif;
        font-style: italic;
        font-weight: 900;
        font-size: 18px;
        color: #000;
        paint-order: stroke fill;
        -webkit-text-stroke: 3px #fff;
        opacity: 0;
        white-space: nowrap;
      }

      .terrain-attribution {
        position: absolute;
        bottom: 0;
        right: 0;
        background: rgba(255, 255, 255, 0.65);
        padding: 1px 5px;
        font-size: 10px;
        border-top-left-radius: 2px;
        line-height: 1.4;
        pointer-events: auto;
      }
      .terrain-attribution a {
        color: #333;
        text-decoration: none;
      }
      .terrain-attribution a:hover {
        text-decoration: underline;
      }

      /* Section headers */
      .ctrl-section-header {
        display: flex;
        align-items: center;
        gap: 6px;
        cursor: pointer;
        user-select: none;
        padding: 4px 0;
        font-family: system-ui, sans-serif;
      }
      .ctrl-chevron {
        display: inline-block;
        width: 12px;
        text-align: center;
        font-size: 12px;
        color: #666;
        transition: transform 0.15s;
        flex-shrink: 0;
      }
      .ctrl-section.open > .ctrl-section-header > .ctrl-chevron {
        transform: rotate(90deg);
      }
      .ctrl-section-title {
        font-weight: 600;
        font-size: 14px;
        flex: 1;
      }
      .ctrl-section-body {
        display: flex;
        flex-direction: column;
        gap: 4px;
        padding: 0 0 4px 0;
      }

      /* Layer panel */
      .layer-item.open {
        background: #f8f8f8;
        border-radius: 4px;
      }
      .layer-row {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 2px 0;
        font-family: system-ui, sans-serif;
        font-size: 13px;
        cursor: default;
      }
      .layer-chevron {
        display: inline-block;
        width: 10px;
        text-align: center;
        font-size: 10px;
        color: #999;
        transition: transform 0.15s;
        flex-shrink: 0;
        cursor: pointer;
        user-select: none;
      }
      .layer-item.open > .layer-row > .layer-chevron {
        transform: rotate(90deg);
      }
      .layer-eye {
        background: none;
        border: none;
        padding: 2px;
        cursor: pointer;
        color: #555;
        border-radius: 3px;
        display: flex;
        align-items: center;
        flex-shrink: 0;
      }
      .layer-eye:hover {
        background: #eee;
      }
      .layer-name {
        flex: 1;
        min-width: 0;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .layer-delete {
        background: none;
        border: none;
        cursor: pointer;
        font-size: 16px;
        line-height: 1;
        color: #999;
        padding: 0 4px;
        flex-shrink: 0;
      }
      .layer-delete:hover {
        color: #d32f2f;
      }
      .layer-props {
        display: flex;
        flex-direction: column;
        gap: 4px;
        padding: 4px 4px 6px 26px;
      }
      .layer-prop {
        display: flex;
        align-items: center;
        gap: 6px;
        font-family: system-ui, sans-serif;
        font-size: 12px;
        color: #555;
      }
      .layer-prop label {
        width: 72px;
        flex-shrink: 0;
      }
      .layer-prop input[type="range"] {
        flex: 1;
        min-width: 0;
      }
      .layer-prop .layer-prop-value {
        width: 24px;
        text-align: right;
        font-size: 11px;
        font-variant-numeric: tabular-nums;
      }
      .layer-color {
        width: 24px;
        height: 20px;
        padding: 0;
        border: 1px solid #ccc;
        border-radius: 3px;
        cursor: pointer;
      }
      .layer-download-btn {
        padding: 2px 8px;
        font-size: 11px;
        font-family: system-ui, sans-serif;
        background: #f5f5f5;
        border: 1px solid #ccc;
        border-radius: 4px;
        cursor: pointer;
        align-self: flex-start;
        margin-top: 2px;
      }
      .layer-download-btn:hover {
        background: #e8e8e8;
      }
      .draw-path-btn {
        padding: 2px 8px;
        font-size: 11px;
        font-family: system-ui, sans-serif;
        background: #f5f5f5;
        border: 1px solid #ccc;
        border-radius: 4px;
        cursor: pointer;
        flex-shrink: 0;
      }
      .draw-path-btn:hover {
        background: #e8e8e8;
      }

      /* Pen drawing tool */
      canvas.terrain.drawing {
        cursor: crosshair !important;
      }
      .draw-active {
        background: #e3f2fd;
        border-radius: 4px;
        padding: 2px 4px;
      }
      .draw-point-count {
        font-size: 11px;
        color: #666;
        font-variant-numeric: tabular-nums;
        flex-shrink: 0;
      }
      .draw-action-btn {
        background: none;
        border: 1px solid #ccc;
        border-radius: 3px;
        cursor: pointer;
        color: #555;
        padding: 3px 4px;
        flex-shrink: 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
      .draw-action-btn:hover {
        background: #e0e0e0;
      }
      .draw-done-btn {
        color: #2e7d32;
      }
      /* Sun times */
      .sun-times {
        display: flex;
        gap: 4px;
        padding: 4px 0;
        justify-content: space-between;
      }
      .sun-time-btn {
        display: flex;
        flex-direction: column;
        align-items: center;
        background: #f5f5f5;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 3px 5px;
        cursor: pointer;
        font-family: system-ui, sans-serif;
        line-height: 1.3;
        flex: 1;
      }
      .sun-time-btn:hover {
        background: #e8e8e8;
      }
      .sun-time-label {
        font-size: 9px;
        color: #888;
        white-space: nowrap;
      }
      .sun-time-value {
        font-size: 12px;
        font-weight: 600;
        color: #333;
        font-variant-numeric: tabular-nums;
      }

      .drop-overlay {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(33, 150, 243, 0.15);
        border: 2px dashed rgba(33, 150, 243, 0.6);
        border-radius: 4px;
        font-family: system-ui, sans-serif;
        font-size: 16px;
        font-weight: 600;
        color: #1565C0;
        pointer-events: none;
        z-index: 10;
      }

      .draw-overlay {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        padding: 6px 14px;
        border-radius: 6px;
        font-family: system-ui, sans-serif;
        font-size: 13px;
        pointer-events: none;
        z-index: 10;
        white-space: nowrap;
      }

      /* Elevation profile panel */
      .elevation-profile-panel {
        position: absolute;
        bottom: 0; left: 0; right: 0;
        height: 20%;
        min-height: 120px;
        max-height: 300px;
        background: rgba(255, 255, 255, 0.85);
        backdrop-filter: blur(8px);
        border-radius: 4px 4px 0 0;
        display: none;
        flex-direction: column;
        z-index: 5;
        box-shadow: 0 -1px 4px rgba(0, 0, 0, 0.1);
      }
      .elevation-profile-panel.visible { display: flex; }
      .elevation-profile-header {
        display: flex;
        align-items: center;
        padding: 4px 8px;
        gap: 8px;
        flex-shrink: 0;
      }
      .elevation-profile-title {
        flex: 1;
        font-family: system-ui, sans-serif;
        font-size: 12px;
        font-weight: 600;
        color: #333;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .elevation-profile-close {
        background: none;
        border: 1px solid #ccc;
        border-radius: 3px;
        cursor: pointer;
        color: #555;
        padding: 3px 4px;
        flex-shrink: 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
      .elevation-profile-close:hover {
        background: #e0e0e0;
      }
      .elevation-profile-canvas {
        flex: 1;
        width: 100%;
        min-height: 0;
      }
    </style>
  </script>
</notebook>
