<!doctype html>
<notebook theme="air">
  <title>Denali Terrain</title>

  <script id="viewer" type="module">
    import { TerrainMap } from './mapviewer/terrain-viewer.js';
    import { TILE_URL_TERRAIN, TILE_URL_SENTINEL } from './tile-urls.js';
    import { createGPULines } from 'npm:webgpu-instanced-lines';
    import simplify from 'npm:simplify-js';
    import { expandable } from './lib/expandable.js';

    const canvas = document.createElement('canvas');
    canvas.className = 'terrain';

    const viewer = await TerrainMap.create(canvas, {
      sources: {
        'arctic-dem': {
          type: 'terrain',
          tiles: [TILE_URL_TERRAIN],
          minzoom: 4,
          maxzoom: 13,
          bounds: [-152.9, 62.2, -148.8, 64.0],
          attribution: '<a href="https://www.pgc.umn.edu/data/arcticdem/" target="_blank" rel="noopener">ArcticDEM</a> | <a href="https://catalog.data.gov/dataset/srtm30-global-1-km-digital-elevation-model-dem-version-11-land-surface" target="_blank" rel="noopener">SRTM30</a>',
        },
        'sentinel': {
          type: 'raster',
          tiles: [TILE_URL_SENTINEL],
          minzoom: 4,
          maxzoom: 11,
          bounds: [-152.9, 62.2, -148.8, 64.0],
          attribution: '<a href="https://dataspace.copernicus.eu/" target="_blank" rel="noopener">Copernicus Sentinel-2</a>',
        },
        'peaks': {
          type: 'geojson',
          data: 'osm/peaks.geojson',
          attribution: '<a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener">OpenStreetMap</a>',
        },
        'fkt': {
          type: 'geojson',
          data: 'strava/fkt.geojson',
          simplify: 0.0001,
          attribution: '<a href="https://www.strava.com/activities/9223277277" target="_blank" rel="noopener">Strava</a>',
        },
      },
      camera: {
        center: [0.08005793958567985, 0.00021365516506647512, 0.27291423467021114],
        distance: 0.0004971889617079275,
        phi: 2.4972122538258654,
        theta: 0.13580281526641474,
      },
      font: {
        atlas: './mapviewer/fonts/roboto-regular.png',
        metadata: './mapviewer/fonts/roboto-regular.json',
      },
      base: [
        { id: 'satellite', source: 'sentinel', blend: 'source-over' },
      ],
      features: [
        /*{
          id: 'ski-tracks-casing',
          type: 'line',
          source: 'fkt',
          paint: {
            'line-color': '#331100',
            'line-width': 7,
            'atmosphere-opacity': 0.5
          }
        },*/
        {
          id: 'ski-tracks',
          type: 'line',
          source: 'fkt',
          paint: {
            'line-color': '#ff8800',
            'line-width': 5,
            'line-border-color': '#331100',
            'line-border-width': 2,
            'atmosphere-opacity': 0.5
          }
        },
        {
          id: 'peak-circles',
          type: 'circle',
          source: 'peaks',
          paint: {
            'circle-radius': 3,
            'circle-color': '#000000',
            'circle-stroke-color': '#ffffff',
            'circle-stroke-width': 1.5,
            'atmosphere-opacity': 0.5
          }
        },
        {
          id: 'peak-labels',
          type: 'text',
          source: 'peaks',
          paint: {
            'text-field': 'name',
            'text-size': 16,
            'text-color': '#000000',
            'text-halo-color': '#ffffff',
            'text-halo-width': 1.25,
            'atmosphere-opacity': 0.5
          }
        },
      ],
      createGPULines,
      simplifyFn: simplify,
    });

    const slopeLegend = html`<div class="slope-legend" style="display: none">
      <div class="slope-legend-title">Slope angle</div>
      <div class="slope-legend-blocks">
        <div style="background: rgb(255, 199, 0)"></div>
        <div style="background: rgb(255, 140, 0)"></div>
        <div style="background: rgb(255, 77, 0)"></div>
        <div style="background: rgb(191, 0, 0)"></div>
        <div style="background: rgb(102, 0, 153)"></div>
        <div style="background: rgb(0, 51, 204)"></div>
        <div style="background: rgb(0, 0, 0)"></div>
      </div>
      <div class="slope-legend-labels">
        <span>26-29°</span>
        <span>30-31°</span>
        <span>32-34°</span>
        <span>35-45°</span>
        <span>46-50°</span>
        <span>51-59°</span>
        <span>60°+</span>
      </div>
    </div>`;
    viewer._slopeLegend = slopeLegend;

    const elevationLabel = html`<div class="elevation-label"></div>`;

    canvas.addEventListener('mousemove', (e) => {
      const hit = viewer.raycast(e.clientX, e.clientY);
      if (hit) {
        const elev = viewer.queryElevationMercator(hit.worldPos[0], hit.worldPos[2]);
        if (elev != null) {
          const feet = Math.round(elev * 3.28084);
          elevationLabel.textContent = `${feet.toLocaleString()} ft`;
          elevationLabel.style.opacity = '1';
        } else {
          elevationLabel.style.opacity = '0';
        }
      } else {
        elevationLabel.style.opacity = '0';
      }
    });
    canvas.addEventListener('mouseleave', () => {
      elevationLabel.style.opacity = '0';
    });

    const container = html`<div style="position: relative">`;
    container.appendChild(canvas);
    container.appendChild(elevationLabel);
    container.appendChild(slopeLegend);
    container.appendChild(viewer.attribution);

    // Compass rose: shows current bearing, click to orient north
    const compassBtn = html`<button class="compass-rose" title="Orient north">
      <svg viewBox="0 0 28 28" width="24" height="24" style="display:block">
        <path d="M14 4L17.5 14L14 12L10.5 14Z" fill="#D32F2F"/>
        <path d="M14 24L10.5 14L14 16L17.5 14Z" fill="#9E9E9E"/>
      </svg>
    </button>`;
    container.appendChild(compassBtn);

    const compassSvg = compassBtn.querySelector('svg');
    function updateCompass() {
      if (!compassBtn.isConnected) return;
      const deg = 90 - viewer.camera.state.phi * 180 / Math.PI;
      compassSvg.style.transform = `rotate(${deg}deg)`;
      requestAnimationFrame(updateCompass);
    }
    requestAnimationFrame(updateCompass);

    compassBtn.addEventListener('click', () => {
      const target = Math.PI / 2;
      const start = viewer.camera.state.phi;
      let diff = target - start;
      diff -= Math.round(diff / (2 * Math.PI)) * 2 * Math.PI;
      const t0 = performance.now();
      function animate(now) {
        const t = Math.min(1, (now - t0) / 300);
        const ease = t * t * (3 - 2 * t);
        viewer.camera.state.phi = start + diff * ease;
        viewer.camera.taint();
        if (t < 1) requestAnimationFrame(animate);
      }
      requestAnimationFrame(animate);
    });

    display(expandable(container, {
      wide: true,
      width: 640,
      height: 600,
      toggleOffset: [-12, -12],
      controls: '.terrain-controls',
      onResize(el, w, h, expanded) {
        if (expanded) {
          canvas.style.width = `${w}px`;
          canvas.style.height = `${h}px`;
        } else {
          canvas.style.width = '';
          canvas.style.height = '';
        }
        viewer.camera.taint();
      }
    }));

    invalidation.then(() => viewer.destroy());
  </script>

  <script id="controls" type="module">
    import SunCalc from 'npm:suncalc';

    const controlsContainer = html`<div class="terrain-controls"></div>`;

    const sunState = { date: new Date(), timeOfDay: 14 };
    const location = viewer._location;

    function updateSunDirection() {
      const tod = sunState.timeOfDay;
      const d = sunState.date;
      const sunDate = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate(), Math.floor(tod) + 8, (tod % 1) * 60, 0));
      const sunPos = SunCalc.getPosition(sunDate, location.lat, location.lon);
      const alt = sunPos.altitude;
      const az = sunPos.azimuth;
      viewer.settings.sunDirection = [
        -Math.cos(alt) * Math.sin(az),
        Math.sin(alt),
        Math.cos(alt) * Math.cos(az)
      ];
    }
    updateSunDirection();

    function addControl(parent, input, onInput) {
      parent.appendChild(input);
      input.addEventListener('input', () => onInput(input.value));
    }

    addControl(controlsContainer,
      Inputs.checkbox(["Imagery", "Features", "Route"], { value: ["Imagery", "Features", "Route"], label: "Layers" }),
      v => {
        viewer.settings.showImagery = v.includes("Imagery");
        viewer.settings.showFeatures = v.includes("Features");
        viewer.settings.showRoute = v.includes("Route");
      }
    );
    // Analysis section
    const analysis = html`<details open><summary style="cursor: pointer;">Analysis</summary><div style="display: flex; flex-direction: column; gap: 4px; margin-top: 4px"></div></details>`;
    const analysisContent = analysis.querySelector('div');
    controlsContainer.appendChild(analysis);

    addControl(analysisContent,
      Inputs.range([0, 1], { value: viewer.settings.hillshadeOpacity, step: 0.01, label: "Hillshade opacity" }),
      v => { viewer.settings.hillshadeOpacity = v; }
    );
    addControl(analysisContent,
      Inputs.range([0, 1], { value: viewer.settings.contourOpacity, step: 0.01, label: "Contour opacity" }),
      v => { viewer.settings.contourOpacity = v; }
    );
    addControl(analysisContent,
      Inputs.range([0, 1], { value: viewer.settings.slopeAngleOpacity, step: 0.01, label: "Slope angle opacity" }),
      v => {
        viewer.settings.slopeAngleOpacity = v;
        viewer._slopeLegend.style.display = v > 0 ? '' : 'none';
      }
    );
    addControl(analysisContent,
      Inputs.range([0, 1], { value: viewer.settings.slopeAspectOpacity, step: 0.01, label: "Slope aspect opacity" }),
      v => { viewer.settings.slopeAspectOpacity = v; }
    );

    // Slope aspect rose: concentric rings for Above/Near/Below treeline
    {
      const ns = 'http://www.w3.org/2000/svg';
      const size = 160;
      const cx = size / 2, cy = size / 2;
      const dirs = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
      const rings = [
        { key: 'slopeAspectMaskAbove', rInner: 0, rOuter: 18 },
        { key: 'slopeAspectMaskNear', rInner: 18, rOuter: 36 },
        { key: 'slopeAspectMaskBelow', rInner: 36, rOuter: 54 },
      ];
      const labelR = 68;
      const masks = { slopeAspectMaskAbove: 0, slopeAspectMaskNear: 0, slopeAspectMaskBelow: 0 };

      const svg = document.createElementNS(ns, 'svg');
      svg.setAttribute('viewBox', `0 0 ${size} ${size}`);
      svg.setAttribute('width', size);
      svg.setAttribute('height', size);
      svg.style.display = 'block';
      svg.style.margin = '4px auto 0';

      for (const ring of rings) {
        for (let i = 0; i < 8; i++) {
          const a0 = (i * 45 - 22.5 - 90) * Math.PI / 180;
          const a1 = (i * 45 + 22.5 - 90) * Math.PI / 180;

          const path = document.createElementNS(ns, 'path');
          let d;
          if (ring.rInner === 0) {
            const x0 = cx + ring.rOuter * Math.cos(a0);
            const y0 = cy + ring.rOuter * Math.sin(a0);
            const x1 = cx + ring.rOuter * Math.cos(a1);
            const y1 = cy + ring.rOuter * Math.sin(a1);
            d = `M${cx},${cy}L${x0.toFixed(1)},${y0.toFixed(1)}L${x1.toFixed(1)},${y1.toFixed(1)}Z`;
          } else {
            const ix0 = cx + ring.rInner * Math.cos(a0), iy0 = cy + ring.rInner * Math.sin(a0);
            const ox0 = cx + ring.rOuter * Math.cos(a0), oy0 = cy + ring.rOuter * Math.sin(a0);
            const ix1 = cx + ring.rInner * Math.cos(a1), iy1 = cy + ring.rInner * Math.sin(a1);
            const ox1 = cx + ring.rOuter * Math.cos(a1), oy1 = cy + ring.rOuter * Math.sin(a1);
            d = `M${ix0.toFixed(1)},${iy0.toFixed(1)}L${ox0.toFixed(1)},${oy0.toFixed(1)}L${ox1.toFixed(1)},${oy1.toFixed(1)}L${ix1.toFixed(1)},${iy1.toFixed(1)}Z`;
          }

          path.setAttribute('d', d);
          path.setAttribute('fill', '#fff');
          path.setAttribute('stroke', '#333');
          path.setAttribute('stroke-width', '0.5');
          path.style.cursor = 'pointer';
          path.style.transition = 'fill 0.1s';

          const ringKey = ring.key;
          const bit = i;
          path.addEventListener('click', () => {
            masks[ringKey] ^= (1 << bit);
            path.setAttribute('fill', (masks[ringKey] & (1 << bit)) ? '#59D91A' : '#fff');
            viewer.settings[ringKey] = masks[ringKey];
          });
          path.addEventListener('mouseenter', () => {
            if (!(masks[ringKey] & (1 << bit))) path.setAttribute('fill', '#eee');
          });
          path.addEventListener('mouseleave', () => {
            if (!(masks[ringKey] & (1 << bit))) path.setAttribute('fill', '#fff');
          });

          svg.appendChild(path);
        }
      }

      for (let i = 0; i < 8; i++) {
        const la = (i * 45 - 90) * Math.PI / 180;
        const text = document.createElementNS(ns, 'text');
        text.setAttribute('x', (cx + labelR * Math.cos(la)).toFixed(1));
        text.setAttribute('y', (cy + labelR * Math.sin(la)).toFixed(1));
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('dominant-baseline', 'central');
        text.setAttribute('font-size', '10');
        text.setAttribute('font-family', 'system-ui, sans-serif');
        text.setAttribute('fill', '#333');
        text.setAttribute('pointer-events', 'none');
        text.textContent = dirs[i];
        svg.appendChild(text);
      }

      const wrapper = html`<div class="aspect-rose" style="max-width: 240px;">
        <label style="font-size: 12px; font-weight: 500; font-family: system-ui, sans-serif; color: #333;">Slope aspect</label>
      </div>`;
      wrapper.appendChild(svg);
      const legend = html`<div style="display: flex; justify-content: center; gap: 12px; font-size: 10px; font-family: system-ui, sans-serif; color: #333; margin-top: 2px;">
        <span>Inner: Above</span>
        <span>Middle: Near</span>
        <span>Outer: Below treeline</span>
      </div>`;
      wrapper.appendChild(legend);
      analysisContent.appendChild(wrapper);
    }
    addControl(analysisContent,
      Inputs.range([0, 10000], { value: viewer.settings.treelineLower, step: 50, label: "Lower treeline (ft)" }),
      v => { viewer.settings.treelineLower = v; }
    );
    addControl(analysisContent,
      Inputs.range([0, 10000], { value: viewer.settings.treelineUpper, step: 50, label: "Upper treeline (ft)" }),
      v => { viewer.settings.treelineUpper = v; }
    );

    // Environment section
    const environment = html`<details><summary style="cursor: pointer;">Environment</summary><div style="display: flex; flex-direction: column; gap: 4px; margin-top: 4px"></div></details>`;
    const envContent = environment.querySelector('div');
    controlsContainer.appendChild(environment);

    addControl(envContent,
      Inputs.range([0.0, 2], { value: viewer.settings.verticalExaggeration, step: 0.01, label: "Vertical exaggeration" }),
      v => { viewer.settings.verticalExaggeration = v; }
    );
    addControl(envContent,
      Inputs.range([10, 90], { value: Math.round(viewer.camera.state.fov * 180 / Math.PI), step: 1, label: "FOV (degrees)" }),
      v => { viewer.camera.state.fov = v * Math.PI / 180; viewer.camera.taint(); }
    );
    addControl(envContent,
      Inputs.date({ value: sunState.date, label: "Date" }),
      v => { if (v) { sunState.date = v; updateSunDirection(); } }
    );
    addControl(envContent,
      Inputs.range([0, 24], { value: sunState.timeOfDay, step: 0.01, label: "Time of day (AKDT)" }),
      v => { sunState.timeOfDay = v; updateSunDirection(); }
    );
    addControl(envContent,
      Inputs.range([0.05, 1], { value: viewer.settings.atmosphereDensity, step: 0.01, label: "Atmosphere density" }),
      v => { viewer.settings.atmosphereDensity = v; }
    );

    const debug = html`<details><summary style="cursor: pointer;">Debug</summary><div style="display: flex; flex-direction: column; gap: 4px; margin-top: 4px"></div></details>`;
    const debugContent = debug.querySelector('div');
    controlsContainer.appendChild(debug);

    addControl(debugContent,
      Inputs.range([1, 5], { value: viewer.settings.densityThreshold, step: 0.1, label: "Tile scale", transform: Math.log }),
      v => { viewer.settings.densityThreshold = v; }
    );
    addControl(debugContent,
      Inputs.toggle({ label: "Show tile borders" }),
      v => { viewer.settings.showTileBorders = v; }
    );
    addControl(debugContent,
      Inputs.toggle({ label: "Show wireframe" }),
      v => { viewer.settings.showWireframe = v; }
    );
    addControl(debugContent,
      Inputs.toggle({ label: "Freeze coverage" }),
      v => { viewer.settings.freezeCoverage = v; }
    );
    addControl(debugContent,
      Inputs.toggle({ label: "Show collision boxes" }),
      v => { viewer.settings.showCollisionBoxes = v; }
    );

    display(controlsContainer);
  </script>

  <script id="intro" type="text/markdown">
This notebook implements an interactive 3D terrain viewer from scratch using [WebGPU](https://developer.mozilla.org/en-US/docs/Web/API/WebGPU_API). It renders elevation data for the Denali region of Alaska, composited with satellite imagery and OpenStreetMap feature labels.

The elevation data comes from the [ArcticDEM](https://www.pgc.umn.edu/data/arcticdem/) mosaic with [SRTM30](https://catalog.data.gov/dataset/srtm30-global-1-km-digital-elevation-model-dem-version-11-land-surface) as a base layer to fill in gaps in ArcticDEM coverage. Satellite imagery is from [Copernicus Sentinel-2](https://dataspace.copernicus.eu/). Peak locations are sourced from [OpenStreetMap](https://www.openstreetmap.org/copyright). The tile pipeline uses [STAC](https://stacspec.org/) APIs for data discovery, [GDAL](https://gdal.org/) for reprojection, and [rio-tiler](https://github.com/cogeotiff/rio-tiler) for slicing and mosaicking Cloud-Optimized GeoTIFFs into map tiles. The route shown is the standard West Buttress route, traced from [Jack Kuenzle's 2023 FKT](https://www.strava.com/activities/9223277277).

The renderer implements terrain mesh rendering, imagery compositing, basic GeoJSON features (no vector tiles!), and single-scattering atmospheric fog. The atmosphere uses Rayleigh and Mie scattering, inspired by [wwwtyro/glsl-atmosphere](https://github.com/wwwtyro/glsl-atmosphere) and [GPU Gems 2, Chapter 16](https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering).

I mean, let's be clear. This is a totally half-baked one-off ad hoc renderer. It uses way too much data for the (remarkably!) high resolution terrain. At the top of my list is to lower the terrain resolution and precompute the hillshading, rather than relying on full-resolution terrain for the shading.
  </script>

  <script id="controls-help" type="text/markdown">
| Input | Action |
|---|---|
| Drag | Pan |
| ⌘+Drag / Right-drag | Orbit |
| Ctrl+Drag | Pivot (look around) |
| ⌥+Drag | Zoom |
| Shift+Drag | Pan (camera plane) |
| Scroll | Zoom |
  </script>

  <script id="styles" type="text/html">
    <style>
      canvas.terrain {
        width: 100%;
        min-width: 0;
        height: 600px;
        display: block;
        border-radius: 4px;
        cursor: grab;
      }
      .status {
        font-family: monospace;
        font-size: 12px;
        color: #666;
      }

      .compass-rose {
        position: absolute;
        top: 10px;
        left: 10px;
        width: 36px;
        height: 36px;
        background: rgba(255, 255, 255, 0.85);
        backdrop-filter: blur(4px);
        border: none;
        border-radius: 50%;
        cursor: pointer;
        padding: 0;
        box-shadow: 0 1px 3px rgba(0,0,0,0.15);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2;
      }
      .compass-rose:hover {
        background: rgba(255, 255, 255, 1);
      }

      .slope-legend {
        position: absolute;
        bottom: 28px;
        right: 10px;
        background: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(4px);
        border-radius: 4px;
        padding: 4px 8px 4px;
        pointer-events: none;
        font-size: 11px;
        line-height: 1;
        font-family: system-ui, sans-serif;
      }
      .slope-legend-title {
        font-weight: 600;
        margin-bottom: 6px;
        color: #333;
      }
      .slope-legend-blocks {
        display: flex;
        gap: 1px;
        width: 240px;
      }
      .slope-legend-blocks > div {
        flex: 1;
        height: 14px;
      }
      .slope-legend-blocks > div:first-child {
        border-radius: 2px 0 0 2px;
      }
      .slope-legend-blocks > div:last-child {
        border-radius: 0 2px 2px 0;
      }
      .slope-legend-labels {
        display: flex;
        gap: 1px;
        width: 240px;
        margin-top: 3px;
      }
      .slope-legend-labels span {
        flex: 1;
        text-align: center;
        font-size: 9px;
        color: #555;
        white-space: nowrap;
      }

      .elevation-label {
        position: absolute;
        bottom: 10px;
        left: 10px;
        pointer-events: none;
        font-family: system-ui, sans-serif;
        font-style: italic;
        font-weight: 900;
        font-size: 18px;
        color: #000;
        paint-order: stroke fill;
        -webkit-text-stroke: 3px #fff;
        opacity: 0;
        white-space: nowrap;
      }

      .terrain-attribution {
        position: absolute;
        bottom: 0;
        right: 0;
        background: rgba(255, 255, 255, 0.65);
        padding: 1px 5px;
        font-size: 10px;
        border-top-left-radius: 2px;
        line-height: 1.4;
        pointer-events: auto;
      }
      .terrain-attribution a {
        color: #333;
        text-decoration: none;
      }
      .terrain-attribution a:hover {
        text-decoration: underline;
      }
    </style>
  </script>
</notebook>
