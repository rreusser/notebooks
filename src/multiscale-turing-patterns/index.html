<!doctype html>
<notebook theme="air">
  <title>Multi-Scale Turing Patterns in WebGPU</title>

  <script id="1" type="text/markdown">
    # Multi-Scale Turing Patterns in WebGPU

    This notebook implements the [Cyclic Symmetric Multi-Scale Turing Patterns](http://www.archive.bridgesmathart.org/2010/bridges2010-387.pdf) of Jonathan McCabe in WebGPU. The simulation uses FFT-based convolution with analytical kernels (Gaussian and circular) to compute activator-inhibitor dynamics across multiple scales. It's a translation of [previous](https://rreusser.github.io/multiscale-turing-patterns/) [implementations](https://observablehq.com/@rreusser/multiscale-turing-pattern-bot-v2), the best output of which I captured in galleries [1](https://rreusser.github.io/multiscale-turing-pattern-gallery/) and [2](https://rreusser.github.io/multiscale-turing-pattern-gallery-2/).

    The algorithm selects the scale with minimum variation at each point, creating the characteristic multiscale patterns. Colors are blended based on which scale dominates locally.
  </script>

  <script id="webgpu-check" type="module">
    if (!navigator.gpu) {
      display(html`<div style="color: red; padding: 20px; border: 1px solid red; background: #fff0f0; border-radius: 4px;">
        <strong>WebGPU is not available</strong><br>
        Please use a browser that supports WebGPU (Chrome 113+, Edge 113+, or Firefox with flags enabled).
      </div>`);
    }
  </script>

  <script id="imports" type="module">
    import { createWebGPUContext, isWebGPUAvailable } from './lib/webgpu-canvas.js';
    import { createTuringPipelines } from './pipeline.js';
    import { createVec4FFTPipelines } from './lib/webgpu-fft/fft.js';
    import { createElementStack } from './lib/element-stack.js';
    import { createZoomableAxes } from './lib/zoomable-axes.js';
    import { expandable } from './lib/expandable.js';
    import { createScaleParamsInput, createTuringSimulation } from './turing-simulation.js';
  </script>

  <script id="context" type="module">
    const { device, canvasFormat, features } = await createWebGPUContext({
      optionalFeatures: ['shader-f16', 'timestamp-query'],
      maxBufferSizes: true,
    });
    const detectedPrecision = features.has('shader-f16') ? 'f16' : 'f32';

    invalidation.then(() => device.destroy());
  </script>

  <script id="precision-input" type="module">
    // Only show f16 option if supported
    const precisionOptions = detectedPrecision === 'f16' ? ['f16', 'f32'] : ['f32'];

    const precisionInput = Inputs.radio(precisionOptions, {
      label: 'Precision',
      value: detectedPrecision
    });
    const precisionValue = view(precisionInput);
  </script>

  <script id="precision" type="module">
    const precision = precisionValue ?? detectedPrecision;

    // Bytes per float based on precision (f16=2, f32=4)
    const bytesPerFloat = precision === 'f16' ? 2 : 4;
  </script>

  <script id="N" type="module">
    const N = parseInt(NString.split('×')[0]);
  </script>

  <script id="grid-size-state" type="module">
    // Plain object to hold grid size - no dependencies, created once
    // This allows other cells to read N without depending on it
    const gridSizeState = { N: 512 };

    // Reference grid size for domain scaling
    // At N=512, shows 1 copy of pattern. At N=1024, shows 2x2 copies.
    const referenceN = 512;
  </script>

  <script id="expandable-state" type="module">
    // Persist expandable state across re-renders (e.g., when grid size changes)
    const expandableState = { expanded: false };
  </script>

  <script id="update-grid-size-state" type="module">
    N; // dependency - updates gridSizeState when N changes
    gridSizeState.N = N;
  </script>

  <script id="num-scales-input" type="module">
    const numScalesInput = Inputs.range([1, 8], {
      value: 4,
      step: 1,
      label: 'Number of scales'
    });
    const numScalesValue = view(numScalesInput);

    display(html`<div id="turing-num-scales">${numScalesInput}</div>`);
  </script>

  <script id="num-scales" type="module">
    const numScales = Math.round(numScalesValue ?? 1);
  </script>

  <script id="scale-params-input" type="module">
    numScales; // dependency

    // Get existing params from previous instance if available
    const existingScaleParams = (this?.value) || [];

    const scaleParamsInput = createScaleParamsInput(numScales, gridSizeState, existingScaleParams);
    const scaleParamsValue = view(scaleParamsInput);

    display(html`<div id="turing-scale-params">${scaleParamsInput}</div>`);
  </script>

  <script id="scale-params" type="module">
    const scaleParams = scaleParamsValue ?? [{
      activatorRadius: 2,
      inhibitorRatio: 2,
      kernelType: 0,
      amount: 0.05,
      weight: 1,
      symmetry: 1,
      color: [0.33, 0.53, 0.8]
    }];
  </script>

  <script id="button-row" type="module">
    // Randomize button - calls into scale params
    const randomizeBtn = document.createElement('button');
    randomizeBtn.textContent = 'Randomize';
    randomizeBtn.style.cssText = 'padding: 4px 8px; cursor: pointer; font-size: 12px;';
    randomizeBtn.onclick = () => {
      const scaleParamsEl = document.querySelector('#turing-scale-params .scale-params-container');
      if (scaleParamsEl?.randomize) scaleParamsEl.randomize();
    };

    // Download PNG button - will be wired up in render cell
    const downloadBtn = document.createElement('button');
    downloadBtn.id = 'turing-download-btn';
    downloadBtn.textContent = 'Download PNG';
    downloadBtn.style.cssText = 'padding: 4px 8px; cursor: pointer; font-size: 12px;';
    downloadBtn.onclick = () => {
      // This will be overwritten by the render cell once canvas is available
      if (downloadBtn._download) downloadBtn._download();
    };

    // Style the buttons
    restartButton.style.cssText = 'padding: 4px 8px; cursor: pointer; font-size: 12px;';

    display(html`<div id="turing-button-row" style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
      ${randomizeBtn}
      ${restartButton}
      ${downloadBtn}
      ${simulateInput}
      ${symmetryInput}
    </div>`);

    // Export download button for render cell to wire up
    const downloadButton = downloadBtn;
  </script>

  <script id="symmetry-column-toggle" type="module">
    symmetryEnabled; // dependency
    const container = document.querySelector('#turing-scale-params .scale-params-container');
    if (container) {
      container.classList.toggle('symmetry-hidden', !symmetryEnabled);
    }
  </script>

  <script id="figure" type="module">
    stack; axes; // dependencies (simState accessed in callback only)

    const figure = html`<figure style="margin: 0;">${stack.element}</figure>`;

    display(expandable(figure, {
      width: Math.min(width, 640),
      height: Math.min(width, 640),
      toggleOffset: [-15, -16],
      controls: [
        '#turing-num-scales',
        '#turing-scale-params',
        '#turing-button-row',
        '#turing-sim-controls',
        '#turing-display-controls'
      ],
      state: expandableState,
      onResize(el, w, h) {
        stack.resize(w, h);
        axes.updateScales(
          d3.scaleLinear().domain([0, referenceN]).range([0, w]),
          d3.scaleLinear().domain([0, referenceN]).range([h, 0])
        );
        simState.dirty = true;
      }
    }));
  </script>

  <script id="status" type="module">
    const statusEl = html`<div id="turing-status" style="font-family: monospace; font-size: 12px; color: #666;">Initializing...</div>`;
    display(statusEl);
  </script>

  <script id="grid-size-input" type="module">
    const maxWorkgroupSize = device.limits.maxComputeWorkgroupSizeX;
    const allSizes = [256, 512, 1024, 2048, 4096];
    const validSizes = allSizes.filter(n => {
      if (n <= maxWorkgroupSize) return true;
      const C = maxWorkgroupSize;
      const R = n / C;
      return Number.isInteger(R) && (R & (R - 1)) === 0;
    });

    const gridSizeOptions = validSizes.map(n => `${n}×${n}`);
    const defaultN = 512;

    const NInput = Inputs.select(gridSizeOptions, {
      value: `${defaultN}×${defaultN}`,
      label: 'Grid size'
    });
    const NString = view(NInput);
  </script>

  <script id="toggle-checkboxes" type="module">
    // Simulate checkbox
    const simulateContainer = document.createElement('label');
    simulateContainer.style.cssText = 'display: flex; align-items: center; gap: 4px; cursor: pointer; font-size: 12px;';
    const simulateCheckbox = document.createElement('input');
    simulateCheckbox.type = 'checkbox';
    simulateCheckbox.checked = true;
    simulateContainer.appendChild(simulateCheckbox);
    simulateContainer.appendChild(document.createTextNode('Simulate'));
    simulateContainer.value = true;
    simulateCheckbox.onchange = () => {
      simulateContainer.value = simulateCheckbox.checked;
      simulateContainer.dispatchEvent(new CustomEvent('input'));
    };
    const simulateValue = view(simulateContainer);

    // Symmetry checkbox
    const symmetryContainer = document.createElement('label');
    symmetryContainer.style.cssText = 'display: flex; align-items: center; gap: 4px; cursor: pointer; font-size: 12px;';
    const symmetryCheckbox = document.createElement('input');
    symmetryCheckbox.type = 'checkbox';
    symmetryCheckbox.checked = false;
    symmetryContainer.appendChild(symmetryCheckbox);
    symmetryContainer.appendChild(document.createTextNode('Symmetry'));
    symmetryContainer.value = false;
    symmetryCheckbox.onchange = () => {
      symmetryContainer.value = symmetryCheckbox.checked;
      symmetryContainer.dispatchEvent(new CustomEvent('input'));
    };
    const symmetryEnabledValue = view(symmetryContainer);

    // Export for use elsewhere
    const simulateInput = simulateContainer;
    const symmetryInput = symmetryContainer;
  </script>

  <script id="symmetry-state" type="module">
    const symmetryState = { enabled: false };
  </script>

  <script id="toggle-values" type="module">
    const simulate = simulateValue ?? true;
    const symmetryEnabled = symmetryEnabledValue ?? false;
    // Update state object without triggering downstream re-renders
    symmetryState.enabled = symmetryEnabled;
  </script>

  <script id="symmetry-dirty" type="module">
    symmetryEnabled; simState; // dependencies
    simState.dirty = true;
  </script>

  <script id="simulation-controls" type="module">
    // Custom restart button
    const restartBtn = document.createElement('button');
    restartBtn.textContent = 'Restart';
    restartBtn.style.cssText = 'padding: 4px 12px; cursor: pointer; font-size: 12px;';
    let restartCount = 0;
    restartBtn.value = restartCount;
    restartBtn.onclick = () => {
      restartBtn.value = ++restartCount;
      restartBtn.dispatchEvent(new CustomEvent('input'));
    };
    const restart = view(restartBtn);

    // Simulation config details
    const stepSizeInput = Inputs.range([0.01, 1.0], {
      value: 0.2,
      step: 0.01,
      label: 'Step size'
    });
    const stepSizeValue = view(stepSizeInput);

    const colorRateInput = Inputs.range([0.001, 0.1], {
      value: 0.02,
      step: 0.001,
      label: 'Color rate'
    });
    const colorRateValue = view(colorRateInput);

    const stepsPerFrameInput = Inputs.range([1, 20], {
      value: 1,
      step: 1,
      label: 'Steps per frame'
    });
    const stepsPerFrameValue = view(stepsPerFrameInput);

    display(html`<div id="turing-sim-controls">
      <details class="sim-config-details" open>
        <summary style="cursor: pointer; font-size: 12px;">Simulation config</summary>
        <div style="padding-left: 8px;">
          <div id="turing-grid-size">${NInput}</div>
          <div id="turing-precision">${precisionInput}</div>
          ${stepSizeInput}
          ${colorRateInput}
          ${stepsPerFrameInput}
        </div>
      </details>
    </div>`);

    // Export restart button for use in button row
    const restartButton = restartBtn;
  </script>

  <script id="sim-params" type="module">
    const stepSize = stepSizeValue ?? 0.02;
    const colorRate = colorRateValue ?? 0.01;
    const stepsPerFrame = Math.round(stepsPerFrameValue ?? 5);
  </script>

  <script id="display-controls" type="module">
    const contrastInput = Inputs.range([0, 0.99], {
      value: 0.5,
      step: 0.01,
      label: 'Contrast'
    });
    const contrastValue = view(contrastInput);

    const brightnessInput = Inputs.range([-2, 2], {
      value: -1,
      step: 0.1,
      label: 'Brightness'
    });
    const brightnessValue = view(brightnessInput);

    const gammaInput = Inputs.range([0.2, 3], {
      value: 1.0,
      step: 0.1,
      label: 'Gamma'
    });
    const gammaValue = view(gammaInput);

    const colorStrengthInput = Inputs.range([0, 4], {
      value: 1.0,
      step: 0.1,
      label: 'Color strength'
    });
    const colorStrengthValue = view(colorStrengthInput);

    const invertInput = Inputs.toggle({ label: 'Invert', value: false });
    const invertValue = view(invertInput);

    display(html`<div id="turing-display-controls">
      <details class="display-config-details">
        <summary style="cursor: pointer; font-size: 12px; margin-bottom: 8px;">Display config</summary>
        <div style="padding-left: 8px;">
          ${contrastInput}
          ${brightnessInput}
          ${gammaInput}
          ${colorStrengthInput}
          ${invertInput}
        </div>
      </details>
    </div>`);
  </script>

  <script id="display-params" type="module">
    const contrast = contrastValue ?? 0.5;
    const brightness = brightnessValue ?? 0;
    const gamma = gammaValue ?? 1.0;
    const colorStrength = colorStrengthValue ?? 0.5;
    const invert = invertValue ?? false;
  </script>

  <script id="buffers" type="module">
    N; numScales; restart; scaleParams; bytesPerFloat; precision; // dependencies

    // Buffer sizes: vec4 = 4 floats, vec2 = 2 floats (complex)
    const solutionSize = N * N * 4 * bytesPerFloat;  // vec4 per pixel
    const complexSize = N * N * 2 * bytesPerFloat;   // vec2 (complex) per pixel
    const bufferUsage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;

    // Track total GPU memory usage
    let totalGPUMemory = 0;

    const solution = [
      device.createBuffer({ label: 'Solution 0', size: solutionSize, usage: bufferUsage }),
      device.createBuffer({ label: 'Solution 1', size: solutionSize, usage: bufferUsage })
    ];
    totalGPUMemory += solutionSize * 2;

    const fhat = device.createBuffer({ label: 'fhat', size: complexSize, usage: bufferUsage });
    const fhatFreq = device.createBuffer({ label: 'fhat_freq', size: complexSize, usage: bufferUsage });
    totalGPUMemory += complexSize * 2;

    const fftTemp = [
      device.createBuffer({ label: 'FFT temp 0', size: complexSize, usage: bufferUsage }),
      device.createBuffer({ label: 'FFT temp 1', size: complexSize, usage: bufferUsage })
    ];
    totalGPUMemory += complexSize * 2;

    // Vec4 FFT buffers (for inverse FFT on convolution results)
    const vec4Size = N * N * 4 * bytesPerFloat;  // vec4 per pixel
    const vec4FftWork = device.createBuffer({ label: 'Vec4 FFT work', size: vec4Size, usage: bufferUsage | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
    const vec4FftTemp = [
      device.createBuffer({ label: 'Vec4 FFT temp 0', size: vec4Size, usage: bufferUsage }),
      device.createBuffer({ label: 'Vec4 FFT temp 1', size: vec4Size, usage: bufferUsage })
    ];
    totalGPUMemory += vec4Size * 3;

    // Create vec4 FFT pipelines for inverse FFT
    const vec4FftPipelines = createVec4FFTPipelines(device, N, device.limits.maxComputeWorkgroupSizeX, precision);

    const numScalePairs = Math.ceil(numScales / 2);
    const aiSize = numScalePairs * N * N * 4 * bytesPerFloat;  // vec4 per pixel per scale pair
    const activatorInhibitor = device.createBuffer({
      label: 'Activator/Inhibitor',
      size: aiSize,
      usage: bufferUsage
    });
    totalGPUMemory += aiSize;

    const initParamsBuffer = device.createBuffer({
      label: 'Init params',
      size: 16,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    const extractParamsBuffer = device.createBuffer({
      label: 'Extract params',
      size: 16,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    const convolveParamsBuffer = device.createBuffer({
      label: 'Convolve params',
      size: 48,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    const updateParamsBuffer = device.createBuffer({
      label: 'Update params',
      size: 32,  // vec2<u32> + u32 + 5*f32 = 32 bytes
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    const scaleParamsSize = numScales * 32;
    const scaleParamsBuffer = device.createBuffer({
      label: 'Scale params',
      size: scaleParamsSize,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    totalGPUMemory += scaleParamsSize;

    const visualizeParamsBuffer = device.createBuffer({
      label: 'Visualize params',
      size: 40,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    totalGPUMemory += 40;

    const viewInverseBuffer = device.createBuffer({
      label: 'View inverse',
      size: 64,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    totalGPUMemory += 64;

    // Uniform buffers (small, fixed size)
    totalGPUMemory += 16 + 16 + 48 + 32; // init, extract, convolve, update params

    // Helper to format bytes
    const formatBytes = (bytes) => {
      if (bytes >= 1024 * 1024 * 1024) return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
      if (bytes >= 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
      if (bytes >= 1024) return (bytes / 1024).toFixed(2) + ' KB';
      return bytes + ' B';
    };

    // Export memory info for status display
    const memoryInfo = {
      total: totalGPUMemory,
      formatted: formatBytes(totalGPUMemory),
      precision
    };
  </script>

  <script id="pipelines" type="module">
    N; precision; // dependencies

    const pipelines = await createTuringPipelines(device, canvasFormat, N, precision);
  </script>

  <script id="stack" type="module">
    canvas; ctx; // dependencies

    const dpr = window.devicePixelRatio || 1;

    function resizeCanvas(w, h) {
      const pixelW = Math.round(w * dpr);
      const pixelH = Math.round(h * dpr);
      if (canvas.width !== pixelW || canvas.height !== pixelH) {
        canvas.width = pixelW;
        canvas.height = pixelH;
        ctx.configure({ device, format: canvasFormat, alphaMode: 'opaque' });
      }
      canvas.style.width = `${w}px`;
      canvas.style.height = `${h}px`;
    }

    const initialSize = Math.min(width, 640);
    resizeCanvas(initialSize, initialSize);

    const stack = createElementStack({
      width: initialSize,
      height: initialSize,
      layers: [
        {
          id: 'canvas',
          element: ({ current, width, height }) => {
            resizeCanvas(width, height);
            return canvas;
          }
        }
      ]
    });
  </script>

  <script id="canvas" type="module">
    const canvas = document.createElement('canvas');
    canvas.id = 'turing-canvas';
    // Size will be set properly by the stack with devicePixelRatio support

    const ctx = canvas.getContext('webgpu');
    // Initial configure - will be reconfigured when stack sets the size
    canvas.width = 1;
    canvas.height = 1;
    ctx.configure({ device, format: canvasFormat, alphaMode: 'opaque' });
  </script>

  <script id="initialize" type="module">
    N; restart; solution; initParamsBuffer; pipelines; // dependencies

    const randomSeed = Math.floor(Math.random() * 0xFFFFFFFF);
    const initParams = new Uint32Array([N, N, randomSeed, 0]);
    device.queue.writeBuffer(initParamsBuffer, 0, initParams);

    const initBindGroup = device.createBindGroup({
      label: 'Initialize bind group',
      layout: pipelines.bindGroupLayouts.initialize,
      entries: [
        { binding: 0, resource: { buffer: solution[0] } },
        { binding: 1, resource: { buffer: initParamsBuffer } }
      ]
    });

    const initEncoder = device.createCommandEncoder({ label: 'Initialize encoder' });
    const initPass = initEncoder.beginComputePass({ label: 'Initialize pass' });
    initPass.setPipeline(pipelines.initialize);
    initPass.setBindGroup(0, initBindGroup);
    initPass.dispatchWorkgroups(Math.ceil(N / 16), Math.ceil(N / 16), 1);
    initPass.end();
    device.queue.submit([initEncoder.finish()]);

    // Also initialize solution[1]
    const init2BindGroup = device.createBindGroup({
      label: 'Initialize bind group 2',
      layout: pipelines.bindGroupLayouts.initialize,
      entries: [
        { binding: 0, resource: { buffer: solution[1] } },
        { binding: 1, resource: { buffer: initParamsBuffer } }
      ]
    });

    const init2Encoder = device.createCommandEncoder({ label: 'Initialize encoder 2' });
    const init2Pass = init2Encoder.beginComputePass({ label: 'Initialize pass 2' });
    init2Pass.setPipeline(pipelines.initialize);
    init2Pass.setBindGroup(0, init2BindGroup);
    init2Pass.dispatchWorkgroups(Math.ceil(N / 16), Math.ceil(N / 16), 1);
    init2Pass.end();
    device.queue.submit([init2Encoder.finish()]);
  </script>

  <script id="sim-state" type="module">
    // No dependencies - simState object is created once and never changes identity
    // This prevents downstream cells (axes, figure) from re-running on restart
    const simState = { dirty: true, solutionIndex: 0, iteration: 0 };
  </script>

  <script id="reset-sim-state" type="module">
    restart; scaleParams; // dependencies - reset when restart clicked or params changed

    // Reset simState values without changing the object identity
    simState.dirty = true;
    simState.solutionIndex = 0;
    simState.iteration = 0;
  </script>

  <script id="axes" type="module">
    stack; // dependencies (simState accessed in callbacks only)

    // Use fixed referenceN domain so view doesn't reset when grid size changes
    // scaleExtent: [0.05, 20] allows zooming out to see 20x domain (for 4096+ grids)
    const axes = createZoomableAxes({
      d3,
      element: stack.element,
      xScale: d3.scaleLinear().domain([0, referenceN]).range([0, stack.width]),
      yScale: d3.scaleLinear().domain([0, referenceN]).range([stack.height, 0]),
      aspectRatio: 1,
      scaleExtent: [0.02, 20],
      onChange: () => {
        simState.dirty = true;
      }
    });

    stack.addEventListener('update', () => { simState.dirty = true; });
  </script>

  <script id="simulation-loop" type="module">
    // Dependencies
    device; ctx; canvas; N; numScales; pipelines; bytesPerFloat;
    solution; fhat; fhatFreq; fftTemp; activatorInhibitor;
    vec4FftWork; vec4FftTemp; vec4FftPipelines;
    extractParamsBuffer; convolveParamsBuffer; updateParamsBuffer;
    scaleParamsBuffer; visualizeParamsBuffer; viewInverseBuffer;
    scaleParams; axes; simState; statusEl; symmetryState;
    stepSize; colorRate; stepsPerFrame; simulate;
    contrast; brightness; gamma; colorStrength; invert;
    memoryInfo;

    // Create simulation instance with initial params
    const simulation = createTuringSimulation({
      device,
      canvasFormat,
      ctx,
      canvas,
      pipelines,
      N,
      numScales,
      bytesPerFloat,
      referenceN,
      solution,
      fhat,
      fhatFreq,
      fftTemp,
      vec4FftWork,
      vec4FftTemp,
      vec4FftPipelines,
      activatorInhibitor,
      extractParamsBuffer,
      convolveParamsBuffer,
      updateParamsBuffer,
      scaleParamsBuffer,
      visualizeParamsBuffer,
      viewInverseBuffer,
      simState,
      symmetryState,
      statusEl,
      memoryInfo,
      axes,
      // Initial simulation params
      scaleParams,
      stepSize,
      colorRate,
      stepsPerFrame,
      simulate,
      contrast,
      brightness,
      gamma,
      colorStrength,
      invert
    });

    // Wire up download button
    const downloadBtnEl = document.querySelector('#turing-download-btn');
    if (downloadBtnEl) {
      downloadBtnEl._download = () => simulation.downloadPNG();
    }

    invalidation.then(() => simulation.dispose());
  </script>

  <script id="docs" type="text/markdown">
    ## Controls

    Each row in the scale parameters table defines a pattern scale:

    - **Activator radius (A)**: The radius of the activator kernel in pixels. Smaller radii create finer details; larger radii create broader structures.
    - **Inhibitor/Activator ratio (I/A)**: The inhibitor radius as a multiple of the activator radius. Higher ratios (e.g., 2.0) create more separation between features. Must be > 1.
    - **Kernel (K)**: Shape of the convolution kernel. Gaussian has smooth falloff; Circle has a sharp cutoff. Gaussian kernels tend to produce smoother features.
    - **Amount (Δ)**: Step size multiplier for this scale. Controls how strongly this scale influences the pattern evolution. Small values (0.01-0.1) give subtle influence; larger values dominate.
    - **Weight (W)**: Relative importance when computing pattern variation. Higher weights make a scale more likely to "win" and drive the local pattern.
    - **Symmetry (S)**: Rotational symmetry order of the kernel. 1 = no symmetry (standard Gaussian/circle), 2-8 = creates n-fold symmetric patterns like stripes (2), triangles (3), squares (4), or hexagons (6).

    Use mouse to zoom and pan the visualization. Click the expand button to view fullscreen.
  </script>

  <script id="gray-scott-equations" type="text/markdown">
    ### The Gray-Scott Model

    Reaction-diffusion can mean a lot of things. The first model I learned about--or really learned *of*, to be more precise--is the Gray-Scott model. The Gray-Scott model describes a chemical reaction between substances ${tex`u`} and ${tex`v`} which diffuse in space at different rates and react, producing an interesting landscape of complicated behaviors.

    ${tex.block`\frac{\partial u}{\partial t} = D_u \nabla^2 u - uv^2 + f(1-u)`}
    ${tex.block`\frac{\partial v}{\partial t} = D_v \nabla^2 v + uv^2 - (f+k)v`}

    In these equations, ${tex`D_u`} and ${tex`D_v`} are diffusion coefficients, ${tex`f`} is the feed rate, and ${tex`k`} is the kill rate. 

    I've been a long-term fan, in particular because the Gray-Scott model is unusually forgiving to simulate. Second order finite differences for diffusion and explicit Euler time-stepping are perfectly adequate.

    John Pearson's 1993 paper ["Complex Patterns in a Simple System"](https://arxiv.org/abs/patt-sol/9304003) maps out the parameter space and documents a remarkable variety of behaviors including self-replicating spots, traveling waves, and labyrinthine patterns. [Karl Sims has a nice tutorial](https://www.karlsims.com/rd.html) which discusses the dynamics. Below, in that style, I've implemented a simple two-dimensional version of the above PDE.
  </script>

  <script id="gray-scott-2d" type="module">
    import createREGL from 'npm:regl@2.1.1';
    import { reglCanvas } from './lib/regl-canvas.js';
    import { createGrayScott2D } from './gray-scott-2d.js';

    const w = 256;
    const h = w / 2;
    const canvas2d = reglCanvas(createREGL, {
      extensions: ['OES_texture_float'],
      attributes: { preserveDrawingBuffer: true },
      pixelRatio: 1
    });
    const regl = canvas2d.value;
    canvas2d.width = w;
    canvas2d.height = h;
    canvas2d.style.border = '1px solid #ccc';
    canvas2d.style.width = '512px';
    canvas2d.style.maxWidth = '100%';
    canvas2d.style.height = 'auto';
    canvas2d.style.aspectRatio = '2 / 1';
    canvas2d.style.cursor = 'pointer';
    canvas2d.style.boxSizing = 'border-box';

    const gsSim = createGrayScott2D(regl, { width: w, height: h });
    gsSim.restart();

    function getMouseUV(e) {
      const rect = canvas2d.getBoundingClientRect();
      return [
        (e.clientX - rect.left) / rect.width,
        1.0 - (e.clientY - rect.top) / rect.height
      ];
    }
    function getTouchUV(e) {
      const rect = canvas2d.getBoundingClientRect();
      const touch = e.touches[0];
      return [
        (touch.clientX - rect.left) / rect.width,
        1.0 - (touch.clientY - rect.top) / rect.height
      ];
    }

    canvas2d.addEventListener('mousedown', e => gsSim.setMouse(getMouseUV(e)));
    canvas2d.addEventListener('mousemove', e => { if (e.buttons & 1) gsSim.setMouse(getMouseUV(e)); });
    canvas2d.addEventListener('mouseup', () => gsSim.setMouse(null));
    canvas2d.addEventListener('mouseleave', () => gsSim.setMouse(null));
    canvas2d.addEventListener('touchstart', e => { e.preventDefault(); gsSim.setMouse(getTouchUV(e)); }, { passive: false });
    canvas2d.addEventListener('touchmove', e => { e.preventDefault(); gsSim.setMouse(getTouchUV(e)); }, { passive: false });
    canvas2d.addEventListener('touchend', () => gsSim.setMouse(null));
    canvas2d.addEventListener('touchcancel', () => gsSim.setMouse(null));

    const loop = regl.frame(() => {
      for (let j = 0; j < 10; j++) gsSim.step();
      gsSim.render();
    });

    invalidation.then(() => loop.cancel());

    const gsRestartBtn = html`<button>Restart</button>`;
    gsRestartBtn.onclick = () => gsSim.restart();
    gsRestartBtn.style.position = 'absolute';
    gsRestartBtn.style.right = '10px';
    gsRestartBtn.style.bottom = '10px';

    const gsFigure = html`<figure id="gray-scott-2d-figure" style="overflow: hidden;">
      <div style="position:relative">
        ${canvas2d}
        ${gsRestartBtn}
      </div>
      <figcaption>2D Gray-Scott reaction-diffusion. Click and drag to paint.</figcaption>
    </figure>`;

    display(gsFigure);
  </script>

  <script id="gray-scott-params" type="module">
    // Shared state for Gray-Scott parameters (allows phase diagram to update simulation)
    const gsParams = { k: 0.062, f: 0.055 };
  </script>

  <script id="gray-scott-phase-diagram" type="module">
    gsSim; // dependency - need simulation to be ready

    // Phase diagram of the Gray-Scott system from linear stability analysis
    // Saddle-node bifurcation: f = (1 ± √(1-16k))² / 16 for 0 ≤ k ≤ 1/16
    // Hopf bifurcation: v² = k at steady state, giving f = [(√k - 2k) + √(k(1 - 4√k))] / 2

    const nPoints = 100;
    const kDomain = [0, 0.08];
    const fDomain = [0, 0.14];
    const plotWidth = 340;
    const plotHeight = 280;
    const marginLeft = 50;
    const marginBottom = 40;
    const marginTop = 25;
    const marginRight = 10;

    // Saddle-node bifurcation curve
    const saddleNodeCurve = [];
    for (let i = 0; i <= nPoints; i++) {
      const k = (i / nPoints) * 0.0625;
      const disc = 1 - 16 * k;
      if (disc >= 0) {
        const fUpper = Math.pow(1 + Math.sqrt(disc), 2) / 16;
        saddleNodeCurve.push({ k, f: fUpper });
      }
    }
    for (let i = nPoints; i >= 0; i--) {
      const k = (i / nPoints) * 0.0625;
      const disc = 1 - 16 * k;
      if (disc >= 0) {
        const fLower = Math.pow(1 - Math.sqrt(disc), 2) / 16;
        saddleNodeCurve.push({ k, f: fLower });
      }
    }

    // Hopf bifurcation curve (numerical iteration)
    // At steady state: f(1-u) = uv², uv = f+k
    // Hopf condition: trace(J) = 0 → v² = k (simplified for Du >> Dv)
    // We iterate: given k, find v = √k, then solve for u and f
    const hopfCurve = [];
    const kMin = 0.015;  // Skip unstable region near origin
    for (let i = 0; i <= nPoints; i++) {
      const k = kMin + (i / nPoints) * (0.0625 - kMin);
      // Hopf condition gives v² = k
      const v = Math.sqrt(k);
      // From steady state: uv = f + k, so u = (f + k) / v
      // Also: f(1-u) = uv² = uk, so f - fu = uk, so f = u(f + k)
      // Therefore: f = u(f + k) → f(1 - u) = uk → f = uk / (1-u)
      // And from uv = f + k: u√k = uk/(1-u) + k = k(u + 1 - u)/(1-u) = k/(1-u)
      // So u = √k / (1-u) → u(1-u) = √k → u - u² = √k → u² - u + √k = 0
      // u = (1 - √(1 - 4√k)) / 2 (taking the smaller root for stability)
      const disc = 1 - 4 * Math.sqrt(k);
      if (disc >= 0) {
        const u = (1 - Math.sqrt(disc)) / 2;
        const f = u * k / (1 - u);
        // Check f is inside saddle-node region
        const snDisc = 1 - 16 * k;
        if (snDisc >= 0 && f > 0) {
          const fUpper = Math.pow(1 + Math.sqrt(snDisc), 2) / 16;
          const fLower = Math.pow(1 - Math.sqrt(snDisc), 2) / 16;
          if (f > fLower && f < fUpper) {
            hopfCurve.push({ k, f });
          }
        }
      }
    }

    // Create scales for coordinate conversion
    const xScale = d3.scaleLinear().domain(kDomain).range([marginLeft, plotWidth - marginRight]);
    const yScale = d3.scaleLinear().domain(fDomain).range([plotHeight - marginBottom, marginTop]);

    // Create base plot with both curves
    const basePlot = Plot.plot({
      width: plotWidth,
      height: plotHeight,
      marginLeft,
      marginBottom,
      marginTop,
      marginRight,
      x: { label: "k (kill rate)", domain: kDomain },
      y: { label: "f (feed rate)", domain: fDomain },
      marks: [
        // Saddle-node bifurcation curve (solid)
        Plot.line(saddleNodeCurve, { x: "k", y: "f", stroke: "#333", strokeWidth: 2 }),
        // Hopf bifurcation curve (dashed)
        Plot.line(hopfCurve, { x: "k", y: "f", stroke: "#333", strokeWidth: 1.5, strokeDasharray: "4,3" }),
        // Region labels
        Plot.text([{ k: 0.035, f: 0.023, text: "Pattern\nformation" }], {
          x: "k", y: "f", text: "text", fontSize: 10, fill: "#666",
          lineAnchor: "middle", textAnchor: "middle"
        })
      ]
    });

    // Create container with SVG overlay for draggable dot
    const container = html`<div id="phase-diagram-container" style="position: relative; width: ${plotWidth}px; height: ${plotHeight}px;">`;
    container.appendChild(basePlot);

    // Create draggable dot as an SVG overlay
    const dotSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    dotSvg.setAttribute("width", plotWidth);
    dotSvg.setAttribute("height", plotHeight);
    dotSvg.style.position = "absolute";
    dotSvg.style.top = "0";
    dotSvg.style.left = "0";
    dotSvg.style.pointerEvents = "none";

    const dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    dot.setAttribute("r", "7");
    dot.setAttribute("fill", "#e63946");
    dot.setAttribute("stroke", "rgba(255,0,0,0.2)");
    dot.setAttribute("stroke-width", "20");
    dot.style.cursor = "grab";
    dot.style.pointerEvents = "auto";
    dotSvg.appendChild(dot);
    container.appendChild(dotSvg);

    // Update dot position from params
    function updateDotPosition() {
      dot.setAttribute("cx", xScale(gsParams.k));
      dot.setAttribute("cy", yScale(gsParams.f));
    }
    updateDotPosition();

    // Dragging logic
    let isDragging = false;

    function clamp(val, min, max) {
      return Math.max(min, Math.min(max, val));
    }

    function updateFromPosition(clientX, clientY) {
      const rect = container.getBoundingClientRect();
      const x = clientX - rect.left;
      const y = clientY - rect.top;

      gsParams.k = clamp(xScale.invert(x), 0.001, 0.079);
      gsParams.f = clamp(yScale.invert(y), 0.001, 0.139);

      updateDotPosition();
      gsSim.setParams(gsParams.f, gsParams.k);
    }

    dot.addEventListener("mousedown", (e) => {
      isDragging = true;
      dot.style.cursor = "grabbing";
      e.preventDefault();
    });

    document.addEventListener("mousemove", (e) => {
      if (isDragging) {
        updateFromPosition(e.clientX, e.clientY);
      }
    });

    document.addEventListener("mouseup", () => {
      if (isDragging) {
        isDragging = false;
        dot.style.cursor = "grab";
      }
    });

    // Touch support
    dot.addEventListener("touchstart", (e) => {
      isDragging = true;
      e.preventDefault();
    }, { passive: false });

    document.addEventListener("touchmove", (e) => {
      if (isDragging && e.touches.length > 0) {
        updateFromPosition(e.touches[0].clientX, e.touches[0].clientY);
      }
    }, { passive: false });

    document.addEventListener("touchend", () => {
      isDragging = false;
    });

    // Parameter display
    const paramDisplay = html`<div id="gs-param-display" style="font-family: monospace; font-size: 11px; color: #666; margin-top: 4px;">
      k = ${gsParams.k.toFixed(4)}, f = ${gsParams.f.toFixed(4)}
    </div>`;

    // Update display periodically
    function updateDisplay() {
      paramDisplay.textContent = `k = ${gsParams.k.toFixed(4)}, f = ${gsParams.f.toFixed(4)}`;
      requestAnimationFrame(updateDisplay);
    }
    updateDisplay();

    display(html`<figure id="gray-scott-phase-figure" style="max-width: ${plotWidth}px;">
      ${container}
      ${paramDisplay}
      <figcaption style="font-size: 11px;">Phase diagram. Drag the red dot to change parameters. Inside the curve: patterns form.</figcaption>
    </figure>`);
  </script>

  <script id="hopf-derivation" type="text/markdown">
    <details>
      <summary>Derivation of the Hopf bifurcation curve</summary>

The Gray-Scott model consists of two coupled reaction-diffusion equations:

${tex.block`\frac{\partial u}{\partial t} = D_u \nabla^2 u - uv^2 + f(1-u)`}
${tex.block`\frac{\partial v}{\partial t} = D_v \nabla^2 v + uv^2 - (f+k)v`}

where ${tex`u`} and ${tex`v`} are the concentrations of two chemical species, ${tex`f`} is the feed rate, and ${tex`k`} is the kill rate.

**Steady states.** Setting the time derivatives to zero (ignoring diffusion for spatially uniform states):

${tex.block`uv^2 = f(1-u), \quad uv = f + k`}

From the second equation, ${tex`v = (f+k)/u`}. Substituting into the first:

${tex.block`u \cdot \frac{(f+k)^2}{u^2} = f(1-u) \implies (f+k)^2 = fu(1-u)`}

**Jacobian matrix.** To determine stability, we examine how small deviations ${tex`\tilde{u} = u - u^*`} and ${tex`\tilde{v} = v - v^*`} from the steady state evolve. The Jacobian matrix, formed from partial derivatives of the reaction terms evaluated at the steady state, governs this evolution:

${tex.block`J = \begin{pmatrix} \partial_u(-uv^2 + f(1-u)) & \partial_v(-uv^2 + f(1-u)) \\ \partial_u(uv^2 - (f+k)v) & \partial_v(uv^2 - (f+k)v) \end{pmatrix}`}

${tex.block`\phantom{J} = \begin{pmatrix} -v^2 - f & -2uv \\ v^2 & 2uv - (f+k) \end{pmatrix}`}

Using ${tex`uv = f+k`} at steady state, the element ${tex`J_{22} = 2(f+k) - (f+k) = f+k`}.

**Hopf bifurcation condition.** The eigenvalues of ${tex`J`} determine stability. For a 2×2 matrix, ${tex`\lambda = \tfrac{1}{2}(\text{Tr} \pm \sqrt{\text{Tr}^2 - 4\det})`}. When ${tex`\det > 0`} and ${tex`\text{Tr} < 0`}, both eigenvalues have negative real parts. These eigenvalues dictate growth and decay of perturbations, so negative real parts means perturbations decay and the steady state is stable. When ${tex`\text{Tr} > 0`}, perturbations grow exponentially.

The boundary ${tex`\text{Tr} = 0`} (with ${tex`\det > 0`}) marks a *Hopf bifurcation*: the eigenvalues become purely imaginary, and the system transitions from stable equilibrium to sustained oscillations. Setting ${tex`\text{Tr}(J) = J_{11} + J_{22} = 0`}:

${tex.block`(-v^2 - f) + (f + k) = 0 \implies v^2 = k`}

So at the Hopf bifurcation, ${tex`v = \sqrt{k}`}.

**Solving for the curve.** Combining ${tex`v = \sqrt{k}`} with the steady-state condition ${tex`uv = f+k`}:

${tex.block`u\sqrt{k} = f + k`}

From ${tex`f(1-u) = uv^2 = uk`}, we get ${tex`f = uk/(1-u)`}. Substituting:

${tex.block`u\sqrt{k} = \frac{uk}{1-u} + k = \frac{uk + k(1-u)}{1-u} = \frac{k}{1-u}`}

Therefore ${tex`u(1-u) = \sqrt{k}`}, giving the quadratic:

${tex.block`u^2 - u + \sqrt{k} = 0`}

Solving: ${tex`u = \frac{1 - \sqrt{1 - 4\sqrt{k}}}{2}`} (taking the smaller root for stability).

Finally, ${tex`f = uk/(1-u)`} gives the Hopf curve parametrized by ${tex`k`}.

**Saddle-node bifurcation.** The solid curve marks where non-trivial steady states exist. Recall the steady-state condition ${tex`(f+k)^2 = fu(1-u)`}. Viewing this as a quadratic in ${tex`u`}, solutions exist only when the discriminant is non-negative: ${tex`f^2 - 4f(f+k)^2 \geq 0`}. The boundary where this discriminant equals zero gives the saddle-node curve ${tex`f = \tfrac{1}{16}(1 \pm \sqrt{1-16k})^2`}. Outside this curve, only the trivial state ${tex`(u,v) = (1,0)`} exists. Inside, a second steady state with ${tex`v > 0`} appears.

**Interpreting the phase diagram.** Outside the dashed Hopf curve, the system settles to a spatially uniform state (no patterns). Inside the dashed curve, the uniform state becomes unstable, and small perturbations grow into the spots and stripes we observe.

    </details>
  </script>

  <script id="mechanism-intro" type="text/markdown">
    ## The activator-inhibitor model

    As interesting as the Gray-Scott model is, we can isolate dynamics of striped and spotted patterns with a simpler *activator-inhibitor* model. The idea, proposed by Alan Turing in 1952, is that two interacting substances with different diffusion rates can spontaneously break spatial symmetry. The key ingredients are:

    1. A slowly-diffusing **activator** that promotes its own growth
    2. A faster-diffusing **inhibitor** that suppresses the activator

    Consider a small bump in the concentration field. The activator, diffusing slowly, remains concentrated near the bump and reinforces local growth. The inhibitor diffuses faster, spreading outward before it can fully suppress the peak. But once the inhibitor reaches the surrounding region, it dominates there, preventing the bump from spreading. The result is a sharpening instability: peaks grow while their surroundings are suppressed, creating the characteristic spacing of Turing patterns.

  </script>

  <script id="gaussian-figure" type="module">
    const sigma_a = 1;
    const sigma_i = 2;
    const xs = d3.range(-6, 6.01, 0.05);

    const gaussianKernel = (x, sigma) => Math.exp(-x * x / (2 * sigma * sigma));

    const activatorData = xs.map(x => ({ x, y: 0.6 * gaussianKernel(x, sigma_a), type: "activator" }));
    const inhibitorData = xs.map(x => ({ x, y: -0.4 * gaussianKernel(x, sigma_i), type: "inhibitor" }));
    const differenceData = xs.map(x => ({
      x,
      y: 0.6 * gaussianKernel(x, sigma_a) - 0.4 * gaussianKernel(x, sigma_i),
      type: "difference"
    }));

    const gaussianPlot = Plot.plot({
      width: 500,
      height: 280,
      marginLeft: 50,
      marginBottom: 35,
      x: { label: "Position", domain: [-5, 5] },
      y: { label: null, domain: [-0.5, 0.8] },
      color: {
        domain: ["activator", "inhibitor", "difference"],
        range: ["#2563eb", "#dc2626", "#16a34a"]
      },
      marks: [
        Plot.ruleY([0], { stroke: "#999", strokeWidth: 1 }),
        Plot.line(activatorData, { x: "x", y: "y", stroke: "type", strokeWidth: 2, curve: "natural" }),
        Plot.line(inhibitorData, { x: "x", y: "y", stroke: "type", strokeWidth: 2, curve: "natural" }),
        Plot.line(differenceData, { x: "x", y: "y", stroke: "type", strokeWidth: 2.5, strokeDasharray: "6,3", curve: "natural" }),
        Plot.text([{ x: 2.8, y: 0.52, text: "Activator (narrow)" }], { x: "x", y: "y", text: "text", fill: "#2563eb", fontSize: 12, fontWeight: 500 }),
        Plot.text([{ x: 3.2, y: -0.32, text: "Inhibitor (wide)" }], { x: "x", y: "y", text: "text", fill: "#dc2626", fontSize: 12, fontWeight: 500 }),
        Plot.text([{ x: -3.2, y: 0.35, text: "Difference (update)" }], { x: "x", y: "y", text: "text", fill: "#16a34a", fontSize: 12, fontWeight: 500 })
      ]
    });

    display(html`<figure id="gaussian-mechanism-figure" style="max-width: 500px;">
      ${gaussianPlot}
      <figcaption>The narrow activator (blue) responds strongly to the peak while the wide inhibitor (red) averages over a broader region. Their difference (green dashed) drives the update: positive at the center, negative at the flanks.</figcaption>
    </figure>`);
  </script>

  <script id="cell-80" type="text/markdown">
    The figure below illustrates this with Gaussian kernels of different widths standing in for the activator and inhibitor influence. The narrow activator kernel responds strongly to the peak, while the wider inhibitor kernel averages over a broader region. Their difference drives the update: positive at the center, negative at the flanks.
  </script>

  <script id="single-scale-turing" type="text/markdown">
    ### 1D Turing pattern model

    The simulation below implements the activator-inhibitor model in one dimension. We maintain a scalar field and use the [Fast Fourier Transform](https://en.wikipedia.org/wiki/Fast_Fourier_transform) (FFT) to repeatedly convolve it with two Gaussian kernels: a narrow activator and a wider inhibitor. At each step, we add the difference to the field, then apply an ${tex`\arctan`} function to keep values bounded.

    The ratio of inhibitor to activator width determines the characteristic spacing of the pattern. A 2:1 ratio creates tight spacing; larger ratios spread the features further apart. Try adjusting the activator radius to see how it affects the emerging pattern. The colored bars below the simulation show the relative widths of the activator (blue) and inhibitor (red) kernels.
  </script>

  <script id="activator-input" type="module">
    // Shared slider - will be bound to 2D slider
    const activatorInput = Inputs.range([2, 25], {
      value: 15,
      step: 0.1,
      label: 'Activator radius'
    });
  </script>

  <script id="turing-1d-simulation" type="module">
    import { createTuring1D } from './turing-1d.js';

    const turing1dN = 256;  // Grid resolution (displayed at 2x for 0.5 pixel ratio)
    const turing1dStepSize = 0.5;
    const turing1dToneMapRange = 1.0;
    const turing1dInhibitorRatio = 2;

    const turingSim = createTuring1D(turing1dN);
    turingSim.initialize();
    turingSim.setKernels(15, turing1dInhibitorRatio);

    // Use the shared slider
    activatorInput.addEventListener('input', () => {
      turingSim.setKernels(activatorInput.value, turing1dInhibitorRatio);
    });

    const turingCanvas = document.createElement('canvas');
    turingCanvas.id = 'turing-1d-canvas';
    turingCanvas.width = turing1dN;
    turingCanvas.height = 75;  // Half height to match 0.5 pixel ratio
    turingCanvas.style.width = '512px';
    turingCanvas.style.maxWidth = '100%';
    turingCanvas.style.height = 'auto';
    turingCanvas.style.aspectRatio = '512 / 150';
    turingCanvas.style.border = '1px solid #ccc';
    turingCanvas.style.cursor = 'crosshair';

    const turingCtx = turingCanvas.getContext('2d');

    // Mouse/touch interaction for painting
    function getMouseX(e) {
      const rect = turingCanvas.getBoundingClientRect();
      return (e.clientX - rect.left) / rect.width;
    }
    function getTouchX(e) {
      const rect = turingCanvas.getBoundingClientRect();
      return (e.touches[0].clientX - rect.left) / rect.width;
    }
    turingCanvas.addEventListener('mousedown', e => turingSim.setMouse(getMouseX(e)));
    turingCanvas.addEventListener('mousemove', e => { if (e.buttons & 1) turingSim.setMouse(getMouseX(e)); });
    turingCanvas.addEventListener('mouseup', () => turingSim.setMouse(null));
    turingCanvas.addEventListener('mouseleave', () => turingSim.setMouse(null));
    turingCanvas.addEventListener('touchstart', e => { e.preventDefault(); turingSim.setMouse(getTouchX(e)); }, { passive: false });
    turingCanvas.addEventListener('touchmove', e => { e.preventDefault(); turingSim.setMouse(getTouchX(e)); }, { passive: false });
    turingCanvas.addEventListener('touchend', () => turingSim.setMouse(null));
    turingCanvas.addEventListener('touchcancel', () => turingSim.setMouse(null));

    const turing1dRestartBtn = html`<button style="position: absolute; right: 10px; bottom: 10px;">Restart</button>`;
    turing1dRestartBtn.onclick = () => {
      turingSim.initialize();
      turingSim.setKernels(activatorInput.value, turing1dInhibitorRatio);
    };

    const kernelIndicator = html`<div id="kernel-indicator-1d" style="display: flex; flex-direction: column; gap: 4px; margin-top: 8px; font-size: 11px; font-family: sans-serif;">
      <div style="display: flex; align-items: center; gap: 8px;">
        <span style="width: 80px; text-align: right; color: #2563eb;">Activator</span>
        <div id="activator-bar-1d" style="height: 8px; background: #2563eb; border-radius: 2px;"></div>
      </div>
      <div style="display: flex; align-items: center; gap: 8px; position: relative;">
        <span style="width: 80px; text-align: right; color: #dc2626;">Inhibitor (2×)</span>
        <div id="inhibitor-bar-1d" style="height: 8px; background: #dc2626; border-radius: 2px;"></div>
        <svg id="drag-handle-1d" style="position: absolute; left: 88px; top: 50%; transform: translateY(-50%); overflow: visible; pointer-events: none;" width="10" height="10">
          <circle id="drag-dot-1d" cx="0" cy="5" r="8" fill="#e63946" stroke="rgba(255,0,0,0.15)" stroke-width="36" style="cursor: grab; pointer-events: auto;" />
        </svg>
      </div>
    </div>`;

    const plotCanvas = document.createElement('canvas');
    plotCanvas.id = 'turing-1d-plot';
    const plotDpr = window.devicePixelRatio || 1;
    plotCanvas.width = 512 * plotDpr;
    plotCanvas.height = 120 * plotDpr;
    plotCanvas.style.width = '512px';
    plotCanvas.style.maxWidth = '100%';
    plotCanvas.style.height = 'auto';
    plotCanvas.style.aspectRatio = '512 / 120';
    plotCanvas.style.display = 'block';
    const plotCtx = plotCanvas.getContext('2d');
    plotCtx.scale(plotDpr, plotDpr);

    display(html`<figure>
      <div style="position: relative;">
        ${turingCanvas}
        ${turing1dRestartBtn}
      </div>
      ${plotCanvas}
      ${kernelIndicator}
      <figcaption style="font-size: 12px; color: #666; margin-top: 8px;">Single-scale Turing pattern. Drag the red dot to adjust kernel size. The plot shows the activator (blue) and negated inhibitor (red) convolutions, with their difference (green dashed).</figcaption>
    </figure>`);

    // Check if initially visible
    const rect = turingCanvas.getBoundingClientRect();
    let isVisible = rect.top < window.innerHeight && rect.bottom > 0;
    const visibilityObserver = new IntersectionObserver((entries) => {
      isVisible = entries[0].isIntersecting;
    }, { threshold: 0.01 });
    visibilityObserver.observe(turingCanvas);

    const activatorBar1D = document.getElementById('activator-bar-1d');
    const inhibitorBar1D = document.getElementById('inhibitor-bar-1d');
    const dragHandle1D = document.getElementById('drag-handle-1d');
    const dragDot1D = document.getElementById('drag-dot-1d');

    function updateKernelIndicator() {
      const canvasWidth = turingCanvas.getBoundingClientRect().width;
      const scale = canvasWidth / turing1dN;
      const radius = activatorInput.value;
      const inhibitorWidth = radius * turing1dInhibitorRatio * 2 * scale;
      activatorBar1D.style.width = (radius * 2 * scale) + 'px';
      inhibitorBar1D.style.width = inhibitorWidth + 'px';
      dragHandle1D.style.left = (88 + inhibitorWidth) + 'px';
    }
    updateKernelIndicator();
    activatorInput.addEventListener('input', updateKernelIndicator);

    const resizeObserver = new ResizeObserver(() => updateKernelIndicator());
    resizeObserver.observe(turingCanvas);

    // Drag handling for kernel size
    let isDragging1D = false;
    dragDot1D.addEventListener('mousedown', (e) => {
      isDragging1D = true;
      dragDot1D.style.cursor = 'grabbing';
      e.preventDefault();
    });
    document.addEventListener('mousemove', (e) => {
      if (!isDragging1D) return;
      const indicatorRect = kernelIndicator.getBoundingClientRect();
      const canvasWidth = turingCanvas.getBoundingClientRect().width;
      const scale = canvasWidth / turing1dN;
      const x = e.clientX - indicatorRect.left - 88; // 88px = label width + gap
      const inhibitorWidth = Math.max(20, Math.min(canvasWidth, x));
      const radius = inhibitorWidth / (turing1dInhibitorRatio * 2 * scale);
      const clampedRadius = Math.max(2, Math.min(25, radius));
      activatorInput.value = clampedRadius;
      activatorInput.dispatchEvent(new Event('input'));
      turingSim.setKernels(clampedRadius, turing1dInhibitorRatio);
    });
    document.addEventListener('mouseup', () => {
      if (isDragging1D) {
        isDragging1D = false;
        dragDot1D.style.cursor = 'grab';
      }
    });
    // Touch support
    dragDot1D.addEventListener('touchstart', (e) => {
      isDragging1D = true;
      e.preventDefault();
    }, { passive: false });
    document.addEventListener('touchmove', (e) => {
      if (!isDragging1D || !e.touches.length) return;
      const indicatorRect = kernelIndicator.getBoundingClientRect();
      const canvasWidth = turingCanvas.getBoundingClientRect().width;
      const scale = canvasWidth / turing1dN;
      const x = e.touches[0].clientX - indicatorRect.left - 88;
      const inhibitorWidth = Math.max(20, Math.min(canvasWidth, x));
      const radius = inhibitorWidth / (turing1dInhibitorRatio * 2 * scale);
      const clampedRadius = Math.max(2, Math.min(25, radius));
      activatorInput.value = clampedRadius;
      activatorInput.dispatchEvent(new Event('input'));
      turingSim.setKernels(clampedRadius, turing1dInhibitorRatio);
    }, { passive: false });
    document.addEventListener('touchend', () => { isDragging1D = false; });

    function updatePlot() {
      // Use CSS pixel dimensions since context is scaled by plotDpr
      const w = 512;
      const h = 120;
      const scaleX = w / turing1dN;
      const scaleY = h / 2;  // Map [-1, 1] to [h, 0]

      plotCtx.fillStyle = '#fff';
      plotCtx.fillRect(0, 0, w, h);

      // Zero line
      plotCtx.strokeStyle = '#ccc';
      plotCtx.lineWidth = 1;
      plotCtx.beginPath();
      plotCtx.moveTo(0, h / 2);
      plotCtx.lineTo(w, h / 2);
      plotCtx.stroke();

      // Helper to draw a line
      function drawLine(data, color, dashed = false) {
        plotCtx.strokeStyle = color;
        plotCtx.lineWidth = 1.5;
        plotCtx.setLineDash(dashed ? [6, 4] : []);
        plotCtx.beginPath();
        for (let i = 0; i < turing1dN; i++) {
          const x = i * scaleX;
          const y = h / 2 - data[i] * scaleY;
          if (i === 0) plotCtx.moveTo(x, y);
          else plotCtx.lineTo(x, y);
        }
        plotCtx.stroke();
        plotCtx.setLineDash([]);
      }

      drawLine(turingSim.activator, '#2563eb');

      // Negate inhibitor for display
      const negInhibitor = new Float64Array(turing1dN);
      for (let i = 0; i < turing1dN; i++) negInhibitor[i] = -turingSim.inhibitor[i];
      drawLine(negInhibitor, '#dc2626');

      // Difference (activator - inhibitor) as dashed line
      const diff = new Float64Array(turing1dN);
      for (let i = 0; i < turing1dN; i++) diff[i] = turingSim.activator[i] - turingSim.inhibitor[i];
      drawLine(diff, '#16a34a', true);
    }

    let turing1dAnimationId;
    function animate() {
      if (isVisible) {
        turingSim.step(turing1dStepSize, turing1dToneMapRange);
        turingSim.render(turingCtx, turingCanvas.width, turingCanvas.height);
        updatePlot();
      }
      turing1dAnimationId = requestAnimationFrame(animate);
    }
    animate();

    invalidation.then(() => {
      cancelAnimationFrame(turing1dAnimationId);
      visibilityObserver.disconnect();
      resizeObserver.disconnect();
    });
  </script>

  <script id="turing-2d-intro" type="text/markdown">
    ### 2D Turing pattern model

    The same dynamics work in two dimensions. Below is a WebGPU implementation using FFT-based convolution on a 256×256 grid.
  </script>

  <script id="turing-2d-simulation" type="module">
    import { createTuring2D } from './turing-2d.js';

    if (!isWebGPUAvailable()) {
      display(html`<div style="color: #666; padding: 12px; border: 1px solid #ccc; background: #f9f9f9; border-radius: 4px; font-size: 13px;">WebGPU is not available.</div>`);
    } else {
      const { device: turing2dDevice, canvasFormat: turing2dCanvasFormat } = await createWebGPUContext();

      const turing2dN = 256;
        const turing2dStepSize = 0.5;
        const turing2dToneMapRange = 1.0;
        const turing2dInhibitorRatio = 2;

        const turing2dSim = createTuring2D(turing2dDevice, {
          width: turing2dN,
          height: turing2dN,
          activatorRadius: 15,
          inhibitorRatio: turing2dInhibitorRatio,
          stepSize: turing2dStepSize,
          toneMapRange: turing2dToneMapRange,
        });

        turing2dSim.initialize();

        // Slider for 2D simulation, bound to the 1D slider
        const activatorInput2D = Inputs.range([2, 25], {
          value: activatorInput.value,
          step: 0.1,
          label: 'Activator radius'
        });
        Inputs.bind(activatorInput2D, activatorInput, invalidation);

        const turing2dCanvas = document.createElement('canvas');
        turing2dCanvas.id = 'turing-2d-canvas';
        turing2dCanvas.width = turing2dN;
        turing2dCanvas.height = turing2dN;
        turing2dCanvas.style.width = '512px';
        turing2dCanvas.style.maxWidth = '100%';
        turing2dCanvas.style.height = 'auto';
        turing2dCanvas.style.aspectRatio = '1 / 1';
        turing2dCanvas.style.border = '1px solid #ccc';
        turing2dCanvas.style.cursor = 'crosshair';

        const turing2dCtx = turing2dCanvas.getContext('webgpu');
        turing2dCtx.configure({ device: turing2dDevice, format: turing2dCanvasFormat, alphaMode: 'opaque' });

        const turing2dRenderer = turing2dSim.createRenderer(turing2dCanvasFormat);

        // Mouse/touch interaction for painting
        function getMouseUV(e) {
          const rect = turing2dCanvas.getBoundingClientRect();
          return [
            (e.clientX - rect.left) / rect.width,
            (e.clientY - rect.top) / rect.height  // Y not flipped - buffer y=0 is at top
          ];
        }
        function getTouchUV(e) {
          const rect = turing2dCanvas.getBoundingClientRect();
          const touch = e.touches[0];
          return [
            (touch.clientX - rect.left) / rect.width,
            (touch.clientY - rect.top) / rect.height
          ];
        }
        turing2dCanvas.addEventListener('mousedown', e => turing2dSim.setMouse(getMouseUV(e)));
        turing2dCanvas.addEventListener('mousemove', e => { if (e.buttons & 1) turing2dSim.setMouse(getMouseUV(e)); });
        turing2dCanvas.addEventListener('mouseup', () => turing2dSim.setMouse(null));
        turing2dCanvas.addEventListener('mouseleave', () => turing2dSim.setMouse(null));
        turing2dCanvas.addEventListener('touchstart', e => { e.preventDefault(); turing2dSim.setMouse(getTouchUV(e)); }, { passive: false });
        turing2dCanvas.addEventListener('touchmove', e => { e.preventDefault(); turing2dSim.setMouse(getTouchUV(e)); }, { passive: false });
        turing2dCanvas.addEventListener('touchend', () => turing2dSim.setMouse(null));
        turing2dCanvas.addEventListener('touchcancel', () => turing2dSim.setMouse(null));

        const turing2dRestartBtn = html`<button style="position: absolute; right: 10px; bottom: 10px;">Restart</button>`;
        turing2dRestartBtn.onclick = () => {
          turing2dSim.setKernels(activatorInput2D.value, turing2dInhibitorRatio);
          turing2dSim.initialize();
        };

        const kernelIndicator2D = html`<div id="kernel-indicator-2d" style="display: flex; flex-direction: column; gap: 4px; margin-top: 8px; font-size: 11px; font-family: sans-serif;">
          <div style="display: flex; align-items: center; gap: 8px;">
            <span style="width: 80px; text-align: right; color: #2563eb;">Activator</span>
            <div id="activator-bar-2d" style="height: 8px; background: #2563eb; border-radius: 2px;"></div>
          </div>
          <div style="display: flex; align-items: center; gap: 8px; position: relative;">
            <span style="width: 80px; text-align: right; color: #dc2626;">Inhibitor (2×)</span>
            <div id="inhibitor-bar-2d" style="height: 8px; background: #dc2626; border-radius: 2px;"></div>
            <svg id="drag-handle-2d" style="position: absolute; left: 88px; top: 50%; transform: translateY(-50%); overflow: visible; pointer-events: none;" width="10" height="10">
              <circle id="drag-dot-2d" cx="0" cy="5" r="8" fill="#e63946" stroke="rgba(255,0,0,0.15)" stroke-width="36" style="cursor: grab; pointer-events: auto;" />
            </svg>
          </div>
        </div>`;

        display(html`<figure id="turing-2d-figure">
          <div style="position: relative; display: inline-block;">
            ${turing2dCanvas}
            ${turing2dRestartBtn}
          </div>
          ${kernelIndicator2D}
          <figcaption style="font-size: 12px; color: #666; margin-top: 8px;">2D single-scale Turing pattern. Drag the red dot to adjust kernel size.</figcaption>
        </figure>`);

        const activatorBar2D = document.getElementById('activator-bar-2d');
        const inhibitorBar2D = document.getElementById('inhibitor-bar-2d');
        const dragHandle2D = document.getElementById('drag-handle-2d');
        const dragDot2D = document.getElementById('drag-dot-2d');

        function updateKernelIndicator2D() {
          const canvasWidth = turing2dCanvas.getBoundingClientRect().width;
          const scale = canvasWidth / turing2dN;
          const radius = activatorInput2D.value;
          const inhibitorWidth = radius * turing2dInhibitorRatio * 2 * scale;
          activatorBar2D.style.width = (radius * 2 * scale) + 'px';
          inhibitorBar2D.style.width = inhibitorWidth + 'px';
          dragHandle2D.style.left = (88 + inhibitorWidth) + 'px';
        }
        updateKernelIndicator2D();

        activatorInput2D.addEventListener('input', () => {
          turing2dSim.setKernels(activatorInput2D.value, turing2dInhibitorRatio);
          updateKernelIndicator2D();
        });
        // Also listen to the first slider (Inputs.bind syncs values but not events)
        activatorInput.addEventListener('input', () => {
          turing2dSim.setKernels(activatorInput.value, turing2dInhibitorRatio);
          updateKernelIndicator2D();
        });

        const turing2dResizeObserver = new ResizeObserver(() => updateKernelIndicator2D());
        turing2dResizeObserver.observe(turing2dCanvas);

        // Drag handling for 2D kernel size
        let isDragging2D = false;
        dragDot2D.addEventListener('mousedown', (e) => {
          isDragging2D = true;
          dragDot2D.style.cursor = 'grabbing';
          e.preventDefault();
        });
        document.addEventListener('mousemove', (e) => {
          if (!isDragging2D) return;
          const indicatorRect = kernelIndicator2D.getBoundingClientRect();
          const canvasWidth = turing2dCanvas.getBoundingClientRect().width;
          const scale = canvasWidth / turing2dN;
          const x = e.clientX - indicatorRect.left - 88;
          const inhibitorWidth = Math.max(20, Math.min(canvasWidth, x));
          const radius = inhibitorWidth / (turing2dInhibitorRatio * 2 * scale);
          const clampedRadius = Math.max(2, Math.min(25, radius));
          activatorInput2D.value = clampedRadius;
          activatorInput.value = clampedRadius;
          activatorInput.dispatchEvent(new Event('input'));
          turing2dSim.setKernels(clampedRadius, turing2dInhibitorRatio);
          updateKernelIndicator2D();
        });
        document.addEventListener('mouseup', () => {
          if (isDragging2D) {
            isDragging2D = false;
            dragDot2D.style.cursor = 'grab';
          }
        });
        // Touch support
        dragDot2D.addEventListener('touchstart', (e) => {
          isDragging2D = true;
          e.preventDefault();
        }, { passive: false });
        document.addEventListener('touchmove', (e) => {
          if (!isDragging2D || !e.touches.length) return;
          const indicatorRect = kernelIndicator2D.getBoundingClientRect();
          const canvasWidth = turing2dCanvas.getBoundingClientRect().width;
          const scale = canvasWidth / turing2dN;
          const x = e.touches[0].clientX - indicatorRect.left - 88;
          const inhibitorWidth = Math.max(20, Math.min(canvasWidth, x));
          const radius = inhibitorWidth / (turing2dInhibitorRatio * 2 * scale);
          const clampedRadius = Math.max(2, Math.min(25, radius));
          activatorInput2D.value = clampedRadius;
          activatorInput.value = clampedRadius;
          activatorInput.dispatchEvent(new Event('input'));
          turing2dSim.setKernels(clampedRadius, turing2dInhibitorRatio);
          updateKernelIndicator2D();
        }, { passive: false });
        document.addEventListener('touchend', () => { isDragging2D = false; });

        // Check if initially visible
        const rect2d = turing2dCanvas.getBoundingClientRect();
        let turing2dIsVisible = rect2d.top < window.innerHeight && rect2d.bottom > 0;
        const turing2dVisibilityObserver = new IntersectionObserver((entries) => {
          turing2dIsVisible = entries[0].isIntersecting;
        }, { threshold: 0.01 });
        turing2dVisibilityObserver.observe(turing2dCanvas);

        let turing2dAnimationId;
        function animate() {
          if (turing2dIsVisible) {
            turing2dSim.step();
            turing2dRenderer.render(turing2dCtx.getCurrentTexture().createView());
          }
          turing2dAnimationId = requestAnimationFrame(animate);
        }
        animate();

      invalidation.then(() => {
        cancelAnimationFrame(turing2dAnimationId);
        turing2dVisibilityObserver.disconnect();
        turing2dResizeObserver.disconnect();
        turing2dSim.destroy();
        turing2dDevice.destroy();
      });
    }
  </script>

  <script id="multiscale-extension" type="text/markdown">
    ## Extension to Multiple Scales

    The single-scale algorithm produces patterns with a characteristic wavelength determined by the kernel ratio. To create the rich, nested structures of true multiscale Turing patterns, we run multiple scales simultaneously and let them compete.

    At each point in the field, we compute activator and inhibitor values for several scales. Each scale proposes an update direction based on the sign of its ${tex`(a - b)`} difference. The question is which scale should "win" at each location.

    The answer comes from looking at the magnitude ${tex`|a - b|`} at each scale. Where this variation is small, the field is already near equilibrium for that scale—further updates would create excessive local contrast. Where variation is large, the scale has strong opinions about which direction to push.

    The algorithm selects the scale with minimum variation at each point and steps in the direction that scale indicates. The effect is that coarse scales dominate in regions where fine scales would fight against each other, while fine scales fill in details where coarse scales have nothing to say. The result is a hierarchy of nested patterns spanning the full range of scales.
  </script>

  <script id="two-scale-intro" type="text/markdown">
    ## Two-Scale Demo

    The simulation below demonstrates this scale-selection logic with just two scales: a fine scale and a coarse scale. Each scale computes its own activator-inhibitor difference, and at each pixel the scale with minimum ${tex`|a - b|`} controls the update direction.

    Check "Show scale selection" to visualize which scale wins at each location. Blue regions are controlled by the fine scale, orange by the coarse scale. 
  </script>

  <script id="two-scale-simulation" type="module">
    import { createTuring2Scale } from './turing-2scale.js';

    if (!isWebGPUAvailable()) {
      display(html`<div style="color: #666; padding: 12px; border: 1px solid #ccc; background: #f9f9f9; border-radius: 4px; font-size: 13px;">WebGPU is not available.</div>`);
    } else {
      const { device: twoScaleDevice, canvasFormat: twoScaleCanvasFormat } = await createWebGPUContext();

      const twoScaleN = 256;

        const twoScaleSim = createTuring2Scale(twoScaleDevice, {
          width: twoScaleN,
          height: twoScaleN,
          activatorRadius1: 2,
          inhibitorRatio1: 2,
          activatorRadius2: 25,
          inhibitorRatio2: 2,
          stepSize: 0.005,
          toneMapRange: 1.0,
        });

        twoScaleSim.initialize();

        const twoScaleCanvas = document.createElement('canvas');
        twoScaleCanvas.id = 'turing-2scale-canvas';
        twoScaleCanvas.width = twoScaleN;
        twoScaleCanvas.height = twoScaleN;
        twoScaleCanvas.style.width = '512px';
        twoScaleCanvas.style.maxWidth = '100%';
        twoScaleCanvas.style.height = 'auto';
        twoScaleCanvas.style.aspectRatio = '1 / 1';
        twoScaleCanvas.style.border = '1px solid #ccc';
        twoScaleCanvas.style.cursor = 'crosshair';

        const twoScaleCtx = twoScaleCanvas.getContext('webgpu');
        twoScaleCtx.configure({ device: twoScaleDevice, format: twoScaleCanvasFormat, alphaMode: 'opaque' });

        const twoScaleRenderer = twoScaleSim.createRenderer(twoScaleCanvasFormat);

        // Mouse/touch interaction
        function getMouseUV(e) {
          const rect = twoScaleCanvas.getBoundingClientRect();
          return [
            (e.clientX - rect.left) / rect.width,
            (e.clientY - rect.top) / rect.height
          ];
        }
        function getTouchUV(e) {
          const rect = twoScaleCanvas.getBoundingClientRect();
          const touch = e.touches[0];
          return [
            (touch.clientX - rect.left) / rect.width,
            (touch.clientY - rect.top) / rect.height
          ];
        }
        twoScaleCanvas.addEventListener('mousedown', e => twoScaleSim.setMouse(getMouseUV(e)));
        twoScaleCanvas.addEventListener('mousemove', e => { if (e.buttons & 1) twoScaleSim.setMouse(getMouseUV(e)); });
        twoScaleCanvas.addEventListener('mouseup', () => twoScaleSim.setMouse(null));
        twoScaleCanvas.addEventListener('mouseleave', () => twoScaleSim.setMouse(null));
        twoScaleCanvas.addEventListener('touchstart', e => { e.preventDefault(); twoScaleSim.setMouse(getTouchUV(e)); }, { passive: false });
        twoScaleCanvas.addEventListener('touchmove', e => { e.preventDefault(); twoScaleSim.setMouse(getTouchUV(e)); }, { passive: false });
        twoScaleCanvas.addEventListener('touchend', () => twoScaleSim.setMouse(null));
        twoScaleCanvas.addEventListener('touchcancel', () => twoScaleSim.setMouse(null));

        const twoScaleRestartBtn = html`<button style="position: absolute; right: 10px; bottom: 10px;">Restart</button>`;
        twoScaleRestartBtn.onclick = () => twoScaleSim.initialize();

        // Scale tint checkbox
        const tintCheckbox = html`<label style="display: flex; align-items: center; gap: 6px; font-size: 12px; cursor: pointer;">
          <input type="checkbox" id="scale-tint-checkbox" checked>
          Show scale selection
        </label>`;
        const twoScaleCheckbox = tintCheckbox.querySelector('input');
        twoScaleCheckbox.onchange = () => twoScaleSim.setShowScaleTint(twoScaleCheckbox.checked);

        // Kernel indicators
        const twoScaleKernelIndicator = html`<div id="kernel-indicator-2scale" style="display: flex; flex-direction: column; gap: 4px; margin-top: 8px; font-size: 11px; font-family: sans-serif;">
          <div style="display: flex; align-items: center; gap: 8px;">
            <span style="width: 100px; text-align: right; color: #3b82f6;">Fine scale (A≈3)</span>
            <div style="height: 8px; background: #3b82f6; border-radius: 2px; width: 12px;"></div>
            <div style="height: 8px; background: #93c5fd; border-radius: 2px; width: 24px;"></div>
            <span style="color: #666; font-size: 10px;">activator / inhibitor</span>
          </div>
          <div style="display: flex; align-items: center; gap: 8px;">
            <span style="width: 100px; text-align: right; color: #f97316;">Coarse scale (A≈20)</span>
            <div style="height: 8px; background: #f97316; border-radius: 2px; width: 80px;"></div>
            <div style="height: 8px; background: #fdba74; border-radius: 2px; width: 160px;"></div>
          </div>
        </div>`;

        display(html`<figure id="turing-2scale-figure">
          <div style="position: relative; display: inline-block;">
            ${twoScaleCanvas}
            ${twoScaleRestartBtn}
          </div>
          ${twoScaleKernelIndicator}
          <div style="margin-top: 8px;">${tintCheckbox}</div>
          <figcaption style="font-size: 12px; color: #666; margin-top: 8px;">Two-scale Turing pattern. Blue tint = fine scale selected, orange tint = coarse scale selected.</figcaption>
        </figure>`);

        // Check if initially visible
        const rectTwoScale = twoScaleCanvas.getBoundingClientRect();
        let twoScaleIsVisible = rectTwoScale.top < window.innerHeight && rectTwoScale.bottom > 0;
        const twoScaleVisibilityObserver = new IntersectionObserver((entries) => {
          twoScaleIsVisible = entries[0].isIntersecting;
        }, { threshold: 0.01 });
        twoScaleVisibilityObserver.observe(twoScaleCanvas);

        let twoScaleAnimationId;
        function animate() {
          if (twoScaleIsVisible) {
            twoScaleSim.step();
            twoScaleRenderer.render(twoScaleCtx.getCurrentTexture().createView());
          }
          twoScaleAnimationId = requestAnimationFrame(animate);
        }
        animate();

      invalidation.then(() => {
        cancelAnimationFrame(twoScaleAnimationId);
        twoScaleVisibilityObserver.disconnect();
        twoScaleSim.destroy();
        twoScaleDevice.destroy();
      });
    }
  </script>

  <script id="implementation" type="text/markdown">
    ## Multi-scale Turing pattern Implementation notes

    The visualization at the top of the page puts all the pieces together and performs a multi-scale simulation. Getting it to work efficiently is a moderate undertaking with a few tricks and caveats documented below. The rough algorithm, from Jonathan McCabe's [Cyclic Symmetric Multi-Scale Turing Patterns](http://www.archive.bridgesmathart.org/2010/bridges2010-387.pdf) is:

    1. Convolve the field with Gaussian or circular kernels at different radii to compute activator and inhibitor values
    2. Find the scale with minimum variation (smallest |activator - inhibitor|)
    3. Step the field in the direction indicated by that scale (positive if activator > inhibitor)
    4. Mix the color toward the dominant scale's color

    This implementation uses several techniques to maximize throughput on the GPU:

    **Packed FFTs**: We compute four real-valued FFTs in a single pass by packing data into complex pairs. The real solution field ${tex`u`} is stored as a vec4 treating it as two identical complex numbers:

    ${tex.block`(u + 0i,\; u + 0i)`}

    Similarly, four convolution kernels (two activator-inhibitor pairs for scales ${tex`n`} and ${tex`n+1`}) are packed into two complex numbers:

    ${tex.block`(\hat{A}_n + i\hat{I}_n,\; \hat{A}_{n+1} + i\hat{I}_{n+1})`}

    where ${tex`\hat{A}`} and ${tex`\hat{I}`} are the frequency-domain activator and inhibitor kernels. After a single forward FFT, we multiply by two sets of frequency-domain kernels and perform one inverse FFT to recover all four convolved outputs. It's interesting to note that even thought the real and complex components of the two kernels end up intermingled in frequency space, the final inverse FFT separates them nicely into the real-valued convolutions we seek.

    **Analytical frequency-domain kernels**: Rather than storing precomputed kernel textures, we evaluate kernels analytically in the shader. The Fourier transform of a Gaussian with standard deviation ${tex`\sigma`} is another Gaussian:

    ${tex.block`\mathcal{F}\left[e^{-x^2/2\sigma^2}\right] = e^{-2\pi^2\sigma^2 f^2}`}

    The Fourier transform of a circular disc of radius ${tex`R`} is a Bessel function of the first kind:

    ${tex.block`\mathcal{F}\left[\Pi(r/R)\right] = \frac{J_1(2\pi R f)}{\pi R f}`}

    This eliminates kernel memory bandwidth entirely and allows arbitrary kernel parameters without regenerating textures.

    **Float16 precision**: All computation uses 16-bit floating point for storage buffers, halving memory bandwidth compared to float32. The reduced precision is sufficient for the visual nature of the simulation while enabling larger grid sizes and faster execution.
  </script>
</notebook>
