<!doctype html>
<notebook theme="air">
  <title>WebGPU Text Rendering</title>
  <script id="0" type="text/markdown">
# WebGPU Text Rendering

This notebook demonstrates instanced text rendering using WebGPU. Text spans are managed by a context that batches all characters into a single draw call.

**Features:**
- Create persistent text spans
- Update text, position, fontSize, color dynamically
- Automatic buffer compaction when spans are destroyed
- All text rendered in a single instanced draw call
- Pan and zoom support
  </script>

  <script id="1" type="module">
    // Check WebGPU support
    if (!navigator.gpu) {
      display(html`<p style="color: red;">WebGPU is not supported in this browser.</p>`);
      throw new Error('WebGPU not supported');
    }

    const adapter = await navigator.gpu.requestAdapter();
    if (!adapter) {
      throw new Error('Failed to get WebGPU adapter');
    }

    const device = await adapter.requestDevice();
    const canvasFormat = navigator.gpu.getPreferredCanvasFormat();

    invalidation.then(() => device.destroy());
  </script>

  <script id="2" type="module">
    import { createZoomableAxes } from './lib/zoomable-axes.js';

    const dpr = window.devicePixelRatio || 1;
    const canvasWidth = Math.min(640, width);
    const canvasHeight = 400;

    // Create stacked container with canvas + SVG overlay
    const container = document.createElement('div');
    container.style.position = 'relative';
    container.style.width = `${canvasWidth}px`;
    container.style.height = `${canvasHeight}px`;

    const canvas = document.createElement('canvas');
    canvas.id = 'text-canvas';
    canvas.width = Math.floor(canvasWidth * dpr);
    canvas.height = Math.floor(canvasHeight * dpr);
    canvas.style.width = `${canvasWidth}px`;
    canvas.style.height = `${canvasHeight}px`;
    canvas.style.border = '1px solid rgba(0,0,0,0.2)';
    canvas.style.position = 'absolute';
    canvas.style.top = '0';
    canvas.style.left = '0';
    container.appendChild(canvas);

    const svg = d3.create("svg")
      .attr("width", canvasWidth)
      .attr("height", canvasHeight)
      .style("cursor", "grab")
      .style("position", "absolute")
      .style("top", "0")
      .style("left", "0")
      .node();
    container.appendChild(svg);

    const gpuContext = canvas.getContext('webgpu');
    gpuContext.configure({
      device,
      format: canvasFormat,
      alphaMode: 'premultiplied'
    });

    // Render state for dirty tracking
    const renderState = { dirty: true };

    // Create zoomable axes - domain is in CSS pixels
    // Use flipY to make Y=0 at top of screen while keeping d3.zoom pan direction correct
    const axes = createZoomableAxes({
      d3,
      element: svg,
      xScale: d3.scaleLinear().domain([0, canvasWidth]).range([0, canvasWidth]),
      yScale: d3.scaleLinear().domain([0, canvasHeight]).range([0, canvasHeight]),
      flipY: true,  // Flip Y so Y=0 is at top of screen (standard screen coords)
      scaleExtent: [0.5, 10],
      onChange: () => {
        renderState.dirty = true;
      }
    });

    const figure = html`<figure style="margin: 0;">
      ${container}
      <figcaption style="margin-top:5px">Drag to pan, scroll to zoom.</figcaption>
    </figure>`;

    display(figure);
  </script>

  <script id="3" type="module">
    // Controls
    const textInput = Inputs.text({ label: 'Text', value: 'Hello WebGPU!', width: 300 });
    const text = view(textInput);

    const fontSizeInput = Inputs.range([8, 120], { label: 'Font Size', value: 48, step: 1 });
    const fontSize = view(fontSizeInput);

    const colorInput = Inputs.color({ label: 'Color', value: '#4fc3f7' });
    const color = view(colorInput);

    const strokeColorInput = Inputs.color({ label: 'Stroke Color', value: '#000000' });
    const strokeColor = view(strokeColorInput);

    const strokeWidthInput = Inputs.range([0, 8], { label: 'Stroke Width', value: 0, step: 0.5 });
    const strokeWidth = view(strokeWidthInput);

    display(html`<div style="display: flex; flex-wrap: wrap; gap: 16px; margin-top: 10px;">
      ${textInput}
      ${fontSizeInput}
      ${colorInput}
      ${strokeColorInput}
      ${strokeWidthInput}
    </div>`);
  </script>

  <script id="4" type="module">
    import { createGPUTextContext, loadFontAtlas } from './webgpu-text.ts';

    // Load pre-generated MSDF font atlas (generated via Docker msdf-atlas-gen)
    const fontAtlas = await loadFontAtlas(device, {
      atlasUrl: './roboto-regular.png',
      metadataUrl: './roboto-regular.json',
    });

    invalidation.then(() => fontAtlas.texture.destroy());

    // Create text context with alpha blending
    const textContext = createGPUTextContext(device, {
      fontAtlas,
      colorTargets: {
        format: canvasFormat,
        blend: {
          color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
          alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' },
        },
      },
    });

    invalidation.then(() => textContext.destroy());
  </script>

  <script id="4b" type="module">
    // Debug: Display the MSDF atlas
    const atlasPreview = fontAtlas.debugCanvas;
    atlasPreview.style.width = '512px';
    atlasPreview.style.height = '512px';
    atlasPreview.style.border = '1px solid #ccc';
    atlasPreview.style.imageRendering = 'pixelated';

    display(html`<details>
      <summary>MSDF Atlas (click to expand)</summary>
      <div style="margin-top: 10px;">
        ${atlasPreview}
        <p style="font-size: 12px; color: #666; margin-top: 5px;">
          RGB channels encode distance to edges at different angles.
          The median of R, G, B gives the final signed distance.
        </p>
      </div>
    </details>`);
  </script>

  <script id="5" type="module">
    // Parse hex color to RGBA array
    function hexToRgba(hex) {
      const r = parseInt(hex.slice(1, 3), 16) / 255;
      const g = parseInt(hex.slice(3, 5), 16) / 255;
      const b = parseInt(hex.slice(5, 7), 16) / 255;
      return [r, g, b, 1];
    }

    // Create the main text span - positions in CSS pixels (view matrix handles transform)
    const mainSpan = textContext.createSpan({
      text: text,
      position: [50, 80],
      fontSize: fontSize,
      color: hexToRgba(color),
      strokeColor: hexToRgba(strokeColor),
      strokeWidth: strokeWidth,
    });

    // Horizontal alignment demo (all at x=320, the center of canvas)
    const centerX = 320;
    const alignY = 140;
    const alignSpans = [
      textContext.createSpan({
        text: 'Left aligned',
        position: [centerX, alignY],
        fontSize: 20,
        color: [1, 0.5, 0.5, 1],
        align: 'left',
      }),
      textContext.createSpan({
        text: 'Center aligned',
        position: [centerX, alignY + 25],
        fontSize: 20,
        color: [0.5, 1, 0.5, 1],
        align: 'center',
      }),
      textContext.createSpan({
        text: 'Right aligned',
        position: [centerX, alignY + 50],
        fontSize: 20,
        color: [0.5, 0.5, 1, 1],
        align: 'right',
      }),
    ];

    // Vertical baseline demo (all at y=280)
    const baselineY = 280;
    const baselineSpans = [
      textContext.createSpan({
        text: 'Top',
        position: [80, baselineY],
        fontSize: 24,
        color: [1, 0.8, 0.3, 1],
        baseline: 'top',
      }),
      textContext.createSpan({
        text: 'Middle',
        position: [180, baselineY],
        fontSize: 24,
        color: [0.3, 1, 0.8, 1],
        baseline: 'middle',
      }),
      textContext.createSpan({
        text: 'Baseline',
        position: [320, baselineY],
        fontSize: 24,
        color: [0.8, 0.3, 1, 1],
        baseline: 'baseline',
      }),
      textContext.createSpan({
        text: 'Bottom',
        position: [480, baselineY],
        fontSize: 24,
        color: [1, 0.3, 0.8, 1],
        baseline: 'bottom',
      }),
    ];

    // Reference line marker for baseline demo
    const refLineSpan = textContext.createSpan({
      text: '-'.repeat(60),
      position: [50, baselineY],
      fontSize: 14,
      color: [0.4, 0.4, 0.4, 1],
      baseline: 'middle',
    });

    // Stroke demo - text with outlines for readability on any background
    const strokeDemoSpans = [
      textContext.createSpan({
        text: 'White outline',
        position: [50, 330],
        fontSize: 28,
        color: [0.2, 0.2, 0.8, 1],
        strokeColor: [1, 1, 1, 1],
        strokeWidth: 2,
      }),
      textContext.createSpan({
        text: 'Dark text, white stroke',
        position: [250, 330],
        fontSize: 28,
        color: [0.1, 0.1, 0.1, 1],
        strokeColor: [1, 1, 1, 0.9],
        strokeWidth: 3,
      }),
      textContext.createSpan({
        text: 'Thick outline effect',
        position: [50, 370],
        fontSize: 32,
        color: [1, 0.8, 0.2, 1],
        strokeColor: [0.4, 0.2, 0, 1],
        strokeWidth: 4,
      }),
    ];

    const exampleSpans = [...alignSpans, ...baselineSpans, refLineSpan, ...strokeDemoSpans];

    // Update main span when controls change
    mainSpan.setText(text);
    mainSpan.setFontSize(fontSize);
    mainSpan.setColor(hexToRgba(color));
    mainSpan.setStrokeColor(hexToRgba(strokeColor));
    mainSpan.setStrokeWidth(strokeWidth);
    renderState.dirty = true;

    invalidation.then(() => {
      mainSpan.destroy();
      exampleSpans.forEach(s => s.destroy());
    });
  </script>

  <script id="6" type="module">
    import { createFrameLoop } from './lib/frame-loop.js';

    // Re-render when controls change
    text; fontSize; color;

    const loop = createFrameLoop(() => {
      if (!renderState.dirty) return;

      const encoder = device.createCommandEncoder();

      const pass = encoder.beginRenderPass({
        colorAttachments: [{
          view: gpuContext.getCurrentTexture().createView(),
          loadOp: 'clear',
          storeOp: 'store',
          clearValue: { r: 0.1, g: 0.1, b: 0.18, a: 1 },
        }],
      });

      // Pass CSS pixel resolution so fontSize operates in CSS pixels
      textContext.draw(pass, {
        resolution: [canvas.width / dpr, canvas.height / dpr],
        viewMatrix: axes.view,
      });

      pass.end();
      device.queue.submit([encoder.finish()]);
      renderState.dirty = false;
    });

    invalidation.then(() => loop.cancel());
  </script>

  <script id="7" type="text/markdown">
---

## Dynamic Span Demo

Click the button to add and remove text spans dynamically.
  </script>

  <script id="8" type="module">
    const addSpanButton = Inputs.button('Add Random Span');
    const addSpan = view(addSpanButton);

    const removeSpanButton = Inputs.button('Remove Random Span');
    const removeSpan = view(removeSpanButton);

    const clearSpansButton = Inputs.button('Clear All Dynamic Spans');
    const clearSpans = view(clearSpansButton);

    display(html`<div style="display: flex; gap: 8px; margin: 10px 0;">
      ${addSpanButton}
      ${removeSpanButton}
      ${clearSpansButton}
    </div>`);
  </script>

  <script id="9" type="module">
    const dynamicSpans = [];
    const words = ['WebGPU', 'Text', 'Rendering', 'Instanced', 'Fast', 'GPU', 'Spans', 'Dynamic'];

    function randomColor() {
      return [Math.random(), Math.random(), Math.random(), 1];
    }

    function addRandomSpan() {
      const word = words[Math.floor(Math.random() * words.length)];
      const span = textContext.createSpan({
        text: word,
        position: [
          50 + Math.random() * (canvasWidth - 200),
          250 + Math.random() * 120,
        ],
        fontSize: 14 + Math.random() * 24,
        color: randomColor(),
      });
      dynamicSpans.push(span);
      renderState.dirty = true;
    }

    function removeRandomSpan() {
      if (dynamicSpans.length > 0) {
        const index = Math.floor(Math.random() * dynamicSpans.length);
        const span = dynamicSpans.splice(index, 1)[0];
        span.destroy();
        renderState.dirty = true;
      }
    }

    function clearAllSpans() {
      dynamicSpans.forEach(s => s.destroy());
      dynamicSpans.length = 0;
      renderState.dirty = true;
    }

    // Handle button clicks
    if (addSpan > 0) addRandomSpan();
    if (removeSpan > 0) removeRandomSpan();
    if (clearSpans > 0) clearAllSpans();

    invalidation.then(() => clearAllSpans());
  </script>

  <script id="10" type="module">
    // Stats display
    const statsDiv = html`<div style="font-family: monospace; padding: 10px; background: #f5f5f5; border-radius: 4px; margin-top: 10px;">
      Total characters: <span id="char-count">0</span>
    </div>`;
    display(statsDiv);

    // Update stats periodically
    const updateStats = () => {
      const count = textContext.getTotalCharacterCount();
      statsDiv.querySelector('#char-count').textContent = count;
    };

    const statsInterval = setInterval(updateStats, 100);
    invalidation.then(() => clearInterval(statsInterval));
  </script>

  <script id="11" type="text/markdown">
---

## API Usage

```javascript
import { createGPUTextContext, loadFontAtlas } from './webgpu-text.ts';

// Load a pre-generated font atlas (via Docker msdf-atlas-gen)
const fontAtlas = await loadFontAtlas(device, {
  atlasUrl: './roboto-regular.png',
  metadataUrl: './roboto-regular.json',
});

// Create the text context
const textContext = createGPUTextContext(device, {
  fontAtlas,
  colorTargets: { format: canvasFormat },
});

// Create text spans with alignment and stroke options
const span = textContext.createSpan({
  text: 'Hello World',
  position: [100, 100],
  fontSize: 32,            // Font size in pixels
  color: [1, 1, 1, 1],
  strokeColor: [0, 0, 0, 1],  // Outline color (RGBA)
  strokeWidth: 2,             // Outline width in pixels
  align: 'center',         // 'left' | 'center' | 'right'
  baseline: 'middle',      // 'top' | 'middle' | 'bottom' | 'baseline'
});

// Update spans dynamically
span.setText('Updated text');
span.setFontSize(24);
span.setColor([1, 0, 0, 1]);
span.setStrokeColor([1, 1, 1, 1]);  // White outline
span.setStrokeWidth(3);
span.setAlign('right');
span.setBaseline('top');

// Destroy spans when done
span.destroy();

// In render loop - pass CSS pixel resolution for consistent sizing:
const dpr = window.devicePixelRatio || 1;
textContext.draw(pass, {
  resolution: [canvas.width / dpr, canvas.height / dpr],
  viewMatrix: axes.view,  // Optional: for pan/zoom
});
```

### Custom Vertex Projection

You can provide a custom WGSL function to transform vertices after text shaping.
This is useful for placing text on 3D planes, curves, or other surfaces.

```javascript
const textContext = createGPUTextContext(device, {
  fontAtlas,
  colorTargets: { format: canvasFormat },
  vertexProjection: /* wgsl */`
    fn projectVertex(position: vec3f, uv: vec2f, color: vec4f) -> vec4f {
      // Example: curve text along a sine wave
      let wave = sin(position.x * 0.02) * 20.0;
      let p = vec3f(position.x, position.y + wave, position.z);
      // Convert to clip space
      let x = p.x / uniforms.resolution.x * 2.0 - 1.0;
      let y = 1.0 - p.y / uniforms.resolution.y * 2.0;
      return vec4f(x, y, p.z, 1.0);
    }
  `,
});
```
  </script>
</notebook>
