<!doctype html>
<notebook theme="air">
  <title>Sliced Optimal Transport</title>
  <script id="0" type="text/markdown">
    # Sliced Optimal Transport

    Imagine trying to combinatorially rearrange the pixels of one image to represent another image the best you can with respect to some metric like the difference in color. (Note that although this may be a fun task, it's most certainly not a particularly good way to accomplish style transfer!)

    For a grayscale image, the task is relatively simple. Sort the pixels of source and target image by intensity, putting them into 1:1 correspondence, then reassign by transferring values from the target to the source image. The resulting image would look like the source image but would share the histogram of the target image.

    For a color image, the task is not so simple, as RGB tuples permit no useful ordering. The [Hungarian Algorithm](https://en.wikipedia.org/wiki/Hungarian_algorithm) provides an exhaustively brute-force solution to the assignment problem we seek to solve, but its ${tex`\mathcal{O}(n^3)`} complexity makes it completely impractical for images. Theo Honohan has pointed to some [good alternative methods](https://graphics.social/@theohonohan/111490607440087628).

    Nonetheless, we'll try out an approximate algorithm, though it's best to think of this problem as a nice testbed for the more general algorithm rather than the algorithm as a particularly good solution to our problem. In his article, [Interpolating Color Image Histograms Using Sliced Optimal Transport](https://blog.demofox.org/2023/11/25/interpolating-color-image-histograms-using-sliced-optimal-transport/), Alan Wolfe summarizes the Sliced Optimal Transport method. For the RGB image case, we select a random three-dimensional unit vector and project RGB tuples onto it. We perform the simple grayscale reassignment algorithm, then unproject the resulting per-pixel adjustments back into three dimensions. We perform this task in batches, each time projecting onto a collection of random vectors and averaging the resulting adjustments together before updating the image. The result is an image which looks like the source image but—_approximately_, at least—contains the reordered pixels of the target image.

    Alan has described it better than I have so you should read his article; I just wanted to prototype it and get a good intuitive sense of what's going on, and that's all you'll find here. I'm happy with my implementation in general, though I'd like to:
    - parallelize work within each batch using web workers
    - more intelligently select random vectors
  </script>
  <script id="709" type="application/vnd.observable.javascript">
    viewof sourceFile = Inputs.select(Object.keys(FILES), {
      label: "Source",
      value: "ellingwood"
    })
  </script>
  <script id="686" type="application/vnd.observable.javascript">
    viewof targetFile = Inputs.select(Object.keys(FILES), {
      label: "Target",
      value: 'webb'
    })
  </script>
  <script id="751" type="application/vnd.observable.javascript">
    viewof downsample = Inputs.range([1, 4], {
      value: 2,
      label: "Downsample",
      step: 0.25
    })
  </script>
  <script id="864" type="application/vnd.observable.javascript">
    viewof batchSize = Inputs.range([1, 32], {
      label: "Batch size",
      value: 4,
      step: 1
    })
  </script>
  <script id="862" type="application/vnd.observable.javascript">
    viewof maxIterations = Inputs.range([1, 1024], {
      label: "Max iterations",
      value: 100,
      transform: Math.log,
      step: 1
    })
  </script>
  <script id="1102" type="application/vnd.observable.javascript">
    viewof tolerance = Inputs.range([0.05, 1], {
      label: "Tolerance",
      transform: Math.log,
      value: 0.3
    })
  </script>
  <script id="969" type="application/vnd.observable.javascript">
    viewof interpolate = Inputs.range([0, 1], { label: "Interpolate", value: 1 })
  </script>
  <script id="652" type="application/vnd.observable.javascript">
    viewof restart = Inputs.button("Restart")
  </script>
  <script id="477" type="application/vnd.observable.javascript">
    html`
      ${drawImage(srcData, ...shape)}
      ${drawImage(interpolated, ...shape)}
      ${drawImage(targetData, ...shape)}
    `
  </script>
  <script id="428" type="application/vnd.observable.javascript">
    html`
      ${plotHistogram(srcData)}
      ${plotHistogram(interpolated)}
      ${plotHistogram(targetData)}
    `
  </script>
  <script id="898" type="application/vnd.observable.javascript">
    Plot.plot({
      height: 150,
      width: Math.min(width, 400),
      y: { grid: true, type: "log" },
      x: { grid: true /*type: "log"*/ },
      marks: [
        Plot.lineY(history, { x: "iteration", y: "delta" }),
        Plot.ruleY([tolerance], { strokeDasharray: "4,4", stroke: "rgb(200 0 0)" })
      ]
    })
  </script>
  <script id="1177" type="application/vnd.observable.javascript">
    viewof smoothHistogram = Inputs.checkbox(["Smooth histogram"], {
      value: ["Smooth histogram"]
    })
  </script>
  <script id="965" type="application/vnd.observable.javascript">
    interpolated = {
      const N = result.src.length;
      const out = new Uint8ClampedArray(N);
      for (let i = 0; i < N; i++) {
        out[i] = srcData[i] + (result.src[i] - srcData[i]) * interpolate;
      }
      return out;
    }
  </script>
  <script id="188" type="application/vnd.observable.javascript">
    result = {
      restart;
      mutable history = [];
      return slicedOptimalTransport(srcData.slice(), targetData, {
        maxIterations,
        batchSize,
        tolerance
      });
    }
  </script>
  <script id="1122" type="application/vnd.observable.javascript">
    function sort(values, indices, left, right) {
      let tmp;
      if (left >= right) return;
      const pivot = values[(left + right) >> 1];
      let i = left - 1;
      let j = right + 1;
      while (true) {
        do i++;
        while (values[i] < pivot);
        do j--;
        while (values[j] > pivot);
        if (i >= j) break;
        tmp = values[i];
        values[i] = values[j];
        values[j] = tmp;
        tmp = indices[i];
        indices[i] = indices[j];
        indices[j] = tmp;
      }
      sort(values, indices, left, j);
      sort(values, indices, j + 1, right);
    }
  </script>
  <script id="1060" type="application/vnd.observable.javascript" pinned="">
    function* slicedOptimalTransport(
      src,
      tgt,
      { maxIterations = 100, batchSize = 4, tolerance = 1 } = {}
    ) {
      if (src.length !== tgt.length)
        throw new Error("Source size must equal target size");

      // TODO: I could probably avoid this if I better understood generator functions
      mutable history = [];

      const N = src.length >> 2;
      const index = new Uint32Array(N);
      const srcProjection = new Float32Array(N);
      const tgtProjection = new Float32Array(N);
      const adjustment = new Float32Array(N * 3);

      let delta = Infinity;
      let iteration = 0;
      while (delta > tolerance && ++iteration <= maxIterations) {
        adjustment.fill(0);
        for (let batchIndex = 0; batchIndex < batchSize; batchIndex++) {
          let [v0, v1, v2] = vec3normalize([], [randn(), randn(), randn()]);

          for (let i = 0, i4 = 0; i < N; i++, i4 += 4) {
            index[i] = i;
            srcProjection[i] = v0 * src[i4] + v1 * src[i4 + 1] + v2 * src[i4 + 2];
            tgtProjection[i] = v0 * tgt[i4] + v1 * tgt[i4 + 1] + v2 * tgt[i4 + 2];
          }

          // Native sort works for target since all we need is the sorted vector, but
          // custom sort is required for the source since we need to sort the indices
          // in parallel with the projection.
          sort(srcProjection, index, 0, N - 1);
          tgtProjection.sort();

          for (let j = 0; j < N; j++) {
            const projectedDiff = tgtProjection[j] - srcProjection[j];
            const i3 = index[j] * 3;
            adjustment[i3 + 0] += v0 * projectedDiff;
            adjustment[i3 + 1] += v1 * projectedDiff;
            adjustment[i3 + 2] += v2 * projectedDiff;
          }
        }

        delta = 0;
        for (let i3 = 0, i4 = 0; i4 < N * 4; i3 += 3, i4 += 4) {
          const dr = adjustment[i3] / batchSize;
          const dg = adjustment[i3 + 1] / batchSize;
          const db = adjustment[i3 + 2] / batchSize;
          src[i4] += dr;
          src[i4 + 1] += dg;
          src[i4 + 2] += db;
          delta += dr * dr + dg * dg + db * db;
        }
        delta = Math.sqrt(delta / N);
        mutable history = mutable history.concat([{ iteration, delta }]);

        yield { delta, src };
      }

      return { delta, src };
    }
  </script>
  <script id="766" type="application/vnd.observable.javascript">
    shape = [(src.width / downsample) | 0, (src.height / downsample) | 0]
  </script>
  <script id="891" type="application/vnd.observable.javascript">
    mutable history = []
  </script>
  <script id="462" type="application/vnd.observable.javascript">
    function drawImage(data, width, height, pixelRatio = 2) {
      const canvas = DOM.element("canvas");
      canvas.style.width = `${(width * downsample) / pixelRatio}px`;
      canvas.style.height = `${(height * downsample) / pixelRatio}px`;
      canvas.width = width;
      canvas.height = height;
      canvas.style.display = "inline-block";
      const ctx = canvas.getContext("2d");
      const imageData = ctx.getImageData(0, 0, width, height);
      imageData.data.set(data);
      ctx.putImageData(imageData, 0, 0);
      return canvas;
    }
  </script>
  <script id="17" type="application/vnd.observable.javascript">
    function getPixels(bitmap, width, height) {
      const canvas = DOM.element("canvas");
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(bitmap, 0, 0, width, height);
      return ctx.getImageData(0, 0, canvas.width, canvas.height).data;
    }
  </script>
  <script id="693" type="application/vnd.observable.javascript">
    FILES = ({
      ellingwood: FileAttachment("ellingwood@1.jpg"),
      gravity: FileAttachment("grav-sm.jpg"),
      m61: FileAttachment("m61.jpg"),
      webb: FileAttachment("webb.jpg"),
      yosemite: FileAttachment("yosemite.jpg"),
      yosemite2: FileAttachment("yosemite-2.jpg"),
      yosemite3: FileAttachment("yosemite-3@1.jpg"),
      yosemite4: FileAttachment("yosemite-smog.jpg"),
      topographic: FileAttachment("topo.jpg"),
      climber: FileAttachment("Fotothek_df_ps_0002300_Sport_^_Klettersport.jpg"),
      bigcat: FileAttachment("bigcat.jpg"),
      hokitika: FileAttachment("nz-sunset.jpg"),
      "arthur's pass": FileAttachment("arthurs-pass.jpg"),
      rainier: FileAttachment("rainier.jpg"),
      shelf: FileAttachment("shelf.jpg"),
      cranes: FileAttachment("cranes.jpg"),
      "smith rock": FileAttachment("smith-rock.jpg"),
      dog: FileAttachment("dog.jpg"),
      "ansel adams": FileAttachment("ansel-adams@1.jpg")
    })
  </script>
  <script id="5" type="application/vnd.observable.javascript">
    src = createImageBitmap(await FILES[sourceFile].blob())
  </script>
  <script id="7" type="application/vnd.observable.javascript">
    target = createImageBitmap(await FILES[targetFile].blob())
  </script>
  <script id="25" type="application/vnd.observable.javascript">
    srcData = getPixels(src, src.width / downsample, src.height / downsample)
  </script>
  <script id="162" type="application/vnd.observable.javascript">
    targetData = getPixels(target, src.width / downsample, src.height / downsample)
  </script>
  <script id="1171" type="application/vnd.observable.javascript">
    function smooth(a) {
      const b = a.slice();
      const n = a.length;
      for (let i = 0; i < n; i++) {
        b[i] =
          0.25 * (a[Math.max(0, i - 1)] + a[Math.min(n - 1, i + 1)]) + 0.5 * a[i];
      }
      for (let i = 0; i < n; i++) {
        a[i] =
          0.25 * (b[Math.max(0, i - 1)] + b[Math.min(n - 1, i + 1)]) + 0.5 * b[i];
      }
      return a;
    }
  </script>
  <script id="104" type="application/vnd.observable.javascript">
    function plotHistogram(
      data,
      { w = Math.max(320, Math.min(src.width / devicePixelRatio, width / 3)) } = {}
    ) {
      function computeHistogram(data) {
        const n = data.length;
        let r = new Uint16Array(256);
        let g = new Uint16Array(256);
        let b = new Uint16Array(256);
        for (let i = 0; i < n; i += 4) {
          r[data[i]]++;
          g[data[i + 1]]++;
          b[data[i + 2]]++;
        }
        if (~smoothHistogram.indexOf("Smooth histogram")) {
          r = smooth(r);
          g = smooth(g);
          b = smooth(b);
        }
        return { r, g, b };
      }

      const { r, g, b } = computeHistogram(data);
      // We like structs of arrays, but observable plot demands arrays of structs
      const transposed = [];
      for (let i = 0; i < 256; i++) {
        transposed[i] = { level: i, r: r[i], g: g[i], b: b[i] };
      }
      const el = Plot.plot({
        height: 200,
        width: w,
        y: { grid: true },
        x: { grid: true },
        marks: [
          Plot.areaY(transposed, {
            x: "level",
            y: "r",
            stroke: "rgb(255 0 0/100%)",
            fill: "rgb(200 0 0/20%)"
          }),
          Plot.areaY(transposed, {
            x: "level",
            y: "g",
            stroke: "rgb(0 150 0/100%)",
            fill: "rgb(0 150 0/20%)"
          }),
          Plot.areaY(transposed, {
            x: "level",
            y: "b",
            stroke: "rgb(0 0 255/100%)",
            fill: "rgb(0 0 255/15%)"
          })
        ]
      });
      el.style.display = "inline-block";
      return el;
    }
  </script>
  <script id="1140" type="application/vnd.observable.javascript">
    import { vec3normalize } from "@rreusser/gl-vec3"
  </script>
  <script id="78" type="application/vnd.observable.javascript">
    randn = (await import("https://cdn.skypack.dev/@stdlib/random-base-randn"))
      .default
  </script>
</notebook>
