<!doctype html>
<notebook theme="air">
  <title>Sliced Optimal Transport</title>
  <script id="1" type="text/markdown">
    # Sliced Optimal Transport
  </script>
  <script id="2" type="text/markdown">
    Imagine wanting to combinatorially reassign the pixels of one image to match another image subject so some cost metric. An exhaustive solution like the [Hungarian Algorithm](https://en.wikipedia.org/wiki/Hungarian_algorithm) has ${tex`\mathcal{O}(n^3)`} complexity, making it both relatively pointless as a style transfer algorithm *and* very expensive.

  </script>
  <script id="29" type="text/markdown">
    Sliced optimal transport is an algorithm for approximately solving the assignment problem in high dimensions. Given two point sets, it finds a correspondence that minimizes total displacement by reducing the problem to a series of one-dimensional sorts.
  </script>
  <script id="3" type="text/markdown">
    ## How It Works

    The animation below demonstrates sliced optimal transport in two dimensions. We start with source points (blue) and target points (orange). Each iteration chooses a random direction and projects both point sets onto that line. After sorting both projections, we pair them by rank and nudge each source point along the projection direction based on the difference between its projected value and that of its paired target.
  </script>
  <script id="5" type="module">

    const demoWidth = width;
    const demoHeight = width;
    const margin = { top: 20, right: 20, bottom: 30, left: 20 };
    const innerWidth = demoWidth - margin.left - margin.right;
    const innerHeight = demoHeight - margin.top - margin.bottom;

    const svg = d3.create("svg")
      .attr("width", demoWidth)
      .attr("height", demoHeight)
      .attr("viewBox", [0, 0, demoWidth, demoHeight])
      .style("max-width", "100%")
      .style("height", "auto")
      .style("display", "block")
      .style("margin", "0 auto");

    const g = svg.append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    const xScale = d3.scaleLinear().domain([-1.5, 1.5]).range([0, innerWidth]);
    const yScale = d3.scaleLinear().domain([-1.5, 1.5]).range([innerHeight, 0]);

    const nPoints = 24;
    const sourceColor = "#4682b4";
    const targetColor = "#e07028";
    const projectionLineColor = "#999";

    function generateCluster(cx, cy, radius, n) {
      const points = [];
      for (let i = 0; i < n; i++) {
        const angle = Math.random() * Math.PI * 2;
        const r = radius * Math.sqrt(Math.random());
        points.push({ x: cx + r * Math.cos(angle), y: cy + r * Math.sin(angle) });
      }
      return points;
    }

    const targetPoints = generateCluster(0, 0, 0.5, nPoints);
    const initialSourcePoints = generateCluster(-0.9, 0, 0.4, nPoints);
    let sourcePoints = initialSourcePoints.map(p => ({ ...p }));

    g.append("line")
      .attr("class", "projection-line")
      .attr("stroke", projectionLineColor)
      .attr("stroke-width", 1)
      .attr("stroke-dasharray", "4,4")
      .style("opacity", 0);

    const projectionG = g.append("g").attr("class", "projections");

    const targetCircles = g.selectAll(".target")
      .data(targetPoints)
      .join("circle")
      .attr("class", "target")
      .attr("cx", d => xScale(d.x))
      .attr("cy", d => yScale(d.y))
      .attr("r", 6)
      .attr("fill", targetColor)
      .attr("opacity", 0.7);

    const sourceCircles = g.selectAll(".source")
      .data(sourcePoints)
      .join("circle")
      .attr("class", "source")
      .attr("cx", d => xScale(d.x))
      .attr("cy", d => yScale(d.y))
      .attr("r", 6)
      .attr("fill", sourceColor);


    let cancelled = false;
    let iteration = 0;

    async function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function project(point, direction) {
      return point.x * direction.x + point.y * direction.y;
    }

    function normalize(v) {
      const len = Math.sqrt(v.x * v.x + v.y * v.y);
      return { x: v.x / len, y: v.y / len };
    }

    async function animateStep() {
      if (cancelled) return;

      iteration++;
      const speed = 0.5 + iteration * 0.17;
      const dur = ms => ms / speed;


      const angle = Math.random() * Math.PI * 2;
      const direction = { x: Math.cos(angle), y: Math.sin(angle) };
      const perp = { x: -direction.y, y: direction.x };
      const lineOffset = -1.0;

      const lineLength = 2.5;
      const projLine = g.select(".projection-line");
      projLine
        .attr("x1", xScale(-direction.x * lineLength + perp.x * lineOffset))
        .attr("y1", yScale(-direction.y * lineLength + perp.y * lineOffset))
        .attr("x2", xScale(direction.x * lineLength + perp.x * lineOffset))
        .attr("y2", yScale(direction.y * lineLength + perp.y * lineOffset))
        .transition()
        .duration(dur(300))
        .style("opacity", 1);

      await sleep(dur(400));
      if (cancelled) return;


      const srcProj = sourcePoints.map((p, i) => ({
        index: i,
        value: project(p, direction),
        point: p
      }));
      const tgtProj = targetPoints.map((p, i) => ({
        index: i,
        value: project(p, direction),
        point: p
      }));

      const pointSpread = 0.06;
      function projectToLine(p, dir, offset, spread) {
        const t = project(p, dir);
        return { x: t * dir.x + perp.x * (offset + spread), y: t * dir.y + perp.y * (offset + spread) };
      }

      const srcProjPoints = sourcePoints.map(p => projectToLine(p, direction, lineOffset, pointSpread));
      const tgtProjPoints = targetPoints.map(p => projectToLine(p, direction, lineOffset, -pointSpread));

      projectionG.selectAll(".src-proj-line")
        .data(sourcePoints)
        .join("line")
        .attr("class", "src-proj-line")
        .attr("x1", d => xScale(d.x))
        .attr("y1", d => yScale(d.y))
        .attr("x2", (d, i) => xScale(srcProjPoints[i].x))
        .attr("y2", (d, i) => yScale(srcProjPoints[i].y))
        .attr("stroke", sourceColor)
        .attr("stroke-width", 1)
        .attr("opacity", 0)
        .transition()
        .duration(dur(300))
        .attr("opacity", 0.3);

      projectionG.selectAll(".tgt-proj-line")
        .data(targetPoints)
        .join("line")
        .attr("class", "tgt-proj-line")
        .attr("x1", d => xScale(d.x))
        .attr("y1", d => yScale(d.y))
        .attr("x2", (d, i) => xScale(tgtProjPoints[i].x))
        .attr("y2", (d, i) => yScale(tgtProjPoints[i].y))
        .attr("stroke", targetColor)
        .attr("stroke-width", 1)
        .attr("opacity", 0)
        .transition()
        .duration(dur(300))
        .attr("opacity", 0.3);

      projectionG.selectAll(".src-proj")
        .data(srcProjPoints)
        .join("circle")
        .attr("class", "src-proj")
        .attr("cx", d => xScale(d.x))
        .attr("cy", d => yScale(d.y))
        .attr("r", 4)
        .attr("fill", sourceColor)
        .attr("opacity", 0)
        .transition()
        .duration(dur(300))
        .attr("opacity", 0.8);

      projectionG.selectAll(".tgt-proj")
        .data(tgtProjPoints)
        .join("circle")
        .attr("class", "tgt-proj")
        .attr("cx", d => xScale(d.x))
        .attr("cy", d => yScale(d.y))
        .attr("r", 4)
        .attr("fill", targetColor)
        .attr("opacity", 0)
        .transition()
        .duration(dur(300))
        .attr("opacity", 0.8);

      await sleep(dur(600));
      if (cancelled) return;


      srcProj.sort((a, b) => a.value - b.value);
      tgtProj.sort((a, b) => a.value - b.value);

      const rankPairs = srcProj.map((src, rank) => ({
        srcIdx: src.index,
        tgtIdx: tgtProj[rank].index,
        srcProj: srcProjPoints[src.index],
        tgtProj: tgtProjPoints[tgtProj[rank].index]
      }));

      projectionG.selectAll(".rank-line")
        .data(rankPairs)
        .join("line")
        .attr("class", "rank-line")
        .attr("x1", d => xScale(d.srcProj.x))
        .attr("y1", d => yScale(d.srcProj.y))
        .attr("x2", d => xScale(d.tgtProj.x))
        .attr("y2", d => yScale(d.tgtProj.y))
        .attr("stroke", "#666")
        .attr("stroke-width", 1.5)
        .attr("opacity", 0)
        .transition()
        .duration(dur(300))
        .attr("opacity", 0.5);

      const stepSize = 0.3;
      const newSourcePoints = sourcePoints.map(p => ({ ...p }));

      for (let rank = 0; rank < srcProj.length; rank++) {
        const src = newSourcePoints[srcProj[rank].index];
        const projDiff = tgtProj[rank].value - srcProj[rank].value;
        src.x += direction.x * projDiff * stepSize;
        src.y += direction.y * projDiff * stepSize;
      }

      await sleep(dur(500));
      if (cancelled) return;


      sourcePoints = newSourcePoints;

      const newSrcProjPoints = sourcePoints.map(p => projectToLine(p, direction, lineOffset, pointSpread));

      sourceCircles
        .data(sourcePoints)
        .transition()
        .duration(dur(500))
        .attr("cx", d => xScale(d.x))
        .attr("cy", d => yScale(d.y));

      projectionG.selectAll(".src-proj-line")
        .data(sourcePoints)
        .transition()
        .duration(dur(500))
        .attr("x1", d => xScale(d.x))
        .attr("y1", d => yScale(d.y))
        .attr("x2", (d, i) => xScale(newSrcProjPoints[i].x))
        .attr("y2", (d, i) => yScale(newSrcProjPoints[i].y));

      projectionG.selectAll(".src-proj")
        .data(newSrcProjPoints)
        .transition()
        .duration(dur(500))
        .attr("cx", d => xScale(d.x))
        .attr("cy", d => yScale(d.y));

      const newRankPairs = rankPairs.map(pair => ({
        ...pair,
        srcProj: newSrcProjPoints[pair.srcIdx]
      }));

      projectionG.selectAll(".rank-line")
        .data(newRankPairs)
        .transition()
        .duration(dur(500))
        .attr("x1", d => xScale(d.srcProj.x))
        .attr("y1", d => yScale(d.srcProj.y));

      await sleep(dur(600));
      if (cancelled) return;

      projLine.transition().duration(dur(200)).style("opacity", 0);
      projectionG.selectAll("*").transition().duration(dur(200)).attr("opacity", 0).remove();

      await sleep(dur(400));

      if (!cancelled && iteration < 40) {
        requestAnimationFrame(animateStep);
      } else if (!cancelled) {
        setTimeout(() => {
          if (cancelled) return;
          iteration = 0;
          sourcePoints = initialSourcePoints.map(p => ({ ...p }));
          sourceCircles
            .data(sourcePoints)
            .transition()
            .duration(500)
            .attr("cx", d => xScale(d.x))
            .attr("cy", d => yScale(d.y));
          setTimeout(() => {
            if (!cancelled) requestAnimationFrame(animateStep);
          }, 600);
        }, 3000);
      }
    }

    requestAnimationFrame(animateStep);

    invalidation.then(() => { cancelled = true; });

    display(html`<figure id="sot-demo-figure">
      ${svg.node()}
      <figcaption>
        Blue points (source) move toward orange points (target) via sliced optimal transport.
      </figcaption>
    </figure>`);
  </script>
  <script id="references" type="text/markdown">
    In practice, we would average updates across a batch of random directions before applying them. For illustration, we show a fractional update from a single direction per step. Repeating this process with new random directions, the source points gradually rearrange to match the target distribution.

    ## References

    Alan Wolfe provides an excellent explanation of sliced optimal transport in his article, [Interpolating Color Image Histograms Using Sliced Optimal Transport](https://blog.demofox.org/2023/11/25/interpolating-color-image-histograms-using-sliced-optimal-transport/). Theo Honohan pointed me to [Color Style Transfer Techniques using Hue, Lightness and Saturation Histogram Matching](https://diglib.eg.org/server/api/core/bitstreams/f24394e8-25f0-42fe-a21c-58d8bf5107f5/content) by László Neumann and Attila Neumann for alternative approaches to color transfer.
  </script>
  <script id="demo-header" type="text/markdown">
    ## Demo

    The interactive demo below applies sliced optimal transport to rearrange the pixels of one image to match the color distribution of another.
  </script>
  <script id="6" type="module">
    const sourceFile = view(Inputs.select(Object.keys(FILES), {
      label: "Source",
      value: "ellingwood"
    }));

    const targetFile = view(Inputs.select(Object.keys(FILES), {
      label: "Target",
      value: 'webb'
    }));

    const downsample = view(Inputs.range([1, 4], {
      value: 2,
      label: "Downsample",
      step: 0.25
    }));

    const batchSize = view(Inputs.range([1, 32], {
      label: "Batch size",
      value: 8,
      step: 1
    }));

    const maxIterations = view(Inputs.range([1, 1024], {
      label: "Max iterations",
      value: 100,
      transform: Math.log,
      step: 1
    }));

    const tolerance = view(Inputs.range([0.05, 1], {
      label: "Tolerance",
      transform: Math.log,
      value: 0.3
    }));

    const interpolate = view(Inputs.range([0, 1], { label: "Interpolate", value: 1 }));

    const restart = view(Inputs.button("Restart"));
  </script>
  <script id="7" type="module">
    const figure = html`<figure class="image-figure">
      <style>
        .image-figure {
          --extra: min(60px, max(0px, calc((100vw - 100%) / 2 - 8px)));
          max-width: min(840px, calc(100vw - 16px));
          width: calc(100% + var(--extra) * 2);
          margin-left: calc(var(--extra) * -1);
          margin-right: calc(var(--extra) * -1);
        }
        .image-figure .grid {
          display: grid;
          grid-template-columns: repeat(3, 1fr);
          gap: 8px;
        }
        .image-figure .column {
          display: flex;
          flex-direction: column;
          align-items: center;
        }
        .image-figure .label {
          text-align: center;
          font-weight: 500;
          font-size: 14px;
          margin-bottom: 4px;
        }
        .image-figure .histogram {
          margin-top: 8px;
        }
        @media (max-width: 600px) {
          .image-figure {
            width: 100%;
            margin-left: 0;
            margin-right: 0;
          }
          .image-figure .grid {
            grid-template-columns: 1fr;
            gap: 16px;
          }
        }
      </style>
      <div class="grid"></div>
    </figure>`;

    const grid = figure.querySelector('.grid');
    const labels = ['Source', 'Result', 'Target'];
    const datasets = [srcData, interpolated, targetData];
    const isMobile = window.innerWidth <= 600;
    const histWidth = isMobile ? Math.min(480, window.innerWidth - 32) : 280;
    const histHeight = isMobile ? 120 : 200;

    datasets.forEach((data, i) => {
      const column = document.createElement('div');
      column.className = 'column';

      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = labels[i];
      column.appendChild(label);

      const canvas = drawImage(data, ...shape);
      canvas.style.width = '100%';
      canvas.style.height = 'auto';
      column.appendChild(canvas);

      const histWrapper = document.createElement('div');
      histWrapper.className = 'histogram';
      const hist = plotHistogram(data, { w: histWidth, h: histHeight });
      hist.style.width = '100%';
      histWrapper.appendChild(hist);
      column.appendChild(histWrapper);

      grid.appendChild(column);
    });

    display(figure);
  </script>
  <script id="8" type="module">
    // Re-render when result changes (result is yielded iteratively)
    result;
    display(html`<figure>${Plot.plot({
      height: 150,
      width: Math.min(width, 400),
      y: { grid: true, type: "log" },
      x: { grid: true },
      marks: [
        Plot.lineY(state.history, { x: "iteration", y: "delta" }),
        Plot.ruleY([tolerance], { strokeDasharray: "4,4", stroke: "rgb(200 0 0)" })
      ]
    })}</figure>`);
  </script>
  <script id="9" type="module">
    const smoothHistogram = view(Inputs.checkbox(["Smooth histograms"], {
      value: ["Smooth histograms"]
    }));
  </script>
  <script id="10" type="module">
    const state = { history: [] };
  </script>
  <script id="11" type="module">
    const N = result.src.length;
    const out = new Uint8ClampedArray(N);
    for (let i = 0; i < N; i++) {
      out[i] = srcData[i] + (result.src[i] - srcData[i]) * interpolate;
    }
    const interpolated = out;
  </script>
  <script id="12" type="module">
    restart;
    state.history = [];
    const result = Generators.observe(notify => {
      let cancelled = false;
      const gen = slicedOptimalTransport(srcData.slice(), targetData, {
        maxIterations,
        batchSize,
        tolerance,
        state
      });

      async function step() {
        if (cancelled) return;
        const { value, done } = await gen.next();
        if (cancelled) return;
        if (value) {
          notify(value);
        }
        if (!done && !cancelled) {
          requestAnimationFrame(step);
        }
      }
      step();

      return () => { cancelled = true; };
    });
  </script>
  <script id="13" type="module">
    // Worker code as a string
    const workerCode = `
      function sort(values, indices, left, right) {
        let tmp;
        if (left >= right) return;
        const pivot = values[(left + right) >> 1];
        let i = left - 1;
        let j = right + 1;
        while (true) {
          do i++;
          while (values[i] < pivot);
          do j--;
          while (values[j] > pivot);
          if (i >= j) break;
          tmp = values[i];
          values[i] = values[j];
          values[j] = tmp;
          tmp = indices[i];
          indices[i] = indices[j];
          indices[j] = tmp;
        }
        sort(values, indices, left, j);
        sort(values, indices, j + 1, right);
      }

      function randn() {
        let u = 0, v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
      }

      function vec3normalize(out, a) {
        const x = a[0], y = a[1], z = a[2];
        let len = x * x + y * y + z * z;
        if (len > 0) len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
        return out;
      }

      self.onmessage = function(e) {
        const { id, src, tgt, N } = e.data;
        const index = new Uint32Array(N);
        const srcProjection = new Float32Array(N);
        const tgtProjection = new Float32Array(N);
        const adjustment = new Float32Array(N * 3);

        const [v0, v1, v2] = vec3normalize([], [randn(), randn(), randn()]);

        for (let i = 0, i4 = 0; i < N; i++, i4 += 4) {
          index[i] = i;
          srcProjection[i] = v0 * src[i4] + v1 * src[i4 + 1] + v2 * src[i4 + 2];
          tgtProjection[i] = v0 * tgt[i4] + v1 * tgt[i4 + 1] + v2 * tgt[i4 + 2];
        }

        sort(srcProjection, index, 0, N - 1);
        tgtProjection.sort();

        for (let j = 0; j < N; j++) {
          const projectedDiff = tgtProjection[j] - srcProjection[j];
          const i3 = index[j] * 3;
          adjustment[i3 + 0] = v0 * projectedDiff;
          adjustment[i3 + 1] = v1 * projectedDiff;
          adjustment[i3 + 2] = v2 * projectedDiff;
        }

        self.postMessage({ id, adjustment }, [adjustment.buffer]);
      };
    `;

    const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
    const workerUrl = URL.createObjectURL(workerBlob);
    const numWorkers = navigator.hardwareConcurrency || 4;

    // Create workers with message ID tracking
    const pendingJobs = new Map();
    let nextJobId = 0;

    const workerPool = Array.from({ length: numWorkers }, () => {
      const worker = new Worker(workerUrl);
      worker.onmessage = (e) => {
        const { id, adjustment } = e.data;
        const resolve = pendingJobs.get(id);
        if (resolve) {
          pendingJobs.delete(id);
          resolve(adjustment);
        }
      };
      return worker;
    });

    function runWorkerJob(workerIndex, src, tgt, N) {
      const id = nextJobId++;
      const worker = workerPool[workerIndex % workerPool.length];
      return new Promise(resolve => {
        pendingJobs.set(id, resolve);
        worker.postMessage({ id, src, tgt, N });
      });
    }

    invalidation.then(() => {
      workerPool.forEach(w => w.terminate());
      URL.revokeObjectURL(workerUrl);
      pendingJobs.clear();
    });
  </script>
  <script id="14" type="text/markdown">
    My original code [from this notebook](https://observablehq.com/@rreusser/sliced-optimal-transport) is presented below. However, this is *not* the code being run in this notebook. This notebook uses a [Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers) pool to perform the batches in parallel since the algorithm can get a bit slow. You can read the modified implementation in [the Notebook Kit source for this page](https://github.com/rreusser/notebooks/tree/main/src/sliced-optimal-transport/index.html).
    ```js
    function* slicedOptimalTransport(
      src,
      tgt,
      { maxIterations = 100, batchSize = 4, tolerance = 1 } = {}
    ) {
      if (src.length !== tgt.length)
    throw new Error("Source size must equal target size");

      // TODO: I could probably avoid this if I better understood generator functions
      mutable history = [];

      const N = src.length >> 2;
      const index = new Uint32Array(N);
      const srcProjection = new Float32Array(N);
      const tgtProjection = new Float32Array(N);
      const adjustment = new Float32Array(N * 3);

      let delta = Infinity;
      let iteration = 0;
      while (delta > tolerance && ++iteration <= maxIterations) {
    adjustment.fill(0);
    for (let batchIndex = 0; batchIndex < batchSize; batchIndex++) {
      let [v0, v1, v2] = vec3normalize([], [randn(), randn(), randn()]);

      for (let i = 0, i4 = 0; i < N; i++, i4 += 4) {
        index[i] = i;
        srcProjection[i] = v0 * src[i4] + v1 * src[i4 + 1] + v2 * src[i4 + 2];
        tgtProjection[i] = v0 * tgt[i4] + v1 * tgt[i4 + 1] + v2 * tgt[i4 + 2];
      }

      // Native sort works for target since all we need is the sorted vector, but
      // custom sort is required for the source since we need to sort the indices
      // in parallel with the projection.
      sort(srcProjection, index, 0, N - 1);
      tgtProjection.sort();

      for (let j = 0; j < N; j++) {
        const projectedDiff = tgtProjection[j] - srcProjection[j];
        const i3 = index[j] * 3;
        adjustment[i3 + 0] += v0 * projectedDiff;
        adjustment[i3 + 1] += v1 * projectedDiff;
        adjustment[i3 + 2] += v2 * projectedDiff;
      }
    }

    delta = 0;
    for (let i3 = 0, i4 = 0; i4 < N * 4; i3 += 3, i4 += 4) {
      const dr = adjustment[i3] / batchSize;
      const dg = adjustment[i3 + 1] / batchSize;
      const db = adjustment[i3 + 2] / batchSize;
      src[i4] += dr;
      src[i4 + 1] += dg;
      src[i4 + 2] += db;
      delta += dr * dr + dg * dg + db * db;
    }
    delta = Math.sqrt(delta / N);
    mutable history = mutable history.concat([{ iteration, delta }]);

    yield { delta, src };
      }

      return { delta, src };
    }
    ```
  </script>
  <script id="15" type="module">
    async function* slicedOptimalTransport(
      src,
      tgt,
      { maxIterations = 100, batchSize = 4, tolerance = 1, state } = {}
    ) {
      if (src.length !== tgt.length)
        throw new Error("Source size must equal target size");

      state.history = [];

      const N = src.length >> 2;

      // Convert to Float32Array for workers
      const srcFloat = new Float32Array(src);
      const tgtFloat = new Float32Array(tgt);

      let delta = Infinity;
      let iteration = 0;
      while (delta > tolerance && ++iteration <= maxIterations) {
        const adjustment = await runBatchParallel(srcFloat, tgtFloat, N, batchSize);

        delta = 0;
        for (let i3 = 0, i4 = 0; i4 < N * 4; i3 += 3, i4 += 4) {
          const dr = adjustment[i3] / batchSize;
          const dg = adjustment[i3 + 1] / batchSize;
          const db = adjustment[i3 + 2] / batchSize;
          srcFloat[i4] += dr;
          srcFloat[i4 + 1] += dg;
          srcFloat[i4 + 2] += db;
          delta += dr * dr + dg * dg + db * db;
        }
        delta = Math.sqrt(delta / N);
        state.history = state.history.concat([{ iteration, delta }]);

        // Convert back to Uint8ClampedArray for display
        const srcClamped = new Uint8ClampedArray(srcFloat.length);
        for (let i = 0; i < srcFloat.length; i++) {
          srcClamped[i] = srcFloat[i];
        }

        yield { delta, src: srcClamped };
      }

      const srcClamped = new Uint8ClampedArray(srcFloat.length);
      for (let i = 0; i < srcFloat.length; i++) {
        srcClamped[i] = srcFloat[i];
      }
      return { delta, src: srcClamped };
    }
  </script>
  <script id="16" type="module">
    async function runBatchParallel(src, tgt, N, batchSize) {
      const promises = [];
      for (let i = 0; i < batchSize; i++) {
        promises.push(runWorkerJob(i, src, tgt, N));
      }
      const adjustments = await Promise.all(promises);
      const combined = new Float32Array(N * 3);
      for (const adj of adjustments) {
        for (let i = 0; i < combined.length; i++) {
          combined[i] += adj[i];
        }
      }
      return combined;
    }

  </script>
  <script id="17" type="module">
    const shape = [(src.width / downsample) | 0, (src.height / downsample) | 0];
  </script>
  <script id="18" type="module">
    function drawImage(data, width, height, pixelRatio = 2) {
      const canvas = document.createElement("canvas");
      canvas.style.width = `${(width * downsample) / pixelRatio}px`;
      canvas.style.height = `${(height * downsample) / pixelRatio}px`;
      canvas.width = width;
      canvas.height = height;
      canvas.style.display = "inline-block";
      const ctx = canvas.getContext("2d");
      const imageData = ctx.getImageData(0, 0, width, height);
      imageData.data.set(data);
      ctx.putImageData(imageData, 0, 0);
      return canvas;
    }
  </script>
  <script id="19" type="module">
    function getPixels(bitmap, width, height) {
      const canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(bitmap, 0, 0, width, height);
      return ctx.getImageData(0, 0, canvas.width, canvas.height).data;
    }
  </script>
  <script id="20" type="module">
    const FILES = {
      ellingwood: FileAttachment("ellingwood.jpg"),
      gravity: FileAttachment("gravity.jpg"),
      m61: FileAttachment("m61.jpg"),
      webb: FileAttachment("webb.jpg"),
      yosemite: FileAttachment("yosemite.jpg"),
      yosemite2: FileAttachment("yosemite2.jpg"),
      yosemite3: FileAttachment("yosemite3.jpg"),
      yosemite4: FileAttachment("yosemite4.jpg"),
      topographic: FileAttachment("topographic.jpg"),
      bigcat: FileAttachment("bigcat.jpg"),
      hokitika: FileAttachment("hokitika.jpg"),
      "arthur's pass": FileAttachment("arthurs-pass.jpg"),
      rainier: FileAttachment("rainier.jpg"),
      shelf: FileAttachment("shelf.jpg"),
      cranes: FileAttachment("cranes.jpg"),
      "smith rock": FileAttachment("smith-rock.jpg"),
      dog: FileAttachment("dog.jpg"),
      "ansel adams": FileAttachment("ansel-adams.jpg")
    };
  </script>
  <script id="21" type="module">
    const src = await createImageBitmap(await FILES[sourceFile].blob());
  </script>
  <script id="22" type="module">
    const target = await createImageBitmap(await FILES[targetFile].blob());
  </script>
  <script id="23" type="module">
    const srcData = getPixels(src, src.width / downsample, src.height / downsample);
  </script>
  <script id="24" type="module">
    const targetData = getPixels(target, src.width / downsample, src.height / downsample);
  </script>
  <script id="25" type="module">
    function smooth(a) {
      const b = a.slice();
      const n = a.length;
      for (let i = 0; i < n; i++) {
        b[i] =
          0.25 * (a[Math.max(0, i - 1)] + a[Math.min(n - 1, i + 1)]) + 0.5 * a[i];
      }
      for (let i = 0; i < n; i++) {
        a[i] =
          0.25 * (b[Math.max(0, i - 1)] + b[Math.min(n - 1, i + 1)]) + 0.5 * b[i];
      }
      return a;
    }
  </script>
  <script id="26" type="module">
    function plotHistogram(
      data,
      { w = Math.max(320, Math.min(src.width / devicePixelRatio, width / 3)), h = 200 } = {}
    ) {
      function computeHistogram(data) {
        const n = data.length;
        let r = new Uint16Array(256);
        let g = new Uint16Array(256);
        let b = new Uint16Array(256);
        for (let i = 0; i < n; i += 4) {
          r[data[i]]++;
          g[data[i + 1]]++;
          b[data[i + 2]]++;
        }
        if (~smoothHistogram.indexOf("Smooth histograms")) {
          r = smooth(r);
          g = smooth(g);
          b = smooth(b);
        }
        return { r, g, b };
      }

      const { r, g, b } = computeHistogram(data);
      // We like structs of arrays, but observable plot demands arrays of structs
      const transposed = [];
      for (let i = 0; i < 256; i++) {
        transposed[i] = { level: i, r: r[i], g: g[i], b: b[i] };
      }
      const el = Plot.plot({
        height: h,
        width: w,
        y: { grid: true },
        x: { grid: true },
        marks: [
          Plot.areaY(transposed, {
            x: "level",
            y: "r",
            stroke: "rgb(255 0 0/100%)",
            fill: "rgb(200 0 0/20%)"
          }),
          Plot.areaY(transposed, {
            x: "level",
            y: "g",
            stroke: "rgb(0 150 0/100%)",
            fill: "rgb(0 150 0/20%)"
          }),
          Plot.areaY(transposed, {
            x: "level",
            y: "b",
            stroke: "rgb(0 0 255/100%)",
            fill: "rgb(0 0 255/15%)"
          })
        ]
      });
      el.style.display = "inline-block";
      return el;
    }
  </script>
  <script id="27" type="module">
    function vec3normalize(out, a) {
      const x = a[0], y = a[1], z = a[2];
      let len = x * x + y * y + z * z;
      if (len > 0) len = 1 / Math.sqrt(len);
      out[0] = a[0] * len;
      out[1] = a[1] * len;
      out[2] = a[2] * len;
      return out;
    }
  </script>
  <script id="28" type="module">
    // Box-Muller transform for standard normal distribution
    function randn() {
      let u = 0, v = 0;
      while (u === 0) u = Math.random();
      while (v === 0) v = Math.random();
      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }
  </script>
</notebook>
