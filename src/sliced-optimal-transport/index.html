<!doctype html>
<notebook theme="air">
  <title>Sliced Optimal Transport</title>
  <script id="0" type="text/markdown">
    # Sliced Optimal Transport
  </script>
  <script id="1" type="text/markdown">
    Imagine trying to combinatorially rearrange the pixels of one image to represent another image the best you can with respect to some metric like the difference in color. Note that although this may be a fun task, it's most certainly not a particularly good way to accomplish style transfer!
  </script>
  <script id="2" type="text/markdown">
    For a grayscale image, the task is relatively simple. Sort the pixels of source and target image by intensity, putting them into 1:1 correspondence, then reassign by transferring values from the target to the source image. The resulting image would look like the source image but would share the histogram of the target image.
  </script>
  <script id="3" type="text/markdown">
    For a color image, the task is not so simple, as RGB tuples permit no useful ordering. The [Hungarian Algorithm](https://en.wikipedia.org/wiki/Hungarian_algorithm) provides an exhaustively brute-force solution to the assignment problem we seek to solve, but its ${tex`\mathcal{O}(n^3)`} complexity makes it completely impractical for images. Theo Honohan has pointed to some [good alternative methods](https://graphics.social/@theohonohan/111490607440087628).
  </script>
  <script id="4" type="text/markdown">
    Nonetheless, we'll try out an approximate algorithm, though it's best to think of this problem as a nice testbed for the more general algorithm rather than the algorithm as a particularly good solution to our problem. In his article, [Interpolating Color Image Histograms Using Sliced Optimal Transport](https://blog.demofox.org/2023/11/25/interpolating-color-image-histograms-using-sliced-optimal-transport/), Alan Wolfe summarizes the Sliced Optimal Transport method. For the RGB image case, we select a random three-dimensional unit vector and project RGB tuples onto it. We perform the simple grayscale reassignment algorithm, then unproject the resulting per-pixel adjustments back into three dimensions. We perform this task in batches, each time projecting onto a collection of random vectors and averaging the resulting adjustments together before updating the image. The result is an image which looks like the source image but, approximately at least, contains the reordered pixels of the target image.
  </script>
  <script id="5" type="text/markdown">
    Alan has described it better than I have so you should read his article; I just wanted to prototype it and get a good intuitive sense of what's going on, and that's all you'll find here. I'm happy with my implementation in general, though I'd like to parallelize work within each batch using web workers and more intelligently select random vectors.
  </script>
  <script id="inputs" type="module">
    const sourceFile = view(Inputs.select(Object.keys(FILES), {
      label: "Source",
      value: "ellingwood"
    }));

    const targetFile = view(Inputs.select(Object.keys(FILES), {
      label: "Target",
      value: 'webb'
    }));

    const downsample = view(Inputs.range([1, 4], {
      value: 2,
      label: "Downsample",
      step: 0.25
    }));

    const batchSize = view(Inputs.range([1, 32], {
      label: "Batch size",
      value: 8,
      step: 1
    }));

    const maxIterations = view(Inputs.range([1, 1024], {
      label: "Max iterations",
      value: 100,
      transform: Math.log,
      step: 1
    }));

    const tolerance = view(Inputs.range([0.05, 1], {
      label: "Tolerance",
      transform: Math.log,
      value: 0.3
    }));

    const interpolate = view(Inputs.range([0, 1], { label: "Interpolate", value: 1 }));

    const restart = view(Inputs.button("Restart"));
  </script>
  <script id="figure-display" type="module">
    const figure = html`<figure class="image-figure">
      <style>
        .image-figure {
          --extra: min(60px, max(0px, calc((100vw - 100%) / 2 - 8px)));
          max-width: min(840px, calc(100vw - 16px));
          width: calc(100% + var(--extra) * 2);
          margin-left: calc(var(--extra) * -1);
          margin-right: calc(var(--extra) * -1);
        }
        .image-figure .grid {
          display: grid;
          grid-template-columns: repeat(3, 1fr);
          gap: 8px;
        }
        .image-figure .column {
          display: flex;
          flex-direction: column;
          align-items: center;
        }
        .image-figure .label {
          text-align: center;
          font-weight: 500;
          font-size: 14px;
          margin-bottom: 4px;
        }
        .image-figure .histogram {
          margin-top: 8px;
        }
        @media (max-width: 600px) {
          .image-figure {
            width: 100%;
            margin-left: 0;
            margin-right: 0;
          }
          .image-figure .grid {
            grid-template-columns: 1fr;
            gap: 16px;
          }
        }
      </style>
      <div class="grid"></div>
    </figure>`;

    const grid = figure.querySelector('.grid');
    const labels = ['Source', 'Result', 'Target'];
    const datasets = [srcData, interpolated, targetData];
    const isMobile = window.innerWidth <= 600;
    const histWidth = isMobile ? Math.min(480, window.innerWidth - 32) : 280;
    const histHeight = isMobile ? 120 : 200;

    datasets.forEach((data, i) => {
      const column = document.createElement('div');
      column.className = 'column';

      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = labels[i];
      column.appendChild(label);

      const canvas = drawImage(data, ...shape);
      canvas.style.width = '100%';
      canvas.style.height = 'auto';
      column.appendChild(canvas);

      const histWrapper = document.createElement('div');
      histWrapper.className = 'histogram';
      const hist = plotHistogram(data, { w: histWidth, h: histHeight });
      hist.style.width = '100%';
      histWrapper.appendChild(hist);
      column.appendChild(histWrapper);

      grid.appendChild(column);
    });

    display(figure);
  </script>
  <script id="convergence-plot" type="module">
    // Re-render when result changes (result is yielded iteratively)
    result;
    display(html`<figure>${Plot.plot({
      height: 150,
      width: Math.min(width, 400),
      y: { grid: true, type: "log" },
      x: { grid: true },
      marks: [
        Plot.lineY(state.history, { x: "iteration", y: "delta" }),
        Plot.ruleY([tolerance], { strokeDasharray: "4,4", stroke: "rgb(200 0 0)" })
      ]
    })}</figure>`);
  </script>
  <script id="smooth-histogram-input" type="module">
    const smoothHistogram = view(Inputs.checkbox(["Smooth histograms"], {
      value: ["Smooth histograms"]
    }));
  </script>
  <script id="state" type="module">
    const state = { history: [] };
  </script>
  <script id="interpolated" type="module">
    const N = result.src.length;
    const out = new Uint8ClampedArray(N);
    for (let i = 0; i < N; i++) {
      out[i] = srcData[i] + (result.src[i] - srcData[i]) * interpolate;
    }
    const interpolated = out;
  </script>
  <script id="result" type="module">
    restart;
    state.history = [];
    const result = Generators.observe(notify => {
      let cancelled = false;
      const gen = slicedOptimalTransport(srcData.slice(), targetData, {
        maxIterations,
        batchSize,
        tolerance,
        state
      });

      async function step() {
        if (cancelled) return;
        const { value, done } = await gen.next();
        if (cancelled) return;
        if (value) {
          notify(value);
        }
        if (!done && !cancelled) {
          requestAnimationFrame(step);
        }
      }
      step();

      return () => { cancelled = true; };
    });
  </script>
  <script id="worker-pool" type="module">
    // Worker code as a string
    const workerCode = `
      function sort(values, indices, left, right) {
        let tmp;
        if (left >= right) return;
        const pivot = values[(left + right) >> 1];
        let i = left - 1;
        let j = right + 1;
        while (true) {
          do i++;
          while (values[i] < pivot);
          do j--;
          while (values[j] > pivot);
          if (i >= j) break;
          tmp = values[i];
          values[i] = values[j];
          values[j] = tmp;
          tmp = indices[i];
          indices[i] = indices[j];
          indices[j] = tmp;
        }
        sort(values, indices, left, j);
        sort(values, indices, j + 1, right);
      }

      function randn() {
        let u = 0, v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
      }

      function vec3normalize(out, a) {
        const x = a[0], y = a[1], z = a[2];
        let len = x * x + y * y + z * z;
        if (len > 0) len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
        return out;
      }

      self.onmessage = function(e) {
        const { id, src, tgt, N } = e.data;
        const index = new Uint32Array(N);
        const srcProjection = new Float32Array(N);
        const tgtProjection = new Float32Array(N);
        const adjustment = new Float32Array(N * 3);

        const [v0, v1, v2] = vec3normalize([], [randn(), randn(), randn()]);

        for (let i = 0, i4 = 0; i < N; i++, i4 += 4) {
          index[i] = i;
          srcProjection[i] = v0 * src[i4] + v1 * src[i4 + 1] + v2 * src[i4 + 2];
          tgtProjection[i] = v0 * tgt[i4] + v1 * tgt[i4 + 1] + v2 * tgt[i4 + 2];
        }

        sort(srcProjection, index, 0, N - 1);
        tgtProjection.sort();

        for (let j = 0; j < N; j++) {
          const projectedDiff = tgtProjection[j] - srcProjection[j];
          const i3 = index[j] * 3;
          adjustment[i3 + 0] = v0 * projectedDiff;
          adjustment[i3 + 1] = v1 * projectedDiff;
          adjustment[i3 + 2] = v2 * projectedDiff;
        }

        self.postMessage({ id, adjustment }, [adjustment.buffer]);
      };
    `;

    const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
    const workerUrl = URL.createObjectURL(workerBlob);
    const numWorkers = navigator.hardwareConcurrency || 4;

    // Create workers with message ID tracking
    const pendingJobs = new Map();
    let nextJobId = 0;

    const workerPool = Array.from({ length: numWorkers }, () => {
      const worker = new Worker(workerUrl);
      worker.onmessage = (e) => {
        const { id, adjustment } = e.data;
        const resolve = pendingJobs.get(id);
        if (resolve) {
          pendingJobs.delete(id);
          resolve(adjustment);
        }
      };
      return worker;
    });

    function runWorkerJob(workerIndex, src, tgt, N) {
      const id = nextJobId++;
      const worker = workerPool[workerIndex % workerPool.length];
      return new Promise(resolve => {
        pendingJobs.set(id, resolve);
        worker.postMessage({ id, src, tgt, N });
      });
    }

    invalidation.then(() => {
      workerPool.forEach(w => w.terminate());
      URL.revokeObjectURL(workerUrl);
      pendingJobs.clear();
    });
  </script>
  <script id="original-code" type="text/markdown">
    My original code [from this notebook](https://observablehq.com/@rreusser/sliced-optimal-transport) is presented below. However, this is *not* the code being run in this notebook. This notebook uses a Web Worker pool to perform the batches in parallel since the algorithm can get a bit slow. You can read the modified implementation [the Notebook Kit source for this page](https://github.com/rreusser/notebooks/tree/main/src/sliced-optimal-transport/index.html).
    ```js
    function* slicedOptimalTransport(
  src,
  tgt,
  { maxIterations = 100, batchSize = 4, tolerance = 1 } = {}
) {
  if (src.length !== tgt.length)
    throw new Error("Source size must equal target size");

  // TODO: I could probably avoid this if I better understood generator functions
  mutable history = [];

  const N = src.length >> 2;
  const index = new Uint32Array(N);
  const srcProjection = new Float32Array(N);
  const tgtProjection = new Float32Array(N);
  const adjustment = new Float32Array(N * 3);

  let delta = Infinity;
  let iteration = 0;
  while (delta > tolerance && ++iteration <= maxIterations) {
    adjustment.fill(0);
    for (let batchIndex = 0; batchIndex < batchSize; batchIndex++) {
      let [v0, v1, v2] = vec3normalize([], [randn(), randn(), randn()]);

      for (let i = 0, i4 = 0; i < N; i++, i4 += 4) {
        index[i] = i;
        srcProjection[i] = v0 * src[i4] + v1 * src[i4 + 1] + v2 * src[i4 + 2];
        tgtProjection[i] = v0 * tgt[i4] + v1 * tgt[i4 + 1] + v2 * tgt[i4 + 2];
      }

      // Native sort works for target since all we need is the sorted vector, but
      // custom sort is required for the source since we need to sort the indices
      // in parallel with the projection.
      sort(srcProjection, index, 0, N - 1);
      tgtProjection.sort();

      for (let j = 0; j < N; j++) {
        const projectedDiff = tgtProjection[j] - srcProjection[j];
        const i3 = index[j] * 3;
        adjustment[i3 + 0] += v0 * projectedDiff;
        adjustment[i3 + 1] += v1 * projectedDiff;
        adjustment[i3 + 2] += v2 * projectedDiff;
      }
    }

    delta = 0;
    for (let i3 = 0, i4 = 0; i4 < N * 4; i3 += 3, i4 += 4) {
      const dr = adjustment[i3] / batchSize;
      const dg = adjustment[i3 + 1] / batchSize;
      const db = adjustment[i3 + 2] / batchSize;
      src[i4] += dr;
      src[i4 + 1] += dg;
      src[i4 + 2] += db;
      delta += dr * dr + dg * dg + db * db;
    }
    delta = Math.sqrt(delta / N);
    mutable history = mutable history.concat([{ iteration, delta }]);

    yield { delta, src };
  }

  return { delta, src };
}
```
  </script>
  <script id="sliced-optimal-transport" type="module">
    async function* slicedOptimalTransport(
      src,
      tgt,
      { maxIterations = 100, batchSize = 4, tolerance = 1, state } = {}
    ) {
      if (src.length !== tgt.length)
        throw new Error("Source size must equal target size");

      state.history = [];

      const N = src.length >> 2;

      // Convert to Float32Array for workers
      const srcFloat = new Float32Array(src);
      const tgtFloat = new Float32Array(tgt);

      let delta = Infinity;
      let iteration = 0;
      while (delta > tolerance && ++iteration <= maxIterations) {
        const adjustment = await runBatchParallel(srcFloat, tgtFloat, N, batchSize);

        delta = 0;
        for (let i3 = 0, i4 = 0; i4 < N * 4; i3 += 3, i4 += 4) {
          const dr = adjustment[i3] / batchSize;
          const dg = adjustment[i3 + 1] / batchSize;
          const db = adjustment[i3 + 2] / batchSize;
          srcFloat[i4] += dr;
          srcFloat[i4 + 1] += dg;
          srcFloat[i4 + 2] += db;
          delta += dr * dr + dg * dg + db * db;
        }
        delta = Math.sqrt(delta / N);
        state.history = state.history.concat([{ iteration, delta }]);

        // Convert back to Uint8ClampedArray for display
        const srcClamped = new Uint8ClampedArray(srcFloat.length);
        for (let i = 0; i < srcFloat.length; i++) {
          srcClamped[i] = srcFloat[i];
        }

        yield { delta, src: srcClamped };
      }

      const srcClamped = new Uint8ClampedArray(srcFloat.length);
      for (let i = 0; i < srcFloat.length; i++) {
        srcClamped[i] = srcFloat[i];
      }
      return { delta, src: srcClamped };
    }
  </script>
  <script id="run-batch-parallel" type="module">
    async function runBatchParallel(src, tgt, N, batchSize) {
      const promises = [];
      for (let i = 0; i < batchSize; i++) {
        promises.push(runWorkerJob(i, src, tgt, N));
      }
      const adjustments = await Promise.all(promises);
      const combined = new Float32Array(N * 3);
      for (const adj of adjustments) {
        for (let i = 0; i < combined.length; i++) {
          combined[i] += adj[i];
        }
      }
      return combined;
    }

  </script>
  <script id="shape" type="module">
    const shape = [(src.width / downsample) | 0, (src.height / downsample) | 0];
  </script>
  <script id="draw-image" type="module">
    function drawImage(data, width, height, pixelRatio = 2) {
      const canvas = document.createElement("canvas");
      canvas.style.width = `${(width * downsample) / pixelRatio}px`;
      canvas.style.height = `${(height * downsample) / pixelRatio}px`;
      canvas.width = width;
      canvas.height = height;
      canvas.style.display = "inline-block";
      const ctx = canvas.getContext("2d");
      const imageData = ctx.getImageData(0, 0, width, height);
      imageData.data.set(data);
      ctx.putImageData(imageData, 0, 0);
      return canvas;
    }
  </script>
  <script id="get-pixels" type="module">
    function getPixels(bitmap, width, height) {
      const canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(bitmap, 0, 0, width, height);
      return ctx.getImageData(0, 0, canvas.width, canvas.height).data;
    }
  </script>
  <script id="files" type="module">
    const FILES = {
      ellingwood: "./files/c58f14ea40fe9b49f83785c23645ee1072b664c9bfa5bb37a3655cfa62f7b20a2f4d4d2f8144e8d84f7e8cd00b93dcb5d02182bee95f9296af3b09311c3d95a1.jpeg",
      gravity: "./files/e39dd4f989d7be57001e54b4b802b1b99ab2fa5cadf1c098188688804cb6195669d716c2fe53db92d5273dac240264b118f82f3d338938768b82239c7dd87c77.jpeg",
      m61: "./files/4a85b5049d0730eaf366a077a9b2e8ec20f6f1db333016940e5721572b151e78ee0d439c43309b79516fd9294319b9e7b57eb548b805752ae7177e84be0cd82d.jpeg",
      webb: "./files/0a5749ce7542538934ccfe722a3ca52a660f087d215de9be268debab1426e0fb243cc1727a4e59a50bab0e24fadc2201c51f04197ec4fc8af094784defc1c637.jpeg",
      yosemite: "./files/71d8bb781fd97bd249fcc54a15bd83d63e89873694b2997b7ad9b74aa0cd53416756a49f88940ca3d0443269a3d7d1d653623eb64740df2a5dbb76d4570c506a.jpeg",
      yosemite2: "./files/c1f51c8c6e3252ca13e095cb761d53f304b6229ea35d26f0f525afaa58bab8676c7322fc3295c7e4d58d71189ac430e71ac0b58c4150a050f178ee8b782f968a.jpeg",
      yosemite3: "./files/58ca4af43850e99ae7e803776cb0e0743632409ddb9a8443947b8ced33b0c1f2725f4f4785f01ef2391d4950c7aa2dd69998aaa054c5226609b4d67e8531ccb7.jpeg",
      yosemite4: "./files/c5704d9f812eb8688d923ee94f1e580e755e9ad2e1e307c20ef0f08476a7e267313332ed25b2e703c3eec6de94cca6145a8477a282419f50426795e8c8bdff5b.jpeg",
      topographic: "./files/376052d1d580b6d1aef50672fca343a60f4944f87fb2ebb7caaff9d4f0c72403d85cc1d3b055bb9d5d1f59c959aaebc77e289656ecd5f8502be2b0f23b1b9d92.jpeg",
      bigcat: "./files/996456a95748650ad01099eb60c40918a5223b11a901d6ecfe8501cb3b2d99feabb73b1395429e4a2bab611dcb62627e56e594bf46198028908ca666859f28cd.jpeg",
      hokitika: "./files/49d6c2c00a0df0ad75f03c4f039fe0c8df2a8b244e4754d53821f4e0ff892a3c541ef65dd2b987b0e7d8b5b5ddc02d055a9037f72df4f48560a90636d1004da6.jpeg",
      "arthur's pass": "./files/6bc1a98f862ef68f3148b9ed7e9c8db7c570b97a55b492048ad3f2dc905a23dc78c7d299c6d86c941845db1ab8d85db83ff8b171ac41dca3e86990ca99354c5b.jpeg",
      rainier: "./files/be256269735534c96b4c5d31bdf7658887d43c965c683bce12733255b73953df9547987434ba4eed313bb5ec377fb77f52c7ba45be6e179ba82c0951609f6cb0.jpeg",
      shelf: "./files/c857167781f363f1ef67c1167806bef2f252d025ae3f0e02790d107d21a54cfd6572f059870c6066d039db832be2f9f75a68500e0590064f98028c1ea1e4c7f2.jpeg",
      cranes: "./files/95e6df9d1056dc4272cf82fa22ccd42e8fdf710a726f8b7b0634d7d46f81432cf59ad8b99a4ba54a8ee24733fde167eea11340d9b87edaa3ee203e3e4341c620.jpeg",
      "smith rock": "./files/77f89c7f66afe86a50a1a0ca1ffd15399da4fad3595cd3e8aae81ce29e4600c487e9e2c58b1dfa137535f81e61d940a22e793f36aac74238d3feb2d7e1aa6248.jpeg",
      dog: "./files/d8d6f7a92241e1b547146a09d0b2accc10e0e26d6af900f06a703a78b698817f53c68542af7009c1f21d9e92d258c752d99947debadeff36b26d83e2d123ad16.jpeg",
      "ansel adams": "./files/23e308face2741c20e26b3f68362aa6004fd188cca1f97f3dbdbfa7cd2fa66eb3d882487afe50878477ac41c82837ccd1a5ed68946040a61cdaf68709b365bef.jpeg"
    };
  </script>
  <script id="src" type="module">
    const src = await createImageBitmap(await (await fetch(FILES[sourceFile])).blob());
  </script>
  <script id="target" type="module">
    const target = await createImageBitmap(await (await fetch(FILES[targetFile])).blob());
  </script>
  <script id="src-data" type="module">
    const srcData = getPixels(src, src.width / downsample, src.height / downsample);
  </script>
  <script id="target-data" type="module">
    const targetData = getPixels(target, src.width / downsample, src.height / downsample);
  </script>
  <script id="smooth" type="module">
    function smooth(a) {
      const b = a.slice();
      const n = a.length;
      for (let i = 0; i < n; i++) {
        b[i] =
          0.25 * (a[Math.max(0, i - 1)] + a[Math.min(n - 1, i + 1)]) + 0.5 * a[i];
      }
      for (let i = 0; i < n; i++) {
        a[i] =
          0.25 * (b[Math.max(0, i - 1)] + b[Math.min(n - 1, i + 1)]) + 0.5 * b[i];
      }
      return a;
    }
  </script>
  <script id="plot-histogram" type="module">
    function plotHistogram(
      data,
      { w = Math.max(320, Math.min(src.width / devicePixelRatio, width / 3)), h = 200 } = {}
    ) {
      function computeHistogram(data) {
        const n = data.length;
        let r = new Uint16Array(256);
        let g = new Uint16Array(256);
        let b = new Uint16Array(256);
        for (let i = 0; i < n; i += 4) {
          r[data[i]]++;
          g[data[i + 1]]++;
          b[data[i + 2]]++;
        }
        if (~smoothHistogram.indexOf("Smooth histograms")) {
          r = smooth(r);
          g = smooth(g);
          b = smooth(b);
        }
        return { r, g, b };
      }

      const { r, g, b } = computeHistogram(data);
      // We like structs of arrays, but observable plot demands arrays of structs
      const transposed = [];
      for (let i = 0; i < 256; i++) {
        transposed[i] = { level: i, r: r[i], g: g[i], b: b[i] };
      }
      const el = Plot.plot({
        height: h,
        width: w,
        y: { grid: true },
        x: { grid: true },
        marks: [
          Plot.areaY(transposed, {
            x: "level",
            y: "r",
            stroke: "rgb(255 0 0/100%)",
            fill: "rgb(200 0 0/20%)"
          }),
          Plot.areaY(transposed, {
            x: "level",
            y: "g",
            stroke: "rgb(0 150 0/100%)",
            fill: "rgb(0 150 0/20%)"
          }),
          Plot.areaY(transposed, {
            x: "level",
            y: "b",
            stroke: "rgb(0 0 255/100%)",
            fill: "rgb(0 0 255/15%)"
          })
        ]
      });
      el.style.display = "inline-block";
      return el;
    }
  </script>
  <script id="vec3normalize" type="module">
    function vec3normalize(out, a) {
      const x = a[0], y = a[1], z = a[2];
      let len = x * x + y * y + z * z;
      if (len > 0) len = 1 / Math.sqrt(len);
      out[0] = a[0] * len;
      out[1] = a[1] * len;
      out[2] = a[2] * len;
      return out;
    }
  </script>
  <script id="randn" type="module">
    // Box-Muller transform for standard normal distribution
    function randn() {
      let u = 0, v = 0;
      while (u === 0) u = Math.random();
      while (v === 0) v = Math.random();
      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }
  </script>
</notebook>
