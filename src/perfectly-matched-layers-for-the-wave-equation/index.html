<!doctype html>
<notebook theme="air">
  <title>Perfectly Matched Layers for the Wave Equation</title>
  <script id="32" type="text/markdown">
    # Perfectly Matched Layers for the Wave Equation
  </script>
  <script id="33" type="text/markdown">
    When simulating wave propagation on a computational grid, a common problem is how to prevent waves from reflecting back into the domain. In physical systems, waves often propagate through unbounded space, but our simulations must work within finite memory. Simply truncating the domain causes waves to reflect artificially from the boundaries, contaminating the solution.
  </script>
  <script id="1" type="text/markdown">
    **Perfectly Matched Layers (PML)** solve this problem by adding absorbing regions at the domain boundaries that eliminate reflections for all angles and frequencies. The technique is based on an analytic continuation of the wave equation into the complex domain. This allows waves to be attenuated independent of frequency, which is not something we can achieve with a simple damping term like for a damped spring. Even better, waves end up decaying both as the propagate toward the layer and as any residual reflections propagate back into the domain.
  </script>
  <script id="34" type="text/markdown">
    For comparison, this complex variable trick causes the absorbing layer to behave differently from physical absorbers such as sound-dampening foam, where high frequencies attenuate much more quickly relative to the width of the absorbing material, allowing low frequencies to pass through. Additionally, spurious reflections result when waves travling in the interior medium suddenly encounter the impedance of the absorbing layer.
  </script>
  <script id="35" type="text/markdown">
    This notebook demonstrates PML for the scalar wave equation, starting with a 1D example before extending to 2D.
  </script>
  <script id="59" type="text/markdown">
    ## The 1D Wave Equation
  </script>
  <script id="23" type="text/markdown">
    The [scalar wave equation](https://en.wikipedia.org/wiki/Wave_equation) for any number of dimensions is given by

    ${tex.block`\frac{\partial^2 u}{\partial t^2} = c^2 \nabla^2 u.`}
  </script>
  <script id="24" type="text/markdown">
    For one dimension, we have

    ${tex.block`\frac{\partial^2 u}{\partial t^2} = c^2 \frac{\partial^2 u}{\partial x^2}.`}
  </script>
  <script id="2" type="text/markdown">
    We could apply PML to this equation, but it will turn out to be easier and require about the same amount of computational work to apply it to what’s probably a less familiar but strictly equivalent form which contains only first-order derivatives,

    ${tex.block`\begin{aligned}
    \frac{\partial u}{\partial t} &= c \frac{\partial v}{\partial x} \\[10pt]
    \frac{\partial v}{\partial t} &= c \frac{\partial u}{\partial x}.
    \end{aligned}`}

    Here, ${tex`u`} is the state variable (e.g. pressure) while ${tex`v`} functions like a velocity.
  </script>
  <script id="51" type="text/markdown">
    ## 1D PML Derivation
  </script>
  <script id="25" type="text/markdown">
    The key insight of PML is to work in the Fourier time domain and apply a complex coordinate stretching to the spatial derivatives. In practical terms, this means replacing spatial derivatives with a modified operator.
  </script>
  <script id="26" type="text/markdown">
    We begin by transforming to the Fourier time domain, replacing ${tex`\frac{\partial}{\partial t}`} with ${tex`-i\omega,`}

    ${tex.block`\begin{aligned}
    -i\omega u &= c \frac{\partial v}{\partial x} \\[10pt]
    -i\omega v &= c \frac{\partial u}{\partial x}.
    \end{aligned}`}
  </script>
  <script id="27" type="text/markdown">
    The PML technique replaces spatial derivatives with a complex coordinate mapping

    ${tex.block`\frac{\partial}{\partial x} \rightarrow \frac{1}{1 + i\frac{\sigma}{\omega}} \frac{\partial}{\partial x}`}
  </script>
  <script id="28" type="text/markdown">
    where ${tex`\sigma(x) \geq 0`} is the absorption strength. This stretching causes waves to decay exponentially in regions where ${tex`\sigma > 0`}. Notice that for ${tex`\sigma = 0`} (no absorption), this reduces to ${tex`\frac{\partial}{\partial x}`}.
  </script>
  <script id="29" type="text/markdown">
    Applying this mapping gives

    ${tex.block`\begin{aligned}
    -i\omega u &= c \frac{1}{1 + i\frac{\sigma}{\omega}} \frac{\partial v}{\partial x} \\[10pt]
    -i\omega v &= c \frac{1}{1 + i\frac{\sigma}{\omega}} \frac{\partial u}{\partial x}
    \end{aligned}`}

  </script>
  <script id="30" type="text/markdown">
    Multiplying both sides by ${tex`1 + i\frac{\sigma}{\omega}`} gives

    ${tex.block`\begin{aligned}
    -i\omega u - \sigma u &= c \frac{\partial v}{\partial x} \\[10pt]
    -i\omega v - \sigma v &= c \frac{\partial u}{\partial x}.
    \end{aligned}`}

  </script>
  <script id="31" type="text/markdown">
    Transforming back to the time domain gives the final 1D PML equations

    ${tex.block`\begin{aligned}
    \frac{\partial u}{\partial t} &= c \frac{\partial v}{\partial x} - \sigma u \\[10pt]
    \frac{\partial v}{\partial t} &= c \frac{\partial u}{\partial x} - \sigma v.
    \end{aligned}`}

  </script>
  <script id="3" type="text/markdown">
    In the interior where ${tex`\sigma = 0`}, these reduce to the original wave equation. In the PML regions, ${tex`\sigma > 0`} causes exponential absorption.
  </script>
  <script id="52" type="text/markdown">
    ## 1D Visualization
  </script>
  <script id="4" type="text/markdown">
    The plot below shows a 1D wave propagating with PML absorbing boundaries on both ends. The shaded regions indicate where ${tex`\sigma > 0`}. Notice how waves exit the domain smoothly without reflecting.
  </script>
  <script id="5" type="module">
    // Mutable params object to avoid reactive flickering
    const params_1d = {
      pmlWidth: 6,
      pmlStrength: 2.0,
      frequency: 0.1
    };
  </script>
  <script id="6" type="module">
    const pmlWidth1d = view(Inputs.range([1, 40], {label: "PML width (grid points)", step: 1, value: 6}));
    const pmlStrength1d = view(Inputs.range([0.1, 5.0], {label: "PML strength", step: 0.1, value: 2.0}));
    const frequency1d = view(Inputs.range([0.025, 0.2], {label: "Oscillator frequency", step: 0.005, value: 0.1}));
  </script>
  <script id="7" type="module">
    // Update params object when controls change (doesn't restart visualization)
    params_1d.pmlWidth = pmlWidth1d;
    params_1d.pmlStrength = pmlStrength1d;
    params_1d.frequency = frequency1d;
  </script>
  <script id="8" type="module">
    import * as Plot from "npm:@observablehq/plot";

    // Simulation parameters
    const N = 200;                    // Grid points
    const PML_EXPONENT = 2.0;         // PML power law exponent
    const C = 1.0;                    // Wave speed
    const DX = 1.0;                   // Grid spacing
    const DT = 0.1 * DX / C;          // Time step (CFL condition)
    const OSCILLATOR_STRENGTH = 4.0;  // Disturbance strength
    const OSCILLATOR_WAVELENGTH = 10.0; // Wavelength of oscillators

    // State arrays
    const u = new Float64Array(N);      // Scalar field
    const v = new Float64Array(N);      // Velocity field

    let t = 0;  // Simulation time

    // Compute sigma at any position x (for staggered grid)
    function sigma_at_position(x) {
      const leftDist = x;
      const rightDist = (N - 1) - x;

      let s = 0;
      if (leftDist < params_1d.pmlWidth) {
        s = Math.max(s, Math.pow((params_1d.pmlWidth - leftDist) / params_1d.pmlWidth, PML_EXPONENT) * params_1d.pmlStrength);
      }
      if (rightDist < params_1d.pmlWidth) {
        s = Math.max(s, Math.pow((params_1d.pmlWidth - rightDist) / params_1d.pmlWidth, PML_EXPONENT) * params_1d.pmlStrength);
      }
      return s;
    }

    // Sigma for u at integer positions
    function sigma(i) {
      return sigma_at_position(i);
    }

    // Sigma for v at half-integer positions
    function sigma_v(i) {
      return sigma_at_position(i + 0.5);
    }

    // Compute forcing term at position i and time t
    function forcing(i, t) {
      const pulseInterval = 300.0;
      const pulse = Math.exp(-Math.pow(Math.abs((t % pulseInterval - pulseInterval * 0.5) / 40.0), 4.0));
      const COUNT = 5;
      const omega = C * Math.PI * params_1d.frequency;

      // Scale amplitude inversely with frequency to maintain constant wave amplitude
      // Lower frequencies get proportionally stronger forcing
      const amplitudeScale = 0.1 / params_1d.frequency;

      let f = 0;
      for (let j = 0; j < COUNT; j++) {
        const offset = (j - COUNT * 0.5) / COUNT * 20.0;
        const center = N / 2 + offset;
        const dist = Math.abs(i - center);

        // Wider, smoother spatial mask (10 grid points)
        const width = 3.0;
        const mask = Math.exp(-Math.pow(dist / width, 2));

        const f0 = Math.sin(omega * t / (j + 1));
        f += f0 * mask * OSCILLATOR_STRENGTH * amplitudeScale * pulse;
      }
      return f;
    }

    // Right-hand side functions for RK4 with staggered grid
    // u is at integer points i
    // v is at half-integer points i+0.5 (stored as v[i])
    function dudt(u_arr, v_arr, t_val) {
      const result = new Float64Array(N);

      // Interior points
      for (let i = 1; i < N - 1; i++) {
        // ∂v/∂x at point i using staggered grid: (v[i] - v[i-1]) / DX
        // v[i] is at position i+0.5, v[i-1] is at position i-0.5
        const dvdx = (v_arr[i] - v_arr[i - 1]) / DX;
        result[i] = C * dvdx - sigma(i) * u_arr[i];
      }

      // Left boundary (i=0): use forward difference from interior v points
      const dvdx_left = (v_arr[1] - v_arr[0]) / DX;
      result[0] = C * dvdx_left - sigma(0) * u_arr[0];

      // Right boundary (i=N-1): use backward difference from interior v points
      const dvdx_right = (v_arr[N - 2] - v_arr[N - 3]) / DX;
      result[N - 1] = C * dvdx_right - sigma(N - 1) * u_arr[N - 1];

      return result;
    }

    function dvdt(u_arr, v_arr, t_val) {
      const result = new Float64Array(N);
      for (let i = 0; i < N - 1; i++) {
        // ∂u/∂x at point i+0.5 using staggered grid: (u[i+1] - u[i]) / DX
        const dudx = (u_arr[i + 1] - u_arr[i]) / DX;
        const f = forcing(i + 0.5, t_val);  // Forcing at half-integer position
        result[i] = C * dudx - sigma_v(i) * v_arr[i] + f;
      }
      return result;
    }

    // RK4 time step
    function step() {
      // Create temporary arrays
      const u_temp = new Float64Array(N);
      const v_temp = new Float64Array(N);

      // k1
      const ku1 = dudt(u, v, t);
      const kv1 = dvdt(u, v, t);

      // k2
      for (let i = 0; i < N; i++) {
        u_temp[i] = u[i] + 0.5 * DT * ku1[i];
        v_temp[i] = v[i] + 0.5 * DT * kv1[i];
      }
      const ku2 = dudt(u_temp, v_temp, t + 0.5 * DT);
      const kv2 = dvdt(u_temp, v_temp, t + 0.5 * DT);

      // k3
      for (let i = 0; i < N; i++) {
        u_temp[i] = u[i] + 0.5 * DT * ku2[i];
        v_temp[i] = v[i] + 0.5 * DT * kv2[i];
      }
      const ku3 = dudt(u_temp, v_temp, t + 0.5 * DT);
      const kv3 = dvdt(u_temp, v_temp, t + 0.5 * DT);

      // k4
      for (let i = 0; i < N; i++) {
        u_temp[i] = u[i] + DT * ku3[i];
        v_temp[i] = v[i] + DT * kv3[i];
      }
      const ku4 = dudt(u_temp, v_temp, t + DT);
      const kv4 = dvdt(u_temp, v_temp, t + DT);

      // Final update
      for (let i = 1; i < N - 1; i++) {
        u[i] += (DT / 6) * (ku1[i] + 2 * ku2[i] + 2 * ku3[i] + ku4[i]);
        v[i] += (DT / 6) * (kv1[i] + 2 * kv2[i] + 2 * kv3[i] + kv4[i]);
      }

      t += DT;
    }

    // Create container for the plot
    const container = html`<div></div>`;

    // Animation loop
    let frameCount = 0;
    let animationId;
    let isVisible = false;

    function animate() {
      // Only animate if visible
      if (!isVisible) return;

      // Run multiple steps per frame for speed
      for (let s = 0; s < 5; s++) {
        step();
      }

      frameCount++;

      // Update plot every few frames
      if (frameCount % 2 === 0) {
        const data = Array.from({ length: N }, (_, i) => ({
          x: i,
          u: u[i],
          sigma: sigma(i)
        }));
        const yrange = 50;

        const chart = Plot.plot({
          width: 640,
          height: 300,
          marginLeft: 50,
          x: {
            label: "Position",
            domain: [0, N]
          },
          y: {
            label: "u(x,t)",
            domain: [-yrange, yrange]
          },
          marks: [
            // PML regions background
            Plot.ruleX(data, {
              x: "x",
              y1: -yrange,
              y2: yrange,
              stroke: "#DDA0DD",  // Plum color
              strokeWidth: 3,
              strokeOpacity: d => d.sigma > 0 ? 0.3 : 0
            }),

            // Wave field as dots
            Plot.dot(data, {
              x: "x",
              y: "u",
              fill: "steelblue",
              r: 2
            })
          ]
        });

        container.replaceChildren(chart);
      }

      animationId = requestAnimationFrame(animate);
    }

    // Intersection Observer to only animate when visible
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        isVisible = entry.isIntersecting;
        if (isVisible) {
          if (!animationId) {
            animate();
          }
        } else {
          if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
          }
        }
      });
    });

    observer.observe(container);

    invalidation.then(() => {
      if (animationId) cancelAnimationFrame(animationId);
      observer.disconnect();
    });

    display(container);
  </script>
  <script id="53" type="text/markdown">
    ## Extension to 2D
  </script>
  <script id="9" type="text/markdown">
    The 2D case follows the same principles but with a key difference: we need separate absorption coefficients ${tex`\sigma_x`} and ${tex`\sigma_y`} for each spatial direction. When we apply the complex coordinate mapping independently to both ${tex`x`} and ${tex`y`} derivatives, cross-terms emerge that don't appear in 1D. These cross-terms require an auxiliary field ${tex`\psi`} to handle the coupling between the two spatial directions within the PML regions.
  </script>
  <script id="54" type="text/markdown">
    The derivation below shows how these auxiliary variables arise naturally from the Fourier domain analysis. In regions where only one direction has absorption (e.g., ${tex`\sigma_x > 0`} but ${tex`\sigma_y = 0`}), the equations simplify. The full complexity only appears in corner regions where both directions have non-zero absorption.
  </script>
  <script id="37" type="text/markdown">
    ## 2D Derivation
  </script>
  <script id="38" type="text/markdown">
    We start with the scalar wave equation in first-order form,

    ${tex.block`\begin{aligned}
    \frac{\partial u}{\partial t} &= c (\nabla \cdot \mathbf{v}) \\[10pt]
    \frac{\partial v_x}{\partial t} &= c \frac{\partial u}{\partial x} \\[10pt]
    \frac{\partial v_y}{\partial t} &= c \frac{\partial u}{\partial y}.
    \end{aligned}`}
  </script>
  <script id="39" type="text/markdown">
    Following the same approach as in 1D, we transform to the Fourier time domain, replacing ${tex`\frac{\partial}{\partial t}`} with ${tex`-i\omega`}

    ${tex.block`\begin{aligned}
    -i\omega u &= c \frac{\partial v_x}{\partial x} + c \frac{\partial v_y}{\partial y} \\[10pt]
    -i\omega v_x &= c \frac{\partial u}{\partial x} \\[10pt]
    -i\omega v_y &= c \frac{\partial u}{\partial y}.
    \end{aligned}`}
  </script>
  <script id="40" type="text/markdown">
    The PML technique replaces spatial derivatives with complex coordinate mappings

    ${tex.block`\frac{\partial}{\partial x} \rightarrow \frac{1}{1 + i\frac{\sigma_x}{\omega}} \frac{\partial}{\partial x}, \quad \frac{\partial}{\partial y} \rightarrow \frac{1}{1 + i\frac{\sigma_y}{\omega}} \frac{\partial}{\partial y}`}
  </script>
  <script id="41" type="text/markdown">
    Applying the mapping to the velocity equations and multiplying through by the denominators yields

    ${tex.block`\begin{aligned}
    -i\omega v_x - \sigma_x v_x &= c \frac{\partial u}{\partial x} \\[10pt]
    -i\omega v_y - \sigma_y v_y &= c \frac{\partial u}{\partial y}
    \end{aligned}`}
  </script>
  <script id="42" type="text/markdown">
    Transforming back to the time domain immediately gives

    ${tex.block`\begin{aligned}
    \frac{\partial v_x}{\partial t} &= c \frac{\partial u}{\partial x} - \sigma_x v_x \\[10pt]
    \frac{\partial v_y}{\partial t} &= c \frac{\partial u}{\partial y} - \sigma_y v_y.
    \end{aligned}`}
  </script>
  <script id="43" type="text/markdown">
    The equation for ${tex`u`} is more involved. Applying the PML mapping gives

    ${tex.block`-i\omega u = c \left(\frac{1}{1 + i\frac{\sigma_x}{\omega}} \frac{\partial v_x}{\partial x} + \frac{1}{1 + i\frac{\sigma_y}{\omega}} \frac{\partial v_y}{\partial y}\right)`}
  </script>
  <script id="44" type="text/markdown">
    Expanding and collecting terms yields

    ${tex.block`\begin{aligned}
    -i\omega u &= c \left(\frac{\partial v_x}{\partial x} + \frac{\partial v_y}{\partial y}\right) - (\sigma_x + \sigma_y) u \\
    &\quad + \left(\frac{ic\sigma_x}{\omega} \frac{\partial v_y}{\partial y} + \frac{ic\sigma_y}{\omega} \frac{\partial v_x}{\partial x} - \frac{i}{\omega} \sigma_x \sigma_y u\right)
    \end{aligned}`}
  </script>
  <script id="45" type="text/markdown">
    The term in parentheses contains factors of ${tex`\frac{i}{\omega}`}, which corresponds to time integration. In other words, in additon to integrating the other state variables in time, we need to integrate one more. We define the term in parentheses as the auxiliary quantity ${tex`\psi,`}
  </script>
  <script id="46" type="text/markdown">
    ${tex.block`\psi = \frac{ic\sigma_x}{\omega} \frac{\partial v_y}{\partial y} + \frac{ic\sigma_y}{\omega} \frac{\partial v_x}{\partial x} - \frac{i}{\omega} \sigma_x \sigma_y u`}
  </script>
  <script id="47" type="text/markdown">
    Multiplying through by ${tex`-i\omega`} and transforming back to the time domain gives

    ${tex.block`\frac{d\psi}{dt} = c \sigma_x \frac{\partial v_y}{\partial y} + c \sigma_y \frac{\partial v_x}{\partial x} - \sigma_x \sigma_y u`}
  </script>
  <script id="48" type="text/markdown">
    The update equation for ${tex`u`} then becomes

    ${tex.block`\frac{du}{dt} = c (\nabla \cdot \mathbf{v}) - (\sigma_x + \sigma_y) u + \psi.`}
  </script>
  <script id="11" type="text/markdown">
    Together with the velocity equations, we have the complete 2D PML system

    ${tex.block`\begin{aligned}
    \frac{\partial u}{\partial t} &= c (\nabla \cdot \mathbf{v}) - (\sigma_x + \sigma_y) u + \psi \\[10pt]
    \frac{\partial \psi}{\partial t} &= c \sigma_x \frac{\partial v_y}{\partial y} + c \sigma_y \frac{\partial v_x}{\partial x} - \sigma_x \sigma_y u \\[10pt]
    \frac{\partial v_x}{\partial t} &= c \frac{\partial u}{\partial x} - \sigma_x v_x \\[10pt]
    \frac{\partial v_y}{\partial t} &= c \frac{\partial u}{\partial y} - \sigma_y v_y
    \end{aligned}`}
  </script>
  <script id="49" type="text/markdown">
    These equations require tracking three fields: the scalar field ${tex`u`}, the auxiliary field ${tex`\psi`}, and the vector field ${tex`\mathbf{v} = (v_x, v_y)`}. In practice, this naturally lends itself to a two-buffer implementation: one storing ${tex`(u, \psi)`} and the other storing ${tex`(v_x, v_y)`}. The two buffers are offset by half a timestep to avoid some of the common instabilities encountered when simulating wave equations.
  </script>
  <script id="56" type="text/markdown">
    ## Implementation
  </script>
  <script id="50" type="text/markdown">
    The following WebGL implementation simulates these equations on the GPU using fragment shaders. Use the controls below to pause/resume the simulation, adjust contrast, and visualize the PML absorption regions (red for ${tex`\sigma_x`}, green for ${tex`\sigma_y`}).
  </script>
  <script id="17" type="module">
    const canvas = html`<canvas width="640" height="640" style="width: 100%; height: auto; display: block; image-rendering: pixelated;"></canvas>`;
    const gl = canvas.getContext("webgl2");

    if (!gl) {
      throw new Error('WebGL 2 is not supported');
    }

    // Enable floating-point textures as render targets
    const ext = gl.getExtension('EXT_color_buffer_float');
    if (!ext) {
      throw new Error('EXT_color_buffer_float extension is not supported');
    }

    // Constants
    const PML_WIDTH = 12.0;
    const PML_EXPONENT = 2.0;
    const PML_STRENGTH = 1.0;
    const OSCILLATOR_STRENGTH = 4.0;
    const OSCILLATOR_WAVELENGTH = 10.0;
    const C = 1.0;
    const DT = 0.5;
    const DX = 1.0;

    // Vertex shader
    const vertexShaderSource = `#version 300 es
        in vec2 a_position;
        void main() {
          gl_Position = vec4(a_position, 0.0, 1.0);
        }
      `;

      // Common functions for shaders
      const commonSource = `
        const float PML_WIDTH = ${PML_WIDTH.toFixed(1)};
        const float PML_EXPONENT = ${PML_EXPONENT.toFixed(1)};
        const float PML_STRENGTH = ${PML_STRENGTH.toFixed(1)};
        const float OSCILLATOR_STRENGTH = ${OSCILLATOR_STRENGTH.toFixed(1)};
        const float OSCILLATOR_WAVELENGTH = ${OSCILLATOR_WAVELENGTH.toFixed(1)};
        const float C = ${C.toFixed(1)};
        const float DT = ${DT.toFixed(1)};
        const float DX = ${DX.toFixed(1)};
        const float PI = 3.14159265358979;

        float linearstep(float a, float b, float x) {
          return clamp((x - a) / (b - a), 0.0, 1.0);
        }

        vec2 sigma(vec2 coord, vec2 res) {
          return pow(
            abs(vec2(
              linearstep(PML_WIDTH, 0.0, coord.x) + linearstep(res.x - PML_WIDTH, res.x, coord.x),
              linearstep(PML_WIDTH, 0.0, coord.y) + linearstep(res.y - PML_WIDTH, res.y, coord.y)
            )),
            vec2(PML_EXPONENT)
          ) * PML_STRENGTH;
        }
      `;

      // Buffer A shader (updates u and psi)
      const bufferASource = `#version 300 es
        precision highp float;
        ${commonSource}
        uniform sampler2D u_bufferA;
        uniform sampler2D u_bufferB;
        uniform vec2 u_resolution;
        uniform float u_pmlWidth;
        uniform float u_usePsi;
        uniform float u_mouseX;
        uniform float u_mouseY;
        uniform float u_mouseMoving;
        uniform float u_mouseActive;
        out vec4 fragColor;

        vec2 sigmaCompute(vec2 coord, vec2 res, float pmlWidth) {
          return pow(
            abs(vec2(
              linearstep(pmlWidth, 0.0, coord.x) + linearstep(res.x - pmlWidth, res.x, coord.x),
              linearstep(pmlWidth, 0.0, coord.y) + linearstep(res.y - pmlWidth, res.y, coord.y)
            )),
            vec2(PML_EXPONENT)
          ) * PML_STRENGTH;
        }

        void main() {
          ivec2 p = ivec2(gl_FragCoord.xy);
          vec4 state = texelFetch(u_bufferA, p, 0);
          float u = state.x, psi = state.y, t = state.z;

          float vx1 = texelFetch(u_bufferB, p + ivec2(1, 0), 0).x;
          float vx0 = texelFetch(u_bufferB, p + ivec2(-1, 0), 0).x;
          float vy1 = texelFetch(u_bufferB, p + ivec2(0, 1), 0).y;
          float vy0 = texelFetch(u_bufferB, p + ivec2(0, -1), 0).y;

          float dvxdx = (vx1 - vx0) / (2.0 * DX);
          float dvydy = (vy1 - vy0) / (2.0 * DX);

          vec2 s = sigmaCompute(gl_FragCoord.xy, u_resolution, u_pmlWidth);

          // When usePsi is disabled, use naive 2D extension (which won't work well)
          float psiContribution = u_usePsi > 0.5 ? psi : 0.0;
          float psiUpdate = u_usePsi > 0.5 ? (s.x * dvydy + s.y * dvxdx - u * s.x * s.y) : 0.0;

          fragColor.xyz = state.xyz + DT * vec3(
            C * (dvxdx + dvydy) - u * (s.x + s.y) + psiContribution,
            C * psiUpdate,
            1.0
          );

          // Apply forcing term: mouse if moving, automatic if not active, none otherwise
          if (u_mouseMoving > 0.5) {
            // Mouse-based forcing with Gaussian profile (only when actually moving)
            float mouseForceWidth = 8.0;
            float mouseDist = length(gl_FragCoord.xy - vec2(u_mouseX, u_mouseY));
            float mouseMask = exp(-pow(mouseDist / mouseForceWidth, 2.0));
            float omega = C * PI / OSCILLATOR_WAVELENGTH;
            float mouseForce = sin(omega * t) * mouseMask * OSCILLATOR_STRENGTH * 0.4;
            fragColor.x += mouseForce;
          } else if (u_mouseActive < 0.5) {
            // Automatic periodic oscillators (only when mouse not active)
            float pulseInterval = 600.0;
            float pulse = exp(-pow(abs((mod(t - pulseInterval, pulseInterval * 0.7) - pulseInterval * 0.5) / 40.0), 4.0));
            int COUNT = 5;
            for (int i = 0; i < COUNT; i++) {
              vec2 r = (float(i) - float(COUNT) * 0.5) / float(COUNT) * vec2(80.0, 0.0);
              float omega = C * PI / OSCILLATOR_WAVELENGTH;
              float oscillatorMask = smoothstep(3.0, 2.0, length(gl_FragCoord.xy - u_resolution * 0.5 + r));
              float u0 = sin(omega * t / float(i + 1));
              fragColor.x += u0 * oscillatorMask * OSCILLATOR_STRENGTH * pulse;
            }
          }
          // When mouse is active but not moving: no forcing, just let waves propagate
        }
      `;

      // Buffer B shader (updates v)
      const bufferBSource = `#version 300 es
        precision highp float;
        ${commonSource}
        uniform sampler2D u_bufferA;
        uniform sampler2D u_bufferB;
        uniform vec2 u_resolution;
        uniform float u_pmlWidth;
        out vec4 fragColor;

        vec2 sigmaCompute(vec2 coord, vec2 res, float pmlWidth) {
          return pow(
            abs(vec2(
              linearstep(pmlWidth, 0.0, coord.x) + linearstep(res.x - pmlWidth, res.x, coord.x),
              linearstep(pmlWidth, 0.0, coord.y) + linearstep(res.y - pmlWidth, res.y, coord.y)
            )),
            vec2(PML_EXPONENT)
          ) * PML_STRENGTH;
        }

        void main() {
          ivec2 p = ivec2(gl_FragCoord.xy);
          vec4 state = texelFetch(u_bufferB, p, 0);
          vec2 v = state.xy;

          float u1x = texelFetch(u_bufferA, p + ivec2(1, 0), 0).x;
          float u0x = texelFetch(u_bufferA, p + ivec2(-1, 0), 0).x;
          float u1y = texelFetch(u_bufferA, p + ivec2(0, 1), 0).x;
          float u0y = texelFetch(u_bufferA, p + ivec2(0, -1), 0).x;

          vec2 ugrad = vec2(u1x - u0x, u1y - u0y) / (2.0 * DX);
          vec2 s = sigmaCompute(gl_FragCoord.xy, u_resolution, u_pmlWidth);

          fragColor.xy = state.xy + DT * (C * ugrad - s * v);
        }
      `;

      // Display shader
      const displaySource = `#version 300 es
        precision highp float;
        ${commonSource}
        uniform sampler2D u_bufferA;
        uniform vec2 u_resolution;
        uniform float u_showSigma;
        uniform float u_contrast;
        uniform float u_pmlWidth;
        out vec4 fragColor;

        vec2 sigmaDisplay(vec2 coord, vec2 res, float pmlWidth) {
          return pow(
            abs(vec2(
              linearstep(pmlWidth, 0.0, coord.x) + linearstep(res.x - pmlWidth, res.x, coord.x),
              linearstep(pmlWidth, 0.0, coord.y) + linearstep(res.y - pmlWidth, res.y, coord.y)
            )),
            vec2(PML_EXPONENT)
          ) * PML_STRENGTH;
        }

        void main() {
          vec2 uv = gl_FragCoord.xy / u_resolution;
          vec4 state = texture(u_bufferA, uv);
          float u = state.x * u_contrast;  // Apply contrast amplification

          // White background with colored waves
          vec3 white = vec3(1.0);
          vec3 cyanColor = vec3(0.0, 0.65, 0.75);    // Darker cyan
          vec3 yellowColor = vec3(0.85, 0.75, 0.0);  // Darker yellow

          // Blend from white to color based on wave amplitude
          float intensity = clamp(abs(u), 0.0, 1.0);
          vec3 targetColor = u > 0.0 ? yellowColor : cyanColor;
          fragColor = vec4(mix(white, targetColor, intensity), 1.0);

          if (u_showSigma > 0.5) {
            vec2 s = sqrt(sigmaDisplay(gl_FragCoord.xy, u_resolution, u_pmlWidth));  // sqrt for better low-value contrast
            fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 1.0), s.x * 0.7);  // Pink for x-direction
            fragColor = mix(fragColor, vec4(0.0, 1.0, 0.0, 1.0), s.y * 0.7);  // Green for y-direction
          }
        }
      `;

      // Compile shader
      function compileShader(source, type) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          const error = gl.getShaderInfoLog(shader);
          console.error('Shader compilation error:', error);
          console.error('Shader source:', source);
          gl.deleteShader(shader);
          throw new Error('Shader compilation failed: ' + error);
        }
        return shader;
      }

      // Create program
      function createProgram(vertSource, fragSource) {
        const vertShader = compileShader(vertSource, gl.VERTEX_SHADER);
        const fragShader = compileShader(fragSource, gl.FRAGMENT_SHADER);
        const program = gl.createProgram();
        gl.attachShader(program, vertShader);
        gl.attachShader(program, fragShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          const error = gl.getProgramInfoLog(program);
          console.error('Program linking error:', error);
          throw new Error('Program linking failed: ' + error);
        }
        return program;
      }

      const bufferAProgram = createProgram(vertexShaderSource, bufferASource);
      const bufferBProgram = createProgram(vertexShaderSource, bufferBSource);
      const displayProgram = createProgram(vertexShaderSource, displaySource);

      // Create full-screen quad
      const quadBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

      // Create framebuffers and textures
      function createFramebuffer(width, height) {
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, width, height, 0, gl.RGBA, gl.FLOAT, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        const fbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

        return { fbo, texture };
      }

      const width = canvas.width;
      const height = canvas.height;

      const bufferA = [createFramebuffer(width, height), createFramebuffer(width, height)];
      const bufferB = [createFramebuffer(width, height), createFramebuffer(width, height)];

      let currentBuffer = 0;

      // Pointer event queue and state
      const pointerQueue = [];
      const mouseState = {
        x: -1000,
        y: -1000,
        lastMoveTime: -10000,  // Initialize to far in the past so automatic forcing starts immediately
        isMoving: false,
        isActive: false
      };

      canvas.addEventListener('pointerenter', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * width / rect.width;
        const y = height - (e.clientY - rect.top) * height / rect.height;
        pointerQueue.push({ x, y, time: performance.now() });
      });

      canvas.addEventListener('pointermove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * width / rect.width;
        const y = height - (e.clientY - rect.top) * height / rect.height;
        pointerQueue.push({ x, y, time: performance.now() });
      });

      canvas.addEventListener('pointerleave', (e) => {
        mouseState.x = -1000;
        mouseState.y = -1000;
        mouseState.lastMoveTime = -10000;  // Reset to far past so automatic forcing restarts immediately
        mouseState.isMoving = false;
        mouseState.isActive = false;
      });

    // Uniform values that can be updated without re-running the animation
    const uniforms = {
      usePsi: 1.0,
      showSigma: 0.0,
      contrast: 0.454,
      pmlWidth: 12.0,
      mouseX: -1000,
      mouseY: -1000,
      mouseMoving: 0.0,
      mouseActive: 0.0
    };

    const webgl_setup = {
      canvas,
      gl,
      width,
      height,
      bufferAProgram,
      bufferBProgram,
      displayProgram,
      quadBuffer,
      bufferA,
      bufferB,
      mouseState,
      uniforms
    };
  </script>
  <script id="18" type="module">
    // Update uniforms object when controls change (doesn't restart animation)
    webgl_setup.uniforms.usePsi = usePsi ? 1.0 : 0.0;
    webgl_setup.uniforms.showSigma = showSigma ? 1.0 : 0.0;
    webgl_setup.uniforms.contrast = Math.max(100**contrast, 0.1);
    webgl_setup.uniforms.pmlWidth = pmlWidth;
  </script>
  <script id="19" type="module">
    const { canvas, gl, width, height, bufferAProgram, bufferBProgram, displayProgram, quadBuffer, bufferA, bufferB, uniforms } = webgl_setup;

    let currentBuffer = 0;
    let animationId;
    let isVisible = false;

    function render() {
      // Only render if visible
      if (!isVisible) return;

      // Process pointer queue and update mouse state
      const now = performance.now();
      while (pointerQueue.length > 0) {
        const event = pointerQueue.shift();
        mouseState.x = event.x;
        mouseState.y = event.y;
        mouseState.lastMoveTime = event.time;
      }

      // Check if mouse is actively moving (within 100ms) and active (within 2s)
      const timeSinceMove = now - mouseState.lastMoveTime;
      mouseState.isMoving = timeSinceMove < 100;
      mouseState.isActive = timeSinceMove < 6000;

      // Update uniforms
      uniforms.mouseX = mouseState.x;
      uniforms.mouseY = mouseState.y;
      uniforms.mouseMoving = mouseState.isMoving ? 1.0 : 0.0;
      uniforms.mouseActive = mouseState.isActive ? 1.0 : 0.0;

      if (!simulate) {
          // Still render the display, just don't update the simulation
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          gl.viewport(0, 0, width, height);
          gl.useProgram(displayProgram);

          const aPositionD = gl.getAttribLocation(displayProgram, 'a_position');
          gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
          gl.enableVertexAttribArray(aPositionD);
          gl.vertexAttribPointer(aPositionD, 2, gl.FLOAT, false, 0, 0);

          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, bufferA[currentBuffer].texture);
          gl.uniform1i(gl.getUniformLocation(displayProgram, 'u_bufferA'), 0);

          gl.uniform2f(gl.getUniformLocation(displayProgram, 'u_resolution'), width, height);
          gl.uniform1f(gl.getUniformLocation(displayProgram, 'u_showSigma'), uniforms.showSigma);
          gl.uniform1f(gl.getUniformLocation(displayProgram, 'u_contrast'), uniforms.contrast);
          gl.uniform1f(gl.getUniformLocation(displayProgram, 'u_pmlWidth'), uniforms.pmlWidth);

          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
          animationId = requestAnimationFrame(render);
          return;
        }

        // Run two time steps per frame for better visual speed
        for (let step = 0; step < 2; step++) {
          const current = currentBuffer;
          const next = 1 - currentBuffer;

          // Update buffer A (u, psi)
          gl.bindFramebuffer(gl.FRAMEBUFFER, bufferA[next].fbo);
          gl.viewport(0, 0, width, height);
          gl.useProgram(bufferAProgram);

          const aPositionA = gl.getAttribLocation(bufferAProgram, 'a_position');
          gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
          gl.enableVertexAttribArray(aPositionA);
          gl.vertexAttribPointer(aPositionA, 2, gl.FLOAT, false, 0, 0);

          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, bufferA[current].texture);
          gl.uniform1i(gl.getUniformLocation(bufferAProgram, 'u_bufferA'), 0);

          gl.activeTexture(gl.TEXTURE1);
          gl.bindTexture(gl.TEXTURE_2D, bufferB[current].texture);
          gl.uniform1i(gl.getUniformLocation(bufferAProgram, 'u_bufferB'), 1);

          gl.uniform2f(gl.getUniformLocation(bufferAProgram, 'u_resolution'), width, height);
          gl.uniform1f(gl.getUniformLocation(bufferAProgram, 'u_pmlWidth'), uniforms.pmlWidth);
          gl.uniform1f(gl.getUniformLocation(bufferAProgram, 'u_usePsi'), uniforms.usePsi);
          gl.uniform1f(gl.getUniformLocation(bufferAProgram, 'u_mouseX'), uniforms.mouseX);
          gl.uniform1f(gl.getUniformLocation(bufferAProgram, 'u_mouseY'), uniforms.mouseY);
          gl.uniform1f(gl.getUniformLocation(bufferAProgram, 'u_mouseMoving'), uniforms.mouseMoving);
          gl.uniform1f(gl.getUniformLocation(bufferAProgram, 'u_mouseActive'), uniforms.mouseActive);

          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

          // Update buffer B (v)
          gl.bindFramebuffer(gl.FRAMEBUFFER, bufferB[next].fbo);
          gl.useProgram(bufferBProgram);

          const aPositionB = gl.getAttribLocation(bufferBProgram, 'a_position');
          gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
          gl.enableVertexAttribArray(aPositionB);
          gl.vertexAttribPointer(aPositionB, 2, gl.FLOAT, false, 0, 0);

          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, bufferA[next].texture);
          gl.uniform1i(gl.getUniformLocation(bufferBProgram, 'u_bufferA'), 0);

          gl.activeTexture(gl.TEXTURE1);
          gl.bindTexture(gl.TEXTURE_2D, bufferB[current].texture);
          gl.uniform1i(gl.getUniformLocation(bufferBProgram, 'u_bufferB'), 1);

          gl.uniform2f(gl.getUniformLocation(bufferBProgram, 'u_resolution'), width, height);
          gl.uniform1f(gl.getUniformLocation(bufferBProgram, 'u_pmlWidth'), uniforms.pmlWidth);

          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

          // Swap buffers for next iteration
          currentBuffer = next;
        }

        // Display
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.viewport(0, 0, width, height);
        gl.useProgram(displayProgram);

        const aPositionD = gl.getAttribLocation(displayProgram, 'a_position');
        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
        gl.enableVertexAttribArray(aPositionD);
        gl.vertexAttribPointer(aPositionD, 2, gl.FLOAT, false, 0, 0);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, bufferA[currentBuffer].texture);
        gl.uniform1i(gl.getUniformLocation(displayProgram, 'u_bufferA'), 0);

        gl.uniform2f(gl.getUniformLocation(displayProgram, 'u_resolution'), width, height);
        gl.uniform1f(gl.getUniformLocation(displayProgram, 'u_showSigma'), uniforms.showSigma);
        gl.uniform1f(gl.getUniformLocation(displayProgram, 'u_contrast'), uniforms.contrast);
        gl.uniform1f(gl.getUniformLocation(displayProgram, 'u_pmlWidth'), uniforms.pmlWidth);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        animationId = requestAnimationFrame(render);
      }

    // Intersection Observer to only render when visible
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        isVisible = entry.isIntersecting;
        if (isVisible) {
          if (!animationId) {
            animationId = requestAnimationFrame(render);
          }
        } else {
          if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
          }
        }
      });
    });

    observer.observe(canvas);

    // Cancel animation when cell is invalidated
    invalidation.then(() => {
      if (animationId) cancelAnimationFrame(animationId);
      observer.disconnect();
    });

    display(canvas);
  </script>
  <script id="20" type="module">
    const simulate = view(Inputs.toggle({label: "Simulate", value: true}));
    const usePsi = view(Inputs.toggle({label: "Use auxiliary ψ equation", value: true}));
    const showSigma = view(Inputs.toggle({label: "Show absorption regions", value: false}));
    const contrast = view(Inputs.range([0, 1], {label: "Contrast", step: 0.01, value: 0}));
    const pmlWidth = view(Inputs.range([4, 40], {label: "PML width (pixels)", step: 1, value: 12}));
  </script>
  <script id="57" type="text/markdown">
    ## Conclusion
  </script>
  <script id="21" type="text/markdown">
    While the resulting equations are somewhat involved, PML provides a remarkably effective solution to the absorbing boundary problem. I’m a little uncertain how to deal with irregular domains with more complicated boundaries, but that’s an exercise for the future!
  </script>
  <script id="58" type="text/markdown">
    ## References
  </script>
  <script id="22" type="text/markdown">
    This derivation extends the technique from [Steven G. Johnson's PML notes](https://math.mit.edu/~stevenj/18.369/spring14/pml.pdf) by applying the PML mapping to both x and y boundaries simultaneously.
  </script>
</notebook>
