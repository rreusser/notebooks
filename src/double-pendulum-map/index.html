<!doctype html>
<notebook theme="air">
  <title>The Double Pendulum Map</title>
  <script id="895" type="text/markdown">
    # The Double Pendulum Map
  </script>
  <script id="539" type="text/markdown">
    A [double pendulum](https://en.wikipedia.org/wiki/Double_pendulum) consists of two connected pendulums, rotating under the force of gravity. This notebook allows you to simulate both *simple* double pendulums (with point masses at the ends) and *compound* double pendulums (with mass distributed uniformly along the length of the arms).
  </script>
  <script id="530" type="application/vnd.observable.javascript">
    html`<figure style="text-align: center;">
    <img width="350" src="${await FileAttachment("compound-pendulum-diagram.svg").url()}" alt="Compound double pendulum diagram">
    <figcaption>A compound double pendulum with mass distributed along the length of each arm.</figcaption>
    </figure>`
  </script>
  <script id="904" type="text/markdown">
    Iterating a double pendulum is a matter of stepping four coupled ordinary differential equations (ODE) in time, one for the angular position of each arm and one for the angular velocity. See the [appendix](#appendix) for detailed derivations of the equations of motion for both point-mass and compound double pendulums.
  </script>
  <script id="363" type="text/markdown">
    [Sam Maksimovich](https://twitter.com/MaksimovichSam) recently created a lovely video in which he simultaneously plots all possible double pendulums starting with zero velocity, using color to illustrate their trajectories. The explanation is far better than anything you'll find here. You should watch it!
  </script>
  <script id="526" type="module">
    tweet('1392357775666159618')
  </script>
  <script id="547" type="text/markdown">
    At the end he mentions it took six hours to render the video. I'm confident I would not be able to create a lovelier or more effective explanation video, but the visualization is exactly the sort of thing GPUs do very well, so it seemed like it would be fun to plug this into WebGL and make a quick, interactive visualization of the pendulum. A major shortcoming is that WebGL only does single precision, and chaotic simulations definitely benefit from at least double precision, but maybe we'll see what we can get away with.
  </script>
  <script id="897" type="text/markdown">
    The visualization below uses the [regl](https://github.com/regl-project/regl) WebGL library to compute and visualize the angle of the of the first (x-axis) and second (y-axis) arms of all double pendulums starting with the specified velocities. This amounts to a two-dimensional slice (just the angular positions) of the four-dimensional phase space (two positions and two velocities).
  </script>
  <script id="898" type="text/markdown">
    Toggle between simple (point masses) and compound (distributed mass) pendulums, adjust the initial velocities, and zoom in on regions below to observe the beautiful fractal structure! üåà
  </script>
  <script id="610" type="module">
    if (colorType === 'half float') {
      display(html`<p style="color:#a00">Warning! This simulation is using half-float precision and as a result won't be accurate. Try a device which supports the floating point WebGL textures for better results.</p>`);
    }
  </script>
  <script id="289" type="module">
    const figure = html`<figure>
      ${stack.element}
      <figcaption>Hover to view pendulum. Scroll to zoom, drag to pan.</figcaption>
    </figure>`;

    display(expandable(figure, {
      width: Math.min(width, 640),
      height: Math.min(width, 640),
      toggleOffset: [-25, -42],
      controls: '.pendulum-controls',
      onResize(el, w, h) {
        stack.resize(w, h);
        axes.updateScales(
          stack.elements.plot.scale("x"),
          stack.elements.plot.scale("y")
        );
        // Compute extended texture domain covering full stack including margins
        const extended = computeTextureDomain(axes.xDomain, axes.yDomain, w, h);
        textureDomain.x[0] = extended.x[0];
        textureDomain.x[1] = extended.x[1];
        textureDomain.y[0] = extended.y[0];
        textureDomain.y[1] = extended.y[1];
        // Resize FBOs and reinitialize to maintain 1:1 resolution
        resizeFBOs(w, h);
        regl.poll();
        y[0].use(() =>
          blit(() => {
            initialize({ ...params, debugCheckerboard: false });
          })
        );
        regl.dirty = true;
      }
    }));
  </script>
  <script id="914" type="text/x-typescript">
    const controlsContainer = html`<div class="pendulum-controls"></div>`;

    function ctrl(input) {
      controlsContainer.appendChild(input);
      return Generators.input(input);
    }

    const m1 = ctrl(Inputs.range([0.1, 1], {
      label: 'Mass 1 (m‚ÇÅ)',
      value: 1,
      step: 0.01,
      transform: Math.log
    }));
    const m2 = ctrl(Inputs.range([0.1, 1], {
      label: 'Mass 2 (m‚ÇÇ)',
      value: 1,
      step: 0.01,
      transform: Math.log
    }));
    const l1 = ctrl(Inputs.range([0.1, 1], {
      label: 'Length 1 (l‚ÇÅ)',
      value: 1,
      step: 0.01,
      transform: Math.log
    }));
    const l2 = ctrl(Inputs.range([0.1, 1], {
      label: 'Length 2 (l‚ÇÇ)',
      value: 1,
      step: 0.01,
      transform: Math.log
    }));
    const omega0_0 = ctrl(Inputs.range([-2, 2], {
      label: 'Initial angular velocity of arm 1',
      value: 0
    }));
    const omega0_1 = ctrl(Inputs.range([-2, 2], {
      label: 'Initial angular velocity of arm 2',
      value: 0
    }));
    const dt = ctrl(Inputs.range([0.001, 0.1], {
      label: 'Time step',
      value: 0.03,
      transform: Math.log
    }));
    const pendulumType = ctrl(Inputs.radio(['Simple', 'Compound'], {
      label: 'Pendulum type',
      value: 'Compound'
    }));
    const simulate = ctrl(Inputs.checkbox(['Simulate', 'Show pendulum at point under mouse'], {
      value: ['Simulate', 'Show pendulum at point under mouse']
    }));
    const resetView = ctrl(Inputs.button('Reset View'));
    const restart = ctrl(Inputs.button('Restart'));

    display(controlsContainer);
  </script>
  <script id="915" type="module">
    // Stable params object - modified in place to avoid triggering reactive updates
    const params = { omega0_0: 0, omega0_1: 0, pendulumType: 'Compound', m1: 1, m2: 1, l1: 1, l2: 1 };
  </script>
  <script id="916" type="module">
    // Update params when controls change (this cell re-runs, but params object reference stays stable)
    params.omega0_0 = omega0_0;
    params.omega0_1 = omega0_1;
    params.pendulumType = pendulumType;
    params.m1 = m1;
    params.m2 = m2;
    params.l1 = l1;
    params.l2 = l2;
  </script>
  <script id="919" type="module">
    function createPlot(width, height, xDomain = [-Math.PI, Math.PI], yDomain = [-Math.PI, Math.PI]) {
      return Plot.plot({
        width,
        height,
        marginTop: 20,
        marginRight: 20,
        marginLeft: 50,
        marginBottom: 40,
        style: { backgroundColor: "transparent", maxWidth: "none", position: "absolute" },
        x: { domain: xDomain, tickSpacing: 80, label: "Œ∏‚ÇÅ", labelAnchor: "center" },
        y: { domain: yDomain, tickSpacing: 80, label: "Œ∏‚ÇÇ", labelAnchor: "center" },
        marks: []
      });
    }
  </script>
  <script id="920" type="module">
    const stack = createElementStack({
      layers: [{
        id: 'regl',
        element: reglElement(createREGL, {
          optionalExtensions: ['OES_texture_half_float', 'OES_texture_float', 'OES_texture_float_linear', 'OES_texture_half_float_linear', 'ANGLE_instanced_arrays'],
          attributes: { antialias: true, alpha: false, depthStencil: false, preserveDrawingBuffer: true }
        })
      }, {
        id: 'plot',
        element: ({ width, height }) => createPlot(width, height)
      }, {
        id: 'svg',
        element: ({ current, width, height }) =>
          (current ? d3.select(current) : d3.create("svg"))
            .attr("width", width)
            .attr("height", height)
            .style("position", "absolute")
            .node()
      }]
    });
  </script>
  <script id="5" type="module">
    const regl = stack.elements.regl.value;
  </script>
  <script id="921" type="module">
    let reinitTimeout = null;

    // Baseline domain
    const baselineDomain = { x: [-Math.PI, Math.PI], y: [-Math.PI, Math.PI] };

    // Plot margins (must match createPlot)
    const margins = { top: 20, right: 10, bottom: 40, left: 50 };

    // Compute extended texture domain that covers full stack (including margins)
    // This ensures 1:1 pixel mapping between texture and screen
    function computeTextureDomain(viewXDomain, viewYDomain, stackWidth, stackHeight) {
      const viewportWidth = stackWidth - margins.left - margins.right;
      const viewportHeight = stackHeight - margins.top - margins.bottom;

      const xScale = (viewXDomain[1] - viewXDomain[0]) / viewportWidth;
      const yScale = (viewYDomain[1] - viewYDomain[0]) / viewportHeight;

      return {
        x: [
          viewXDomain[0] - margins.left * xScale,
          viewXDomain[1] + margins.right * xScale
        ],
        y: [
          viewYDomain[0] - margins.bottom * yScale,
          viewYDomain[1] + margins.top * yScale
        ]
      };
    }

    function reinitialize() {
      // Compute extended texture domain that covers full stack including margins
      const extended = computeTextureDomain(axes.xDomain, axes.yDomain, stack.width, stack.height);
      textureDomain.x[0] = extended.x[0];
      textureDomain.x[1] = extended.x[1];
      textureDomain.y[0] = extended.y[0];
      textureDomain.y[1] = extended.y[1];

      // Resize FBOs to match viewport
      resizeFBOs(stack.width, stack.height);

      // Initialize the texture
      regl.poll();
      y[0].use(() =>
        blit(() => {
          initialize({ ...params, debugCheckerboard: false });
        })
      );
      regl.dirty = true;
    }

    function resetToBaseline() {
      // Reset textureDomain to extended baseline (covering margins)
      const extended = computeTextureDomain(baselineDomain.x, baselineDomain.y, stack.width, stack.height);
      textureDomain.x[0] = extended.x[0];
      textureDomain.x[1] = extended.x[1];
      textureDomain.y[0] = extended.y[0];
      textureDomain.y[1] = extended.y[1];

      // Reset zoom to initial domain (this will trigger onChange -> reinitialize)
      axes.reset();
    }

    const axes = createZoomableAxes({
      d3,
      element: stack.elements.svg,
      xScale: stack.elements.plot.scale("x"),
      yScale: stack.elements.plot.scale("y"),
      aspectRatio: 1,
      scaleExtent: [0.1, 1000],
      onChange: ({ xDomain, yDomain }) => {
        regl.dirty = true;
        const newPlot = createPlot(stack.width, stack.height, xDomain, yDomain);
        stack.elements.plot.replaceWith(newPlot);
        stack.elements.plot = newPlot;
        stack.dispatchEvent(new CustomEvent('update'));

        // Debounced reinitialize after zoom stops
        clearTimeout(reinitTimeout);
        reinitTimeout = setTimeout(reinitialize, 300);
      }
    });
  </script>
  <script id="922" type="module">
    // React to reset view button
    resetView;
    if (resetView > 0) {
      resetToBaseline();
    }
  </script>
  <script id="158" type="module">
    // The main simulation and initialization setup.
    // Trigger reinitialization when controls change
    restart;
    pendulumType;
    omega0_0;
    omega0_1;
    m1; m2; l1; l2;

    // Compute extended texture domain covering full stack including margins
    const extended = computeTextureDomain(axes.xDomain, axes.yDomain, stack.width, stack.height);
    textureDomain.x[0] = extended.x[0];
    textureDomain.x[1] = extended.x[1];
    textureDomain.y[0] = extended.y[0];
    textureDomain.y[1] = extended.y[1];

    // Resize FBOs to match stack (full size including margins)
    resizeFBOs(stack.width, stack.height);

    // Must call this when calling regl outside of frame loop
    regl.poll();

    // Call initialize in blit context, writing to y[0] framebuffer
    y[0].use(() =>
      blit(() => {
        initialize({ ...params, debugCheckerboard: false });
      })
    );

    // Export a token so frame loop can depend on initialization
    const initialized = true;
  </script>
  <script id="54" type="module">
    // Depend on initialization completing
    initialized;
    // Trigger redraw on restart
    restart;
    m1; m2; l1; l2;

    const DEBUG_CHECKERBOARD = false;  // DEBUG: Set to true to show static checkerboard
    const run = !DEBUG_CHECKERBOARD && ~simulate.indexOf('Simulate');
    const showPen = ~simulate.indexOf('Show pendulum at point under mouse');
    const isCompound = pendulumType === 'Compound';

    regl.dirty = true;
    const frame = regl.frame(() => {
      blit(() => {
        if (regl.dirty || run) {
          regl.clear({ color: [1, 1, 1, 1] });
        }

        // Step the simulation if running (disabled in debug mode)
        if (run) {
          // Run two steps from one data framebuffer to the other,
          // i.e. from y1=f(y0) and then back to y0=f(y1)
          update([
            { dt, src: y[0], dst: y[1], isCompound, m1, m2, l1, l2 },
            { dt, src: y[1], dst: y[0], isCompound, m1, m2, l1, l2 }
          ]);
        }

        // Draw the simulation if something has happened
        if (regl.dirty || run) {
          drawMap();
          if (showPen && mouseHover.active) {
            drawPendulum({ state: y[0], l1, l2, isCompound });
          }
          regl.dirty = false;
        }
      });
    });
    invalidation.then(() => frame.cancel());
  </script>
  <script id="78" type="module">
    // Configure two 2D textures to store (theta1, theta2, velocity1, velocity2) in the four channels of an (r, g, b, a) texture.
    const colorType = canWriteToFBOOfType(regl, 'float')
      ? 'float'
      : canWriteToFBOOfType(regl, 'half float')
      ? 'half float'
      : 'uint8'
  </script>
  <script id="923" type="module">
    // Track the world-space domain that the texture currently represents
    // This starts at the full range and updates after each reinitialize
    const textureDomain = {
      x: [-Math.PI, Math.PI],
      y: [-Math.PI, Math.PI]
    };
  </script>
  <script id="58" type="module">
    // Create framebuffers sized to match viewport at device pixel ratio
    const initialWidth = Math.round(stack.width * pixelRatio);
    const initialHeight = Math.round(stack.height * pixelRatio);

    // Check if linear filtering is supported for the texture type
    const supportsLinearFilter = (colorType === 'float' && regl.hasExtension('OES_texture_float_linear')) ||
                                  (colorType === 'half float' && regl.hasExtension('OES_texture_half_float_linear')) ||
                                  colorType === 'uint8';
    const filterMode = 'nearest';//supportsLinearFilter ? 'linear' : 'nearest';

    const y = (function () {
      const fbos = [0, 1].map(() =>
        regl.framebuffer({
          color: regl.texture({
            width: initialWidth,
            height: initialHeight,
            type: colorType,
            wrap: 'clamp',
            min: filterMode,
            mag: filterMode
          }),
          depth: false,
          stencil: false
        })
      );
      invalidation.then(() => fbos.forEach(fbo => fbo.destroy()));
      return fbos;
    })();

    // Helper to resize FBOs when viewport changes
    function resizeFBOs(w, h) {
      const pw = Math.round(w * pixelRatio);
      const ph = Math.round(h * pixelRatio);
      if (y[0].width !== pw || y[0].height !== ph) {
        y[0].resize(pw, ph);
        y[1].resize(pw, ph);
      }
    }
  </script>
  <script id="113" type="module">
    const blit = regl({
      // Configure a full-viewport vertex shader:
      vert: `
        precision mediump float;
        attribute vec2 xy;
        void main () {
          gl_Position = vec4(xy, 0, 1);
        }`,
      attributes: { xy: [-4, -4, 4, -4, 0, 4] },
      uniforms: {
        resolution: ctx => [ctx.framebufferWidth, ctx.framebufferHeight]
      },
      count: 3,
      depth: { enable: false }
    })
  </script>
  <script id="151" type="module">
    const initialize = regl({
      frag: `
        precision highp float;
        uniform vec2 resolution, omega0;
        uniform vec4 texDomain; // xMin, xMax, yMin, yMax - the domain this texture represents
        uniform bool isCompound;
        uniform float m1, m2, l1, l2;
        uniform bool debugCheckerboard;
        #define PI ${Math.PI}
        void main () {
          // DEBUG: Output checkerboard pattern to verify texture sizing
          // Each checker is 8x8 texture pixels - should appear as perfect squares if 1:1
          if (debugCheckerboard) {
            float checker = mod(floor(gl_FragCoord.x / 8.0) + floor(gl_FragCoord.y / 8.0), 2.0);
            gl_FragColor = vec4(vec3(checker), 1.0);
            return;
          }

          // UV position in texture [0, 1]
          vec2 uv = gl_FragCoord.xy / resolution;

          // Map UV to world coordinates (theta values) based on textureDomain
          vec2 theta = vec2(
            mix(texDomain.x, texDomain.y, uv.x),
            mix(texDomain.z, texDomain.w, uv.y)
          );

          vec2 velocity;
          if (isCompound) {
            // Convert angular velocities to generalized momenta for compound pendulum
            // Mass matrix from Lagrangian: p = M*theta_dot
            float cosTheta12 = cos(theta.x - theta.y);
            float m11 = ((m1 / 3.0) + m2) * l1 * l1;
            float m22 = (m2 / 3.0) * l2 * l2;
            float m12 = 0.5 * m2 * l1 * l2 * cosTheta12;
            velocity = vec2(
              m11 * omega0.x + m12 * omega0.y,
              m12 * omega0.x + m22 * omega0.y
            );
          } else {
            // For simple pendulum, also use generalized momenta
            // Mass matrix: p = M*theta_dot
            float cosTheta12 = cos(theta.x - theta.y);
            float m11 = (m1 + m2) * l1 * l1;
            float m22 = m2 * l2 * l2;
            float m12 = m2 * l1 * l2 * cosTheta12;
            velocity = vec2(
              m11 * omega0.x + m12 * omega0.y,
              m12 * omega0.x + m22 * omega0.y
            );
          }

          // Store normalized: map [-PI, PI] to [0, 1]
          gl_FragColor = (vec4(theta, velocity) + PI) / (2.0 * PI);
        }`,
      uniforms: {
        resolution: ctx => [ctx.framebufferWidth, ctx.framebufferHeight],
        omega0: (ctx, props) => [props.omega0_0, props.omega0_1],
        texDomain: () => [textureDomain.x[0], textureDomain.x[1], textureDomain.y[0], textureDomain.y[1]],
        isCompound: (ctx, props) => props.pendulumType === 'Compound',
        debugCheckerboard: regl.prop('debugCheckerboard'),
        m1: regl.prop('m1'),
        m2: regl.prop('m2'),
        l1: regl.prop('l1'),
        l2: regl.prop('l2')
      }
    })
  </script>
  <script id="176" type="module">
    const update = regl({
      frag: `
        precision highp float;
        uniform sampler2D y;
        uniform vec2 resolution;
        uniform float dt;
        uniform bool isCompound;
        uniform float m1, m2, l1, l2;
        #define PI ${Math.PI}
        #define g 1.0

        // Compound double pendulum (distributed mass)
        // State: (Œ∏‚ÇÅ, Œ∏‚ÇÇ, p_Œ∏‚ÇÅ, p_Œ∏‚ÇÇ) where p_Œ∏ are generalized momenta
        vec4 derivativeCompound (vec4 state) {
          vec2 theta = state.xy;
          vec2 pTheta = state.zw;
          float cosTheta12 = cos(theta.x - theta.y);

          // Mass matrix from Lagrangian formulation
          float m11 = ((m1 / 3.0) + m2) * l1 * l1;
          float m22 = (m2 / 3.0) * l2 * l2;
          float m12 = 0.5 * m2 * l1 * l2 * cosTheta12;

          // Invert mass matrix to get Œ∏Ãá from p (where p = M*Œ∏Ãá)
          float det = m11 * m22 - m12 * m12;
          vec2 thetaDot = vec2(
            (m22 * pTheta.x - m12 * pTheta.y) / det,
            (m11 * pTheta.y - m12 * pTheta.x) / det
          );

          float thetaDot12sinTheta12 = thetaDot.x * thetaDot.y * sin(theta.x - theta.y);
          vec2 pThetaDot = vec2(
            -0.5 * m2 * l1 * l2 * thetaDot12sinTheta12 - 0.5 * (m1 + 2.0 * m2) * g * l1 * sin(theta.x),
             0.5 * m2 * l1 * l2 * thetaDot12sinTheta12 - 0.5 * m2 * g * l2 * sin(theta.y)
          );
          return vec4(thetaDot, pThetaDot);
        }

        // Simple double pendulum (point masses)
        // State: (Œ∏‚ÇÅ, Œ∏‚ÇÇ, p_Œ∏‚ÇÅ, p_Œ∏‚ÇÇ) where p_Œ∏ are generalized momenta
        vec4 derivativeSimple (vec4 state) {
          vec2 theta = state.xy;
          vec2 pTheta = state.zw;
          float cosTheta12 = cos(theta.x - theta.y);

          // Mass matrix for simple pendulum
          float m11 = (m1 + m2) * l1 * l1;
          float m22 = m2 * l2 * l2;
          float m12 = m2 * l1 * l2 * cosTheta12;

          // Invert mass matrix to get Œ∏Ãá from p
          float det = m11 * m22 - m12 * m12;
          vec2 thetaDot = vec2(
            (m22 * pTheta.x - m12 * pTheta.y) / det,
            (m11 * pTheta.y - m12 * pTheta.x) / det
          );

          // Momentum time derivatives
          float thetaDot12sinTheta12 = thetaDot.x * thetaDot.y * sin(theta.x - theta.y);
          vec2 pThetaDot = vec2(
            -m2 * l1 * l2 * thetaDot12sinTheta12 - (m1 + m2) * g * l1 * sin(theta.x),
             m2 * l1 * l2 * thetaDot12sinTheta12 - m2 * g * l2 * sin(theta.y)
          );

          return vec4(thetaDot, pThetaDot);
        }

        vec4 derivative (vec4 state) {
          if (isCompound) {
            return derivativeCompound(state);
          } else {
            return derivativeSimple(state);
          }
        }

        void main () {
          // Read the state (theta1, theta2, velocity1, velocity2) from the rgba texture
          vec4 yn = texture2D(y, gl_FragCoord.xy / resolution);

          // Convert from [0, 1] to [-PI, PI]:
          yn = yn * (2.0 * PI) - PI;

          // RK4 integration
          vec4 k1 = dt * derivative(yn);
          vec4 k2 = dt * derivative(yn + 0.5 * k1);
          vec4 k3 = dt * derivative(yn + 0.5 * k2);
          vec4 k4 = dt * derivative(yn + k3);
          yn += (k1 + k4 + 2.0 * (k2 + k3)) / 6.0;

          // Convert back from [-PI, PI] to [0, 1]:
          yn = (yn + PI) / (2.0 * PI);

          // Loop angles if they exceed the range
          yn.xy = fract(yn.xy);

          // Output the state to the four color channels
          gl_FragColor = yn;
        }`,
      framebuffer: regl.prop('dst'),
      uniforms: {
        y: regl.prop('src'),
        resolution: ctx => [ctx.framebufferWidth, ctx.framebufferHeight],
        dt: regl.prop('dt'),
        isCompound: regl.prop('isCompound'),
        m1: regl.prop('m1'),
        m2: regl.prop('m2'),
        l1: regl.prop('l1'),
        l2: regl.prop('l2')
      }
    })
  </script>
  <script id="95" type="module">
    const drawMap = regl({
      frag: `
        precision highp float;
        uniform sampler2D colorscale, y;
        uniform vec4 axesViewport; // x, y, width, height in pixels
        uniform vec4 viewDomain;   // current view: xMin, xMax, yMin, yMax
        uniform vec4 texDomain;    // texture domain: xMin, xMax, yMin, yMax
        uniform bool debugPassthrough;
        #define PI ${Math.PI}
        #define TWOPI ${2 * Math.PI}

        vec3 colormap(vec2 uv) {
          uv *= TWOPI;
          return pow(0.5 + 0.5 * vec3(sin(uv.x) * vec2(-cos(uv.y), sin(uv.y)), -cos(uv.x)), vec3(0.75));
        }

        void main () {
          // Map from viewport pixel to normalized position [0,1] within viewport
          vec2 viewportUV = (gl_FragCoord.xy - axesViewport.xy) / axesViewport.zw;

          // Ephemeral transform: map viewportUV to textureUV
          // textureUV = offset + viewportUV * scale
          vec2 viewSize = vec2(viewDomain.y - viewDomain.x, viewDomain.w - viewDomain.z);
          vec2 texSize = vec2(texDomain.y - texDomain.x, texDomain.w - texDomain.z);
          vec2 scale = viewSize / texSize;
          vec2 offset = vec2(viewDomain.x - texDomain.x, viewDomain.z - texDomain.z) / texSize;
          vec2 uv = offset + viewportUV * scale;

          // Check if UV is outside texture bounds - show solid color
          if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
            gl_FragColor = vec4(0.95, 0.95, 0.95, 1.0); // Light gray for out of bounds
            return;
          }

          // Sample the state at this pixel
          vec4 state = texture2D(y, uv);

          // DEBUG: Pass through raw texture value for checkerboard testing
          if (debugPassthrough) {
            gl_FragColor = vec4(state.rgb, 1.0);
            return;
          }

          // Color it by the projection of the 4D state to 2D (theta1, theta2):
          gl_FragColor = vec4(colormap(state.xy), 1);
        }`,
      uniforms: {
        y: () => y[0],
        axesViewport: (ctx) => {
          const vp = reglAxesViewport(axes)(ctx);
          return [vp.x, vp.y, vp.width, vp.height];
        },
        viewDomain: () => [axes.xDomain[0], axes.xDomain[1], axes.yDomain[0], axes.yDomain[1]],
        texDomain: () => [textureDomain.x[0], textureDomain.x[1], textureDomain.y[0], textureDomain.y[1]],
        debugPassthrough: false  // DEBUG: Set to true to see raw checkerboard
      },
      scissor: { enable: true, box: reglAxesViewport(axes) },
      viewport: reglAxesViewport(axes)
    })
  </script>
  <script id="886" type="module">
    // Draw pendulum using regl-gpu-lines for nice rendering
    // All computation stays on GPU - sample texture in vertex shader

    const drawPendulumLine = reglLines(regl, {
      vert: `
        precision highp float;

        #pragma lines: attribute float index;
        #pragma lines: position = getPosition(index);
        #pragma lines: width = getWidth();

        uniform sampler2D state;
        uniform vec2 hover;
        uniform float l1, l2, width;

        #define PI ${Math.PI}

        vec4 getPosition(float idx) {
          // Sample state from texture
          vec2 theta = texture2D(state, hover).xy * (2.0 * PI) - PI;

          // Compute pendulum positions
          vec2 v1 = l1 * vec2(sin(theta.x), -cos(theta.x));
          vec2 v2 = l2 * vec2(sin(theta.y), -cos(theta.y));

          vec2 p0 = vec2(0);
          vec2 p1 = v1;
          vec2 p2 = p1 + v2;

          // Select position based on index
          vec2 pos = idx < 0.5 ? p0 : (idx < 1.5 ? p1 : p2);

          // Scale to fit in clip space
          return vec4(pos * 0.45, 0, 1);
        }

        float getWidth() { return width; }
      `,
      frag: `
        precision lowp float;
        uniform vec3 color;
        void main () {
          gl_FragColor = vec4(color, 1);
        }
      `,
      uniforms: {
        state: regl.prop('state'),
        hover: () => mouseHover.pt,
        l1: regl.prop('l1'),
        l2: regl.prop('l2'),
        width: (ctx, props) => ctx.pixelRatio * props.width,
        color: regl.prop('color')
      },
      depth: { enable: false },
      scissor: { enable: true, box: reglAxesViewport(axes) },
      viewport: (ctx) => {
        const axesVp = reglAxesViewport(axes)(ctx);
        const size = Math.min(axesVp.width, axesVp.height);
        return {
          x: axesVp.x + (axesVp.width - size) / 2,
          y: axesVp.y + (axesVp.height - size) / 2,
          width: size,
          height: size
        };
      }
    });

    // Draw circles for point masses (simple pendulum) or pivots
    const drawPendulumPoints = regl({
      vert: `
        precision highp float;
        attribute float pointIndex;
        uniform sampler2D state;
        uniform vec2 hover;
        uniform float l1, l2, pointSize;
        varying float vPointSize;

        #define PI ${Math.PI}

        void main() {
          vec2 theta = texture2D(state, hover).xy * (2.0 * PI) - PI;

          vec2 v1 = l1 * vec2(sin(theta.x), -cos(theta.x));
          vec2 v2 = l2 * vec2(sin(theta.y), -cos(theta.y));

          vec2 p0 = vec2(0);
          vec2 p1 = v1;
          vec2 p2 = p1 + v2;

          vec2 pos = pointIndex < 0.5 ? p0 : (pointIndex < 1.5 ? p1 : p2);

          gl_Position = vec4(pos * 0.45, 0, 1);
          gl_PointSize = pointSize;
          vPointSize = pointSize;
        }
      `,
      frag: `
        precision highp float;
        uniform vec3 fillColor;
        uniform vec3 strokeColor;
        uniform float strokeWidthPx;
        varying float vPointSize;

        void main() {
          // Distance from center in pixels
          float distPx = length(gl_PointCoord - 0.5) * vPointSize;
          float radius = vPointSize * 0.5;

          // Smooth edges with 1px anti-aliasing
          float outerEdge = smoothstep(radius, radius - 1.0, distPx);
          float innerEdge = smoothstep(radius - strokeWidthPx, radius - strokeWidthPx - 1.0, distPx);

          // Blend stroke (outside) and fill (inside)
          vec3 color = mix(strokeColor, fillColor, innerEdge);
          gl_FragColor = vec4(color, outerEdge);
        }
      `,
      attributes: {
        pointIndex: [0, 1, 2]
      },
      uniforms: {
        state: regl.prop('state'),
        hover: () => mouseHover.pt,
        l1: regl.prop('l1'),
        l2: regl.prop('l2'),
        pointSize: (ctx, props) => ctx.pixelRatio * props.pointSize,
        fillColor: regl.prop('fillColor'),
        strokeColor: regl.prop('strokeColor'),
        strokeWidthPx: (ctx, props) => ctx.pixelRatio * props.strokeWidthPx
      },
      primitive: 'points',
      count: 3,
      depth: { enable: false },
      blend: {
        enable: true,
        func: {
          srcRGB: 'src alpha',
          srcAlpha: 1,
          dstRGB: 'one minus src alpha',
          dstAlpha: 1
        },
        equation: { rgb: 'add', alpha: 'add' },
        color: [0, 0, 0, 0]
      },
      scissor: { enable: true, box: reglAxesViewport(axes) },
      viewport: (ctx) => {
        const axesVp = reglAxesViewport(axes)(ctx);
        const size = Math.min(axesVp.width, axesVp.height);
        return {
          x: axesVp.x + (axesVp.width - size) / 2,
          y: axesVp.y + (axesVp.height - size) / 2,
          width: size,
          height: size
        };
      }
    });

    // Pre-allocate buffers for line vertices [0, 1, 2]
    const lineVertexBuffer = regl.buffer([0, 1, 2]);
    const lineEndpointBuffer = regl.buffer([[0, 1, 2], [2, 1, 0]]);

    const lineData = {
      join: 'round',
      cap: 'round',
      vertexCount: 3,
      vertexAttributes: { index: lineVertexBuffer },
      endpointCount: 2,
      endpointAttributes: { index: lineEndpointBuffer }
    };

    function drawPendulum(props) {
      const { state, l1, l2, isCompound } = props;

      if (isCompound) {
        // Compound: thick coral bars with round joins
        drawPendulumLine({
          ...lineData,
          state, l1, l2,
          width: 14,
          color: [0.75, 0.22, 0.17]  // #c0392b
        });
        // Small pivot points
        drawPendulumPoints({
          state, l1, l2,
          pointSize: 12,
          fillColor: [0.4, 0.4, 0.4],
          strokeColor: [0.25, 0.25, 0.25],
          strokeWidthPx: 1.5
        });
      } else {
        // Simple: darker gray rods for visibility
        drawPendulumLine({
          ...lineData,
          state, l1, l2,
          width: 3,
          color: [0.35, 0.35, 0.35]  // #595959
        });
        // Red point masses with dark outline
        drawPendulumPoints({
          state, l1, l2,
          pointSize: 18,
          fillColor: [0.91, 0.30, 0.24],  // #e74c3c
          strokeColor: [0.6, 0.15, 0.1],  // darker red
          strokeWidthPx: 1.5
        });
      }
    }
  </script>
  <script id="889" type="module">
    const mouseHover = { pt: [0, 0], active: false, dragging: false };

    // Set up mouse tracking on the SVG layer (topmost interactive element)
    const canvas = stack.elements.svg;
    function onPointerMove(event) {
      // Convert pixel coordinates to texture coordinates [0, 1]
      const rect = canvas.getBoundingClientRect();
      const x = (event.clientX - rect.left) / rect.width;
      const y = 1 - (event.clientY - rect.top) / rect.height;
      mouseHover.pt[0] = x;
      mouseHover.pt[1] = y;
      regl.dirty = true;
    }
    function onPointerEnter() {
      mouseHover.active = true;
      regl.dirty = true;
    }
    function onPointerLeave() {
      mouseHover.active = false;
      regl.dirty = true;
    }
    function onPointerDown() {
      mouseHover.dragging = true;
      canvas.classList.remove('crosshair-cursor');
    }
    function onPointerUp() {
      mouseHover.dragging = false;
      // Re-check if showPen is enabled
      if (simulate.includes('Show pendulum at point under mouse')) {
        canvas.classList.add('crosshair-cursor');
      }
    }
    canvas.addEventListener('pointermove', onPointerMove, false);
    canvas.addEventListener('pointerenter', onPointerEnter, false);
    canvas.addEventListener('pointerleave', onPointerLeave, false);
    canvas.addEventListener('pointerdown', onPointerDown, false);
    window.addEventListener('pointerup', onPointerUp, false);

    invalidation.then(() => {
      canvas.removeEventListener('pointermove', onPointerMove);
      canvas.removeEventListener('pointerenter', onPointerEnter);
      canvas.removeEventListener('pointerleave', onPointerLeave);
      canvas.removeEventListener('pointerdown', onPointerDown);
      window.removeEventListener('pointerup', onPointerUp);
    });

  </script>
  <script id="924" type="text/html">
    <style>
      .crosshair-cursor { cursor: crosshair !important; }
    </style>
  </script>
  <script id="925" type="module">
    // Reactively update cursor when simulate changes
    const svgEl = stack.elements.svg;
    if (simulate.includes('Show pendulum at point under mouse')) {
      svgEl.classList.add('crosshair-cursor');
    } else {
      svgEl.classList.remove('crosshair-cursor');
    }
  </script>
  <script id="901" type="module">
    await import('./lib/twttr.js')
    const twttr = window.twttr
  </script>
  <script id="903" type="module">
    function tweet(id, options) {
      const div = document.createElement("DIV");
      Promise.resolve().then(() => twttr.widgets.createTweet(id, div, options));
      return div;
    }
  </script>
  <script id="49" type="module">
    const pixelRatio = window.devicePixelRatio;
  </script>
  <script id="890" type="module">
    import createREGL from 'npm:regl@2.1.1'
    import reglLines from 'npm:regl-gpu-lines@2.4.1'
    import { createElementStack } from './lib/element-stack.js'
    import { reglElement, reglAxesViewport } from './lib/regl-canvas.js'
    import { createZoomableAxes } from './lib/zoomable-axes.js'
    import { expandable } from './lib/expandable.js'
  </script>
  <script id="485" type="module">
    import { canWriteToFBOOfType } from 'observable:@rreusser/regl-tools'
  </script>
  <script id="635" type="module">
    import { rangeSlider } from 'observable:@mootari/range-slider'
  </script>
  <script id="791" type="module">
    function lerp(a, b, t) {
      return a + t * (b - a);
    }
  </script>
  <script id="906" type="text/markdown">
    <h2 id="appendix">Appendix: Derivations of Equations of Motion</h2>
  </script>
  <script id="907" type="text/markdown">
    ### Simple Double Pendulum (Point Masses)
  </script>
  <script id="908" type="application/vnd.observable.javascript">
    html`<figure style="text-align: center;">
    <img width="350" src="${await FileAttachment("simple-pendulum-diagram.svg").url()}" alt="Simple double pendulum diagram">
    </figure>`
  </script>
  <script id="909" type="text/markdown">
    Consider a double pendulum with point masses ${tex`m_1`} and ${tex`m_2`} at distances ${tex`l_1`} and ${tex`l_2`} from their respective pivots, with angles ${tex`\theta_1`} and ${tex`\theta_2`} measured from vertical (downward).

    #### Coordinates

    The position of mass 1:

    ${tex.block`\begin{aligned}
    x_1 &= l_1 \sin \theta_1 \\
    y_1 &= -l_1 \cos \theta_1
    \end{aligned}`}

    The position of mass 2:

    ${tex.block`\begin{aligned}
    x_2 &= l_1 \sin \theta_1 + l_2 \sin \theta_2 \\
    y_2 &= -l_1 \cos \theta_1 - l_2 \cos \theta_2
    \end{aligned}`}

    #### Kinetic Energy

    Taking time derivatives:

    ${tex.block`\begin{aligned}
    \dot{x}_1 &= l_1 \dot{\theta}_1 \cos \theta_1 \\
    \dot{y}_1 &= l_1 \dot{\theta}_1 \sin \theta_1 \\
    \dot{x}_2 &= l_1 \dot{\theta}_1 \cos \theta_1 + l_2 \dot{\theta}_2 \cos \theta_2 \\
    \dot{y}_2 &= l_1 \dot{\theta}_1 \sin \theta_1 + l_2 \dot{\theta}_2 \sin \theta_2
    \end{aligned}`}

    The kinetic energy is:

    ${tex.block`\begin{aligned}
    T &= \frac{1}{2} m_1 (\dot{x}_1^2 + \dot{y}_1^2) + \frac{1}{2} m_2 (\dot{x}_2^2 + \dot{y}_2^2) \\
    &= \frac{1}{2} m_1 l_1^2 \dot{\theta}_1^2 + \frac{1}{2} m_2 \left[ l_1^2 \dot{\theta}_1^2 + l_2^2 \dot{\theta}_2^2 + 2 l_1 l_2 \dot{\theta}_1 \dot{\theta}_2 \cos(\theta_1 - \theta_2) \right]
    \end{aligned}`}

    #### Potential Energy

    ${tex.block`V = -m_1 g l_1 \cos \theta_1 - m_2 g (l_1 \cos \theta_1 + l_2 \cos \theta_2)`}

    #### Lagrangian

    ${tex.block`L = T - V`}

    #### Euler-Lagrange Equations

    The Euler-Lagrange equations ${tex`\frac{d}{dt}\frac{\partial L}{\partial \dot{\theta}_i} - \frac{\partial L}{\partial \theta_i} = 0`} yield (after simplification):

    ${tex.block`\begin{aligned}
    (m_1 + m_2) l_1^2 \ddot{\theta}_1 + m_2 l_1 l_2 \ddot{\theta}_2 \cos(\theta_1 - \theta_2) &= -m_2 l_1 l_2 \dot{\theta}_2^2 \sin(\theta_1 - \theta_2) - (m_1 + m_2) g l_1 \sin \theta_1 \\
    m_2 l_2^2 \ddot{\theta}_2 + m_2 l_1 l_2 \ddot{\theta}_1 \cos(\theta_1 - \theta_2) &= m_2 l_1 l_2 \dot{\theta}_1^2 \sin(\theta_1 - \theta_2) - m_2 g l_2 \sin \theta_2
    \end{aligned}`}

    #### Generalized Momenta

    The generalized momenta are:

    ${tex.block`\begin{aligned}
    p_{\theta_1} &= \frac{\partial L}{\partial \dot{\theta}_1} = (m_1 + m_2) l_1^2 \dot{\theta}_1 + m_2 l_1 l_2 \dot{\theta}_2 \cos(\theta_1 - \theta_2) \\
    p_{\theta_2} &= \frac{\partial L}{\partial \dot{\theta}_2} = m_2 l_2^2 \dot{\theta}_2 + m_2 l_1 l_2 \dot{\theta}_1 \cos(\theta_1 - \theta_2)
    \end{aligned}`}

    In matrix form ${tex`\mathbf{p} = M(\theta) \dot{\boldsymbol{\theta}}`} where:

    ${tex.block`M = \begin{pmatrix}
    (m_1 + m_2) l_1^2 & m_2 l_1 l_2 \cos(\theta_1 - \theta_2) \\
    m_2 l_1 l_2 \cos(\theta_1 - \theta_2) & m_2 l_2^2
    \end{pmatrix}`}

    Inverting to get ${tex`\dot{\boldsymbol{\theta}} = M^{-1} \mathbf{p}`} and computing ${tex`\dot{\mathbf{p}} = \frac{\partial L}{\partial \boldsymbol{\theta}}`}:

    ${tex.block`\begin{aligned}
    \dot{p}_{\theta_1} &= -m_2 l_1 l_2 \dot{\theta}_1 \dot{\theta}_2 \sin(\theta_1 - \theta_2) - (m_1 + m_2) g l_1 \sin\theta_1 \\
    \dot{p}_{\theta_2} &= m_2 l_1 l_2 \dot{\theta}_1 \dot{\theta}_2 \sin(\theta_1 - \theta_2) - m_2 g l_2 \sin\theta_2
    \end{aligned}`}

    As a first-order system with state ${tex`\mathbf{y} = (\theta_1, \theta_2, p_{\theta_1}, p_{\theta_2})^T`}:

    ${tex.block`\frac{d\mathbf{y}}{dt} = \begin{pmatrix}
    \dot{\theta}_1(\theta_1, \theta_2, p_{\theta_1}, p_{\theta_2}) \\
    \dot{\theta}_2(\theta_1, \theta_2, p_{\theta_1}, p_{\theta_2}) \\
    \dot{p}_{\theta_1}(\theta_1, \theta_2, p_{\theta_1}, p_{\theta_2}) \\
    \dot{p}_{\theta_2}(\theta_1, \theta_2, p_{\theta_1}, p_{\theta_2})
    \end{pmatrix}`}
  </script>
  <script id="910" type="text/markdown">
    ### Compound Double Pendulum (Distributed Mass)
  </script>
  <script id="911" type="application/vnd.observable.javascript">
    html`<figure style="text-align: center;">
    <img width="350" src="${await FileAttachment("compound-pendulum-diagram.svg").url()}" alt="Compound double pendulum diagram">
    </figure>`
  </script>
  <script id="912" type="text/markdown">
    For a compound pendulum, the mass is distributed along each arm. Consider uniform rods of lengths ${tex`l_1`} and ${tex`l_2`} with masses ${tex`m_1`} and ${tex`m_2`}, and moments of inertia ${tex`I_1 = \frac{1}{3}m_1 l_1^2`} and ${tex`I_2 = \frac{1}{3}m_2 l_2^2`} about their pivot points.

    #### Center of Mass Positions

    The centers of mass are located at the midpoints:

    ${tex.block`\begin{aligned}
    x_{c1} &= \frac{l_1}{2} \sin \theta_1, \quad y_{c1} = -\frac{l_1}{2} \cos \theta_1 \\
    x_{c2} &= l_1 \sin \theta_1 + \frac{l_2}{2} \sin \theta_2, \quad y_{c2} = -l_1 \cos \theta_1 - \frac{l_2}{2} \cos \theta_2
    \end{aligned}`}

    #### Kinetic Energy

    The kinetic energy includes both translational and rotational components:

    ${tex.block`T = \frac{1}{2} I_1 \dot{\theta}_1^2 + \frac{1}{2} m_1 (\dot{x}_{c1}^2 + \dot{y}_{c1}^2) + \frac{1}{2} I_2 \dot{\theta}_2^2 + \frac{1}{2} m_2 (\dot{x}_{c2}^2 + \dot{y}_{c2}^2)`}

    For a uniform rod rotating about its end, ${tex`I_1 = \frac{1}{3}m_1 l_1^2`} and ${tex`I_2 = \frac{1}{3}m_2 l_2^2`}. The translational kinetic energies are:

    ${tex.block`\begin{aligned}
    \frac{1}{2} m_1 (\dot{x}_{c1}^2 + \dot{y}_{c1}^2) &= \frac{1}{2} m_1 \frac{l_1^2}{4} \dot{\theta}_1^2 \\
    \frac{1}{2} m_2 (\dot{x}_{c2}^2 + \dot{y}_{c2}^2) &= \frac{1}{2} m_2 \left[ l_1^2 \dot{\theta}_1^2 + \frac{l_2^2}{4} \dot{\theta}_2^2 + l_1 l_2 \dot{\theta}_1 \dot{\theta}_2 \cos(\theta_1 - \theta_2) \right]
    \end{aligned}`}

    Thus:

    ${tex.block`T = \frac{1}{6} m_1 l_1^2 \dot{\theta}_1^2 + \frac{1}{2} m_2 l_1^2 \dot{\theta}_1^2 + \frac{1}{6} m_2 l_2^2 \dot{\theta}_2^2 + \frac{1}{2} m_2 l_1 l_2 \dot{\theta}_1 \dot{\theta}_2 \cos(\theta_1 - \theta_2)`}

    #### Potential Energy

    ${tex.block`V = -m_1 g \frac{l_1}{2} \cos \theta_1 - m_2 g \left( l_1 \cos \theta_1 + \frac{l_2}{2} \cos \theta_2 \right)`}

    #### Generalized Momenta

    The generalized momenta are:

    ${tex.block`\begin{aligned}
    p_{\theta_1} &= \frac{\partial L}{\partial \dot{\theta}_1} = \left(\frac{m_1}{3} + m_2\right) l_1^2 \dot{\theta}_1 + \frac{m_2}{2} l_1 l_2 \dot{\theta}_2 \cos(\theta_1 - \theta_2) \\
    p_{\theta_2} &= \frac{\partial L}{\partial \dot{\theta}_2} = \frac{m_2}{3} l_2^2 \dot{\theta}_2 + \frac{m_2}{2} l_1 l_2 \dot{\theta}_1 \cos(\theta_1 - \theta_2)
    \end{aligned}`}

    In matrix form ${tex`\mathbf{p} = M(\theta) \dot{\boldsymbol{\theta}}`} where:

    ${tex.block`M = \begin{pmatrix}
    \left(\frac{m_1}{3} + m_2\right) l_1^2 & \frac{m_2}{2} l_1 l_2 \cos(\theta_1 - \theta_2) \\
    \frac{m_2}{2} l_1 l_2 \cos(\theta_1 - \theta_2) & \frac{m_2}{3} l_2^2
    \end{pmatrix}`}

    Inverting to get ${tex`\dot{\boldsymbol{\theta}} = M^{-1} \mathbf{p}`} and computing ${tex`\dot{\mathbf{p}} = \frac{\partial L}{\partial \boldsymbol{\theta}}`}:

    ${tex.block`\begin{aligned}
    \dot{p}_{\theta_1} &= -\frac{m_2}{2} l_1 l_2 \dot{\theta}_1 \dot{\theta}_2 \sin(\theta_1 - \theta_2) - \left(\frac{m_1}{2} + m_2\right) g l_1 \sin\theta_1 \\
    \dot{p}_{\theta_2} &= \frac{m_2}{2} l_1 l_2 \dot{\theta}_1 \dot{\theta}_2 \sin(\theta_1 - \theta_2) - \frac{m_2}{2} g l_2 \sin\theta_2
    \end{aligned}`}

    As a first-order system with state ${tex`\mathbf{y} = (\theta_1, \theta_2, p_{\theta_1}, p_{\theta_2})^T`}:

    ${tex.block`\frac{d\mathbf{y}}{dt} = \begin{pmatrix}
    \dot{\theta}_1(\theta_1, \theta_2, p_{\theta_1}, p_{\theta_2}) \\
    \dot{\theta}_2(\theta_1, \theta_2, p_{\theta_1}, p_{\theta_2}) \\
    \dot{p}_{\theta_1}(\theta_1, \theta_2, p_{\theta_1}, p_{\theta_2}) \\
    \dot{p}_{\theta_2}(\theta_1, \theta_2, p_{\theta_1}, p_{\theta_2})
    \end{pmatrix}`}
  </script>
</notebook>
