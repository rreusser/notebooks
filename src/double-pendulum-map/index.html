<!doctype html>
<notebook theme="air">
  <title>The Double Pendulum Map</title>
  <script id="895" type="text/markdown">
    # The Double Pendulum Map
  </script>
  <script id="539" type="text/markdown">
    A [double pendulum](https://en.wikipedia.org/wiki/Double_pendulum) consists of two connected pendulums, rotating under the force of gravity. This notebook allows you to simulate both *simple* double pendulums (with point masses at the ends) and *compound* double pendulums (with mass distributed uniformly along the length of the arms).
  </script>
  <script id="530" type="application/vnd.observable.javascript">
    html`<figure style="text-align: center;">
    <img width="350" src="${await FileAttachment("compound-pendulum-diagram.svg").url()}" alt="Compound double pendulum diagram">
    <figcaption>A compound double pendulum with mass distributed along the length of each arm.</figcaption>
    </figure>`
  </script>
  <script id="904" type="text/markdown">
    Iterating a double pendulum is a matter of stepping four coupled ordinary differential equations (ODE) in time, one for the angular position of each arm and one for the angular velocity. See the [appendix](#appendix) for detailed derivations of the equations of motion for both point-mass and compound double pendulums.
  </script>
  <script id="363" type="text/markdown">
    [Sam Maksimovich](https://twitter.com/MaksimovichSam) recently created a lovely video in which he simultaneously plots all possible double pendulums starting with zero velocity, using color to illustrate their trajectories. The explanation is far better than anything you'll find here. You should watch it!
  </script>
  <script id="526" type="module">
    tweet('1392357775666159618')
  </script>
  <script id="547" type="text/markdown">
    At the end he mentions it took six hours to render the video. I'm confident I would not be able to create a lovelier or more effective explanation video, but the visualization is exactly the sort of thing GPUs do very well, so it seemed like it would be fun to plug this into WebGL and make a quick, interactive visualization of the pendulum. A major shortcoming is that WebGL only does single precision, and chaotic simulations definitely benefit from at least double precision, but maybe we'll see what we can get away with.
  </script>
  <script id="897" type="text/markdown">
    The visualization below uses the [regl](https://github.com/regl-project/regl) WebGL library to compute and visualize the angle of the of the first (x-axis) and second (y-axis) arms of all double pendulums starting with the specified velocities. This amounts to a two-dimensional slice (just the angular positions) of the four-dimensional phase space (two positions and two velocities).
  </script>
  <script id="898" type="text/markdown">
    Toggle between simple (point masses) and compound (distributed mass) pendulums, adjust the initial velocities, and zoom in on regions below to observe the beautiful fractal structure! üåà
  </script>
  <script id="610" type="module">
    if (colorType === 'half float') {
      display(html`<p style="color:#a00">Warning! This simulation is using half-float precision and as a result won't be accurate. Try a device which supports the floating point WebGL textures for better results.</p>`);
    }
  </script>
  <script id="571" type="module">
    const pendulumType = view(Inputs.radio(['Simple', 'Compound'], {
      label: 'Pendulum type',
      value: 'Compound'
    }));
  </script>
    <script id="289" type="module">
    const figure = html`<figure>
      ${stack.element}
      <figcaption>Hover to view pendulum. Scroll to zoom, drag to pan.</figcaption>
    </figure>`;

    display(expandable(figure, {
      width: Math.min(width, 640),
      height: Math.min(width, 640),
      toggleOffset: [-6, -33],
      onResize(el, w, h) {
        stack.resize(w, h);
        axes.updateScales(
          stack.elements.plot.scale("x"),
          stack.elements.plot.scale("y")
        );
        // Sync textureDomain to new aspect-ratio-adjusted view domain
        textureDomain.x[0] = axes.xDomain[0];
        textureDomain.x[1] = axes.xDomain[1];
        textureDomain.y[0] = axes.yDomain[0];
        textureDomain.y[1] = axes.yDomain[1];
        // Resize FBOs and reinitialize to maintain 1:1 resolution
        resizeFBOs(w, h);
        regl.poll();
        y[0].use(() =>
          blit(() => {
            initialize({ omega0_0, omega0_1, pendulumType, m1, m2, l1, l2 });
          })
        );
        regl.dirty = true;
      }
    }));
  </script>
  <script id="917" type="text/x-typescript">
    const simulate = view(Inputs.checkbox(['Simulate', 'Show pendulum at point under mouse'], {
      value: ['Simulate', 'Show pendulum at point under mouse']
    }));
  </script>
  <script id="916" type="text/x-typescript">
    const restart = view(Inputs.button('Restart'));
  </script>
  <script id="resetView" type="text/x-typescript">
    const resetView = view(Inputs.button('Reset View'));
  </script>
  <script id="914" type="text/x-typescript">
    const m1 = view(Inputs.range([0.1, 1], {
      label: 'Mass 1 (m‚ÇÅ)',
      value: 1,
      step: 0.01,
      transform: Math.log
    }));
    const m2 = view(Inputs.range([0.1, 1], {
      label: 'Mass 2 (m‚ÇÇ)',
      value: 1,
      step: 0.01,
      transform: Math.log
    }));
    const l1 = view(Inputs.range([0.1, 1], {
      label: 'Length 1 (l‚ÇÅ)',
      value: 1,
      step: 0.01,
      transform: Math.log
    }));
    const l2 = view(Inputs.range([0.1, 1], {
      label: 'Length 2 (l‚ÇÇ)',
      value: 1,
      step: 0.01,
      transform: Math.log
    }));
    const omega0_0 = view(Inputs.range([-2, 2], {
      label: 'Initial angular velocity of arm 1',
      value: 0
    }));
    const omega0_1 = view(Inputs.range([-2, 2], {
      label: 'Initial angular velocity of arm 2',
      value: 0
    }));
    const dt = view(Inputs.range([0.001, 0.1], {
      label: 'Time step',
      value: 0.03,
      transform: Math.log
    }));
  </script>
  <script id="createPlot" type="module">
    function createPlot(width, height, xDomain = [-Math.PI, Math.PI], yDomain = [-Math.PI, Math.PI]) {
      return Plot.plot({
        width,
        height,
        marginTop: 20,
        marginRight: 10,
        marginLeft: 50,
        marginBottom: 40,
        style: { backgroundColor: "transparent", maxWidth: "none", position: "absolute" },
        x: { domain: xDomain, tickSpacing: 80, label: "Œ∏‚ÇÅ", labelAnchor: "center" },
        y: { domain: yDomain, tickSpacing: 80, label: "Œ∏‚ÇÇ", labelAnchor: "center" },
        marks: []
      });
    }
  </script>
  <script id="stack" type="module">
    const stack = createElementStack({
      layers: [{
        id: 'regl',
        element: reglElement(createREGL, {
          optionalExtensions: ['OES_texture_half_float', 'OES_texture_float', 'OES_texture_float_linear', 'OES_texture_half_float_linear', 'ANGLE_instanced_arrays'],
          attributes: { antialias: true, alpha: false, depthStencil: false, preserveDrawingBuffer: true }
        })
      }, {
        id: 'plot',
        element: ({ width, height }) => createPlot(width, height)
      }, {
        id: 'svg',
        element: ({ current, width, height }) =>
          (current ? d3.select(current) : d3.create("svg"))
            .attr("width", width)
            .attr("height", height)
            .style("position", "absolute")
            .node()
      }]
    });
  </script>
  <script id="5" type="module">
    const regl = stack.elements.regl.value;
  </script>
  <script id="axes" type="module">
    let reinitTimeout = null;

    // Baseline domain
    const baselineDomain = { x: [-Math.PI, Math.PI], y: [-Math.PI, Math.PI] };

    function reinitialize() {
      // Sync textureDomain to current view domain
      textureDomain.x[0] = axes.xDomain[0];
      textureDomain.x[1] = axes.xDomain[1];
      textureDomain.y[0] = axes.yDomain[0];
      textureDomain.y[1] = axes.yDomain[1];

      // Resize FBOs to match viewport
      resizeFBOs(stack.width, stack.height);

      // Initialize the texture
      regl.poll();
      y[0].use(() =>
        blit(() => {
          initialize({ omega0_0, omega0_1, pendulumType, m1, m2, l1, l2 });
        })
      );
      regl.dirty = true;
    }

    function resetToBaseline() {
      // Reset textureDomain to baseline
      textureDomain.x[0] = baselineDomain.x[0];
      textureDomain.x[1] = baselineDomain.x[1];
      textureDomain.y[0] = baselineDomain.y[0];
      textureDomain.y[1] = baselineDomain.y[1];

      // Reset zoom to initial domain (this will trigger onChange -> reinitialize)
      axes.reset();
    }

    const axes = createZoomableAxes({
      d3,
      element: stack.elements.svg,
      xScale: stack.elements.plot.scale("x"),
      yScale: stack.elements.plot.scale("y"),
      aspectRatio: 1,
      onChange: ({ xDomain, yDomain }) => {
        regl.dirty = true;
        const newPlot = createPlot(stack.width, stack.height, xDomain, yDomain);
        stack.elements.plot.replaceWith(newPlot);
        stack.elements.plot = newPlot;
        stack.dispatchEvent(new CustomEvent('update'));

        // Debounced reinitialize after zoom stops
        clearTimeout(reinitTimeout);
        reinitTimeout = setTimeout(reinitialize, 300);
      }
    });
  </script>
  <script id="handleResetView" type="module">
    // React to reset view button
    resetView;
    if (resetView > 0) {
      resetToBaseline();
    }
  </script>
  <script id="158" type="module">
    // The main simulation and initialization setup.
    // Trigger reinitialization when 'restart' clicked or pendulum type changes
    restart;
    pendulumType;

    // Sync textureDomain to current view domain
    textureDomain.x[0] = axes.xDomain[0];
    textureDomain.x[1] = axes.xDomain[1];
    textureDomain.y[0] = axes.yDomain[0];
    textureDomain.y[1] = axes.yDomain[1];

    // Resize FBOs to match viewport
    resizeFBOs(stack.width, stack.height);

    // Must call this when calling regl outside of frame loop
    regl.poll();

    // Call initialize in blit context, writing to y[0] framebuffer
    y[0].use(() =>
      blit(() => {
        initialize({ omega0_0, omega0_1, pendulumType, m1, m2, l1, l2 });
      })
    );

    // Export a token so frame loop can depend on initialization
    const initialized = true;
  </script>
  <script id="54" type="module">
    // Depend on initialization completing
    initialized;
    // Trigger redraw on restart
    restart;
    m1; m2; l1; l2;

    const run = ~simulate.indexOf('Simulate');
    const showPen = ~simulate.indexOf('Show pendulum at point under mouse');
    const isCompound = pendulumType === 'Compound';

    regl.dirty = true;
    const frame = regl.frame(() => {
      blit(() => {
        if (regl.dirty || run) {
          regl.clear({ color: [1, 1, 1, 1] });
        }

        // Step the simulation if running
        if (run) {
          // Run two steps from one data framebuffer to the other,
          // i.e. from y1=f(y0) and then back to y0=f(y1)
          update([
            { dt, src: y[0], dst: y[1], isCompound, m1, m2, l1, l2 },
            { dt, src: y[1], dst: y[0], isCompound, m1, m2, l1, l2 }
          ]);
        }

        // Draw the simulation if something has happened
        if (regl.dirty || run) {
          drawMap();
          if (showPen && mouseHover.active) {
            drawPendulum([
              { y, w1: [0, 0, 0], w2: [0, 1, 0], l1, l2 },
              { y, w1: [0, 1, 0], w2: [0, 0, 1], l1, l2 }
            ]);
          }
          regl.dirty = false;
        }
      });
    });
    invalidation.then(() => frame.cancel());
  </script>
  <script id="78" type="module">
    // Configure two 2D textures to store (theta1, theta2, velocity1, velocity2) in the four channels of an (r, g, b, a) texture.
    const colorType = canWriteToFBOOfType(regl, 'float')
      ? 'float'
      : canWriteToFBOOfType(regl, 'half float')
      ? 'half float'
      : 'uint8'
  </script>
  <script id="textureDomain" type="module">
    // Track the world-space domain that the texture currently represents
    // This starts at the full range and updates after each reinitialize
    const textureDomain = {
      x: [-Math.PI, Math.PI],
      y: [-Math.PI, Math.PI]
    };
  </script>
  <script id="58" type="module">
    // Create framebuffers sized to match viewport at device pixel ratio
    const initialWidth = Math.round(stack.width * pixelRatio);
    const initialHeight = Math.round(stack.height * pixelRatio);

    // Check if linear filtering is supported for the texture type
    const supportsLinearFilter = (colorType === 'float' && regl.hasExtension('OES_texture_float_linear')) ||
                                  (colorType === 'half float' && regl.hasExtension('OES_texture_half_float_linear')) ||
                                  colorType === 'uint8';
    const filterMode = 'nearest';//supportsLinearFilter ? 'linear' : 'nearest';

    const y = (function () {
      const fbos = [0, 1].map(() =>
        regl.framebuffer({
          color: regl.texture({
            width: initialWidth,
            height: initialHeight,
            type: colorType,
            wrap: 'clamp',
            min: filterMode,
            mag: filterMode
          }),
          depth: false,
          stencil: false
        })
      );
      invalidation.then(() => fbos.forEach(fbo => fbo.destroy()));
      return fbos;
    })();

    // Helper to resize FBOs when viewport changes
    function resizeFBOs(w, h) {
      const pw = Math.round(w * pixelRatio);
      const ph = Math.round(h * pixelRatio);
      if (y[0].width !== pw || y[0].height !== ph) {
        y[0].resize(pw, ph);
        y[1].resize(pw, ph);
      }
    }
  </script>
  <script id="113" type="module">
    const blit = regl({
      // Configure a full-viewport vertex shader:
      vert: `
        precision mediump float;
        attribute vec2 xy;
        void main () {
          gl_Position = vec4(xy, 0, 1);
        }`,
      attributes: { xy: [-4, -4, 4, -4, 0, 4] },
      uniforms: {
        resolution: ctx => [ctx.framebufferWidth, ctx.framebufferHeight]
      },
      count: 3,
      depth: { enable: false }
    })
  </script>
  <script id="151" type="module">
    const initialize = regl({
      frag: `
        precision highp float;
        uniform vec2 resolution, omega0;
        uniform vec4 texDomain; // xMin, xMax, yMin, yMax - the domain this texture represents
        uniform bool isCompound;
        uniform float m1, m2, l1, l2;
        #define PI ${Math.PI}
        void main () {
          // UV position in texture [0, 1]
          vec2 uv = gl_FragCoord.xy / resolution;

          // Map UV to world coordinates (theta values) based on textureDomain
          vec2 theta = vec2(
            mix(texDomain.x, texDomain.y, uv.x),
            mix(texDomain.z, texDomain.w, uv.y)
          );

          vec2 velocity;
          if (isCompound) {
            // Convert angular velocities to generalized momenta for compound pendulum
            // Mass matrix from Lagrangian: p = M*theta_dot
            float cosTheta12 = cos(theta.x - theta.y);
            float m11 = ((m1 / 3.0) + m2) * l1 * l1;
            float m22 = (m2 / 3.0) * l2 * l2;
            float m12 = 0.5 * m2 * l1 * l2 * cosTheta12;
            velocity = vec2(
              m11 * omega0.x + m12 * omega0.y,
              m12 * omega0.x + m22 * omega0.y
            );
          } else {
            // For simple pendulum, also use generalized momenta
            // Mass matrix: p = M*theta_dot
            float cosTheta12 = cos(theta.x - theta.y);
            float m11 = (m1 + m2) * l1 * l1;
            float m22 = m2 * l2 * l2;
            float m12 = m2 * l1 * l2 * cosTheta12;
            velocity = vec2(
              m11 * omega0.x + m12 * omega0.y,
              m12 * omega0.x + m22 * omega0.y
            );
          }

          // Store normalized: map [-PI, PI] to [0, 1]
          gl_FragColor = (vec4(theta, velocity) + PI) / (2.0 * PI);
        }`,
      uniforms: {
        resolution: ctx => [ctx.framebufferWidth, ctx.framebufferHeight],
        omega0: (ctx, props) => [props.omega0_0, props.omega0_1],
        texDomain: () => [textureDomain.x[0], textureDomain.x[1], textureDomain.y[0], textureDomain.y[1]],
        isCompound: (ctx, props) => props.pendulumType === 'Compound',
        m1: regl.prop('m1'),
        m2: regl.prop('m2'),
        l1: regl.prop('l1'),
        l2: regl.prop('l2')
      }
    })
  </script>
  <script id="176" type="module">
    const update = regl({
      frag: `
        precision highp float;
        uniform sampler2D y;
        uniform vec2 resolution;
        uniform float dt;
        uniform bool isCompound;
        uniform float m1, m2, l1, l2;
        #define PI ${Math.PI}
        #define g 1.0

        // Compound double pendulum (distributed mass)
        // State: (Œ∏‚ÇÅ, Œ∏‚ÇÇ, p_Œ∏‚ÇÅ, p_Œ∏‚ÇÇ) where p_Œ∏ are generalized momenta
        vec4 derivativeCompound (vec4 state) {
          vec2 theta = state.xy;
          vec2 pTheta = state.zw;
          float cosTheta12 = cos(theta.x - theta.y);

          // Mass matrix from Lagrangian formulation
          float m11 = ((m1 / 3.0) + m2) * l1 * l1;
          float m22 = (m2 / 3.0) * l2 * l2;
          float m12 = 0.5 * m2 * l1 * l2 * cosTheta12;

          // Invert mass matrix to get Œ∏Ãá from p (where p = M*Œ∏Ãá)
          float det = m11 * m22 - m12 * m12;
          vec2 thetaDot = vec2(
            (m22 * pTheta.x - m12 * pTheta.y) / det,
            (m11 * pTheta.y - m12 * pTheta.x) / det
          );

          float thetaDot12sinTheta12 = thetaDot.x * thetaDot.y * sin(theta.x - theta.y);
          vec2 pThetaDot = vec2(
            -0.5 * m2 * l1 * l2 * thetaDot12sinTheta12 - 0.5 * (m1 + 2.0 * m2) * g * l1 * sin(theta.x),
             0.5 * m2 * l1 * l2 * thetaDot12sinTheta12 - 0.5 * m2 * g * l2 * sin(theta.y)
          );
          return vec4(thetaDot, pThetaDot);
        }

        // Simple double pendulum (point masses)
        // State: (Œ∏‚ÇÅ, Œ∏‚ÇÇ, p_Œ∏‚ÇÅ, p_Œ∏‚ÇÇ) where p_Œ∏ are generalized momenta
        vec4 derivativeSimple (vec4 state) {
          vec2 theta = state.xy;
          vec2 pTheta = state.zw;
          float cosTheta12 = cos(theta.x - theta.y);

          // Mass matrix for simple pendulum
          float m11 = (m1 + m2) * l1 * l1;
          float m22 = m2 * l2 * l2;
          float m12 = m2 * l1 * l2 * cosTheta12;

          // Invert mass matrix to get Œ∏Ãá from p
          float det = m11 * m22 - m12 * m12;
          vec2 thetaDot = vec2(
            (m22 * pTheta.x - m12 * pTheta.y) / det,
            (m11 * pTheta.y - m12 * pTheta.x) / det
          );

          // Momentum time derivatives
          float thetaDot12sinTheta12 = thetaDot.x * thetaDot.y * sin(theta.x - theta.y);
          vec2 pThetaDot = vec2(
            -m2 * l1 * l2 * thetaDot12sinTheta12 - (m1 + m2) * g * l1 * sin(theta.x),
             m2 * l1 * l2 * thetaDot12sinTheta12 - m2 * g * l2 * sin(theta.y)
          );

          return vec4(thetaDot, pThetaDot);
        }

        vec4 derivative (vec4 state) {
          if (isCompound) {
            return derivativeCompound(state);
          } else {
            return derivativeSimple(state);
          }
        }

        void main () {
          // Read the state (theta1, theta2, velocity1, velocity2) from the rgba texture
          vec4 yn = texture2D(y, gl_FragCoord.xy / resolution);

          // Convert from [0, 1] to [-PI, PI]:
          yn = yn * (2.0 * PI) - PI;

          // RK4 integration
          vec4 k1 = dt * derivative(yn);
          vec4 k2 = dt * derivative(yn + 0.5 * k1);
          vec4 k3 = dt * derivative(yn + 0.5 * k2);
          vec4 k4 = dt * derivative(yn + k3);
          yn += (k1 + k4 + 2.0 * (k2 + k3)) / 6.0;

          // Convert back from [-PI, PI] to [0, 1]:
          yn = (yn + PI) / (2.0 * PI);

          // Loop angles if they exceed the range
          yn.xy = fract(yn.xy);

          // Output the state to the four color channels
          gl_FragColor = yn;
        }`,
      framebuffer: regl.prop('dst'),
      uniforms: {
        y: regl.prop('src'),
        resolution: ctx => [ctx.framebufferWidth, ctx.framebufferHeight],
        dt: regl.prop('dt'),
        isCompound: regl.prop('isCompound'),
        m1: regl.prop('m1'),
        m2: regl.prop('m2'),
        l1: regl.prop('l1'),
        l2: regl.prop('l2')
      }
    })
  </script>
  <script id="95" type="module">
    const drawMap = regl({
      frag: `
        precision highp float;
        uniform sampler2D colorscale, y;
        uniform vec4 axesViewport; // x, y, width, height in pixels
        uniform vec4 viewDomain;   // current view: xMin, xMax, yMin, yMax
        uniform vec4 texDomain;    // texture domain: xMin, xMax, yMin, yMax
        #define PI ${Math.PI}
        #define TWOPI ${2 * Math.PI}

        vec3 colormap(vec2 uv) {
          uv *= TWOPI;
          return pow(0.5 + 0.5 * vec3(sin(uv.x) * vec2(-cos(uv.y), sin(uv.y)), -cos(uv.x)), vec3(0.75));
        }

        void main () {
          // Map from viewport pixel to normalized position [0,1] within viewport
          vec2 viewportUV = (gl_FragCoord.xy - axesViewport.xy) / axesViewport.zw;

          // Ephemeral transform: map viewportUV to textureUV
          // textureUV = offset + viewportUV * scale
          vec2 viewSize = vec2(viewDomain.y - viewDomain.x, viewDomain.w - viewDomain.z);
          vec2 texSize = vec2(texDomain.y - texDomain.x, texDomain.w - texDomain.z);
          vec2 scale = viewSize / texSize;
          vec2 offset = vec2(viewDomain.x - texDomain.x, viewDomain.z - texDomain.z) / texSize;
          vec2 uv = offset + viewportUV * scale;

          // Check if UV is outside texture bounds - show solid color
          if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
            gl_FragColor = vec4(0.95, 0.95, 0.95, 1.0); // Light gray for out of bounds
            return;
          }

          // Sample the state at this pixel
          vec4 state = texture2D(y, uv);

          // Color it by the projection of the 4D state to 2D (theta1, theta2):
          gl_FragColor = vec4(colormap(state.xy), 1);
        }`,
      uniforms: {
        y: () => y[0],
        axesViewport: (ctx) => {
          const vp = reglAxesViewport(axes)(ctx);
          return [vp.x, vp.y, vp.width, vp.height];
        },
        viewDomain: () => [axes.xDomain[0], axes.xDomain[1], axes.yDomain[0], axes.yDomain[1]],
        texDomain: () => [textureDomain.x[0], textureDomain.x[1], textureDomain.y[0], textureDomain.y[1]]
      },
      scissor: { enable: true, box: reglAxesViewport(axes) },
      viewport: reglAxesViewport(axes)
    })
  </script>
  <script id="886" type="module">
    const drawPendulum = regl({
      vert: `
    precision mediump float;
    attribute vec2 line;
    uniform vec2 resolution;
    uniform vec3 w1, w2;
    uniform vec2 hover;
    uniform float lineWidth;
    uniform sampler2D y;
    uniform float l1, l2;
    #define PI ${Math.PI}
    void main () {
      // Sample the state directly from the texture by passing the hovered
      // point as a uniform, so that the data never leaves the GPU.
      vec2 state = texture2D(y, hover).xy * (2.0 * PI) - PI;

      // Vectors representing the directions of the arms of the pendulum (scaled by lengths)
      vec2 v1 = l1 * vec2(sin(state.x), -cos(state.x));
      vec2 v2 = l2 * vec2(sin(state.y), -cos(state.y));

      // Points representing the joints of the pendulum (and the end)
      vec2 p0 = vec2(0);
      vec2 p1 = v1;
      vec2 p2 = p1 + v2;

      // Select two of the three above (arm1 or arm2) as endpoints of
      // the line to be rendered
      vec2 a = w1.x * p0 + w1.y * p1 + w1.z * p2;
      vec2 b = w2.x * p0 + w2.y * p1 + w2.z * p2;

      // Normal and tangential vectors
      vec2 t = normalize(b - a);
      vec2 n = vec2(-t.y, t.x);

      // Select which end of line we're at
      vec2 p = mix(a, b, line.y) * 0.5;

      // Offset normal to the line by the line width
      p += n * line.x * lineWidth;

      gl_Position = vec4(p, 0, 1);
    }`,
      frag: `
        precision lowp float;
        void main () {
          gl_FragColor = vec4(0, 0, 0, 1);
        }`,
      attributes: {
        line: [0.5, 0, 0.5, 1, -0.5, 0, -0.5, 1]
      },
      uniforms: {
        y: regl.prop('y[0]'),
        w1: regl.prop('w1'),
        w2: regl.prop('w2'),
        hover: () => mouseHover.pt,
        lineWidth: ctx => (4.0 * ctx.pixelRatio) / ctx.framebufferWidth,
        resolution: ctx => [ctx.framebufferWidth, ctx.framebufferHeight],
        l1: regl.prop('l1'),
        l2: regl.prop('l2')
      },
      depth: { enable: false },
      scissor: { enable: true, box: reglAxesViewport(axes) },
      viewport: reglAxesViewport(axes),
      primitive: 'triangle strip',
      count: 4
    })
  </script>
  <script id="889" type="module">
    const mouseHover = { pt: [0, 0], active: false };

    // Set up mouse tracking on the regl canvas
    const canvas = stack.elements.regl;
    function onPointerMove(event) {
      // Convert pixel coordinates to texture coordinates [0, 1]
      const rect = canvas.getBoundingClientRect();
      const x = (event.clientX - rect.left) / rect.width;
      const y = 1 - (event.clientY - rect.top) / rect.height;
      mouseHover.pt[0] = x;
      mouseHover.pt[1] = y;
      regl.dirty = true;
    }
    function onPointerEnter() {
      mouseHover.active = true;
      regl.dirty = true;
    }
    function onPointerLeave() {
      mouseHover.active = false;
      regl.dirty = true;
    }
    canvas.addEventListener('pointermove', onPointerMove, false);
    canvas.addEventListener('pointerenter', onPointerEnter, false);
    canvas.addEventListener('pointerleave', onPointerLeave, false);

    invalidation.then(() => {
      canvas.removeEventListener('pointermove', onPointerMove);
      canvas.removeEventListener('pointerenter', onPointerEnter);
      canvas.removeEventListener('pointerleave', onPointerLeave);
    });
  </script>
  <script id="901" type="module">
    await import('./lib/twttr.js')
    const twttr = window.twttr
  </script>
  <script id="903" type="module">
    function tweet(id, options) {
      const div = document.createElement("DIV");
      Promise.resolve().then(() => twttr.widgets.createTweet(id, div, options));
      return div;
    }
  </script>
    <script id="49" type="module">
    const pixelRatio = window.devicePixelRatio;
  </script>
  <script id="890" type="module">
    import createREGL from 'npm:regl@2.1.1'
    import { createElementStack } from './lib/element-stack.js'
    import { reglElement, reglAxesViewport } from './lib/regl-canvas.js'
    import { createZoomableAxes } from './lib/zoomable-axes.js'
    import { expandable } from './lib/expandable.js'
  </script>
  <script id="485" type="module">
    import { canWriteToFBOOfType } from 'observable:@rreusser/regl-tools'
  </script>
  <script id="635" type="module">
    import { rangeSlider } from 'observable:@mootari/range-slider'
  </script>
  <script id="791" type="module">
    function lerp(a, b, t) {
      return a + t * (b - a);
    }
  </script>
  <script id="651" type="text/html">
    <style>
    input[type=range] {
      width: 500px;
    }
    </style>
  </script>
  <script id="906" type="text/markdown">
    <h2 id="appendix">Appendix: Derivations of Equations of Motion</h2>
  </script>
  <script id="907" type="text/markdown">
    ### Simple Double Pendulum (Point Masses)
  </script>
  <script id="908" type="application/vnd.observable.javascript">
    html`<figure style="text-align: center;">
    <img width="350" src="${await FileAttachment("simple-pendulum-diagram.svg").url()}" alt="Simple double pendulum diagram">
    </figure>`
  </script>
  <script id="909" type="text/markdown">
    Consider a double pendulum with point masses ${tex`m_1`} and ${tex`m_2`} at distances ${tex`l_1`} and ${tex`l_2`} from their respective pivots, with angles ${tex`\theta_1`} and ${tex`\theta_2`} measured from vertical (downward).

    #### Coordinates

    The position of mass 1:

    ${tex.block`\begin{aligned}
    x_1 &= l_1 \sin \theta_1 \\
    y_1 &= -l_1 \cos \theta_1
    \end{aligned}`}

    The position of mass 2:

    ${tex.block`\begin{aligned}
    x_2 &= l_1 \sin \theta_1 + l_2 \sin \theta_2 \\
    y_2 &= -l_1 \cos \theta_1 - l_2 \cos \theta_2
    \end{aligned}`}

    #### Kinetic Energy

    Taking time derivatives:

    ${tex.block`\begin{aligned}
    \dot{x}_1 &= l_1 \dot{\theta}_1 \cos \theta_1 \\
    \dot{y}_1 &= l_1 \dot{\theta}_1 \sin \theta_1 \\
    \dot{x}_2 &= l_1 \dot{\theta}_1 \cos \theta_1 + l_2 \dot{\theta}_2 \cos \theta_2 \\
    \dot{y}_2 &= l_1 \dot{\theta}_1 \sin \theta_1 + l_2 \dot{\theta}_2 \sin \theta_2
    \end{aligned}`}

    The kinetic energy is:

    ${tex.block`\begin{aligned}
    T &= \frac{1}{2} m_1 (\dot{x}_1^2 + \dot{y}_1^2) + \frac{1}{2} m_2 (\dot{x}_2^2 + \dot{y}_2^2) \\
    &= \frac{1}{2} m_1 l_1^2 \dot{\theta}_1^2 + \frac{1}{2} m_2 \left[ l_1^2 \dot{\theta}_1^2 + l_2^2 \dot{\theta}_2^2 + 2 l_1 l_2 \dot{\theta}_1 \dot{\theta}_2 \cos(\theta_1 - \theta_2) \right]
    \end{aligned}`}

    #### Potential Energy

    ${tex.block`V = -m_1 g l_1 \cos \theta_1 - m_2 g (l_1 \cos \theta_1 + l_2 \cos \theta_2)`}

    #### Lagrangian

    ${tex.block`L = T - V`}

    #### Euler-Lagrange Equations

    The Euler-Lagrange equations ${tex`\frac{d}{dt}\frac{\partial L}{\partial \dot{\theta}_i} - \frac{\partial L}{\partial \theta_i} = 0`} yield (after simplification):

    ${tex.block`\begin{aligned}
    (m_1 + m_2) l_1^2 \ddot{\theta}_1 + m_2 l_1 l_2 \ddot{\theta}_2 \cos(\theta_1 - \theta_2) &= -m_2 l_1 l_2 \dot{\theta}_2^2 \sin(\theta_1 - \theta_2) - (m_1 + m_2) g l_1 \sin \theta_1 \\
    m_2 l_2^2 \ddot{\theta}_2 + m_2 l_1 l_2 \ddot{\theta}_1 \cos(\theta_1 - \theta_2) &= m_2 l_1 l_2 \dot{\theta}_1^2 \sin(\theta_1 - \theta_2) - m_2 g l_2 \sin \theta_2
    \end{aligned}`}

    #### Generalized Momenta

    The generalized momenta are:

    ${tex.block`\begin{aligned}
    p_{\theta_1} &= \frac{\partial L}{\partial \dot{\theta}_1} = (m_1 + m_2) l_1^2 \dot{\theta}_1 + m_2 l_1 l_2 \dot{\theta}_2 \cos(\theta_1 - \theta_2) \\
    p_{\theta_2} &= \frac{\partial L}{\partial \dot{\theta}_2} = m_2 l_2^2 \dot{\theta}_2 + m_2 l_1 l_2 \dot{\theta}_1 \cos(\theta_1 - \theta_2)
    \end{aligned}`}

    In matrix form ${tex`\mathbf{p} = M(\theta) \dot{\boldsymbol{\theta}}`} where:

    ${tex.block`M = \begin{pmatrix}
    (m_1 + m_2) l_1^2 & m_2 l_1 l_2 \cos(\theta_1 - \theta_2) \\
    m_2 l_1 l_2 \cos(\theta_1 - \theta_2) & m_2 l_2^2
    \end{pmatrix}`}

    Inverting to get ${tex`\dot{\boldsymbol{\theta}} = M^{-1} \mathbf{p}`} and computing ${tex`\dot{\mathbf{p}} = \frac{\partial L}{\partial \boldsymbol{\theta}}`}:

    ${tex.block`\begin{aligned}
    \dot{p}_{\theta_1} &= -m_2 l_1 l_2 \dot{\theta}_1 \dot{\theta}_2 \sin(\theta_1 - \theta_2) - (m_1 + m_2) g l_1 \sin\theta_1 \\
    \dot{p}_{\theta_2} &= m_2 l_1 l_2 \dot{\theta}_1 \dot{\theta}_2 \sin(\theta_1 - \theta_2) - m_2 g l_2 \sin\theta_2
    \end{aligned}`}

    As a first-order system with state ${tex`\mathbf{y} = (\theta_1, \theta_2, p_{\theta_1}, p_{\theta_2})^T`}:

    ${tex.block`\frac{d\mathbf{y}}{dt} = \begin{pmatrix}
    \dot{\theta}_1(\theta_1, \theta_2, p_{\theta_1}, p_{\theta_2}) \\
    \dot{\theta}_2(\theta_1, \theta_2, p_{\theta_1}, p_{\theta_2}) \\
    \dot{p}_{\theta_1}(\theta_1, \theta_2, p_{\theta_1}, p_{\theta_2}) \\
    \dot{p}_{\theta_2}(\theta_1, \theta_2, p_{\theta_1}, p_{\theta_2})
    \end{pmatrix}`}
  </script>
  <script id="910" type="text/markdown">
    ### Compound Double Pendulum (Distributed Mass)
  </script>
  <script id="911" type="application/vnd.observable.javascript">
    html`<figure style="text-align: center;">
    <img width="350" src="${await FileAttachment("compound-pendulum-diagram.svg").url()}" alt="Compound double pendulum diagram">
    </figure>`
  </script>
  <script id="912" type="text/markdown">
    For a compound pendulum, the mass is distributed along each arm. Consider uniform rods of lengths ${tex`l_1`} and ${tex`l_2`} with masses ${tex`m_1`} and ${tex`m_2`}, and moments of inertia ${tex`I_1 = \frac{1}{3}m_1 l_1^2`} and ${tex`I_2 = \frac{1}{3}m_2 l_2^2`} about their pivot points.

    #### Center of Mass Positions

    The centers of mass are located at the midpoints:

    ${tex.block`\begin{aligned}
    x_{c1} &= \frac{l_1}{2} \sin \theta_1, \quad y_{c1} = -\frac{l_1}{2} \cos \theta_1 \\
    x_{c2} &= l_1 \sin \theta_1 + \frac{l_2}{2} \sin \theta_2, \quad y_{c2} = -l_1 \cos \theta_1 - \frac{l_2}{2} \cos \theta_2
    \end{aligned}`}

    #### Kinetic Energy

    The kinetic energy includes both translational and rotational components:

    ${tex.block`T = \frac{1}{2} I_1 \dot{\theta}_1^2 + \frac{1}{2} m_1 (\dot{x}_{c1}^2 + \dot{y}_{c1}^2) + \frac{1}{2} I_2 \dot{\theta}_2^2 + \frac{1}{2} m_2 (\dot{x}_{c2}^2 + \dot{y}_{c2}^2)`}

    For a uniform rod rotating about its end, ${tex`I_1 = \frac{1}{3}m_1 l_1^2`} and ${tex`I_2 = \frac{1}{3}m_2 l_2^2`}. The translational kinetic energies are:

    ${tex.block`\begin{aligned}
    \frac{1}{2} m_1 (\dot{x}_{c1}^2 + \dot{y}_{c1}^2) &= \frac{1}{2} m_1 \frac{l_1^2}{4} \dot{\theta}_1^2 \\
    \frac{1}{2} m_2 (\dot{x}_{c2}^2 + \dot{y}_{c2}^2) &= \frac{1}{2} m_2 \left[ l_1^2 \dot{\theta}_1^2 + \frac{l_2^2}{4} \dot{\theta}_2^2 + l_1 l_2 \dot{\theta}_1 \dot{\theta}_2 \cos(\theta_1 - \theta_2) \right]
    \end{aligned}`}

    Thus:

    ${tex.block`T = \frac{1}{6} m_1 l_1^2 \dot{\theta}_1^2 + \frac{1}{2} m_2 l_1^2 \dot{\theta}_1^2 + \frac{1}{6} m_2 l_2^2 \dot{\theta}_2^2 + \frac{1}{2} m_2 l_1 l_2 \dot{\theta}_1 \dot{\theta}_2 \cos(\theta_1 - \theta_2)`}

    #### Potential Energy

    ${tex.block`V = -m_1 g \frac{l_1}{2} \cos \theta_1 - m_2 g \left( l_1 \cos \theta_1 + \frac{l_2}{2} \cos \theta_2 \right)`}

    #### Generalized Momenta

    The generalized momenta are:

    ${tex.block`\begin{aligned}
    p_{\theta_1} &= \frac{\partial L}{\partial \dot{\theta}_1} = \left(\frac{m_1}{3} + m_2\right) l_1^2 \dot{\theta}_1 + \frac{m_2}{2} l_1 l_2 \dot{\theta}_2 \cos(\theta_1 - \theta_2) \\
    p_{\theta_2} &= \frac{\partial L}{\partial \dot{\theta}_2} = \frac{m_2}{3} l_2^2 \dot{\theta}_2 + \frac{m_2}{2} l_1 l_2 \dot{\theta}_1 \cos(\theta_1 - \theta_2)
    \end{aligned}`}

    In matrix form ${tex`\mathbf{p} = M(\theta) \dot{\boldsymbol{\theta}}`} where:

    ${tex.block`M = \begin{pmatrix}
    \left(\frac{m_1}{3} + m_2\right) l_1^2 & \frac{m_2}{2} l_1 l_2 \cos(\theta_1 - \theta_2) \\
    \frac{m_2}{2} l_1 l_2 \cos(\theta_1 - \theta_2) & \frac{m_2}{3} l_2^2
    \end{pmatrix}`}

    Inverting to get ${tex`\dot{\boldsymbol{\theta}} = M^{-1} \mathbf{p}`} and computing ${tex`\dot{\mathbf{p}} = \frac{\partial L}{\partial \boldsymbol{\theta}}`}:

    ${tex.block`\begin{aligned}
    \dot{p}_{\theta_1} &= -\frac{m_2}{2} l_1 l_2 \dot{\theta}_1 \dot{\theta}_2 \sin(\theta_1 - \theta_2) - \left(\frac{m_1}{2} + m_2\right) g l_1 \sin\theta_1 \\
    \dot{p}_{\theta_2} &= \frac{m_2}{2} l_1 l_2 \dot{\theta}_1 \dot{\theta}_2 \sin(\theta_1 - \theta_2) - \frac{m_2}{2} g l_2 \sin\theta_2
    \end{aligned}`}

    As a first-order system with state ${tex`\mathbf{y} = (\theta_1, \theta_2, p_{\theta_1}, p_{\theta_2})^T`}:

    ${tex.block`\frac{d\mathbf{y}}{dt} = \begin{pmatrix}
    \dot{\theta}_1(\theta_1, \theta_2, p_{\theta_1}, p_{\theta_2}) \\
    \dot{\theta}_2(\theta_1, \theta_2, p_{\theta_1}, p_{\theta_2}) \\
    \dot{p}_{\theta_1}(\theta_1, \theta_2, p_{\theta_1}, p_{\theta_2}) \\
    \dot{p}_{\theta_2}(\theta_1, \theta_2, p_{\theta_1}, p_{\theta_2})
    \end{pmatrix}`}
  </script>
</notebook>
