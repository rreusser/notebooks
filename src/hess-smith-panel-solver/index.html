<!doctype html>
<notebook theme="air">
  <title>Hess-Smith Panel Method</title>
  <script id="1" type="text/markdown">
    # Hess-Smith Panel Method

    The [Hess-Smith panel method](https://en.wikipedia.org/wiki/Panel_method) computes potential flow around arbitrary 2D shapes by distributing singularities along the body surface. Given an airfoil shape and angle of attack, it determines the velocity field, pressure distribution, and lift. Adjust parameters below to explore lift generated by flow over an airfoil.
  </script>
  <script id="2" type="text/x-typescript">
    const figure = html`<figure id="panel-solver-figure">
      ${stack.element}
      <figcaption>Pressure field around a NACA 4-digit airfoil. Drag to pan, scroll to zoom.</figcaption>
    </figure>`;

    display(expandable(figure, {
      width: Math.min(width, 800),
      height: Math.min(500, width * 0.625),
      toggleOffset: [-14, -82],
      controls: '.panel-solver-controls',
      onResize(el, w, h) {
        stack.resize(w, h);
        axes.updateScales(
          stack.elements.plot.scale("x"),
          stack.elements.plot.scale("y")
        );
        renderState.dirty = true;
        if (renderState.render) renderState.render();
      }
    }));
  </script>
  <script id="3" type="text/x-typescript">
    const controlsContainer = html`<div class="panel-solver-controls"></div>`;

    function ctrl(input) {
      controlsContainer.appendChild(input);
      return Generators.input(input);
    }

    const alpha = ctrl(Inputs.range([-20, 20], {
      label: "Angle of attack",
      value: 7,
      step: 0.1
    }));

    const panelCount = ctrl(Inputs.range([10, 200], {
      label: "Panel count",
      value: 40,
      step: 1
    }));

    const camber = ctrl(Inputs.range([-0.2, 0.2], {
      label: "Camber (m)",
      value: 0.04,
      step: 0.001
    }));

    const camberLoc = ctrl(Inputs.range([0.2, 0.8], {
      label: "Camber location (p)",
      value: 0.4,
      step: 0.01
    }));

    const thickness = ctrl(Inputs.range([0.01, 0.5], {
      label: "Thickness (t)",
      value: 0.12,
      step: 0.01
    }));

    const kuttaCondition = ctrl(Inputs.toggle({
      label: "Kutta condition",
      value: true
    }));

    // Fixed values (no controls)
    const clustering = true;
    const contourOpacity = 0.05;
    const fillOpacity = 1.0;
    const edgeOpacity = 1.0;
    const edgeWidth = 3.0;
    const vertexOpacity = 0.9;
    const forceArrowScale = 0.15;
    const pointSize = 5;

    const shadingOpacity = ctrl(Inputs.range([0, 1], {
      label: "Shading opacity",
      value: 0.15,
      step: 0.01
    }));

    const streamlineCount = ctrl(Inputs.range([0, 2000], {
      label: "Streamline count",
      value: 500,
      step: 1
    }));

    const streamlineOpacity = ctrl(Inputs.range([0, 1], {
      label: "Streamline opacity",
      value: 0.3,
      step: 0.01
    }));

    const streamlineLength = ctrl(Inputs.range([5, 40], {
      label: "Streamline length",
      value: 20,
      step: 1
    }));

    const forceAtQuarterChord = ctrl(Inputs.toggle({
      label: "Force at quarter-chord (AC)",
      value: true
    }));

    const showPressureDist = ctrl(Inputs.toggle({
      label: "Show pressure distribution",
      value: true
    }));

    const pressureScale = ctrl(Inputs.range([0.01, 0.1], {
      label: "Pressure scale",
      value: 0.01,
      step: 0.005
    }));

    const pressureOffset = ctrl(Inputs.range([0, 50], {
      label: "Pressure offset (Cp)",
      value: 10.0,
      step: 0.1
    }));

    display(controlsContainer);
  </script>
  <script id="4" type="text/x-typescript">
    display(html`<div style="font-family: var(--sans-serif); margin-top: 0.5em;">
      <strong>Lift coefficient:</strong> ${liftCoeff.toFixed(4)}
    </div>`);
  </script>
  <script id="54" type="text/markdown">
    ## Sources and Vortices

  </script>
  <script id="5" type="text/markdown">
    To analyze flow over a two-dimensional geometry, the vortex-panel method of Hess and Smith starts by cutting a smooth surface into piecewise-linear panels.
  </script>
  <script id="55" type="text/x-typescript">
    // Create a simple diagram showing a panelized NACA 2412 airfoil
    const w = 400;
    const margin = { left: 30, right: 30, top: 25, bottom: 25 };
    const plotW = w - margin.left - margin.right;
    const xDomain = [-0.05, 1.05];
    const yDomain = [-0.12, 0.12];
    const xRange = xDomain[1] - xDomain[0];
    const yRange = yDomain[1] - yDomain[0];
    const plotH = plotW * yRange / xRange;
    const h = plotH + margin.top + margin.bottom;

    const svg = d3.create("svg")
      .attr("width", w)
      .attr("height", h)
      .attr("viewBox", `0 0 ${w} ${h}`)
      .style("max-width", "100%")
      .style("display", "block")
      .style("margin", "1em auto");

    // NACA 2412 parameters
    const m = 0.02;  // max camber
    const p = 0.4;   // location of max camber
    const t = 0.12;  // thickness

    // Generate airfoil coordinates with ~10 panels (11 points)
    const nPoints = 11;
    const points = [];

    for (let i = 0; i < nPoints; i++) {
      // Cosine spacing for better leading edge resolution
      const theta = Math.PI * i / (nPoints - 1);
      const x = 0.5 * (1 - Math.cos(theta));

      // Camber line
      let yc, dyc;
      if (x < p) {
        yc = (m / (p * p)) * (2 * p * x - x * x);
        dyc = (2 * m / (p * p)) * (p - x);
      } else {
        yc = (m / ((1 - p) * (1 - p))) * ((1 - 2 * p) + 2 * p * x - x * x);
        dyc = (2 * m / ((1 - p) * (1 - p))) * (p - x);
      }

      // Thickness distribution
      const yt = 5 * t * (0.2969 * Math.sqrt(x) - 0.1260 * x - 0.3516 * x * x + 0.2843 * x * x * x - 0.1015 * x * x * x * x);

      // Upper and lower surfaces
      const thetaC = Math.atan(dyc);
      const xu = x - yt * Math.sin(thetaC);
      const yu = yc + yt * Math.cos(thetaC);
      const xl = x + yt * Math.sin(thetaC);
      const yl = yc - yt * Math.cos(thetaC);

      if (i === 0) {
        points.push([xu, yu]); // Leading edge (upper = lower)
      } else if (i === nPoints - 1) {
        points.push([xu, yu]); // Trailing edge (upper = lower)
      } else {
        points.unshift([xl, yl]); // Lower surface (reversed order)
        points.push([xu, yu]);    // Upper surface
      }
    }

    // Scales
    const xScale = d3.scaleLinear().domain(xDomain).range([margin.left, margin.left + plotW]);
    const yScale = d3.scaleLinear().domain(yDomain).range([margin.top + plotH, margin.top]);

    // Draw filled interior
    const pathData = points.map((pt, i) => `${i === 0 ? 'M' : 'L'} ${xScale(pt[0])} ${yScale(pt[1])}`).join(' ') + ' Z';
    svg.append("path")
      .attr("d", pathData)
      .attr("fill", "#ddd")
      .attr("stroke", "none");

    // Draw panel edges
    for (let i = 0; i < points.length; i++) {
      const p1 = points[i];
      const p2 = points[(i + 1) % points.length];
      svg.append("line")
        .attr("x1", xScale(p1[0]))
        .attr("y1", yScale(p1[1]))
        .attr("x2", xScale(p2[0]))
        .attr("y2", yScale(p2[1]))
        .attr("stroke", "#333")
        .attr("stroke-width", 2);
    }

    // Draw vertices
    for (const pt of points) {
      svg.append("circle")
        .attr("cx", xScale(pt[0]))
        .attr("cy", yScale(pt[1]))
        .attr("r", 4)
        .attr("fill", "#333");
    }

    display(html`<figure style="margin: 1em auto; max-width: 420px;">
      ${svg.node()}
      <figcaption style="text-align: center; font-size: 14px; margin-top: 8px;">
        A NACA 2412 airfoil discretized into panels.
      </figcaption>
    </figure>`);
  </script>
  <script id="56" type="text/markdown">
    The essence of the method is to construct the fluid flow we want through superposition of simpler fluid flows. We can superimpose fluid flows because, to a reasonable approximation, the flow is both *inviscid* and *irrotational*. Inviscid means that, away from surfaces at least, the flow is dominated by momentum forces and that viscous forces are negligible. Irrotational means that, even though the fluid may move in curved arcs, an individual parcel of fluid does not actually rotate. The upshot of these conditions, called the [potential flow](https://en.wikipedia.org/wiki/Potential_flow) approximation, is that we can superimpose simple fluid flow solutions to construct a more complicated flow.
  </script>
  <script id="61" type="text/markdown">
    To compute flow around the airfoil, we use two potential flow features as our building blocks. First, **source panels** push fluid perpendicular to the respective panel surfaces.
  </script>
  <script id="6" type="text/x-typescript">
    // Compute velocity induced by a single panel at point (x, y)
    // Panel goes from (x1, y1) to (x2, y2)
    // sigma = source strength, gamma = vortex strength (per unit length)
    function panelVelocity(x, y, x1, y1, x2, y2, sigma, gamma) {
      // Vectors from panel endpoints to field point
      const r1x = x - x1, r1y = y - y1;
      const r2x = x - x2, r2y = y - y2;

      const r1sq = r1x * r1x + r1y * r1y;
      const r2sq = r2x * r2x + r2y * r2y;

      // Avoid singularity at panel endpoints
      if (r1sq < 1e-10 || r2sq < 1e-10) return { vx: 0, vy: 0 };

      // Panel tangent and normal
      const dx = x2 - x1, dy = y2 - y1;
      const len = Math.sqrt(dx * dx + dy * dy);
      const tx = dx / len, ty = dy / len;
      const nx = -ty, ny = tx;

      // Geometric quantities
      const lambda = 0.5 * Math.log(r2sq / r1sq);
      const det = r1x * r2y - r2x * r1y;
      const dot = r1x * r2x + r1y * r2y;
      const beta = Math.atan2(det, dot);

      // Velocity contributions (equation from panel method)
      const c = 0.5 / Math.PI;
      const vx = c * (sigma * (-lambda * tx + beta * nx) + gamma * (beta * tx + lambda * nx));
      const vy = c * (sigma * (-lambda * ty + beta * ny) + gamma * (beta * ty + lambda * ny));

      return { vx, vy };
    }

    // Trace a streamline from starting point using RK4 integration
    function traceStreamline(x0, y0, x1, y1, x2, y2, sigma, gamma, dt, steps, bounds) {
      const points = [];
      let x = x0, y = y0;

      // Helper to get normalized velocity direction
      function velocityDir(px, py) {
        const { vx, vy } = panelVelocity(px, py, x1, y1, x2, y2, sigma, gamma);
        const vmag = Math.sqrt(vx * vx + vy * vy);
        if (vmag < 1e-10) return { dx: 0, dy: 0, valid: false };
        return { dx: vx / vmag, dy: vy / vmag, valid: true };
      }

      for (let i = 0; i < steps; i++) {
        if (x < bounds.xmin || x > bounds.xmax || y < bounds.ymin || y > bounds.ymax) break;
        points.push([x, y]);

        // RK4 integration
        const k1 = velocityDir(x, y);
        if (!k1.valid) break;

        const k2 = velocityDir(x + 0.5 * dt * k1.dx, y + 0.5 * dt * k1.dy);
        if (!k2.valid) break;

        const k3 = velocityDir(x + 0.5 * dt * k2.dx, y + 0.5 * dt * k2.dy);
        if (!k3.valid) break;

        const k4 = velocityDir(x + dt * k3.dx, y + dt * k3.dy);
        if (!k4.valid) break;

        x += (dt / 6) * (k1.dx + 2 * k2.dx + 2 * k3.dx + k4.dx);
        y += (dt / 6) * (k1.dy + 2 * k2.dy + 2 * k3.dy + k4.dy);
      }

      return points;
    }

    // Create SVG diagram for panel-induced flow
    function createPanelDiagram(title, sigma, gamma, isVortex = false) {
      const w = 380, h = 300;
      const margin = { top: 35, right: 25, bottom: 25, left: 25 };
      const innerW = w - margin.left - margin.right;
      const innerH = h - margin.top - margin.bottom;

      // Panel endpoints (horizontal panel centered at origin)
      const panelX1 = -0.5, panelY1 = 0;
      const panelX2 = 0.5, panelY2 = 0;

      // Domain
      const bounds = { xmin: -1.5, xmax: 1.5, ymin: -1.2, ymax: 1.2 };

      const xScale = d3.scaleLinear().domain([bounds.xmin, bounds.xmax]).range([0, innerW]);
      const yScale = d3.scaleLinear().domain([bounds.ymin, bounds.ymax]).range([innerH, 0]);

      const svg = d3.create("svg")
        .attr("width", w)
        .attr("height", h)
        .attr("viewBox", `0 0 ${w} ${h}`)
        .style("max-width", "100%")
        .style("background", "transparent")
        .style("border-radius", "4px");

      // Title
      svg.append("text")
        .attr("x", w / 2)
        .attr("y", 22)
        .attr("text-anchor", "middle")
        .attr("font-family", "var(--sans-serif)")
        .attr("font-size", "15px")
        .attr("font-weight", "600")
        .text(title);

      const g = svg.append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

      // Draw streamlines - different seeding for source vs vortex
      const streamlineSeeds = [];

      if (isVortex) {
        // For vortex: seed along a vertical line to get concentric loops
        // Fewer seeds at well-spaced distances from center
        for (let r = 0.15; r <= 1.1; r += 0.18) {
          streamlineSeeds.push([0, r]);
        }
      } else {
        // For source: seeds around the edges (reduced density)
        for (let i = -6; i <= 6; i += 2) {
          if (Math.abs(i) >= 1) {
            streamlineSeeds.push([-1.4, i * 0.15]);
            streamlineSeeds.push([1.4, i * 0.15]);
          }
        }
        // Seeds above and below
        for (let i = -4; i <= 4; i += 2) {
          streamlineSeeds.push([i * 0.25, 1.1]);
          streamlineSeeds.push([i * 0.25, -1.1]);
        }
      }

      const line = d3.line()
        .x(d => xScale(d[0]))
        .y(d => yScale(d[1]));

      // Trace all streamlines first
      const allStreamlines = [];
      for (const [sx, sy] of streamlineSeeds) {
        const fwd = traceStreamline(sx, sy, panelX1, panelY1, panelX2, panelY2, sigma, gamma, 0.03, 200, bounds);
        const bwd = traceStreamline(sx, sy, panelX1, panelY1, panelX2, panelY2, sigma, gamma, -0.03, 200, bounds);
        const combined = [...bwd.reverse(), ...fwd.slice(1)];
        if (combined.length > 3) {
          allStreamlines.push(combined);
        }
      }

      // Draw streamlines
      for (const streamline of allStreamlines) {
        g.append("path")
          .attr("d", line(streamline))
          .attr("fill", "none")
          .attr("stroke", "#4a90d9")
          .attr("stroke-width", 2)
          .attr("stroke-opacity", 0.75);
      }

      // Place arrowheads with minimum spacing
      const arrowheads = [];  // List of placed arrowhead positions
      const minDist = 0.28;   // Minimum distance between arrowheads (in data coords)
      const arrowSize = 7;    // Arrow size in pixels

      function canPlaceArrow(x, y) {
        for (const [ax, ay] of arrowheads) {
          const dist = Math.sqrt((x - ax) ** 2 + (y - ay) ** 2);
          if (dist < minDist) return false;
        }
        return true;
      }

      // Walk along each streamline and place arrows
      for (const streamline of allStreamlines) {
        for (let i = 2; i < streamline.length - 2; i += 3) {
          const [x, y] = streamline[i];
          if (canPlaceArrow(x, y)) {
            arrowheads.push([x, y]);

            // Get direction from neighboring points
            const [x0, y0] = streamline[i - 1];
            const [x1, y1] = streamline[i + 1];
            const angle = Math.atan2(y1 - y0, x1 - x0);

            // Draw arrowhead as a small triangle
            const sx = xScale(x), sy = yScale(y);
            const cos = Math.cos(angle), sin = Math.sin(angle);
            // Scale sin for y since yScale is inverted
            const sinY = -sin;

            // Triangle points: tip, and two back corners
            const tipX = sx + arrowSize * cos;
            const tipY = sy + arrowSize * sinY;
            const backL_X = sx - arrowSize * 0.5 * cos - arrowSize * 0.5 * (-sinY);
            const backL_Y = sy - arrowSize * 0.5 * sinY - arrowSize * 0.5 * cos;
            const backR_X = sx - arrowSize * 0.5 * cos + arrowSize * 0.5 * (-sinY);
            const backR_Y = sy - arrowSize * 0.5 * sinY + arrowSize * 0.5 * cos;

            g.append("path")
              .attr("d", `M${tipX},${tipY} L${backL_X},${backL_Y} L${backR_X},${backR_Y} Z`)
              .attr("fill", "#4a90d9")
              .attr("stroke", "none");
          }
        }
      }

      // Draw the panel (thick line)
      g.append("line")
        .attr("x1", xScale(panelX1))
        .attr("y1", yScale(panelY1))
        .attr("x2", xScale(panelX2))
        .attr("y2", yScale(panelY2))
        .attr("stroke", "#333")
        .attr("stroke-width", 4)
        .attr("stroke-linecap", "round");

      // Panel endpoints
      g.append("circle")
        .attr("cx", xScale(panelX1))
        .attr("cy", yScale(panelY1))
        .attr("r", 4)
        .attr("fill", "#e74c3c");

      g.append("circle")
        .attr("cx", xScale(panelX2))
        .attr("cy", yScale(panelY2))
        .attr("r", 4)
        .attr("fill", "#e74c3c");

      // Labels
      // Helper to add text with white shadow for legibility
      function addLabelWithShadow(x, y, anchor, text) {
        // White shadow (stroke behind)
        g.append("text")
          .attr("x", x)
          .attr("y", y)
          .attr("text-anchor", anchor)
          .attr("font-family", "var(--serif)")
          .attr("font-size", "14px")
          .attr("font-style", "italic")
          .attr("fill", "white")
          .attr("stroke", "white")
          .attr("stroke-width", 3)
          .attr("stroke-linejoin", "round")
          .text(text);
        // Foreground text
        g.append("text")
          .attr("x", x)
          .attr("y", y)
          .attr("text-anchor", anchor)
          .attr("font-family", "var(--serif)")
          .attr("font-size", "14px")
          .attr("font-style", "italic")
          .attr("fill", "#333")
          .text(text);
      }

      addLabelWithShadow(xScale(panelX1) - 10, yScale(panelY1) + 5, "end", "(xⱼ, yⱼ)");
      addLabelWithShadow(xScale(panelX2) + 10, yScale(panelY2) + 5, "start", "(xⱼ₊₁, yⱼ₊₁)");

      return svg.node();
    }

  </script>
  <script id="7" type="text/x-typescript">
    const sourceDiagram = createPanelDiagram("Source Panel (σ = 1)", 1, 0, false);

    display(html`<figure style="margin: 1em auto; max-width: 400px;">
      ${sourceDiagram}
      <figcaption style="text-align: center; font-size: 14px; margin-top: 8px;">
        A source panel creates flow emanating perpendicular to the surface.
      </figcaption>
    </figure>`);
  </script>
  <script id="43" type="text/markdown">
    Second, **vortex panels** create circulation around panel surfaces.
  </script>
  <script id="8" type="text/x-typescript">
    const vortexDiagram = createPanelDiagram("Vortex Panel (γ = 1)", 0, 1, true);

    display(html`<figure style="margin: 1em auto; max-width: 400px;">
      ${vortexDiagram}
      <figcaption style="text-align: center; font-size: 14px; margin-top: 8px;">
        A vortex panel creates circulation around the panel.
      </figcaption>
    </figure>`);
  </script>
  <script id="44" type="text/markdown">
    The figure below shows three panels, each with its own source/sink distribution, and with equal vortex distribution along the panels. On top of this, we’ve superimposed an incoming free stream velocity representing the geometry moving forward through the air.
  </script>
  <script id="58" type="text/x-typescript">
    import { createInteractivePanelDiagram } from './interactive-panel-diagram.js';

    const { controls, figure: interactiveFigure } = createInteractivePanelDiagram({
      d3,
      html,
      Inputs,
      device,
      canvasFormat,
      width,
      devicePixelRatio
    });

    display(controls);
    display(interactiveFigure);
  </script>
  <script id="46" type="text/markdown">
    The resulting flow for this toy example is nice, but it’s unphysical; air passes right through the panel surfaces. To remedy the situation, we apply two conditions. First, the **non-penetration condition** states that fluid cannot flow into or out of a solid surface, that it flows *tangential* to each panel surface.
  </script>
  <script id="57" type="text/x-typescript">
    // Create a simple diagram illustrating the non-penetration condition
    const w = 280, h = 140;
    const svg = d3.create("svg")
      .attr("width", w)
      .attr("height", h)
      .attr("viewBox", `0 0 ${w} ${h}`)
      .style("max-width", "100%")
      .style("display", "block")
      .style("margin", "1em auto");

    // Panel parameters - slightly inclined
    const angle = -15 * Math.PI / 180;
    const cx = w / 2, cy = h / 2 + 10;
    const panelLen = 160;
    const cos = Math.cos(angle), sin = Math.sin(angle);

    // Panel endpoints
    const x1 = cx - panelLen / 2 * cos;
    const y1 = cy - panelLen / 2 * sin;
    const x2 = cx + panelLen / 2 * cos;
    const y2 = cy + panelLen / 2 * sin;

    // Shaded region below panel (indicating solid body)
    const shadeDepth = 30;
    const nx = -sin, ny = cos; // normal pointing "up" (outward)
    svg.append("path")
      .attr("d", `M ${x1} ${y1}
                  L ${x2} ${y2}
                  L ${x2 + shadeDepth * nx} ${y2 + shadeDepth * ny}
                  L ${x1 + shadeDepth * nx} ${y1 + shadeDepth * ny} Z`)
      .attr("fill", "#ddd")
      .attr("stroke", "none");

    // Surface face stroke only
    svg.append("line")
      .attr("x1", x1)
      .attr("y1", y1)
      .attr("x2", x2)
      .attr("y2", y2)
      .attr("stroke", "#333")
      .attr("stroke-width", 2);

    // Arrow styling
    const arrowColor = "#4a90d9";

    // Create arrowhead marker
    svg.append("defs").append("marker")
      .attr("id", "nonpen-arrowhead")
      .attr("viewBox", "0 0 10 10")
      .attr("refX", 9)
      .attr("refY", 5)
      .attr("markerWidth", 5)
      .attr("markerHeight", 5)
      .attr("orient", "auto")
      .append("path")
      .attr("d", "M 0 0 L 10 5 L 0 10 Z")
      .attr("fill", arrowColor);

    // Flow arrow parallel to surface, offset above
    const arrowOffset = 12; // distance above panel
    const arrowLen = 100;
    const ax1 = cx - arrowLen / 2 * cos - arrowOffset * nx;
    const ay1 = cy - arrowLen / 2 * sin - arrowOffset * ny;
    const ax2 = cx + arrowLen / 2 * cos - arrowOffset * nx;
    const ay2 = cy + arrowLen / 2 * sin - arrowOffset * ny;

    svg.append("line")
      .attr("x1", ax1)
      .attr("y1", ay1)
      .attr("x2", ax2)
      .attr("y2", ay2)
      .attr("stroke", arrowColor)
      .attr("stroke-width", 2.5)
      .attr("marker-end", "url(#nonpen-arrowhead)");

    // Label for velocity
    svg.append("text")
      .attr("x", ax2 + 8)
      .attr("y", ay2 - 8)
      .attr("font-family", "var(--serif)")
      .attr("font-size", "14px")
      .attr("font-style", "italic")
      .attr("fill", arrowColor)
      .text("v");

    display(html`<figure style="margin: 1em auto; max-width: 300px;">
      ${svg.node()}
      <figcaption style="text-align: center; font-size: 14px; margin-top: 8px;">
        Flow velocity is tangent to the panel surface.
      </figcaption>
    </figure>`);
  </script>
  <script id="47" type="text/markdown">
    Second, the **Kutta condition** states that fluid must leave an airfoil's trailing edge smoothly. The logic is straightforward. The potential flow approximation indicates that any transverse velocity at the sharp cusp of the trailing edge would require the flow to have infinite velocity at that point. Viscosity, even though we've neglected it, becomes important at this point and would cause the airfoil to shed a vortex to prevent this unphysical infinite-velocity state. This vortex shedding would continue until smooth flow is obtained, so we assume the flow has already equilibriated and smooth flow has been obtained, therefore the transverse velocity component at the trailing edge is precisely zero.
  </script>
  <script id="48" type="text/x-typescript">
    // Create a simple diagram illustrating the Kutta condition
    const w = 320, h = 200;
    const svg = d3.create("svg")
      .attr("width", w)
      .attr("height", h)
      .attr("viewBox", `0 0 ${w} ${h}`)
      .style("max-width", "100%")
      .style("display", "block")
      .style("margin", "1em auto");

    // Trailing edge triangle (sharp wedge shape)
    const tipX = 260, tipY = 100;
    const backX = 60;
    const halfHeight = 50;

    // Draw airfoil trailing edge as filled shape
    svg.append("path")
      .attr("d", `M ${backX} ${tipY - halfHeight}
                  L ${tipX} ${tipY}
                  L ${backX} ${tipY + halfHeight} Z`)
      .attr("fill", "#ddd")
      .attr("stroke", "none");

    // Top and bottom edges only (not left side)
    svg.append("line")
      .attr("x1", backX)
      .attr("y1", tipY - halfHeight)
      .attr("x2", tipX)
      .attr("y2", tipY)
      .attr("stroke", "#333")
      .attr("stroke-width", 2);

    svg.append("line")
      .attr("x1", backX)
      .attr("y1", tipY + halfHeight)
      .attr("x2", tipX)
      .attr("y2", tipY)
      .attr("stroke", "#333")
      .attr("stroke-width", 2);

    // Arrow styling
    const arrowColor = "#4a90d9";
    const arrowWidth = 2.5;

    // Create arrowhead marker
    svg.append("defs").append("marker")
      .attr("id", "kutta-arrowhead")
      .attr("viewBox", "0 0 10 10")
      .attr("refX", 9)
      .attr("refY", 5)
      .attr("markerWidth", 5)
      .attr("markerHeight", 5)
      .attr("orient", "auto")
      .append("path")
      .attr("d", "M 0 0 L 10 5 L 0 10 Z")
      .attr("fill", arrowColor);

    // Separation between upper and lower flow at exit
    const sep = 6;

    // Upper surface flow - bezier curve leaving smoothly
    svg.append("path")
      .attr("d", `M ${backX - 20} ${tipY - halfHeight - 15}
                  Q ${backX + 60} ${tipY - halfHeight + 5},
                    ${tipX - 30} ${tipY - 14}
                  Q ${tipX + 20} ${tipY - sep},
                    ${tipX + 50} ${tipY - sep}`)
      .attr("fill", "none")
      .attr("stroke", arrowColor)
      .attr("stroke-width", arrowWidth)
      .attr("marker-end", "url(#kutta-arrowhead)");

    // Lower surface flow - bezier curve leaving smoothly
    svg.append("path")
      .attr("d", `M ${backX - 20} ${tipY + halfHeight + 15}
                  Q ${backX + 60} ${tipY + halfHeight - 5},
                    ${tipX - 30} ${tipY + 14}
                  Q ${tipX + 20} ${tipY + sep},
                    ${tipX + 50} ${tipY + sep}`)
      .attr("fill", "none")
      .attr("stroke", arrowColor)
      .attr("stroke-width", arrowWidth)
      .attr("marker-end", "url(#kutta-arrowhead)");

    // Label
    svg.append("text")
      .attr("x", tipX + 10)
      .attr("y", tipY + 35)
      .attr("text-anchor", "middle")
      .attr("font-family", "var(--sans-serif)")
      .attr("font-size", "13px")
      .attr("fill", "#666")
      .text("trailing edge");

    display(html`<figure style="margin: 1em auto; max-width: 350px;">
      ${svg.node()}
      <figcaption style="text-align: center; font-size: 14px; margin-top: 8px;">
        The Kutta condition requires flow from the upper and lower surfaces to leave the trailing edge smoothly, meeting at the same velocity.
      </figcaption>
    </figure>`);
  </script>
  <script id="150" type="text/markdown">
    Moreover, since the flow here is subsonic, this circulation generated by the Kutta condition propagates back upstream, adjusting the flow over the airfoil until we meet the classic description of an airfoil with flow circulating over the top faster than underneath, therefore generating lift by way of [Bernoulli's principle](https://en.wikipedia.org/wiki/Bernoulli%27s_principle).
  </script>
  <script id="60" type="text/markdown">
    ## Mathematical formulation
  </script>
  <script id="53" type="text/markdown">
    The rest of this document put the above physical arguments into a mathematical form we can solve.
  </script>
  <script id="11" type="text/markdown">
    ### Panel Geometry

    We discretize the airfoil surface into ${tex`n`} panels connecting ${tex`n+1`} vertices. Each panel ${tex`j`} has endpoints ${tex`(x_j, y_j)`} and ${tex`(x_{j+1}, y_{j+1})`}, with the control point placed at the midpoint:

    ${tex.block`
    (\xi_i, \eta_i) = \frac{1}{2}\bigl((x_i, y_i) + (x_{i+1}, y_{i+1})\bigr)
    `}

    The panel angle ${tex`\theta_j = \text{atan2}(y_{j+1} - y_j, x_{j+1} - x_j)`} defines the local tangent ${tex`\mathbf{t}_j = (\cos\theta_j, \sin\theta_j)`} and outward normal ${tex`\mathbf{n}_j = (-\sin\theta_j, \cos\theta_j)`}.
  </script>
  <script id="12" type="text/markdown">
    ### Panel Influence Coefficients

    The velocity induced at a control point by a panel depends on the geometry relating them. Let ${tex`\mathbf{r}_{ij}`} and ${tex`\mathbf{r}_{ij+1}`} be the vectors from the endpoints of panel ${tex`j`} to control point ${tex`i`}:

    ${tex.block`
    \begin{aligned}
    \mathbf{r}_{ij} &= (\xi_i, \eta_i) - (x_j, y_j) \\
    \mathbf{r}_{ij+1} &= (\xi_i, \eta_i) - (x_{j+1}, y_{j+1})
    \end{aligned}
    `}

    The influence coefficients are expressed in terms of two geometric quantities. The first is the angle subtended by panel ${tex`j`} as seen from control point ${tex`i`}:

    ${tex.block`
    \beta_{ij} = \text{atan2}\bigl(\mathbf{r}_{ij} \times \mathbf{r}_{ij+1},\; \mathbf{r}_{ij} \cdot \mathbf{r}_{ij+1}\bigr)
    `}

    For the self-influence case (${tex`i = j`}), the control point lies on the panel itself, and ${tex`\beta_{ii} = \pi \cdot w`} where ${tex`w = \pm 1`} is the winding direction. The second quantity is the log-ratio of distances from the control point to the panel endpoints:

    ${tex.block`
    \lambda_{ij} = \frac{1}{2}\ln\frac{|\mathbf{r}_{ij+1}|^2}{|\mathbf{r}_{ij}|^2} = \ln\frac{|\mathbf{r}_{ij+1}|}{|\mathbf{r}_{ij}|}
    `}
  </script>
  <script id="13" type="text/markdown">
    ### Velocity Components

    The induced velocity at control point ${tex`i`} from panel ${tex`j`} is most usefully expressed in the local coordinate system of panel ${tex`i`}. With ${tex`\Delta\theta_{ij} = \theta_i - \theta_j`} denoting the angle difference between panels, the normal component of velocity (positive pointing outward from the body) is

    ${tex.block`
    \begin{aligned}
    v_{n,ij} = \frac{1}{2\pi}\Bigl[&\sigma_j\bigl(\sin\Delta\theta_{ij}\cdot\lambda_{ij} + \cos\Delta\theta_{ij}\cdot\beta_{ij}\bigr) \\
    &+ \gamma\bigl(\cos\Delta\theta_{ij}\cdot\lambda_{ij} - \sin\Delta\theta_{ij}\cdot\beta_{ij}\bigr)\Bigr]
    \end{aligned}
    `}

    and the tangential component (positive in the direction of increasing panel index) is

    ${tex.block`
    \begin{aligned}
    v_{t,ij} = \frac{1}{2\pi}\Bigl[&\sigma_j\bigl(\sin\Delta\theta_{ij}\cdot\beta_{ij} - \cos\Delta\theta_{ij}\cdot\lambda_{ij}\bigr) \\
    &+ \gamma\bigl(\sin\Delta\theta_{ij}\cdot\lambda_{ij} + \cos\Delta\theta_{ij}\cdot\beta_{ij}\bigr)\Bigr].
    \end{aligned}
    `}

    Notice that both the source strength ${tex`\sigma_j`} and the vortex strength ${tex`\gamma`} contribute to both velocity components. The normal velocities enter the no-penetration condition; the tangential velocities enter the Kutta condition.
  </script>
  <script id="14" type="text/markdown">
    ### Boundary Conditions

    The no-penetration condition requires that fluid cannot pass through the airfoil surface. At each control point ${tex`i`}, the total normal velocity (from all panels plus the freestream) must vanish:

    ${tex.block`
    \sum_{j=1}^{n} v_{n,ij} + v_\infty \sin(\theta_i - \alpha) = 0
    `}

    where ${tex`\alpha`} is the angle of attack and ${tex`v_\infty \sin(\theta_i - \alpha)`} is the freestream's normal component at panel ${tex`i`}. Writing this condition at each of the ${tex`n`} control points gives ${tex`n`} linear equations in the ${tex`n + 1`} unknowns.

    The Kutta condition supplies the final equation. It requires that flow leaves the trailing edge smoothly rather than wrapping around at infinite velocity. Physically, this is what allows a real airfoil to generate lift. Mathematically, we enforce that the tangential velocities on the upper and lower surfaces are equal and opposite at the trailing edge:

    ${tex.block`
    v_{t,1} + v_{t,n} = 0
    `}

    where the total tangential velocity at panel ${tex`i`} is

    ${tex.block`
    v_{t,i} = \sum_{j=1}^{n} v_{t,ij} + v_\infty \cos(\theta_i - \alpha).
    `}

    With ${tex`n`} no-penetration equations and ${tex`1`} Kutta condition, we have exactly ${tex`n + 1`} equations for ${tex`n + 1`} unknowns.
  </script>
  <script id="15" type="text/markdown">
    ### Matrix Formulation
    Expanding the boundary conditions and collecting coefficients, we obtain the linear system ${tex`\mathbf{A}\mathbf{x} = \mathbf{b}`}. The unknown vector contains all ${tex`n`} source strengths followed by the vortex strength:

    ${tex.block`
    \mathbf{x} = \begin{pmatrix} \sigma_1 \\ \sigma_2 \\ \vdots \\ \sigma_n \\ \gamma \end{pmatrix}
    `}

    For rows ${tex`i = 1, \ldots, n`} (no-penetration):

    ${tex.block`
    \begin{aligned}
    A_{ij} &= \frac{1}{2\pi}\bigl(\sin\Delta\theta_{ij}\cdot\lambda_{ij} + \cos\Delta\theta_{ij}\cdot\beta_{ij}\bigr) \\
    A_{i,n+1} &= \sum_{j=1}^{n} \frac{1}{2\pi}\bigl(\cos\Delta\theta_{ij}\cdot\lambda_{ij} - \sin\Delta\theta_{ij}\cdot\beta_{ij}\bigr) \\
    b_i &= v_\infty \sin(\theta_i - \alpha)
    \end{aligned}
    `}

    For row ${tex`n+1`} (Kutta condition), summing contributions from panels 1 and ${tex`n`}:

    ${tex.block`
    \begin{aligned}
    A_{n+1,j} &= \frac{1}{2\pi}\bigl(\sin\Delta\theta_{1j}\cdot\beta_{1j} - \cos\Delta\theta_{1j}\cdot\lambda_{1j}\bigr) \\
    &\quad + \frac{1}{2\pi}\bigl(\sin\Delta\theta_{nj}\cdot\beta_{nj} - \cos\Delta\theta_{nj}\cdot\lambda_{nj}\bigr) \\[6pt]
    A_{n+1,n+1} &= \sum_{j=1}^{n} \frac{1}{2\pi}\bigl(\sin\Delta\theta_{1j}\cdot\lambda_{1j} + \cos\Delta\theta_{1j}\cdot\beta_{1j} \\
    &\quad + \sin\Delta\theta_{nj}\cdot\lambda_{nj} + \cos\Delta\theta_{nj}\cdot\beta_{nj}\bigr) \\[6pt]
    b_{n+1} &= -v_\infty\bigl(\cos(\theta_1 - \alpha) + \cos(\theta_n - \alpha)\bigr)
    \end{aligned}
    `}

    The result is ${tex`n + 1`} equations for ${tex`n + 1`} unknowns, which can be solved directly by matrix inversion. In this demo, the system is solved using LUP decomposition with partial pivoting.
  </script>
  <script id="16" type="text/markdown">
    ### Lift Coefficient

    Once solved, the circulation is ${tex`\Gamma = \gamma L`} where ${tex`L`} is the total panel perimeter. By the [Kutta-Joukowski theorem](https://en.wikipedia.org/wiki/Kutta%E2%80%93Joukowski_theorem):

    ${tex.block`
    C_L = \frac{2\Gamma}{c \cdot v_\infty}
    `}

    where ${tex`c`} is the length of the airfoil cross-section, called the *chord* length.
  </script>
  <script id="17" type="text/x-typescript">
    import { createElementStack } from './lib/element-stack.js'
    import { createWebGPUContext, webgpuElement, webgpuAxesViewport } from './lib/webgpu-canvas.js'
    import { createZoomableAxes } from './lib/zoomable-axes.js'
    import { expandable } from './lib/expandable.js'
    import meshAirfoil from './airfoil.js'
    import solveVortexPanel from './vortex-panel-solver.js'
    import computeLift from './compute-lift.js'
    import {
      createRenderer,
      quantizeColorscale,
      preparePanelData,
      triangulateAirfoil
    } from './webgpu-renderer.js'
  </script>
  <script id="18" type="text/x-typescript">
    const { device, canvasFormat } = await createWebGPUContext();
    invalidation.then(() => device.destroy());
  </script>
  <script id="19" type="text/x-typescript">
    const colorscale = quantizeColorscale(d3.interpolateViridis, 256);
  </script>
  <script id="20" type="text/x-typescript">
    function createPlot(width, height, xDomain = [-0.3, 1.3], yDomain = [-0.5, 0.5]) {
      return Plot.plot({
        width,
        height,
        marginTop: 10,
        marginRight: 10,
        marginLeft: 40,
        marginBottom: 30,
        style: { backgroundColor: "transparent", maxWidth: "none", position: "absolute" },
        x: { domain: xDomain, grid: false, tickSpacing: 100 },
        y: { domain: yDomain, grid: false, tickSpacing: 100 }
      });
    }
  </script>
  <script id="21" type="text/x-typescript">
    const stack = createElementStack({
      layers: [{
        id: 'webgpu',
        element: webgpuElement(device, canvasFormat, { alphaMode: 'premultiplied' })
      }, {
        id: 'plot',
        element: ({ width, height }) => createPlot(width, height)
      }, {
        id: 'svg',
        element: ({ current, width, height }) =>
          (current ? d3.select(current) : d3.create("svg"))
            .attr("width", width)
            .attr("height", height)
            .node()
      }]
    });
  </script>
  <script id="22" type="text/x-typescript">
    const axes = createZoomableAxes({
      d3,
      element: stack.elements.svg,
      xScale: stack.elements.plot.scale("x"),
      yScale: stack.elements.plot.scale("y"),
      aspectRatio: 1,
      onChange: ({ xDomain, yDomain }) => {
        renderState.dirty = true;
        const newPlot = createPlot(stack.width, stack.height, xDomain, yDomain);
        stack.elements.plot.replaceWith(newPlot);
        stack.elements.plot = newPlot;
        stack.dispatchEvent(new CustomEvent('update'));
        if (renderState.render) renderState.render();
      }
    });
  </script>
  <script id="23" type="text/x-typescript">
    const gpuContext = stack.elements.webgpu._gpuContext;
    const renderState = { dirty: true };
    const renderer = createRenderer(device, canvasFormat);
    invalidation.then(() => renderer.destroy());
  </script>
  <script id="24" type="text/x-typescript">
    // Mutable lift coefficient state that can be updated during drag
    const liftState = { value: 0 };
  </script>
  <script id="25" type="text/x-typescript">
    // Mutable pressure distribution state that can be updated during drag
    const panelCpState = { data: null };
  </script>
  <script id="26" type="text/x-typescript">
    // Rotation helper for SVG coordinates (shared by vertex handles and force arrow)
    function rotatePoint(px, py, cx, cy, angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const dx = px - cx, dy = py - cy;
      return [cx + dx * cos - dy * sin, cy + dx * sin + dy * cos];
    }
  </script>
  <script id="27" type="text/x-typescript">
    // SVG draggable vertex handles
    const svgLayer = d3.select(stack.elements.svg);

    // Create vertex data with indices
    const vertexData = geometry.x.map((_, i) => ({ index: i }));

    // Create handle groups
    const handleGroups = svgLayer.selectAll('g.vertex-handle')
      .data(vertexData, d => d.index)
      .join('g')
      .attr('class', 'vertex-handle')
      .style('cursor', 'move');

    // Invisible hit area (larger for easier grabbing)
    handleGroups.selectAll('circle.hit-area')
      .data(d => [d])
      .join('circle')
      .attr('class', 'hit-area')
      .attr('r', 18)
      .attr('fill', 'transparent');

    // Visible circle (smaller than hit area)
    handleGroups.selectAll('circle.visible')
      .data(d => [d])
      .join('circle')
      .attr('class', 'visible')
      .attr('r', pointSize * 0.7)
      .attr('fill', `rgba(255, 102, 51, ${vertexOpacity})`)
      .attr('stroke', `rgba(0, 0, 0, ${vertexOpacity * 0.8})`)
      .attr('stroke-width', 2)
      .attr('pointer-events', 'none');

    // Update positions function (applies -alpha rotation for display)
    function updateHandlePositions() {
      const alphaRad = -alpha * Math.PI / 180;
      const cx = 0.5, cy = 0;
      handleGroups.attr('transform', d => {
        const [rx, ry] = rotatePoint(geometryState.x[d.index], geometryState.y[d.index], cx, cy, alphaRad);
        const x = axes.xScale(rx);
        const y = axes.yScale(ry);
        return `translate(${x},${y})`;
      });
    }

    // Drag behavior
    handleGroups.call(d3.drag()
      .on('start', function() {
        d3.select(this).select('circle.visible')
          .attr('stroke', '#000')
          .attr('stroke-width', 2);
      })
      .on('drag', function(event, d) {
        // Convert screen position back to data coordinates, then un-rotate
        const alphaRad = -alpha * Math.PI / 180;
        const cx = 0.5, cy = 0;
        const screenX = axes.xScale.invert(event.x);
        const screenY = axes.yScale.invert(event.y);
        // Un-rotate: apply +alpha to get back to airfoil frame
        const [dataX, dataY] = rotatePoint(screenX, screenY, cx, cy, -alphaRad);
        geometryState.x[d.index] = dataX;
        geometryState.y[d.index] = dataY;
        geometryState.version++;

        // Update this handle position immediately
        d3.select(this).attr('transform', `translate(${event.x},${event.y})`);

        // Recompute solution directly
        const newSolution = solveVortexPanel({
          geometry: geometryState,
          kuttaCondition,
          vInf,
          alpha
        });

        // Update mutable data structures
        panelData.set(preparePanelData(geometryState, newSolution));

        const newMesh = triangulateAirfoil(geometryState);
        airfoilMesh.vertices = newMesh.vertices;
        airfoilMesh.indices = newMesh.indices;

        // Update lift coefficient and notify listeners
        liftState.value = computeLift({ geometry: geometryState, solution: newSolution, vInf });
        stack.dispatchEvent(new CustomEvent('liftchange'));

        // Update pressure distribution and center of pressure
        if (typeof computePanelCp === 'function') {
          panelCpState.data = computePanelCp(geometryState, newSolution, vInf, alpha);
          if (typeof computeCenterOfPressure === 'function') {
            panelCpState.centerOfPressure = computeCenterOfPressure(geometryState, panelCpState.data, alpha);
          }
        }

        renderState.dirty = true;
      })
      .on('end', function() {
        d3.select(this).select('circle.visible')
          .attr('stroke', `rgba(0, 0, 0, ${vertexOpacity * 0.8})`)
          .attr('stroke-width', 2);
      })
    );

    // Initial position update
    updateHandlePositions();

    // Update on zoom/pan (clean up old listener on cell re-run)
    stack.addEventListener('update', updateHandlePositions);
    invalidation.then(() => stack.removeEventListener('update', updateHandlePositions));
  </script>
  <script id="28" type="text/x-typescript">
    // SVG force arrow showing lift at center of pressure (computed from panel Cp)
    // Use select-or-create pattern to avoid duplicates
    let forceArrowGroup = svgLayer.select('g.force-arrow');
    if (forceArrowGroup.empty()) {
      forceArrowGroup = svgLayer.append('g')
        .attr('class', 'force-arrow')
        .attr('pointer-events', 'none');
    }

    // Clear any existing content and rebuild
    forceArrowGroup.selectAll('*').remove();

    // Arrow as a single polygon: white outline behind, red fill on top
    const arrowOutline = forceArrowGroup.append('path')
      .attr('fill', 'white')
      .attr('stroke', 'white')
      .attr('stroke-width', 6)
      .attr('stroke-linejoin', 'round');

    const arrowFill = forceArrowGroup.append('path')
      .attr('fill', '#e74c3c')
      .attr('stroke', 'none');

    function updateForceArrow() {
      // Read current lift coefficient from mutable state
      const currentLift = liftState.value;

      if (!showPressureDist || Math.abs(currentLift) < 0.001) {
        forceArrowGroup.attr('visibility', 'hidden');
        return;
      }
      forceArrowGroup.attr('visibility', 'visible');

      const alphaRad = -alpha * Math.PI / 180;
      const cx = 0.5, cy = 0;

      // Get force application point - either quarter-chord (AC) or computed center of pressure
      let xForce, yForce;
      if (forceAtQuarterChord) {
        // Aerodynamic center at quarter-chord, on the camber line
        xForce = 0.25;
        yForce = camber * (camberLoc > 0.001
          ? (xForce < camberLoc
              ? (2 * camberLoc * xForce - xForce * xForce) / (camberLoc * camberLoc)
              : ((1 - 2 * camberLoc) + 2 * camberLoc * xForce - xForce * xForce) / ((1 - camberLoc) * (1 - camberLoc)))
          : 0);
      } else {
        // Computed center of pressure
        const cp = panelCpState.centerOfPressure || { x: 0.25, y: 0 };
        xForce = cp.x;
        yForce = cp.y;
      }

      // Rotate to display frame
      const [acX, acY] = rotatePoint(xForce, yForce, cx, cy, alphaRad);

      // Convert to screen coordinates
      const screenX = axes.xScale(acX);
      const screenY = axes.yScale(acY);

      // Force magnitude and length
      const forceMag = Math.abs(currentLift) * forceArrowScale;
      const screenLen = forceMag * Math.abs(axes.yScale(0) - axes.yScale(1));

      // Lift direction: perpendicular to freestream, tilted by alpha in body coords
      // In display frame, lift points mostly up but tilted BACKWARD (toward trailing edge)
      // This creates both a vertical (lift) and horizontal (induced drag) component
      const liftAngle = -Math.PI / 2 - alphaRad;  // -90° - rotation (drag is backward)
      const sign = currentLift >= 0 ? 1 : -1;
      const dirX = sign * Math.cos(liftAngle);
      const dirY = sign * Math.sin(liftAngle);  // SVG y is inverted

      // Arrow geometry - fat arrow polygon
      const shaftWidth = 8;
      const headLen = Math.min(25, screenLen * 0.35);
      const headWidth = 22;

      // Perpendicular direction for shaft/head width
      const perpX = -dirY;
      const perpY = dirX;

      // Key points along arrow
      const baseX = screenX, baseY = screenY;
      const tipX = screenX + dirX * screenLen;
      const tipY = screenY + dirY * screenLen;
      const neckX = tipX - dirX * headLen;
      const neckY = tipY - dirY * headLen;

      // Build arrow as a single polygon
      const hw = headWidth / 2, sw = shaftWidth / 2;
      const arrowPath = `
        M ${baseX - perpX * sw} ${baseY - perpY * sw}
        L ${neckX - perpX * sw} ${neckY - perpY * sw}
        L ${neckX - perpX * hw} ${neckY - perpY * hw}
        L ${tipX} ${tipY}
        L ${neckX + perpX * hw} ${neckY + perpY * hw}
        L ${neckX + perpX * sw} ${neckY + perpY * sw}
        L ${baseX + perpX * sw} ${baseY + perpY * sw}
        Z
      `;

      arrowOutline.attr('d', arrowPath);
      arrowFill.attr('d', arrowPath);
    }

    updateForceArrow();
    stack.addEventListener('update', updateForceArrow);
    stack.addEventListener('liftchange', updateForceArrow);
    invalidation.then(() => {
      stack.removeEventListener('update', updateForceArrow);
      stack.removeEventListener('liftchange', updateForceArrow);
    });
  </script>
  <script id="29" type="text/x-typescript">
    // Base geometry from parameters - this gets copied to mutable state
    const baseGeometry = meshAirfoil({
      count: panelCount,
      m: camber,
      p: camberLoc,
      t: thickness,
      clustering,
      closeEnd: false
    });
  </script>
  <script id="30" type="text/x-typescript">
    // Mutable geometry state that can be modified by dragging
    // Created once, updated in place by reset-geometry-on-shape-change
    const geometryState = {
      x: [],
      y: [],
      version: 0  // Increment to trigger updates
    };

    // Reset geometry when base parameters change
    const resetGeometry = (base) => {
      geometryState.x = [...base.x];
      geometryState.y = [...base.y];
      geometryState.version++;
    };

    // Accessor that returns current geometry in expected format
    const geometry = {
      get x() { return geometryState.x; },
      get y() { return geometryState.y; }
    };
  </script>
  <script id="31" type="text/x-typescript">
    // Depend on geometryVersion to ensure geometryState is reset first
    void(geometryVersion);
    const vInf = 1;
    const solution = solveVortexPanel({
      geometry,
      kuttaCondition,
      vInf,
      alpha
    });
  </script>
  <script id="32" type="text/x-typescript">
    // Update lift state when solution changes
    liftState.value = computeLift({ geometry, solution, vInf });
    // Snapshot for reactive cells (like the display)
    const liftCoeff = liftState.value;
  </script>
  <script id="33" type="text/x-typescript">
    import computeWinding from './compute-winding.js';

    // Compute pressure coefficient at each panel midpoint
    // Uses tangential velocity computation matching the solver formulas
    function computePanelCp(geom, sol, vInfMag, alphaDegs) {
      const { x, y } = geom;
      const n = x.length - 1;
      const al = alphaDegs * Math.PI / 180;
      const gamma = sol.shape[0] > n ? sol.get(n) : 0;

      const cpValues = [];
      const midpoints = [];
      const normals = [];
      const theta = [];  // Panel angles

      // Precompute panel angles (same as solver)
      for (let i = 0; i < n; i++) {
        const ty = y[i + 1] - y[i];
        const tx = x[i + 1] - x[i];
        theta[i] = Math.atan2(ty, tx);
      }

      const winding = computeWinding(x, y);

      for (let i = 0; i < n; i++) {
        // Panel midpoint
        const xi = 0.5 * (x[i] + x[i + 1]);
        const yi = 0.5 * (y[i] + y[i + 1]);
        midpoints.push([xi, yi]);

        // Panel tangent and normal
        const thi = theta[i];
        const nx = -Math.sin(thi), ny = Math.cos(thi);  // Outward normal
        normals.push([nx, ny]);

        // Compute tangential velocity at panel midpoint (matching solver formulas)
        let vt = vInfMag * Math.cos(thi - al);  // Freestream tangential component

        for (let j = 0; j < n; j++) {
          const sigma = sol.get(j);
          const thj = theta[j];

          const rij = Math.sqrt((xi - x[j]) ** 2 + (yi - y[j]) ** 2);
          const rij1 = Math.sqrt((xi - x[j + 1]) ** 2 + (yi - y[j + 1]) ** 2);

          let bij = Math.PI * winding;
          if (i !== j) {
            const dx1 = xi - x[j];
            const dx2 = xi - x[j + 1];
            const dy1 = yi - y[j];
            const dy2 = yi - y[j + 1];
            const det = dx1 * dy2 - dx2 * dy1;
            const dot = dx2 * dx1 + dy2 * dy1;
            bij = Math.atan2(det, dot);
          }

          const sij = Math.sin(thi - thj);
          const cij = Math.cos(thi - thj);
          const lij = Math.log(rij1 / rij);
          const c = 0.5 / Math.PI;

          // Tangential velocity contribution (from solver's Kutta condition formula)
          vt += c * sigma * (sij * bij - cij * lij);
          vt += c * gamma * (sij * lij + cij * bij);
        }

        // Pressure coefficient: Cp = 1 - (V_t/V_inf)^2
        // At the surface, velocity is purely tangential (normal = 0 by boundary condition)
        const cp = 1 - (vt / vInfMag) ** 2;
        cpValues.push(cp);
      }

      return { cpValues, midpoints, normals };
    }

    // Compute center of pressure from panel Cp values
    // Returns {x, y} in airfoil coordinates
    function computeCenterOfPressure(geom, cpData, alphaDegs) {
      const { x, y } = geom;
      const n = x.length - 1;
      const al = alphaDegs * Math.PI / 180;

      // Lift direction (perpendicular to freestream, pointing "up" for positive lift)
      const liftDirX = -Math.sin(al);
      const liftDirY = Math.cos(al);

      let totalLift = 0;
      let momentX = 0;  // Moment about x = 0
      let momentY = 0;  // Moment about y = 0

      for (let i = 0; i < n; i++) {
        const cp = cpData.cpValues[i];
        const [mx, my] = cpData.midpoints[i];
        const [nx, ny] = cpData.normals[i];

        // Panel length
        const dx = x[i + 1] - x[i];
        const dy = y[i + 1] - y[i];
        const panelLen = Math.sqrt(dx * dx + dy * dy);

        // Force on panel (points inward, so opposite to normal)
        // F = -Cp * panelLen * (-normal) = Cp * panelLen * normal
        // But for pressure force: F = -Cp * ds * n (pressure pushes inward when Cp > 0... actually no)
        // Pressure coefficient: Cp = (p - p_inf) / q_inf
        // Force per unit span: dF = -Cp * q_inf * ds * n (negative because pressure acts opposite to outward normal)
        // For our purposes, we just need the relative distribution
        const forceMag = -cp * panelLen;  // Force magnitude in normal direction (into surface)
        const forceX = forceMag * nx;
        const forceY = forceMag * ny;

        // Lift component (projection onto lift direction)
        const lift = forceX * liftDirX + forceY * liftDirY;

        totalLift += lift;
        momentX += mx * lift;
        momentY += my * lift;
      }

      // Center of pressure
      if (Math.abs(totalLift) < 1e-10) {
        return { x: 0.25, y: 0 };  // Default to quarter chord if no lift
      }

      return {
        x: momentX / totalLift,
        y: momentY / totalLift
      };
    }

    // Compute and store panel Cp data
    panelCpState.data = computePanelCp(geometryState, solution, vInf, alpha);
    panelCpState.centerOfPressure = computeCenterOfPressure(geometryState, panelCpState.data, alpha);
    const panelCpData = panelCpState.data;
  </script>
  <script id="34" type="text/x-typescript">
    // Reset geometry when baseGeometry changes (which depends on shape parameters)
    // This MUST run before solution/panel-data/airfoil-mesh updates
    resetGeometry(baseGeometry);
    // Export version so other cells can depend on this completing
    const geometryVersion = geometryState.version;
  </script>
  <script id="35" type="text/x-typescript">
    // Trigger render when any parameters change
    void(alpha, panelCount, camber, camberLoc, thickness, kuttaCondition, clustering,
         contourOpacity, shadingOpacity, streamlineCount, streamlineOpacity,
         streamlineLength, fillOpacity, edgeOpacity, edgeWidth, vertexOpacity, pointSize,
         showPressureDist, pressureScale, pressureOffset,
         panelData, airfoilMesh, panelCpData);
    renderState.dirty = true;
    // Render immediately if render function is available
    if (renderState.render) renderState.render();
  </script>
  <script id="36" type="text/x-typescript">
    // Update force arrow when lift or display parameters change
    void(alpha, camber, camberLoc, liftCoeff, showPressureDist, forceAtQuarterChord);
    if (typeof updateForceArrow === 'function') updateForceArrow();
  </script>
  <script id="37" type="text/x-typescript">
    // Mutable panel data that can be updated during drag
    const panelData = {
      _data: null,
      get(i) { return this._data[i]; },
      get length() { return this._data.length; },
      set(newData) { this._data = newData; },
      [Symbol.iterator]() { return this._data[Symbol.iterator](); }
    };
    // Make it array-like for spreading
    Object.defineProperty(panelData, 'buffer', { get() { return this._data.buffer; } });
    Object.defineProperty(panelData, 'byteLength', { get() { return this._data.byteLength; } });
  </script>
  <script id="38" type="text/x-typescript">
    // Mutable mesh that can be updated during drag
    const airfoilMesh = {
      vertices: null,
      indices: null
    };
  </script>
  <script id="39" type="text/x-typescript">
    // Update panel data when solution changes
    // solution already depends on geometryVersion, so geometryState is current
    panelData.set(preparePanelData(geometryState, solution));
    // Trigger render after data update
    renderState.dirty = true;
    if (renderState.render) renderState.render();
  </script>
  <script id="40" type="text/x-typescript">
    // Update airfoil mesh when geometry changes
    // Depend on geometryVersion to ensure geometryState is current
    void(geometryVersion);
    const newMesh = triangulateAirfoil(geometryState);
    airfoilMesh.vertices = newMesh.vertices;
    airfoilMesh.indices = newMesh.indices;
    // Trigger render after mesh update
    renderState.dirty = true;
    if (renderState.render) renderState.render();
  </script>
  <script id="41" type="text/x-typescript">
    let animFrameId = null;

    function render() {
      if (!renderState.dirty) return;
      console.log('render');

      try {
        const encoder = device.createCommandEncoder();

        const pass = encoder.beginRenderPass({
          colorAttachments: [{
            view: gpuContext.getCurrentTexture().createView(),
            loadOp: 'clear',
            storeOp: 'store',
            clearValue: { r: 0, g: 0, b: 0, a: 0 },
          }],
        });

        // Set viewport to match axes
        const canvas = stack.elements.webgpu;
        const vp = webgpuAxesViewport(axes, devicePixelRatio, canvas.height);
        pass.setViewport(vp.x, vp.y, vp.width, vp.height, 0, 1);
        pass.setScissorRect(Math.floor(vp.x), Math.floor(vp.y), Math.floor(vp.width), Math.floor(vp.height));

        // In the airfoil frame, freestream is at angle alpha (matching the panel solution)
        // The display rotation makes it appear horizontal
        const vInfAlpha = alpha * Math.PI / 180;
        const vInfVec = [vInf * Math.cos(vInfAlpha), vInf * Math.sin(vInfAlpha)];

        // Helper: multiply two 4x4 matrices (column-major)
        function mat4mul(a, b) {
          const out = new Float32Array(16);
          for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 4; j++) {
              out[j * 4 + i] = a[i] * b[j * 4] + a[4 + i] * b[j * 4 + 1] +
                               a[8 + i] * b[j * 4 + 2] + a[12 + i] * b[j * 4 + 3];
            }
          }
          return out;
        }

        // Build rotation matrix for angle θ around point (cx, cy)
        function makeRotation(theta, cx, cy) {
          const c = Math.cos(theta), s = Math.sin(theta);
          const tx = cx * (1 - c) + cy * s;
          const ty = cy * (1 - c) - cx * s;
          // Column-major 4x4
          return new Float32Array([
            c, s, 0, 0,
            -s, c, 0, 0,
            0, 0, 1, 0,
            tx, ty, 0, 1
          ]);
        }

        const alphaRad = -alpha * Math.PI / 180;
        const cx = 0.5, cy = 0;

        // R rotates by -alpha (makes airfoil nose-up for positive alpha)
        const R = makeRotation(alphaRad, cx, cy);
        // R_inv rotates by +alpha (inverse rotation)
        const R_inv = makeRotation(-alphaRad, cx, cy);

        // For rendering geometry: rotatedView = view * R
        // (rotate points, then apply view transform)
        const rotatedView = mat4mul(axes.view, R);

        // For field sampling: rotatedViewInverse = R_inv * viewInverse
        // (unproject from screen, then rotate back to airfoil frame)
        const rotatedViewInverse = mat4mul(R_inv, axes.viewInverse);

        const currentPanelData = panelData._data;

        // Skip rendering if data not ready
        if (!currentPanelData) {
          pass.end();
          device.queue.submit([encoder.finish()]);
          renderState.dirty = false;
          animFrameId = requestAnimationFrame(renderLoop);
          return;
        }

        // Draw pressure field
        renderer.drawField(pass, {
          viewInverse: rotatedViewInverse,
          vInf: vInfVec,
          panelData: currentPanelData,
          panelCount: geometry.x.length - 1,
          colorscale,
          contourOpacity,
          shadingOpacity
        });

        // Draw streamlines
        if (streamlineCount > 0 && streamlineOpacity > 0.01) {
          const scale = Math.hypot(rotatedView[0], rotatedView[5]);
          renderer.drawStreamlines(pass, {
            view: rotatedView,
            viewInverse: rotatedViewInverse,
            vInf: vInfVec,
            resolution: [canvas.width, canvas.height],
            panelData: currentPanelData,
            panelCount: geometry.x.length - 1,
            colorscale,
            lineWidth: 2 * devicePixelRatio,
            dt: 0.1 / scale,
            noise: 0.2,
            byPressure: 0,
            streamlineCount,
            streamlineLength,
            opacity: streamlineOpacity
          });
        }

        // Draw pressure distribution (behind airfoil)
        if (showPressureDist && panelCpState.data) {
          renderer.drawPressureDist(pass, {
            view: rotatedView,
            geometry: geometryState,
            cpData: panelCpState.data,
            scale: pressureScale,
            cpOffset: pressureOffset,
            color: [1.0, 0.3, 0.3, 0.6]
          });
        }

        // Draw airfoil fill
        if (fillOpacity > 0.01 && airfoilMesh.vertices && airfoilMesh.indices) {
          renderer.drawAirfoil(pass, {
            view: rotatedView,
            color: [0.3, 0.3, 0.3, fillOpacity],
            vertices: airfoilMesh.vertices,
            indices: airfoilMesh.indices
          });
        }

        // Draw panel edges
        if (edgeOpacity > 0.01) {
          renderer.drawPanelEdges(pass, {
            view: rotatedView,
            geometry: geometryState,
            color: [0.0, 0.0, 0.0, edgeOpacity],
            lineWidth: edgeWidth * devicePixelRatio,
            resolution: [canvas.width, canvas.height]
          });
        }

        // Note: Vertex points are now rendered as SVG for interactivity

        pass.end();
        device.queue.submit([encoder.finish()]);

        renderState.dirty = false;
      } catch (e) {
        console.error('Render error:', e);
      }
    }

    function renderLoop() {
      render();
      animFrameId = requestAnimationFrame(renderLoop);
    }

    // Start the RAF loop
    animFrameId = requestAnimationFrame(renderLoop);

    // Expose render function for immediate calls
    renderState.render = render;

    invalidation.then(() => {
      if (animFrameId !== null) {
        cancelAnimationFrame(animFrameId);
        animFrameId = null;
      }
    });
  </script>
  <script id="42" type="text/markdown">
    ## GPU Field Evaluation

    The panel method solution (source strengths ${tex`\sigma_j`} and vortex strength ${tex`\gamma`}) is computed on the CPU, then uploaded to the GPU. For each pixel, the fragment shader evaluates the induced velocity by summing contributions from all panels.

    At any field point ${tex`\mathbf{r}`}, iterating over panels:

    ${tex.block`
    \mathbf{v}_\text{induced} = \frac{1}{2\pi}\sum_{j=1}^{n} \Bigl[\sigma_j\bigl(-\lambda_j\,\mathbf{t}_j + \beta_j\,\mathbf{n}_j\bigr) + \gamma\bigl(\beta_j\,\mathbf{t}_j + \lambda_j\,\mathbf{n}_j\bigr)\Bigr]
    `}

    where ${tex`\beta_j`} and ${tex`\lambda_j`} are computed from the vectors to each panel's endpoints.

    The pressure coefficient follows from Bernoulli's equation for incompressible flow:

    ${tex.block`C_p = 1 - \frac{|\mathbf{v}|^2}{|\mathbf{v}_\infty|^2}`}

    Streamlines are traced by integrating the velocity field in the vertex shader. Each streamline is rendered as a triangle strip with opacity that fades toward the ends.
  </script>
</notebook>
