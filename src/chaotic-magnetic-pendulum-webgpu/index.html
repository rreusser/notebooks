<!doctype html>
<notebook theme="air">
  <title>Chaotic Magnetic Pendulum (WebGPU)</title>
  <script id="1" type="text/markdown">
    # Chaotic Magnetic Pendulum (WebGPU)

    *See also the [WebGL version](../chaotic-magnetic-pendulum/).*
  </script>
  <script id="4" type="text/x-typescript">
    const figure = html`<figure>
      ${stack.element}
      <figcaption>Drag points to adjust magnet positions. Use mouse wheel to zoom, drag background to pan.</figcaption>
    </figure>`;

    display(expandable(figure, {
      width: Math.min(width, 640),
      height: Math.min(640, width),
      toggleOffset: [-14, -32],
      controls: '.magnetic-pendulum-controls',
      onResize(el, w, h) {
        stack.resize(w, h);
        axes.updateScales(
          stack.elements.plot.scale("x"),
          stack.elements.plot.scale("y")
        );
        renderState.dirty = true;
      }
    }));
  </script>
  <script id="30" type="text/x-typescript">
    const controlsContainer = html`<div class="magnetic-pendulum-controls"></div>`;

    function ctrl(input) {
      controlsContainer.appendChild(input);
      return Generators.input(input);
    }

    const h = ctrl(Inputs.range([1e-3 * 0, 1], {
      label: "pendulum height, h",
      value: 0.5
    }))
    const b = ctrl(Inputs.range([1e-8, 1], { label: "friction", value: 0.2 }))
    const tolerance = ctrl(Inputs.range([1e-6, 1e-2], {
      transform: Math.log,
      label: "tolerance",
      value: 3e-4
    }))
    const steps = ctrl(Inputs.range([0, 400], {
      label: "integration steps",
      value: 120,
      step: 1
    }))
    const N = ctrl(Inputs.range([2, 10], {
      label: "Magnet count",
      value: 3,
      step: 1
    }))
    const opts = ctrl(Inputs.checkbox([
      "Draw trajectory",
    ], {
      value: ["Draw trajectory"]
    }));

    display(controlsContainer);
  </script>
  <script id="9" type="text/markdown">
    The plot above represents a top-down view of a chaotic [magnetic pendulum](https://simple.wikipedia.org/wiki/Magnetic_pendulum). The black dots represent attracting magnets. Click and drag to move them. Each point on the plot represents the starting position of a pendulum. A pendulum is released from rest, and a bit of friction ensures it eventually comes to rest at one of the magnets. Color indicates which.
  </script>
  <script id="10" type="text/markdown">
    For two-dimensional position ${tex`\mathbf{x}`}, friction ${tex`b`}, and magnets ${tex`\mathbf{X}_n`}, the pendulum moves according to the equations
  </script>
  <script id="11" type="text/markdown">
    ${tex.block`
    \frac{d^2 \mathbf{x}}{dt^2} + b \frac{d\mathbf{x}}{dt} + \mathbf{x} = \sum_{n=1}^{${N}} \frac{\mathbf{X}_n - x}{\left(|\mathbf{X}_n - \mathbf{x}|^2 + h^2\right)^{5/2}}.
    `}
  </script>
  <script id="12" type="text/markdown">
    Pendulum height ${tex`h`} means the bottom of the pendulum is elevated slightly above the magnets so that it doesn't experience infinite acceleration when it gets close.
  </script>
  <script id="13" type="text/markdown">
    For more information, see [The Magnetic Pendulum](https://chalkdustmagazine.com/features/the-magnetic-pendulum/) or [Gravity Fractals](https://www.youtube.com/watch?v=LavXSS5Xtbg&ab_channel=2swap).
  </script>
  <script id="35" type="text/markdown">
    ## Implementation
  </script>
  <script id="38" type="text/markdown">
    The trajectory when the mouse is moved—corresponding to *one* trajectory—is computed on the CPU, while the colorful background field—corresponding to *every* trajectory—is iterated on the GPU.
  </script>
  <script id="40" type="text/markdown">
    In both formats, the biggest challenge is computing trajectories efficiently. The pendulum may change direction quickly and so needs a small time step, but the pendulum can take a long time to come to a rest. These competing priorities make efficient evaluation essential.
  </script>
  <script id="39" type="text/markdown">
    Both therefore use the adaptive RK4(5) method. The CPU variant is implemented in [@rreusser/integration#ode45](https://observablehq.com/@rreusser/integration#ode45). Adaptive means that the timestep is modified on each step to maximize the step size while controlling the error. This is done through careful construction of the [Runge-Kutta](https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods) method using coefficients of the [Cash-Karp method](https://en.wikipedia.org/wiki/Cash%E2%80%93Karp_method). The coefficients allow the same derivative evaluations to produce both a fifth order and so-called *embedded* fourth order estimate of the next state. The difference between the estimates produces an error estimate, which can subsequently be worked backwards into the timestep required to achieve a specified error threshold.
  </script>
  <script id="50" type="text/markdown">
    To get started, we define the derivative function
  </script>
  <script id="49" type="text/x-typescript">
    const iDeriv = Array.from({length: N}).map((_, i) => i);
    const glslDeriv = `vec4 deriv (vec4 y) {
      vec2 pos = y.xy;
      vec2 vel = y.zw;
      ${iDeriv.map(i => `vec2 r${i} = p${i} - pos;`).join('\n  ')}
      ${iDeriv.map(i => `float d${i} = dot(r${i}, r${i}) + h2;`).join('\n  ')}
      vec2 force = ${iDeriv.map(i => `r${i} / (d${i} * d${i} * sqrt(d${i}))`).join(' +\n               ')};
      return vec4(vel, force - b * vel - pos);
    }`
  </script>
  <script id="55" type="text/markdown">
    ```wgsl
    ${wgslDeriv}
    ```
  </script>
  <script id="47" type="text/markdown">
    The WGSL variant of `rk45` is reproduced below. It's mostly equivalent to the CPU variant except modified for the limitations of WGSL control flow.
  </script>
  <script id="42" type="text/markdown">
    ```wgsl
    const safety: f32 = 0.95;
    const maxDecrease: f32 = 0.02;
    const maxIncrease: f32 = 50.0;

    struct RK45Result {
      y: vec4<f32>,
      dt: f32,
    };

    fn rk45(y_in: vec4<f32>, dt_in: f32) -> RK45Result {
      var y = y_in;
      var dt = dt_in;

      // Fifth order estimate using constants for the Cash-Karp method
      let k1 = deriv(y);
      let k2 = deriv(y + dt * 0.2 * k1);
      let k3 = deriv(y + dt * (0.075 * k1 + 0.225 * k2));
      let k4 = deriv(y + dt * (0.3 * k1 - 0.9 * k2 + 1.2 * k3));
      let k5 = deriv(y + dt * (-0.203703703703703703 * k1 + 2.5 * k2 - 2.592592592592592592 * k3 + 1.296296296296296296 * k4));
      let k6 = deriv(y + dt * (0.029495804398148148 * k1 + 0.341796875 * k2 + 0.041594328703703703 * k3 + 0.400345413773148148 * k4 + 0.061767578125 * k5));

      // Estimate the error using the embedded fourth order method
      let tmp = dt * (0.004293774801587301 * k1 - 0.018668586093857832 * k3 + 0.034155026830808080 * k4 + 0.019321986607142857 * k5 - 0.039102202145680406 * k6);
      let err2 = dot(tmp, tmp);

      // Accept the step if error is within tolerance
      let accept = err2 <= uniforms.tol2;
      if (accept || uniforms.discardFails == 0u) {
        y = y + dt * (0.097883597883597883 * k1 + 0.402576489533011272 * k3 + 0.210437710437710437 * k4 + 0.289102202145680406 * k6);
      }

      // Adjust dt according to the estimate
      let exp = select(0.1, 0.125, accept);
      dt = dt * clamp(safety * pow(uniforms.tol2 / err2, exp), maxDecrease, maxIncrease);

      return RK45Result(y, dt);
    }
    ```
  </script>
  <script id="48" type="text/markdown">
    Note that if the error threshold is not achieved (that is, if we need to reduce the time step to keep error under control), then we simply throw out the timestep entirely. This is very wasteful! *C'est la vie*.
  </script>
  <script id="43" type="text/markdown">
    Given zero velocity and starting position `xy`, the final iteration loop is reproduced below. We start by packing the state into a `vec4<f32>`. We update the state ${steps} times, overwriting the state and mutating `dt` on each step.
  </script>
  <script id="45" type="text/markdown">
    ```wgsl
    var y = vec4<f32>(xy, 0.0, 0.0);
    var dt = 0.01;
    for (var i = 0; i < ${steps}; i++) {
      let result = rk45(y, dt);
      y = result.y;
      dt = result.dt;
    }
    ```
  </script>
  <script id="52" type="text/markdown">
    The final step is to choose a weighted average of color depending on how close it ends up to each magnet at the end of the integration loop. Has it actually come to a rest? Is it close to any of the magnets? Who knows! Or more specifically, subject to the reasonable limitations of fragment shaders, we can't really know, so we just do our best and go with it.

    I've chosen a rainbow color palette from [Inigo Quilez](https://iquilezles.org/articles/palettes/) and used a [quasirandom sequence](https://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/) from Martin Roberts to distribute the colors somewhat randomly so that adjacent colors around the unit circle aren't also adjacent around the color wheel.
  </script>
  <script id="67" type="text/x-typescript">
    const iPalette = Array.from({length: N}).map((_, i) => i);
    const glslPalette = `float quasirandom (int n) {
      return fract(0.5 + ${1.0 / 1.6180339887498948482} * float(n));
    }
    vec3 palette(float t) {
      const vec3 a = vec3(0.5, 0.5, 0.5);
      const vec3 b = vec3(0.5, 0.5, 0.5);
      const vec3 c = vec3(1.0, 1.0, 1.0);
      const vec3 d = vec3(0.00, 0.33, 0.67);
      return a + b * cos(6.283185 * (c * t + d));
    }`;
    const glslScheme = `vec3 computeWeightedColor (vec2 y) {
      ${iPalette.map(i => `vec2 r${i} = y - p${i};`).join('\n  ')}
      ${iPalette.map(i => `float w${i} = 1.0 / dot(r${i}, r${i}); w${i} *= w${i};`).join('\n  ')}
      return (
        ${
          iPalette.map(i => {
            const theta = Math.PI * 2 * i / N;
            const a = 0.5 + 0.5 * Math.cos(theta);
            const b = 0.5 + 0.5 * Math.cos(theta + Math.PI * 2 / 3);
            const c = 0.5 + 0.5 * Math.cos(theta + Math.PI * 4 / 3);
            return `w${i} * mix(palette(0.63 + quasirandom(${i})), vec3(0.9), 0.35)`;
          }).join(' +\n    ')
        }
      ) / (${iPalette.map(i => `w${i}`).join(' + ')});
    }`;
  </script>
  <script id="68" type="text/markdown">
    ```wgsl
    ${wgslPalette}
    ```
  </script>
  <script id="69" type="text/markdown">
    ```wgsl
    ${wgslScheme}
    ```
  </script>
  <script id="53" type="text/markdown">
    That's it. Once in place, adaptive methods are just great. It's a pretty handy function which you're free to lift and use. (The source is MIT Licensed.) You can view the live notebook [on Observable](https://observablehq.com/@rreusser/magnetic-pendulum).
  </script>
  <script id="7" type="text/x-typescript">
    import { ode45 } from "observable:@rreusser/integration"
  </script>
  <script id="2" type="text/x-typescript">
    import { createElementStack } from './lib/element-stack.js'
    import { createWebGPUContext, webgpuElement, webgpuAxesViewport } from './lib/webgpu-canvas.js'
    import { createZoomableAxes } from './lib/zoomable-axes.js'
    import { expandable } from './lib/expandable.js'
  </script>
  <script id="3" type="text/x-typescript">
    // Initialize WebGPU
    const { device, canvasFormat } = await createWebGPUContext();
    invalidation.then(() => device.destroy());
  </script>
  <script id="29" type="text/x-typescript">
    function createPlot(width, height, xDomain = [-3, 3], yDomain = [-3, 3]) {
      return Plot.plot({
        width,
        height,
        marginTop: 10,
        marginRight: 10,
        marginLeft: 40,
        marginBottom: 30,
        style: { backgroundColor: "transparent", maxWidth: "none", position: "absolute" },
        x: { domain: xDomain, grid: true, tickSpacing: 100 },
        y: { domain: yDomain, grid: true, tickSpacing: 100 }
      });
    }
  </script>
  <script id="5" type="text/x-typescript">
    const stack = createElementStack({
      layers: [{
        id: 'webgpu',
        element: webgpuElement(device, canvasFormat, { alphaMode: 'premultiplied' })
      }, {
        id: 'plot',
        element: ({ width, height }) => createPlot(width, height)
      }, {
        id: 'svg',
        element: ({ current, width, height }) =>
          (current ? d3.select(current) : d3.create("svg"))
            .attr("width", width)
            .attr("height", height)
            .node()
      }]
    });
  </script>
  <script id="8" type="text/x-typescript">
    const axes = createZoomableAxes({
      d3,
      element: stack.elements.svg,
      xScale: stack.elements.plot.scale("x"),
      yScale: stack.elements.plot.scale("y"),
      aspectRatio: 1,
      onChange: ({ xDomain, yDomain }) => {
        renderState.dirty = true;
        const newPlot = createPlot(stack.width, stack.height, xDomain, yDomain);
        stack.elements.plot.replaceWith(newPlot);
        stack.elements.plot = newPlot;
        stack.dispatchEvent(new CustomEvent('update'));
      }
    });
  </script>
  <script id="18" type="text/x-typescript">
    const gpuContext = stack.elements.webgpu._gpuContext;
    const renderState = { dirty: true };
  </script>
  <script id="27" type="text/x-typescript">
    const magnets = Array.from({length: N}).map((_, i) => ({
      index: i,
      x: Math.sin(2 * Math.PI * i / N),
      y: Math.cos(2 * Math.PI * i / N)
    }));
  </script>
  <script id="24" type="text/x-typescript">
    function deriv(yp, [x, y, u, v]) {
      let fx = 0.0;
      let fy = 0.0;

      for (let i = 0; i < magnets.length; i++) {
        const dx = magnets[i].x - x;
        const dy = magnets[i].y - y;
        const d = dx * dx + dy * dy + h * h;
        const inv = 1.0 / (d * d * Math.sqrt(d));
        fx += dx * inv;
        fy += dy * inv;
      }

      yp[0] = u;
      yp[1] = v;
      yp[2] = fx - b * u - x;
      yp[3] = fy - b * v - y;
    }
    function computeTrajectory([x, y]) {
      if (!~opts.indexOf("Draw trajectory") || isNaN(x)) return [];
      const state = { y: [x, y, 0, 0], t: 0 };
      const history = [{ x: state.y[0], y: state.y[1] }];
      for (let i = 0; i < 2000 && !state.limitReached; i++) {
        ode45(state, deriv, { tLimit: 50, tolerance: 2e-6 });
        history.push({ x: state.y[0], y: state.y[1] });
      }
      return history;
    };
  </script>
  <script id="26" type="text/x-typescript">
    // SVG interaction for trajectories and magnet controls
    {
      const svg = d3.select(stack.elements.svg);

      // Add clipPath for viewport
      const defs = svg.selectAll('defs').data([0]).join('defs');
      const clipRect = defs.selectAll('clipPath#viewport-clip')
        .data([0])
        .join('clipPath')
        .attr('id', 'viewport-clip')
        .selectAll('rect')
        .data([0])
        .join('rect');

      // Clipped group for content
      const clippedGroup = svg.selectAll('g.clipped')
        .data([0])
        .join('g')
        .attr('class', 'clipped')
        .attr('clip-path', 'url(#viewport-clip)');

      svg.on("mousemove", (event) => {
        updateTrajectory(computeTrajectory([
          axes.xScale.invert(event.offsetX),
          axes.yScale.invert(event.offsetY)
        ]));
      });

      function makeline(data) {
        return d3.line()
          .x(({ x }) => axes.xScale(x))
          .y(({ y }) => axes.yScale(y))(data);
      }

      function updateTrajectory(trajectory) {
        clippedGroup
          .selectAll(".trajectorybg")
          .data([trajectory || []])
          .join(
            (enter) =>
              enter
                .append("path")
                .style("fill", "none")
                .style("stroke-width", 5)
                .style("stroke", "rgba(255,255,255,0.6)")
                .attr("class", "trajectorybg")
                .attr("d", makeline),
            (update) => update.attr("d", makeline)
          );
        clippedGroup
          .selectAll(".trajectory")
          .data([trajectory || []])
          .join(
            (enter) =>
              enter
                .append("path")
                .style("fill", "none")
                .style("stroke-width", 2)
                .style("stroke", "blue")
                .attr("class", "trajectory")
                .attr("d", makeline),
            (update) => update.attr("d", makeline)
          );
      }

      function updatePositions() {
        // Update clip rect to match viewport
        const [x0, x1] = axes.xRange;
        const [y0, y1] = axes.yRange;
        clipRect
          .attr('x', Math.min(x0, x1))
          .attr('y', Math.min(y0, y1))
          .attr('width', Math.abs(x1 - x0))
          .attr('height', Math.abs(y1 - y0));

        clippedGroup.selectAll("circle.magnet")
          .attr("cx", d => axes.xScale(d.x))
          .attr("cy", d => axes.yScale(d.y));
      }

      updateTrajectory([]);
      clippedGroup
        .selectAll("circle.magnet")
        .data(magnets)
        .join(
          (enter) =>
            enter
              .append("circle")
              .attr("class", "magnet")
              .attr("r", 5)
              .style("fill", "black")
              .style("stroke", "white")
              .style("stroke-width", 2)
              .style("cursor", "move")
              .call(
                d3.drag()
                  .subject(function(event, d) {
                    return { x: axes.xScale(d.x), y: axes.yScale(d.y) };
                  })
                  .on('start', function() { d3.select(this).attr('cursor', 'grabbing'); })
                  .on("drag", function(event, d) {
                    d.x = axes.xScale.invert(event.x);
                    d.y = axes.yScale.invert(event.y);
                    updatePositions();
                    updateTrajectory([]);
                    renderState.dirty = true;
                  })
                  .on('end', function() { d3.select(this).attr('cursor', 'move'); })
              )
        );

      updatePositions();
      stack.addEventListener('update', () => {
        updatePositions();
        updateTrajectory([]);
      });
    }
  </script>
  <script id="21" type="text/x-typescript">
    // Generate WGSL derivative function (magnets stored as vec4, use .xy)
    const wgslDeriv = `fn deriv(y: vec4<f32>) -> vec4<f32> {
      let pos = y.xy;
      let vel = y.zw;
      ${iDeriv.map(i => `let r${i} = uniforms.magnets[${i}].xy - pos;`).join('\n      ')}
      ${iDeriv.map(i => `let d${i} = dot(r${i}, r${i}) + uniforms.h2;`).join('\n      ')}
      let force = ${iDeriv.map(i => `r${i} / (d${i} * d${i} * sqrt(d${i}))`).join(' +\n                 ')};
      return vec4<f32>(vel, force - uniforms.b * vel - pos);
    }`;

    // Generate WGSL palette functions
    const wgslPalette = `fn quasirandom(n: i32) -> f32 {
      return fract(0.5 + ${1.0 / 1.6180339887498948482} * f32(n));
    }
    fn palette(t: f32) -> vec3<f32> {
      let a = vec3<f32>(0.5, 0.5, 0.5);
      let b = vec3<f32>(0.5, 0.5, 0.5);
      let c = vec3<f32>(1.0, 1.0, 1.0);
      let d = vec3<f32>(0.00, 0.33, 0.67);
      return a + b * cos(6.283185 * (c * t + d));
    }`;

    const wgslScheme = `fn computeWeightedColor(y: vec2<f32>) -> vec3<f32> {
      ${iPalette.map(i => `let r${i} = y - uniforms.magnets[${i}].xy;`).join('\n      ')}
      ${iPalette.map(i => `var w${i} = 1.0 / dot(r${i}, r${i}); w${i} *= w${i};`).join('\n      ')}
      return (
        ${iPalette.map(i => `w${i} * mix(palette(0.63 + quasirandom(${i})), vec3<f32>(0.9), 0.35)`).join(' +\n        ')}
      ) / (${iPalette.map(i => `w${i}`).join(' + ')});
    }`;

    // WGSL shader code
    const shaderCode = `
      struct Uniforms {
        viewInverse: mat4x4<f32>,
        h2: f32,
        b: f32,
        tol2: f32,
        discardFails: u32,
        magnets: array<vec4<f32>, ${N}>,  // Only .xy used, but vec4 required for 16-byte alignment
      };

      @group(0) @binding(0) var<uniform> uniforms: Uniforms;

      struct VertexOutput {
        @builtin(position) position: vec4<f32>,
        @location(0) xy: vec2<f32>,
      };

      @vertex
      fn vertex(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {
        // Generate fullscreen triangle covering clip space
        // Vertices: (-1,-1), (3,-1), (-1,3)
        let x = f32((vertexIndex << 1u) & 2u) * 2.0 - 1.0;
        let y = f32(vertexIndex & 2u) * 2.0 - 1.0;

        var output: VertexOutput;
        // Transform through viewInverse to get data coordinates
        let dataCoord = uniforms.viewInverse * vec4<f32>(x, y, 0.0, 1.0);
        output.xy = dataCoord.xy;
        // WebGPU clips space has Y up, framebuffer has Y down - the viewport handles this
        output.position = vec4<f32>(x, y, 0.0, 1.0);
        return output;
      }

      ${wgslDeriv}

      const safety: f32 = 0.95;
      const maxDecrease: f32 = 0.02;
      const maxIncrease: f32 = 50.0;

      struct RK45Result {
        y: vec4<f32>,
        dt: f32,
      };

      fn rk45(y_in: vec4<f32>, dt_in: f32) -> RK45Result {
        var y = y_in;
        var dt = dt_in;

        // Fifth order estimate using constants for the Cash-Karp method
        let k1 = deriv(y);
        let k2 = deriv(y + dt * 0.2 * k1);
        let k3 = deriv(y + dt * (0.075 * k1 + 0.225 * k2));
        let k4 = deriv(y + dt * (0.3 * k1 - 0.9 * k2 + 1.2 * k3));
        let k5 = deriv(y + dt * (-0.203703703703703703 * k1 + 2.5 * k2 - 2.592592592592592592 * k3 + 1.296296296296296296 * k4));
        let k6 = deriv(y + dt * (0.029495804398148148 * k1 + 0.341796875 * k2 + 0.041594328703703703 * k3 + 0.400345413773148148 * k4 + 0.061767578125 * k5));

        // Estimate the error using the embedded fourth order method
        let tmp = dt * (0.004293774801587301 * k1 - 0.018668586093857832 * k3 + 0.034155026830808080 * k4 + 0.019321986607142857 * k5 - 0.039102202145680406 * k6);
        let err2 = dot(tmp, tmp);

        // Accept the step if error is within tolerance
        let accept = err2 <= uniforms.tol2;
        if (accept || uniforms.discardFails == 0u) {
          y = y + dt * (0.097883597883597883 * k1 + 0.402576489533011272 * k3 + 0.210437710437710437 * k4 + 0.289102202145680406 * k6);
        }

        // Adjust dt according to the estimate
        let exp = select(0.1, 0.125, accept);
        dt = dt * clamp(safety * pow(uniforms.tol2 / err2, exp), maxDecrease, maxIncrease);

        return RK45Result(y, dt);
      }

      ${wgslPalette}
      ${wgslScheme}

      @fragment
      fn fragment(@location(0) xy: vec2<f32>) -> @location(0) vec4<f32> {
        var y = vec4<f32>(xy, 0.0, 0.0);
        var dt = 0.01;
        for (var i = 0; i < ${steps}; i++) {
          let result = rk45(y, dt);
          y = result.y;
          dt = result.dt;
        }
        return vec4<f32>(computeWeightedColor(y.xy), 1.0);
      }
    `;

    // Create shader module
    const shaderModule = device.createShaderModule({
      label: 'magnetic-pendulum-shader',
      code: shaderCode,
    });

    // Create bind group layout
    const bindGroupLayout = device.createBindGroupLayout({
      label: 'magnetic-pendulum-bind-group-layout',
      entries: [{
        binding: 0,
        visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
        buffer: { type: 'uniform' },
      }],
    });

    // Create pipeline layout
    const pipelineLayout = device.createPipelineLayout({
      label: 'magnetic-pendulum-pipeline-layout',
      bindGroupLayouts: [bindGroupLayout],
    });

    // Create render pipeline
    const pipeline = device.createRenderPipeline({
      label: 'magnetic-pendulum-pipeline',
      layout: pipelineLayout,
      vertex: {
        module: shaderModule,
        entryPoint: 'vertex',
      },
      fragment: {
        module: shaderModule,
        entryPoint: 'fragment',
        targets: [{ format: canvasFormat }],
      },
      primitive: {
        topology: 'triangle-list',
      },
    });

    // Calculate uniform buffer size (must be multiple of 16)
    // mat4x4 (64) + h2 (4) + b (4) + tol2 (4) + discardFails (4) + magnets (N * 16)
    // = 80 + N * 16, rounded up to multiple of 16
    const uniformBufferSize = Math.ceil((80 + N * 16) / 16) * 16;

    // Create uniform buffer
    const uniformBuffer = device.createBuffer({
      label: 'magnetic-pendulum-uniforms',
      size: uniformBufferSize,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });

    // Create bind group
    const bindGroup = device.createBindGroup({
      label: 'magnetic-pendulum-bind-group',
      layout: bindGroupLayout,
      entries: [{
        binding: 0,
        resource: { buffer: uniformBuffer },
      }],
    });

    // Helper to update uniforms
    function updateUniforms(viewInverse, h, b, tolerance, magnets, discardFails) {
      const data = new ArrayBuffer(uniformBufferSize);
      const floatView = new Float32Array(data);
      const uintView = new Uint32Array(data);

      // viewInverse matrix (16 floats = 64 bytes)
      floatView.set(viewInverse, 0);

      // h2, b, tol2, discardFails (at byte 64)
      floatView[16] = h * h;
      floatView[17] = b;
      floatView[18] = tolerance * tolerance;
      uintView[19] = discardFails ? 1 : 0;

      // magnets array (starting at byte 80, vec4 per magnet for alignment)
      for (let i = 0; i < magnets.length; i++) {
        floatView[20 + i * 4] = magnets[i].x;
        floatView[20 + i * 4 + 1] = magnets[i].y;
        floatView[20 + i * 4 + 2] = 0; // unused z
        floatView[20 + i * 4 + 3] = 0; // unused w
      }

      device.queue.writeBuffer(uniformBuffer, 0, data);
    }

    // Render function
    function drawField(params) {
      updateUniforms(
        params.viewInverse,
        params.h,
        params.b,
        params.tolerance,
        params.magnets,
        params.discard
      );

      const encoder = device.createCommandEncoder();
      const pass = encoder.beginRenderPass({
        colorAttachments: [{
          view: gpuContext.getCurrentTexture().createView(),
          loadOp: 'clear',
          storeOp: 'store',
          clearValue: { r: 0, g: 0, b: 0, a: 0 },
        }],
      });

      // Set viewport and scissor to match axes
      const canvas = stack.elements.webgpu;
      const vp = webgpuAxesViewport(axes, devicePixelRatio, canvas.height);
      pass.setViewport(vp.x, vp.y, vp.width, vp.height, 0, 1);
      pass.setScissorRect(Math.floor(vp.x), Math.floor(vp.y), Math.floor(vp.width), Math.floor(vp.height));

      pass.setPipeline(pipeline);
      pass.setBindGroup(0, bindGroup);
      pass.draw(3);
      pass.end();

      device.queue.submit([encoder.finish()]);
    }
  </script>
  <script id="20" type="text/x-typescript">
    renderState.dirty = true;
    let animFrameId = null;

    function renderLoop() {
      if (!renderState.dirty) {
        animFrameId = requestAnimationFrame(renderLoop);
        return;
      }
      try {
        drawField({
          viewInverse: axes.viewInverse,
          h, b, magnets, tolerance,
          discard: !opts.includes('Use steps which exceed tolerance')
        });
        renderState.dirty = false;
      } catch (e) {
        console.error(e);
        animFrameId = null;
        return;
      }
      animFrameId = requestAnimationFrame(renderLoop);
    }

    animFrameId = requestAnimationFrame(renderLoop);

    invalidation.then(() => {
      if (animFrameId !== null) {
        cancelAnimationFrame(animFrameId);
        animFrameId = null;
      }
    });
  </script>
  <script id="59" type="text/x-typescript">
    function srgbToLinear(c) {
      return c <= 0.04045
        ? c / 12.92
        : Math.pow((c + 0.055) / 1.055, 2.4);
    }

    function hexToLinearRgb(hex) {
      hex = hex.replace(/^#/, "");
      if (hex.length === 3) {
        hex = hex.split("").map(c => c + c).join("");
      }

      const r = srgbToLinear(parseInt(hex.slice(0, 2), 16) / 255);
      const g = srgbToLinear(parseInt(hex.slice(2, 4), 16) / 255);
      const b = srgbToLinear(parseInt(hex.slice(4, 6), 16) / 255);

      return [r, g, b];
    }
  </script>
  <script id="60" type="text/x-typescript">
    const colorScheme = d3.schemeCategory10.map(hexToLinearRgb).map(([r, g, b]) => `vec3(${r},${g},${b})`);
  </script>
</notebook>
