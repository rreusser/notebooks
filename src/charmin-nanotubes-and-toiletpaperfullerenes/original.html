<!doctype html>
<notebook theme="air">
  <title>Toiletpaperfullerenes and Charmin Nanotubes</title>
  <script id="2779" type="application/vnd.observable.javascript">
    md`# Toiletpaperfullerenes and Charmin Nanotubes

    Toilet paper tubes have the curious property that you can flatten them, cut out loops, and link the loops together without fasteners.

    For a couple years now, I've hoarded every used cardboard toilet paper tube that's passed through our home. Feeling inspired after seeing a tweet (with apologies, author long since forgotten), I stockedpiled tubes and built a [Buckyball](https://en.wikipedia.org/wiki/Buckminsterfullerene). Vines in the bedroom now climb a six foot [carbon nanotube](https://en.wikipedia.org/wiki/Carbon_nanotube) trellis (*Charmin nanotube*, if you will, and not exactly *nano* either, for that matter). And [Alison Martin's work](https://mastodon.social/@alisonmartin57) continuously inspires me.

    *Update: I've tracked down some precedent, though perhaps not the actual tweet that inspired me as this seems to be a popular project! See tweets by [@Ian_Willey](https://twitter.com/Ian_Willey/status/1119257024649474049) and‚Äîwith excellent instructions‚Äî[@mrallanmaths](https://twitter.com/mrallanmaths/status/1125438241774166017).*

    This notebook represents my attempt to step things up. It provides some basic instructions and suggestions, as well as a simulator to help the toilet-paper-tube-constrained make the best use of what they have. In hindsight, the simulation certainly wasn't necessary. And at any rate, there's really no upper limit to tackling this with trial and error; the recyclability means there's no need to open a family dialogue about where to store the large geometric constructions that result.
    `
  </script>
  <script id="2750" type="application/vnd.observable.javascript">
    html`
    <figure>
      <img src="${await FileAttachment("spikyball.jpg").url()}" width="${Math.min(
      width,
      600
    )}">
      <figcaption>The finished product, composed of 49 recycled toilet paper tubes (and which I realize after building sorta brings things full circle and looks a bit like a coronavirus).</figcaption>
    </figure>
    `
  </script>
  <script id="3337" type="application/vnd.observable.javascript">
    md`## Fabrication

    My brand is regular Trader Joe's toilet paper, though I have no reason to believe anything about the brand is particularly important, beyond consistency of diameter‚Äîwith the exception of those cowards who make tube-free toilet paper rolls. Those won't work. I've considered side-stepping material collection and waiting to buy tag board when shelter-in-place eases, though to be honest, the recycled nature of the raw materials is a primary factor which draws me to this project.

    Accumulating raw materials is simple. Flatten the tubes and‚Äîif you live with family‚Äîstash them somewhere a family member is unlikely to find them, lest you be required to explain yourself. Conversely, you may wish to avoid much wailing and gnashing of teeth and discuss your hoarding early on to prevent your stash from getting casually recycled.

    The pattern below illustrates the required cuts. The angle required for three edges to join gracefully is ${tex`30^\circ`}, which makes the measurements easy. I've found a far easier method than measuring every tube though is to add opposing marks to one tube and use it as a template. I get about eight strips per tube. 

    <em>Update: I've trended toward thicker strips, as it makes the final constructions a bit more robust. The only limit on thickness is they can't be so thick that the joints on opposite ends interfere and prevent linking. Further simplifying, even cutting strips at flat 0Àö angles produces a visually appealing look and may save a bit of trouble.</em>`
  </script>
  <script id="3328" type="application/vnd.observable.javascript">
    html`
    <figure>
      <img src="${await FileAttachment("measurements.jpg").url()}" width="${Math.min(
      width,
      400
    )}">
      <figcaption>The pattern of cuts illustrated on a flattened toilet paper tube.</figcaption>
    </figure>
    `
  </script>
  <script id="3354" type="application/vnd.observable.javascript">
    md`Assembling the joints is straightforward. The pieces lock together in pleasing ${tex`120^\circ`} angles, requiring no additional fasteners up until the very last piece of the model, which requires a cut and some tape.

    The illustration below shows how the joints interlock. I'd give more instruction, but if you actually want to do this, there's no better way to learn than through experimentation. After some fumbling around, I learned to always attach new pieces by branching off in the same direction, after which it becomes quite repetitive.`
  </script>
  <script id="3332" type="application/vnd.observable.javascript">
    html`
    <figure>
      <img src="${await FileAttachment("interlock@1.jpg").url()}" width="${Math.min(
      width,
      400
    )}">
      <figcaption>Three loops link together to form an interlocked joint.</figcaption>
    </figure>
    `
  </script>
  <script id="3379" type="application/vnd.observable.javascript">
    md`Assembling larger patterns is where things start to get frustrating and difficult. I have little advice here except to rely heavily on patterns, examples, and patience. And perhaps the simulator below. For inspiration, the best paper I found is ["The Topology of Fullerenes"](https://onlinelibrary.wiley.com/doi/full/10.1002/wcms.1207) by Schwerdtfeger, Wirz, and Avery.

    In my initial attempt, I started making a torus and failed to appreciate just how much of a material shortage I'd encounter. After some iteration though, I tried out different constructions. My favorite so far is our rabbit tunnel.`
  </script>
  <script id="4115" type="text/markdown">
    <figure>
      <img src="${await FileAttachment("IMG_3353.jpg").url()}">
      <figcaption>A semi-completed Y-joint tunnel with rabbit (barely visible, hiding from curious dog) inside.</figcaption>
    </figure>
  </script>
  <script id="3431" type="application/vnd.observable.javascript">
    md`With quiet sheltered-in-place weekends and little access to toilet paper (at which point these constructions quickly became the least of my worries), I dismantled my initial constructions, explored construction via simulation, and eventually settled on the model pictured at the top of the notebook. The rest of this notebook steps through simulation of these models.

    I now return to the material collection phase. üßªüßªüßªüßªüßªüßªüßª`
  </script>
  <script id="2675" type="application/vnd.observable.javascript">
    md`## Simulation`
  </script>
  <script id="3466" type="application/vnd.observable.javascript">
    md`We'll get right to the point and present the finished simulator, followed by an explanation of how it works. It's really non-scientific in the sense that I've pulled forces and energies out of the sky to get it to look nice. It's not without some physical justification, but there's little motivation by legit physical chemistry, and the optimization method is staggeringly inefficient.

    We represent the model as a graph consisting of vertices and edges. The topology follows one rule:

    - Every vertex has no more than three outgoing edges.

    This rule is enough to constrain the topology, though it says nothing about the particular geometry of the result in three-dimensional space.

    **Notes**:
    - You'll need a desktop computer to use the simulator.
    - The genus 3 torus comes from the lovely [construction of Alison Martin](https://twitter.com/alisonmartin57/status/1254050723077279745), whose work has certainly inspired a lot of this exploration to begin with!
    - Most of the other constructions come from the paper listed above, ["The Topology of Fullerenes"](https://onlinelibrary.wiley.com/doi/full/10.1002/wcms.1207) by Schwerdtfeger, Wirz, and Avery.
    - I chose a regrettable data structure (a simple list of edges and vertices) which makes faces, as much as I'd love to display them, difficult to work out. My apologies. ü§∑‚Äç`
  </script>
  <script id="2607" type="application/vnd.observable.javascript">
    presetGraphs = {
      function debias(graph) {
        return translateGraph(graph, vec3scale([], computeCentroid(graph), -1));
      }

      return {
        Starter: {
          vertices: [
            [-1, -1, 0],
            [-1, 1, 0],
            [-0.5, 0, 0.0],
            [0.5, 0, 0.0],
            [1, -1, 0],
            [1, 1, 0]
          ],
          edges: [
            [0, 2],
            [1, 2],
            [2, 3],
            [3, 4],
            [3, 5]
          ]
        },
        "C60 Fullerene": debias(await FileAttachment("fullerene.json").json()),
        "C180 Fullerene": debias(
          await FileAttachment("c180-fullerene.json").json()
        ),
        "C320 Fullerene": debias(
          await FileAttachment("c320-fullerene.json").json()
        ),
        "C500 Fullerene": debias(
          await FileAttachment("c500-fullerene.json").json()
        ),
        Capsule: debias(await FileAttachment("capsule.json").json()),
        "C240 torus": debias(await FileAttachment("c240-torus.json").json()),
        "C360 torus": debias(await FileAttachment("c360-torus.json").json()),
        Dodecahedron: debias(await FileAttachment("dodecahedron.json").json()),
        "C28[5,7]-D7d": debias(await FileAttachment("c28-57-d7d.json").json()),
        "C28-Td[5,6]": debias(await FileAttachment("c28-td-56.json").json()),
        "C260-I[5,7]": debias(await FileAttachment("spiky@1.json").json()),
        "C360-D5h[5,6,7]": debias(await FileAttachment("C310-D5h-567.json").json()),
        "C120-5d[5,6,7] peanut fulleroid": debias(
          await FileAttachment("c120-peanut-fulleroid.json").json()
        ),
        "C168-D3d[5,6,7] peanut fulleroid": debias(
          await FileAttachment("double-fullerene.json").json()
        ),
        "Double torus": debias(await FileAttachment("double-torus.json").json()),
        "Genus-3 Torus": debias(
          await FileAttachment("mess-of-vertices.json").json()
        ),
        "Genus-3 Torus (extended)": debias(
          await FileAttachment("genus-3-extended-torus@1.json").json()
        ),
        "Not quite Klein Quartic": debias(
          await FileAttachment("klein-quartic@1.json").json()
        ),
        "Metadodecahedron (reduce the iterations per frame!)": debias(
          await FileAttachment("metafullerene-2.json").json()
        ),
        "Bent tube": debias(await FileAttachment("model (1).json").json())
      };
    }
  </script>
  <script id="2606" type="application/vnd.observable.javascript">
    viewof presetGraph = select({
      options: Object.keys(presetGraphs),
      value: 'C260-I[5,7]',
      title: 'Preset'
    })
  </script>
  <script id="2648" type="application/vnd.observable.javascript">
    DOM.download(
      () =>
        new Blob(
          [
            JSON.stringify({
              vertices: ctx.state.graph.vertices,
              edges: ctx.state.graph.edges
            })
          ],
          {
            type: "application/json"
          }
        ),
      "model.json",
      "Download current graph as JSON"
    )
  </script>
  <script id="3814" type="application/vnd.observable.javascript">
    viewof reset = button({ value: 'Reset' })
  </script>
  <script id="232" type="application/vnd.observable.javascript">
    viewof simulate = checkbox({ value: 'simulate', options: ['simulate'] })
  </script>
  <script id="4061" type="application/vnd.observable.javascript">
    viewof strainColoring = slider({
      description: 'Axial strain coloring',
      min: 0,
      max: 5,
      step: 0.1,
      value: 1.5
    })
  </script>
  <script id="4023" type="application/vnd.observable.javascript">
    viewof borderWidth = slider({
      min: 0,
      max: 5,
      step: 0.5,
      value: 3,
      description: "Border width"
    })
  </script>
  <script id="4018" type="application/vnd.observable.javascript">
    viewof pointSize = slider({
      min: 0.5,
      max: 5,
      step: 0.5,
      value: 3,
      description: "Vertex size"
    })
  </script>
  <script id="1010" type="application/vnd.observable.javascript">
     {
      updateParameters;
      const el = drawGraph(ctx, invalidation);
      const fig = html`
        <figure style="max-width:900px">
          ${el}
          <figcaption>${md`Select the [starter preset above](#presetGraph) to experiement. Click a vertex to select, then either click to add a new vertex or click an existing vertex to create a new connection. <kbd>Spacebar</kbd> to deselect. <kbd>Backspace</kbd> deletes vertices, <kbd>s</kbd>/<kbd>c</kbd> splits/collapses vertices of degree 2. <kbd>e</kbd> to explode a vertex. Drag to rotate, <kbd>shift</kbd> + drag to pan, and <kbd>a</kbd> to aim the camera at the selected vertex.`}</figcaption>
        </figure>
      `;
      return fig;
    }
  </script>
  <script id="2635" type="application/vnd.observable.javascript">
    viewof iterations = slider({
      description: 'Iterations per frame',
      min: 0,
      max: 200,
      step: 1,
      value: 30
    })
  </script>
  <script id="218" type="application/vnd.observable.javascript">
    viewof k = slider({
      min: 0,
      max: 2,
      step: 0.01,
      value: 1,
      description: "Axial spring constant"
    })
  </script>
  <script id="276" type="application/vnd.observable.javascript">
    viewof l0 = slider({
      min: 0.1,
      max: 2,
      step: 0.01,
      value: 1,
      description: "Equilibrium length, l0"
    })
  </script>
  <script id="393" type="application/vnd.observable.javascript">
    viewof theta0 = slider({
      min: 1,
      max: 180,
      step: 1,
      value: 150,
      description: "Equilibrium bending angle, Œ∏‚ÇÄ"
    })
  </script>
  <script id="411" type="application/vnd.observable.javascript">
    viewof kBend = slider({
      min: 0,
      max: 2,
      step: 0.01,
      value: 0.3,
      description: "Bending spring constant"
    })
  </script>
  <script id="1270" type="application/vnd.observable.javascript">
    viewof kTorsion = slider({
      min: 0,
      max: 0.2,
      step: 0.01,
      value: 0.1,
      description: "Torsional spring constant"
    })
  </script>
  <script id="3863" type="application/vnd.observable.javascript">
    graphCopy = {
      reset;
      return cloneGraph(presetGraphs[presetGraph]);
    }
  </script>
  <script id="3011" type="application/vnd.observable.javascript">
    updateGraph = {
      ctx.state = createState(graphCopy);
      createInteractions(ctx.state, ctx.camera, invalidation);
    }
  </script>
  <script id="3050" type="application/vnd.observable.javascript">
    updateParameters = {
      // Force a dependency on graph updates
      updateGraph;

      // We add these parameters *after* setting the graph so that changing parameters
      // doesn't reset the graph.
      ctx.state.k = k;
      ctx.state.l0 = l0;
      ctx.state.theta0 = theta0;
      ctx.state.kBend = kBend * l0 * l0;
      ctx.state.kTorsion = kTorsion * l0 * l0;
      ctx.state.iterations = iterations;
      ctx.state.simulate = simulate;
    }
  </script>
  <script id="2512" type="application/vnd.observable.javascript">
    md`## Physical model`
  </script>
  <script id="3094" type="application/vnd.observable.javascript">
    md`

    The sections below outline how the simulation works. We take a simple approach to computing physical configuration in three dimensions. We write down an energy function that's minimized by nice, physically pleasant configurations, then directly minimize the energy via [gradient descent](https://en.wikipedia.org/wiki/Gradient_descent) on the vertex positions.

    The concept of gradient descent is simple. We compute the change in energy with respect to independent changes in each vertex position, then move each vertex slightly downhill, opposite the direction of the gradient. There are more efficient ways to minimize energy, but we simply take a simultaneous small step for all vertices.
    `
  </script>
  <script id="3096" type="application/vnd.observable.javascript">
    html`
    <figure>
      <img src="${await FileAttachment("descent.png").url()}" width="${Math.min(
      width,
      500
    )}">
      <figcaption><p>Gradient descent minimizes energy by taking incremental steps downhill.</p></figcaption>
    </figure>
    `
  </script>
  <script id="2718" type="application/vnd.observable.javascript">
    md`### Mathematical Statement

    We write an arbitrary energy function for our graph that maps the configuration to a single real number, ${tex.block`E = E(v_i, e_j) \in \mathbb{R}`} where ${tex`v_i`} and ${tex`e_j`} are the ${tex`i^{th}`} vertex and ${tex`j^{th}`} edge of the graph, respectively. ${tex`E`} here is any useful function, picked out of the sky, such that it's minimized when the graph reaches a desirable configuration. We compute the gradient with respect to the *x-y-z* coordinates of all ${tex`N`} vertex positions, ${tex.block`\nabla E = \left(\frac{\partial E}{\partial v_{0,x}}, \frac{\partial E}{\partial v_{0,y}}, \frac{\partial E}{\partial v_{0,z}}, \frac{\partial E}{\partial v_{1,x}}, \ldots, \frac{\partial E}{\partial v_{N - 1,z}}\right).`} In the sense of rolling down a hill, this gradient points uphill so that we update the solution in the direction of a small downhill step. We compute the ${tex`n + 1^{th}`} step of vertex ${tex`v_i`} as ${tex.block`v_i^{n + 1} = v_i^n - \gamma \frac{\partial E}{\partial v_i}`} where ${tex`\gamma`} is some small number.

    It's no more complicated than that, but we must now select a function ${tex`E`}.`
  </script>
  <script id="3166" type="application/vnd.observable.javascript">
    md`## Axial stiffness

    We start simple and add lengthwise (axial) stiffness to enforce uniform length. Given an edge connecting vertices ${tex`a`} and ${tex`b`}, we denote the length of the edge ${tex`r_{ab}`} and the equilibrium length ${tex`r_0`}.`
  </script>
  <script id="3583" type="application/vnd.observable.javascript">
    html`
    <figure>
      <img src="${await FileAttachment("axial.png").url()}" width="${Math.min(
      width,
      300
    )}">
      <figcaption><p>Points ${tex`a`} and ${tex`b`} are separated by radius ${tex`r_{ab}`}.</p></figcaption>
    </figure>
    `
  </script>
  <script id="3646" type="application/vnd.observable.javascript">
    md`The minimum-energy configuration occurs when ${tex`r_{ab} = r_0`}, so we construct an energy function ${tex.block`E_{axial} = k_{axial} (r_{ab} - r_0)^2`} where ${tex`k_{axial}`} is the axial stiffness. Note that ${tex`E_{axial} = 0`} when ${tex`r_{ab} = r_0`}. Since ${tex`E_{axial}`} is strictly non-negative, this is just fancy way of saying that the energy can't get any lower than when the length is equal to the desired length; it's the bottom of the hill.

    If we differentiate this function with respect to the position of the two endpoints, then we obtain the gradient. For example, the energy gradient with respect to the coordinates of vertex ${tex`a`} is ${tex.block`
    \begin{aligned}\frac{\partial E}{\partial v_{a, x}} &= k_{axial}  \left(1 - \frac{r_0}{r_{ab}}\right) \left(v_{a,x} - v_{b, x}\right)\end{aligned} \\
    \begin{aligned}\frac{\partial E}{\partial v_{a, y}} &= k_{axial}  \left(1 - \frac{r_0}{r_{ab}}\right) \left(v_{a,y} - v_{b, y}\right)\end{aligned} \\
    \begin{aligned}\frac{\partial E}{\partial v_{a, z}} &= k_{axial}  \left(1 - \frac{r_0}{r_{ab}}\right) \left(v_{a,z} - v_{b, z}\right)\end{aligned}
    `} The gradient with respect to the coordinates of vertex ${tex`b`} are equal and opposite.

    The function below iterates over all edges and accumulates the energy gradient into a single array.`
  </script>
  <script id="158" type="application/vnd.observable.javascript">
    function computeSpringEnergyGradient(gradient, graph, l0, k) {
      for (var iEdge = 0; iEdge < graph.edges.length; iEdge++) {
        var edge = graph.edges[iEdge];
        var e0 = 3 * edge[0];
        var e1 = 3 * edge[1];
        var p0 = graph.vertices[edge[0]];
        var p1 = graph.vertices[edge[1]];
        var l = vec3distance(p0, p1);
        var c = k * (1 - l0 / l);
        var fx = c * (p0[0] - p1[0]);
        var fy = c * (p0[1] - p1[1]);
        var fz = c * (p0[2] - p1[2]);
        gradient[e0 + 0] += fx;
        gradient[e1 + 0] -= fx;
        gradient[e0 + 1] += fy;
        gradient[e1 + 1] -= fy;
        gradient[e0 + 2] += fz;
        gradient[e1 + 2] -= fz;
      }
      return gradient;
    }
  </script>
  <script id="3158" type="application/vnd.observable.javascript">
    graph2 = ({
      vertices: [
        [-1, 0, 0],
        [-0.5, -0.866, 0],
        [0.5, -0.866, 0],
        [1, 0, 0],
        [0.5, 0.866, 0],
        [-0.5, 0.866, 0]
      ],
      edges: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 0]]
    })
  </script>
  <script id="3128" type="application/vnd.observable.javascript">
    {
      updateParameters2;
      const el = drawGraph(ctx2, invalidation);
      const fig = html`
        <figure>
          ${el}
          <figcaption><p>Axial stiffness enforces edge length but doesn't adequately constrain the structure. Move the points in three dimensions and observe that the structure is not maintained.</p></figcaption>
        </figure>
      `;
      return fig;
    }
  </script>
  <script id="3174" type="application/vnd.observable.javascript">
    viewof l0_2 = slider({
      min: 0.1,
      max: 2,
      step: 0.01,
      value: 1,
      description: "Equilibrium length"
    })
  </script>
  <script id="3190" type="application/vnd.observable.javascript">
    viewof k_2 = slider({
      min: 0,
      max: 2,
      step: 0.01,
      value: 1,
      description: "Axial spring constant"
    })
  </script>
  <script id="3119" type="application/vnd.observable.javascript">
    updateGraph2 = {
      ctx2.state = createState(graph2);
      createInteractions(ctx2.state, ctx2.camera, invalidation);
    }
  </script>
  <script id="3125" type="application/vnd.observable.javascript">
    updateParameters2 = {
      // Force a dependency on graph updates
      updateGraph2;

      // We add these parameters *after* setting the graph so that changing parameters
      // doesn't reset the graph.
      ctx2.state.k = k_2;
      ctx2.state.l0 = l0_2;
      ctx2.state.theta0 = theta0;
      ctx2.state.kBend = 0;
      ctx2.state.kTorsion = 0;
      ctx2.state.iterations = 1;
      ctx2.state.simulate = true;
    }
  </script>
  <script id="3687" type="application/vnd.observable.javascript">
    md`## Dihedral stiffness`

  </script>
  <script id="3689" type="application/vnd.observable.javascript">
    html`
    <figure>
      <img src="${await FileAttachment("angular.png").url()}" width="${Math.min(
      width,
      400
    )}">
      <figcaption><p>The segment connecting ${tex`a`}, ${tex`b`}, and ${tex`c`} form angle ${tex`\theta`}.</p></figcaption>
    </figure>
    `
  </script>
  <script id="3169" type="application/vnd.observable.javascript">
    md`Axial stiffness alone clearly does not accomplish our goal of maintaining pleasant configurations. We now add an additional type of stiffness: *dihedral stiffness*. The rationale is that edges meet at a preferred angle, ${tex`\theta_0`}. We therefore define the energy function ${tex.block`E_{dihedral} = k_{dihedral}(\theta - \theta_0)^2.`} I'm sure chemistry has a lot to say about this topic, but it seems to be the case based on the structures produced that ${tex`180^\circ`} is the desired pairwise dihedral angle, and that angles of ${tex`120^\circ`} are simply the resulting compromise wherever three edges meet a vertex and result in three pairwise dihedral angles.`
  </script>
  <script id="333" type="application/vnd.observable.javascript">
    function computeJoinAngleEnergyGradient(gradient, graph, theta0, kBend) {
      computeAdjacency(graph);
      var cosTheta0 = Math.cos((theta0 * Math.PI) / 180);
      function accumulateGradient(a, b, c, ia, ib, ic) {
        var fb, fc;
        var abx = b[0] - a[0];
        var aby = b[1] - a[1];
        var abz = b[2] - a[2];
        var acx = c[0] - a[0];
        var acy = c[1] - a[1];
        var acz = c[2] - a[2];
        var ab = Math.sqrt(abx * abx + aby * aby + abz * abz);
        var ac = Math.sqrt(acx * acx + acy * acy + acz * acz);
        var ab_ac = abx * acx + aby * acy + abz * acz;
        var cosTheta = ab_ac / (ab * ac);
        var f = (kBend * 2 * (cosTheta - cosTheta0)) / (ab * ac);
        var r = ab / ac;

        fb = f * (acx - (cosTheta / r) * abx);
        fc = f * (abx - cosTheta * r * acx);
        gradient[3 * ia + 0] -= fb + fc;
        gradient[3 * ib + 0] += fb;
        gradient[3 * ic + 0] += fc;

        fb = f * (acy - (cosTheta / r) * aby);
        fc = f * (aby - cosTheta * r * acy);
        gradient[3 * ia + 1] -= fb + fc;
        gradient[3 * ib + 1] += fb;
        gradient[3 * ic + 1] += fc;

        fb = f * (acz - (cosTheta / r) * abz);
        fc = f * (abz - cosTheta * r * acz);
        gradient[3 * ia + 2] -= fb + fc;
        gradient[3 * ib + 2] += fb;
        gradient[3 * ic + 2] += fc;
      }

      for (var iVertex = 0; iVertex < graph.edges.length; iVertex++) {
        var p = graph.vertices[iVertex];
        var iEdge1 = graph.edgeAdjacency[3 * iVertex + 0];
        var iEdge2 = graph.edgeAdjacency[3 * iVertex + 1];
        var iEdge3 = graph.edgeAdjacency[3 * iVertex + 2];
        var edge1 = iEdge1 >= 0 ? graph.edges[iEdge1] : null;
        var edge2 = iEdge2 >= 0 ? graph.edges[iEdge2] : null;
        var edge3 = iEdge3 >= 0 ? graph.edges[iEdge3] : null;
        var iVertex1 =
          iEdge1 >= 0 ? (edge1[0] === iVertex ? edge1[1] : edge1[0]) : -1;
        var iVertex2 =
          iEdge2 >= 0 ? (edge2[0] === iVertex ? edge2[1] : edge2[0]) : -1;
        var iVertex3 =
          iEdge3 >= 0 ? (edge3[0] === iVertex ? edge3[1] : edge3[0]) : -1;
        var p1 = graph.vertices[iVertex1];
        var p2 = graph.vertices[iVertex2];
        var p3 = graph.vertices[iVertex3];
        if (p1 && p2) accumulateGradient(p, p1, p2, iVertex, iVertex1, iVertex2);
        if (p2 && p3) accumulateGradient(p, p2, p3, iVertex, iVertex2, iVertex3);
        if (p3 && p1) accumulateGradient(p, p3, p1, iVertex, iVertex3, iVertex1);
      }
      return gradient;
    }
  </script>
  <script id="3171" type="application/vnd.observable.javascript">
    graph3 = ({
      vertices: [
        [-1, 0, 0],
        [-0.5, -0.866, 0],
        [0.5, -0.866, 0],
        [1, 0, 0],
        [0.5, 0.866, 0],
        [-0.5, 0.866, 0]
      ],
      edges: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 0]]
    })
  </script>
  <script id="3207" type="application/vnd.observable.javascript">
    {
      updateParameters3;
      const el = drawGraph(ctx3, invalidation);
      const fig = html`
        <figure>
          ${el}
          <figcaption><p>The combination of dihedral and axial stiffness is enough to maintain sructure. Move the points in three dimensions and observe that the ring maintains its structure.</p></figcaption>
        </figure>
      `;
      return fig;
    }
  </script>
  <script id="3203" type="application/vnd.observable.javascript">
    viewof kBend_3 = slider({
      min: 0,
      max: 2,
      step: 0.01,
      value: 0.3,
      description: "Bending spring constant"
    })
  </script>
  <script id="3205" type="application/vnd.observable.javascript">
    viewof theta0_3 = slider({
      min: 1,
      max: 180,
      step: 1,
      value: 120,
      description: "Equilibrium bending angle, Œ∏‚ÇÄ"
    })
  </script>
  <script id="3198" type="application/vnd.observable.javascript">
    updateGraph3 = {
      ctx3.state = createState(graph3);
      createInteractions(ctx3.state, ctx3.camera, invalidation);
    }
  </script>
  <script id="3200" type="application/vnd.observable.javascript">
    updateParameters3 = {
      // Force a dependency on graph updates
      updateGraph3;

      // We add these parameters *after* setting the graph so that changing parameters
      // doesn't reset the graph.
      ctx3.state.k = 1;
      ctx3.state.l0 = 1;
      ctx3.state.theta0 = theta0_3;
      ctx3.state.kBend = kBend_3;
      ctx3.state.kTorsion = 0;
      ctx3.state.iterations = 1;
      ctx3.state.simulate = true;
    }
  </script>
  <script id="3218" type="application/vnd.observable.javascript">
    md`## Torsional stiffness`
  </script>
  <script id="3869" type="application/vnd.observable.javascript">
    md`Finally we tackle torsion about an edge.`
  </script>
  <script id="2866" type="application/vnd.observable.javascript">
    html`
    <figure>
      <img src="${await FileAttachment("torsion@1.png").url()}" width="${Math.min(
      width,
      400
    )}">
      <figcaption><p>Stiffness of the cardboard from which we construct the model generates a moment which pushes the six vertices toward a flat configuration.</p></figcaption>
    </figure>
    `
  </script>
  <script id="3704" type="application/vnd.observable.javascript">
    md`The figure above shows six adjacent vertices connected by an edge. Torsional stiffness of the cardboard produces a rotational force which causes vertices ${tex`c`}, ${tex`d`}, ${tex`e`}, and ${tex`f`} to rotate toward flat.`

  </script>
  <script id="2876" type="application/vnd.observable.javascript">
    html`
    <figure>
      <img src="${await FileAttachment(
        "torsion-setup.png"
      ).url()}" width="${Math.min(width, 600)}">
      <figcaption><p>We define unit vectors ${tex`\alpha`},  ${tex`\beta`}, and  ${tex`\gamma`} based on the six adjacent vertices.</p></figcaption>
    </figure>
    `
  </script>
  <script id="2898" type="application/vnd.observable.javascript">
    md`Without the sort of physical justification required for a scientifically valid molecular dynamics simulation, we simply pick an energy function that's minimized when the outer vertices are not twisted. We therefore define the unit vectors ${tex`\vec{\alpha}`}, ${tex`\vec{\beta}`}, and ${tex`\vec{\gamma}`} ${tex.block`\vec{\alpha} \equiv \frac{\vec{b} - \vec{a}}{|\vec{b} - \vec{a}|},\;\;\;\vec{\beta} \equiv \frac{\vec{d} - \vec{c}}{|\vec{d} - \vec{c}|},\;\;\;\vec{\gamma} \equiv \frac{\vec{f} - \vec{e}}{|\vec{f} - \vec{e}|}`} and define the energy function ${tex.block`E_{torsion} = -((\vec{\alpha} \times \vec{\beta}) \cdot (\vec{\alpha} \times \vec{\gamma}))^2.`} Due to the square, this function takes the value ${tex`-1`} when ${tex`\vec{\alpha} \times \vec{\beta}`} is either parallel *or* antiparallel to ${tex`\vec{\alpha} \times \vec{\gamma}`}. In words, this means that the value is minimized when vertices ${tex`c`}, ${tex`d`}, ${tex`e`}, and ${tex`f`} exhibit no rotation relative to the central edge, ${tex`e_{ab}`}.`
  </script>
  <script id="3694" type="application/vnd.observable.javascript">
    md`Note importantly that if we did not normalize vectors ${tex`\vec{\alpha}`}, ${tex`\vec{\beta}`}, and ${tex`\vec{\gamma}`}, then ${tex`E_{torsion}`} would depend upon the distance between the vertices, and the simulation would either blow up or collapse to a point, depending on the sign of ${tex`E_{torsion}`}. As it stands though, the constraint that ${tex`\vec{\alpha}`}, ${tex`\vec{\beta}`}, and ${tex`\vec{\gamma}`} are unit vectors produces a strictly torsional force.

    Computing the gradient of the above function without an explosion of terms is a bit challenging. I spent a couple sheets of paper giving it a try before recalling why [Einstein summation notation](https://en.wikipedia.org/wiki/Einstein_notation) is so useful in vector calculus.

    The page below illustrates the full derivation of all eighteen components of the gradient.`
  </script>
  <script id="3435" type="application/vnd.observable.javascript">
    html`
    <figure>
      <a href="${await FileAttachment(
        "derivation.jpg"
      ).url()}" target="_blank"><img src="${await FileAttachment(
      "derivation.jpg"
    ).url()}" width="${Math.min(width, 600)}"></a>
      <figcaption></figcaption>
    </figure>
    `
  </script>
  <script id="500" type="application/vnd.observable.javascript">
    function computeTorsionalEnergyGradient(gradient, graph, kTorsion) {
      const da = vec3create();
      const dc = vec3create();
      const de = vec3create();
      var alpha = vec3create();
      var beta = vec3create();
      var gamma = vec3create();
      const verticesCD = [0, 0];
      const verticesEF = [0, 0];

      function getAlternateVertices(out, idx3, referenceVertex) {
        var iA = graph.vertexAdjacency[idx3];
        var iB = graph.vertexAdjacency[idx3 + 1];
        var iC = graph.vertexAdjacency[idx3 + 2];
        if (iA === referenceVertex) {
          out[0] = iB;
          out[1] = iC;
        } else if (iB === referenceVertex) {
          out[0] = iA;
          out[1] = iC;
        } else {
          out[0] = iA;
          out[1] = iB;
        }
      }

      function computeGradient(da, dc, de, alpha, beta, gamma, rab, rcd, ref) {
        const bg = vec3dot(beta, gamma);
        const ag = vec3dot(alpha, gamma);
        const ab = vec3dot(alpha, beta);
        var E0 = (bg - ab * ag) * kTorsion;

        vec3scale(da, alpha, -2.0 * ab * ag);
        vec3scaleAndAdd(da, da, beta, ag);
        vec3scaleAndAdd(da, da, gamma, ab);
        vec3scale(da, da, (-2 * E0) / rab);

        vec3scale(dc, beta, bg - ag * ab);
        vec3sub(dc, dc, gamma);
        vec3scaleAndAdd(dc, dc, alpha, ag);
        vec3scale(dc, dc, (-2 * E0) / rcd);

        vec3scale(de, gamma, bg - ab * ag);
        vec3sub(de, de, beta);
        vec3scaleAndAdd(de, de, alpha, ab);
        vec3scale(de, de, (-2 * E0) / ref);
      }

      for (var iEdge = 0; iEdge < graph.edges.length; iEdge++) {
        const edge = graph.edges[iEdge];
        const iA = edge[0];
        const iB = edge[1];
        const idxA = iA * 3;
        const idxB = iB * 3;
        if (iA === -1 || iB === -1) throw new Error('Invalid edge');
        if (
          graph.vertexAdjacency[idxA + 2] === -1 ||
          graph.vertexAdjacency[idxB + 2] === -1
        )
          continue;
        getAlternateVertices(verticesCD, idxA, iB);
        getAlternateVertices(verticesEF, idxB, iA);
        const iC = verticesCD[0];
        const iD = verticesCD[1];
        const iE = verticesEF[0];
        const iF = verticesEF[1];
        const idxC = 3 * iC;
        const idxD = 3 * iD;
        const idxE = 3 * iE;
        const idxF = 3 * iF;
        const a = graph.vertices[iA];
        const b = graph.vertices[iB];
        const c = graph.vertices[iC];
        const d = graph.vertices[iD];
        const e = graph.vertices[iE];
        const f = graph.vertices[iF];

        vec3sub(alpha, b, a);
        const rab = vec3length(alpha);
        vec3scale(alpha, alpha, 1 / rab);

        vec3sub(beta, d, c);
        const rcd = vec3length(beta);
        vec3scale(beta, beta, 1 / rcd);

        vec3sub(gamma, f, e);
        const ref = vec3length(gamma);
        vec3scale(gamma, gamma, 1 / ref);

        computeGradient(da, dc, de, alpha, beta, gamma, rab, rcd, ref);

        gradient[idxA] += da[0];
        gradient[idxA + 1] += da[1];
        gradient[idxA + 2] += da[2];
        gradient[idxB] -= da[0];
        gradient[idxB + 1] -= da[1];
        gradient[idxB + 2] -= da[2];

        gradient[idxC] += dc[0];
        gradient[idxC + 1] += dc[1];
        gradient[idxC + 2] += dc[2];
        gradient[idxD] -= dc[0];
        gradient[idxD + 1] -= dc[1];
        gradient[idxD + 2] -= dc[2];

        gradient[idxE] += de[0];
        gradient[idxE + 1] += de[1];
        gradient[idxE + 2] += de[2];
        gradient[idxF] -= de[0];
        gradient[idxF + 1] -= de[1];
        gradient[idxF + 2] -= de[2];
      }
      return gradient;
    }
  </script>
  <script id="3261" type="application/vnd.observable.javascript">
    graph4 = ({
      vertices: [
        [-1, 0, 0.86],
        [-1, 0, -0.86],
        [-0.5, 0, 0],
        [0.5, 0, 0],
        [1, 0, -0.86],
        [1, 0, 0.86]
      ],
      edges: [[0, 2], [1, 2], [2, 3], [3, 4], [3, 5]]
    })
  </script>
  <script id="3276" type="application/vnd.observable.javascript">
    {
      updateParameters4;
      const el = drawGraph(ctx4, invalidation);
      const fig = html`
        <figure>
          ${el}
          <figcaption><p>Move the vertices above and observe that the addition of torsional stiffness keeps the above structure planar.</p></figcaption>
        </figure>
      `;
      return fig;
    }
  </script>
  <script id="3295" type="application/vnd.observable.javascript">
    viewof kTorsion_4 = slider({
      min: 0,
      max: 0.05,
      step: 0.001,
      value: 0.025,
      precision: 3,
      description: "Torsional spring constant"
    })
  </script>
  <script id="3267" type="application/vnd.observable.javascript">
    updateGraph4 = {
      ctx4.state = createState(graph4);
      createInteractions(ctx4.state, ctx4.camera, invalidation);
    }
  </script>
  <script id="3269" type="application/vnd.observable.javascript">
    updateParameters4 = {
      // Force a dependency on graph updates
      updateGraph4;

      // We add these parameters *after* setting the graph so that changing parameters
      // doesn't reset the graph.
      ctx4.state.k = 1;
      ctx4.state.l0 = 1;
      ctx4.state.theta0 = 180;
      ctx4.state.kBend = 0.5;
      ctx4.state.kTorsion = kTorsion_4;
      ctx4.state.iterations = 1;
      ctx4.state.simulate = true;
    }
  </script>
  <script id="2552" type="application/vnd.observable.javascript">
    md`## Graph operations`
  </script>
  <script id="2692" type="application/vnd.observable.javascript">
    md`The graph is modeled as a simple set of vertices and edges.

    In hindsight, I regret such a simple choice because it makes faces quite difficult to work out after the fact. Mikola Lysenko recommended his [planar-dual](https://github.com/mikolalysenko/planar-dual) module which extracts faces using a 2D projection of the graph. It worked, but I found it very sensitive to the particular parojection so that any faces which were inverted in the particular projection were omitted. There are workarounds, but something like a [half edge mesh](https://github.com/nmwsharp/DDGSpring2016/wiki/Halfedge-Mesh-Data-Structure) from the start would prevent needing such convoluted patches at the end.`
  </script>
  <script id="2704" type="application/vnd.observable.javascript">
    md`The operations below build a very simple adjacency graph. We cache it right on the \`graph\` object and simply delete the cached adjacency when connectivity changes, thus forcing recomputation the next time it's queried.`
  </script>
  <script id="1284" type="application/vnd.observable.javascript">
    function computeAdjacency(graph) {
      if (!graph.vertexAdjacency) {
        graph.vertexAdjacency = buildVertexAdjacency(graph);
      }
      if (!graph.edgeAdjacency) {
        graph.edgeAdjacency = buildEdgeAdjacency(graph);
      }
      return graph;
    }
  </script>
  <script id="1158" type="application/vnd.observable.javascript">
    function buildVertexAdjacency(graph) {
      var vertexAdjacency = new Int32Array(graph.vertices.length * 3);
      vertexAdjacency.fill(-1);
      function addAdjacency(vA, vB) {
        var idx = 3 * vA;
        if (vertexAdjacency[idx] >= 0) idx++;
        if (vertexAdjacency[idx] >= 0) idx++;
        if (vertexAdjacency[idx] >= 0)
          throw new Error('Too many connections for vertex ' + vA + '-' + vB + '!');
        vertexAdjacency[idx] = vB;
      }
      for (var iEdge = 0; iEdge < graph.edges.length; iEdge++) {
        var edge = graph.edges[iEdge];
        var vA = edge[0];
        var vB = edge[1];
        //console.log(edge);
        addAdjacency(vA, vB);
        addAdjacency(vB, vA);
      }
      return vertexAdjacency;
    }
  </script>
  <script id="306" type="application/vnd.observable.javascript">
    function buildEdgeAdjacency(graph) {
      var edgeAdjacency = new Int32Array(graph.vertices.length * 3);
      edgeAdjacency.fill(-1);
      function addEdge(vertexIndex, edgeIndex) {
        var idx = 3 * vertexIndex;
        if (edgeAdjacency[idx] >= 0) idx++;
        if (edgeAdjacency[idx] >= 0) idx++;
        if (edgeAdjacency[idx] >= 0)
          throw new Error('Too many connections for edge ' + idx + '!');
        edgeAdjacency[idx] = edgeIndex;
      }
      for (var iEdge = 0; iEdge < graph.edges.length; iEdge++) {
        var edge = graph.edges[iEdge];
        addEdge(edge[0], iEdge);
        addEdge(edge[1], iEdge);
      }
      return edgeAdjacency;
    }
  </script>
  <script id="2012" type="application/vnd.observable.javascript">
    function clearCachedAdjacency(graph) {
      delete graph.vertexAdjacency;
      delete graph.edgeAdjacency;
    }
  </script>
  <script id="2709" type="application/vnd.observable.javascript">
    md`The operations below implement a few simple graph modification functions.`
  </script>
  <script id="1999" type="application/vnd.observable.javascript">
    function isValid(graph) {
      const vertexCount = graph.vertices.length;
      for (let i = 0; i < graph.edges.length; i++) {
        const edge = graph.edges[i];
        const i0 = edge[0];
        const i1 = edge[1];
        if (i0 >= vertexCount || i1 >= vertexCount) return false;
      }
      return true;
    }
  </script>
  <script id="1892" type="application/vnd.observable.javascript">
    function addEdge(graph, newEdge) {
      computeAdjacency(graph);
      var e1 = graph.edgeAdjacency[newEdge[0] * 3];
      var e2 = graph.edgeAdjacency[newEdge[0] * 3 + 1];
      var e3 = graph.edgeAdjacency[newEdge[0] * 3 + 2];
      if (e3 >= 0 || graph.edgeAdjacency[newEdge[1] * 3 + 2] >= 0) return;
      function edgeEqual(ea, eb) {
        return (
          (ea[0] === eb[0] && ea[1] === eb[1]) ||
          (ea[0] === eb[1] && ea[1] === eb[0])
        );
      }
      if (e1 >= 0 && edgeEqual(graph.edges[e1], newEdge)) return false;
      if (e2 >= 0 && edgeEqual(graph.edges[e2], newEdge)) return false;
      if (e3 >= 0 && edgeEqual(graph.edges[e3], newEdge)) return false;
      graph.edges.push(newEdge);

      clearCachedAdjacency(graph);
    }
  </script>
  <script id="1764" type="application/vnd.observable.javascript">
    function deleteVertex(graph, vertexIndex) {
      if (vertexIndex === undefined)
        throw new Error('Invalid vertex index, ' + vertexIndex);
      if (vertexIndex < 0) return vertexIndex;
      computeAdjacency(graph);
      const edgesToRemove = [
        graph.edgeAdjacency[vertexIndex * 3],
        graph.edgeAdjacency[vertexIndex * 3 + 1],
        graph.edgeAdjacency[vertexIndex * 3 + 2]
      ];
      var adjacentVertexIndex = -1;
      if (edgesToRemove[0] >= 0) {
        var edge = graph.edges[edgesToRemove[0]];
        adjacentVertexIndex = edge[vertexIndex === edge[0] ? 1 : 0];
      }
      clearCachedAdjacency(graph);
      edgesToRemove.sort((a, b) => b - a);
      for (var i = 0; i < edgesToRemove.length; i++) {
        if (edgesToRemove[i] < 0) continue;
        graph.edges.splice(edgesToRemove[i], 1);
      }
      graph.vertices.splice(vertexIndex, 1);
      for (var i = 0; i < graph.edges.length; i++) {
        const edge = graph.edges[i];
        if (edge[0] > vertexIndex) edge[0]--;
        if (edge[1] > vertexIndex) edge[1]--;
      }
      if (adjacentVertexIndex > vertexIndex) adjacentVertexIndex--;
      return adjacentVertexIndex;
    }
  </script>
  <script id="1990" type="application/vnd.observable.javascript">
    collapseVertex = function(graph, vertexIndex) {
      if (vertexIndex < 0) return vertexIndex;
      computeAdjacency(graph);
      if (degree(graph.edgeAdjacency, vertexIndex) !== 2) return vertexIndex;

      var edge = graph.edges[graph.edgeAdjacency[3 * vertexIndex]];
      var adjacentIndex = edge[0] === vertexIndex ? edge[1] : edge[0];

      let v0 = graph.vertexAdjacency[vertexIndex * 3];
      let v1 = graph.vertexAdjacency[vertexIndex * 3 + 1];

      deleteVertex(graph, vertexIndex);

      // We got rid of the vertex we want and must now decrement the adjacent vertices
      // *only if* their indices changed because they were after the deleted vertex
      if (v0 > vertexIndex) v0--;
      if (v1 > vertexIndex) v1--;
      graph.edges.push([v0, v1]);

      if (adjacentIndex > vertexIndex) adjacentIndex--;

      clearCachedAdjacency(graph);

      return adjacentIndex;
    }
  </script>
  <script id="3933" type="application/vnd.observable.javascript">
    function splitVertex(graph, vertexIndex) {
      if (vertexIndex < 0) return vertexIndex;
      computeAdjacency(graph);
      if (degree(graph.edgeAdjacency, vertexIndex) !== 2) return vertexIndex;

      var vertex = graph.vertices[vertexIndex];
      var edge = graph.edges[graph.edgeAdjacency[3 * vertexIndex]];
      var adjacentIndex = edge[0] === vertexIndex ? edge[1] : edge[0];
      var adjacentVertex = graph.vertices[adjacentIndex];

      var newVertex = [
        0.5 * (vertex[0] + adjacentVertex[0]),
        0.5 * (vertex[1] + adjacentVertex[1]),
        0.5 * (vertex[2] + adjacentVertex[2])
      ];

      var newVertexIndex = graph.vertices.length;
      graph.vertices[newVertexIndex] = newVertex;
      graph.edges.push([adjacentIndex, newVertexIndex]);
      edge[edge[0] === vertexIndex ? 1 : 0] = newVertexIndex;

      clearCachedAdjacency(graph);

      return newVertexIndex;
    }
  </script>
  <script id="3977" type="application/vnd.observable.javascript">
    function explodeVertex(graph, vertexIndex) {
      if (vertexIndex < 0) return vertexIndex;
      computeAdjacency(graph);

      var edgeIndex1 = graph.edgeAdjacency[3 * vertexIndex + 1];
      var edgeIndex2 = graph.edgeAdjacency[3 * vertexIndex + 2];
      var vertex = graph.vertices[vertexIndex];

      if (edgeIndex1 >= 0) {
        var edge = graph.edges[edgeIndex1];
        edge[vertexIndex === edge[0] ? 0 : 1] = graph.vertices.length;
        graph.vertices.push(vertex.slice());
      }

      if (edgeIndex2 >= 0) {
        var edge = graph.edges[edgeIndex2];
        edge[vertexIndex === edge[0] ? 0 : 1] = graph.vertices.length;
        graph.vertices.push(vertex.slice());
      }

      clearCachedAdjacency(graph);

      return vertexIndex;
    }
  </script>
  <script id="526" type="application/vnd.observable.javascript">
    function degree(edgeAdjacency, i) {
      if (edgeAdjacency[3 * i] === -1) return 0;
      if (edgeAdjacency[3 * i + 1] === -1) return 1;
      if (edgeAdjacency[3 * i + 2] === -1) return 2;
      return 3;
    }
  </script>
  <script id="2563" type="application/vnd.observable.javascript">
    function computeCentroid(graph) {
      const vertices = graph.vertices;
      let x = 0;
      let y = 0;
      let z = 0;
      for (var i = 0; i < vertices.length; i++) {
        const p = vertices[i];
        x += p[0];
        y += p[1];
        z += p[2];
      }
      x /= vertices.length;
      y /= vertices.length;
      z /= vertices.length;
      return [x, y, z];
    }
  </script>
  <script id="2565" type="application/vnd.observable.javascript">
    function translateGraph(graph, offset) {
      const vertices = graph.vertices;
      for (var i = 0; i < vertices.length; i++) {
        const p = vertices[i];
        p[0] += offset[0];
        p[1] += offset[1];
        p[2] += offset[2];
      }
      return graph;
    }
  </script>
  <script id="2684" type="application/vnd.observable.javascript">
    function cloneGraph(graph) {
      var newGraph = { vertices: [], edges: [] };
      for (var i = 0; i < graph.vertices.length; i++) {
        newGraph.vertices.push(graph.vertices[i].slice());
      }
      for (var i = 0; i < graph.edges.length; i++) {
        newGraph.edges.push(graph.edges[i].slice());
      }
      return newGraph;
    }
  </script>
  <script id="239" type="application/vnd.observable.javascript">
    function iterate(graph, gamma, state) {
      var gradient = new Float64Array(graph.vertices.length * 3);
      if (state.k > 0)
        computeSpringEnergyGradient(gradient, graph, state.l0, state.k);
      if (state.kBend > 0)
        computeJoinAngleEnergyGradient(gradient, graph, state.theta0, state.kBend);
      if (state.kTorsion > 0)
        computeTorsionalEnergyGradient(gradient, graph, state.kTorsion);
      for (var i = 0; i < graph.vertices.length; i++) {
        if (i === state.activeVertexIndex) continue;
        graph.vertices[i][0] -= gradient[i * 3 + 0] * gamma;
        graph.vertices[i][1] -= gradient[i * 3 + 1] * gamma;
        graph.vertices[i][2] -= gradient[i * 3 + 2] * gamma;
      }
    }
  </script>
  <script id="2502" type="application/vnd.observable.javascript">
    md`## Drawing commands`
  </script>
  <script id="1329" type="application/vnd.observable.javascript">
    function flattenEdges(graph) {
      var a = new Float32Array(graph.edges.length * 6);
      for (var i = 0, i6 = 0; i < graph.edges.length; i++, i6 += 6) {
        var e = graph.edges[i];
        var ia = e[0];
        var ib = e[1];
        a[i6 + 0] = graph.vertices[ia][0];
        a[i6 + 1] = graph.vertices[ia][1];
        a[i6 + 2] = graph.vertices[ia][2];
        a[i6 + 3] = graph.vertices[ib][0];
        a[i6 + 4] = graph.vertices[ib][1];
        a[i6 + 5] = graph.vertices[ib][2];
      }
      return a;
    }
  </script>
  <script id="2525" type="application/vnd.observable.javascript">
    function flattenVertices(graph) {
      var a = new Float32Array(graph.vertices.length * 3);
      for (var i = 0, i3 = 0; i < graph.vertices.length; i++, i3 += 3) {
        a[i3 + 0] = graph.vertices[i][0];
        a[i3 + 1] = graph.vertices[i][1];
        a[i3 + 2] = graph.vertices[i][2];
      }
      return a;
    }
  </script>
  <script id="45" type="application/vnd.observable.javascript">
    function createDrawVertices(regl) {
      const icosphere = createIcosphere(1);
      const positions = regl.buffer(icosphere.positions);
      const cells = regl.elements(icosphere.cells);
      const indices = new Uint16Array(65536);
      const vertexBuffer = regl.buffer(new Float32Array(65536));
      for (var i = 0; i < indices.length; i++) indices[i] = i;
      const indexBuffer = regl.buffer(indices);
      return regl({
        vert: `
        precision highp float;
        attribute vec3 icoPosition;
        attribute vec3 vertex;
        attribute float index;
        uniform mat4 projectionView;
        uniform float pointSize;
        uniform float selectedIndex, hoverIndex;
        varying float isSelected, isActive, isHover;
        void main () {
          isSelected = index == selectedIndex ? 1.0 : 0.0;
          isHover = index == hoverIndex ? 1.0 : 0.0;
          vec4 p0 = projectionView * vec4(vertex, 1);
          float size = p0.z * pointSize;
          gl_Position = projectionView * vec4(vertex + icoPosition * size, 1);
        }`,
        frag: `
        precision highp float;
        varying float isSelected, isHover;
        void main () {
          gl_FragColor = vec4(
            vec3(0.14, 0.37, 0.69) + isHover * vec3(0, 0.5, 0) + isSelected * vec3(1, 0, 0)
            , 1);
        }`,
        attributes: {
          icoPosition: positions,
          vertex: (ctx, props) => ({
            buffer: props.vertexBuffer,
            divisor: 1
          }),
          index: {
            buffer: indexBuffer,
            divisor: 1
          }
        },
        elements: cells,
        cull: { enable: true, face: 'back' },
        uniforms: {
          pointSize: (ctx, props) =>
            (ctx.pixelRatio * props.pointSize) / ctx.viewportHeight,
          selectedIndex: (ctx, props) => props.selectedVertexIndex,
          hoverIndex: (ctx, props) => props.hoverVertexIndex
        },
        primitive: 'triangles',
        count: icosphere.cells.length * 3,
        instances: (ctx, props) => props.count
      });
    }
  </script>
  <script id="1295" type="application/vnd.observable.javascript">
    function createDrawEdges(regl) {
      var SIZEOF_FLOAT = 4;
      var DEFAULT_LINE_COLOR = [0, 0, 0, 1];
      var DEFAULT_BORDER_COLOR = [1, 1, 1, 1];
      var DEFAULT_LINE_WIDTH = 2;
      var DEFAULT_BORDER_WIDTH = 2;

      return regl({
        vert: `
          precision highp float;

          uniform mat4 projectionView;
          uniform float uAspect, uTurningAngleSafetyExtension, uScaleFactor, uPixelRatio, uL0, uStrainColoring;
          attribute vec3 aPosition, aNextPosition;
          attribute vec2 aLinePosition;
          varying float vOffset;
          varying vec2 vStrokeEdges;
          uniform float uBorderWidth;
          uniform float uLineWidth;
          varying vec3 vColor;

          vec2 lineNormal (vec4 p, vec4 n, float aspect) { 
            return normalize((p.yx / p.w  - n.yx / n.w) * vec2(1, aspect));
          }

          const float pi = 3.14159;

          vec3 colormap (float x) {
            float cx = clamp(x, 0.0, 1.0);
            return vec3(
              cos(pi * cx),
              cos(pi * (cx - 0.5)),
              cos(pi * (cx - 1.0))
            );
          }

          void main () {
            // Compute the position of two adjacent points
            vec4 currentPoint = projectionView * vec4(aPosition, 1);
            vec4 nextPoint = projectionView * vec4(aNextPosition, 1);
            float strain = (length(aNextPosition - aPosition) / uL0 - 1.0);
            vColor = colormap(0.5 + strain * uStrainColoring * 2.0) * 0.8 * (uStrainColoring > 0.0 ? 1.0 : 0.0);

            float totalWidth = uLineWidth + uBorderWidth * 2.0;

            // Use the aLinePosition attribute to select either the current or next point
            gl_Position = mix(currentPoint, nextPoint, aLinePosition.y);

            // Apply the screen-space offset to make a line of the correct width
            vec2 vn = lineNormal(currentPoint, nextPoint, uAspect);
              gl_Position.xy += (
              vn / vec2(-uAspect, 1) * aLinePosition.x * totalWidth +
              -vn.yx * vec2(1, uAspect) * aLinePosition.y * totalWidth * uTurningAngleSafetyExtension
            ) * gl_Position.w * uScaleFactor;

            // Pass the horizontal line offset to the fragment shader so we can
            // add a stroke to the line
            vOffset = aLinePosition.x * totalWidth;

            vStrokeEdges = uBorderWidth < 1e-3 ? vec2(-100, -101) : (uLineWidth + vec2(-1, 1) / uPixelRatio);
          }`,
        frag: `
          precision highp float;

          uniform vec4 uColor, uBorderColor;
          varying float vOffset;
          varying vec3 vColor;
          varying vec2 vStrokeEdges;

          void main () {
            gl_FragColor = mix(
              uBorderColor,
              vec4(vColor, 1),
              smoothstep( vStrokeEdges.y,  vStrokeEdges.x, vOffset) *
              smoothstep(-vStrokeEdges.y, -vStrokeEdges.x, vOffset)
            );
          }`,
        polygonOffset: {
          enable: true,
          offset: {
            factor: 2,
            units: 2
          }
        },
        attributes: {
          aLinePosition: [[-1, 0], [1, 0], [-1, 1], [1, 1]],
          aPosition: (ctx, props) => ({
            buffer: props.vertexBuffer,
            offset: 0,
            stride: 6 * 4,
            divisor: 1
          }),
          aNextPosition: (ctx, props) => ({
            buffer: props.vertexBuffer,
            offset: 3 * 4,
            stride: 6 * 4,
            divisor: 1
          })
        },
        elements: regl.prop('edgeBuffer'),
        uniforms: {
          uL0: (ctx, props) => (props.l0 === undefined ? 1 : props.l0),
          uStrainColoring: (ctx, props) =>
            props.strainColoring === undefined ? 0 : props.strainColoring,
          uBorderColor: regl.prop('borderColor'),
          uLineWidth: regl.prop('lineWidth'),
          uBorderWidth: regl.prop('borderWidth'),
          uColor: regl.prop('color'),
          uAspect: ctx => ctx.viewportWidth / ctx.viewportHeight,
          uScaleFactor: (ctx, props) => ctx.pixelRatio / ctx.viewportHeight,
          uPixelRatio: regl.context('pixelRatio'),
          uTurningAngleSafetyExtension: (ctx, props) => {
            var turningAngle =
              (Math.PI / 180) *
              (props.maxExpectedTurningAngle === undefined
                ? 5
                : props.maxExpectedTurningAngle);
            return turningAngle < 1e-4
              ? turningAngle * 0.5
              : (1 - Math.cos(turningAngle)) / Math.sin(turningAngle);
          }
        },
        primitive: 'triangle strip',
        instances: regl.prop('count'),
        count: 4
      });
    }
  </script>
  <script id="6" type="application/vnd.observable.javascript">
    function drawGraph(ctx, invalidation) {
      const c = ctx.cache(
        {
          drawVertices: () => createDrawVertices(ctx.regl),
          drawEdges: () => createDrawEdges(ctx.regl)
        },
        true
      );
      let visible = false;
      const vertexBuffer = ctx.regl.buffer(new Float32Array(65536));
      const edgeVerticesBuffer = ctx.regl.buffer(new Float32Array(65536));
      ctx.camera.taint();
      const frame = ctx.regl.frame(() => {
        if (!visible) return;
        const state = ctx.state;
        const graph = state && state.graph;
        try {
          ctx.camera.tick(({ dirty }) => {
            if (!state.simulate && !dirty) return;
            if (graph) {
              if (state.simulate) {
                for (var i = 0; i < iterations; i++) {
                  iterate(graph, 0.1, ctx.state);
                }
              }
              vertexBuffer.subdata(flattenVertices(graph));
              edgeVerticesBuffer.subdata(flattenEdges(graph));
            }

            ctx.regl.clear({ color: [1, 1, 1, 1], depth: 1 });

            if (graph) {
              ctx.data.drawVertices(
                Object.assign({}, state, {
                  vertexBuffer,
                  count: graph.vertices.length,
                  pointSize
                })
              );

              ctx.data.drawEdges({
                vertexBuffer: edgeVerticesBuffer,
                strainColoring,
                l0,
                color: [0, 0, 0, 1],
                lineWidth: 2,
                borderWidth,
                borderColor: [1, 1, 1, 1],
                count: graph.edges.length
              });
            }
          });
        } catch (e) {
          console.error(e);
          //console.log('current graph', JSON.stringify(graph));
          frame.cancel();
        }
      });

      // Stop drawing the plot when offscreen
      const observer = new IntersectionObserver(entries => {
        visible = entries.pop().intersectionRatio > 0;
      });
      observer.observe(ctx.container);

      invalidation &&
        invalidation.then(() => {
          frame.cancel();
          observer.disconnect();
        });

      return ctx.container;
    }
  </script>
  <script id="2493" type="application/vnd.observable.javascript">
    md`## WebGL context and camera`
  </script>
  <script id="24" type="application/vnd.observable.javascript">
    function createContext(opts) {
      opts = Object.assign(
        {
          width: Math.min(window.outerWidth - 80, width),
          height: Math.min(window.outerHeight - 80, Math.floor(width * 0.9)),
          eye: [0, 1, -20]
        },
        opts
      );
      const pixelRatio = devicePixelRatio;
      const container = document.createElement('div');
      container.style.width = `${opts.width}px`;
      container.style.height = `${opts.height}px`;
      const regl = createREGL({
        container,
        pixelRatio,
        extensions: ['ANGLE_instanced_arrays']
      });
      const camera = reglCamera(regl, { eye: opts.eye });
      const data = {};
      function cache(evaluate, cacheBust) {
        Object.keys(evaluate).forEach(key => {
          if (cacheBust) {
            data[key] = evaluate[key]();
          } else {
            data[key] = data[key] || evaluate[key]();
          }
        });
        return data;
      }
      return { regl, container, camera, data, cache };
    }
  </script>
  <script id="661" type="application/vnd.observable.javascript">
    createOrbitCamera = {
      // https://github.com/mikolalysenko/orbit-camera/blob/master/LICENSE
      //
      // The MIT License (MIT)
      //
      // Copyright (c) 2013 Mikola Lysenko
      //
      // Permission is hereby granted, free of charge, to any person obtaining a copy
      // of this software and associated documentation files (the "Software"), to deal
      // in the Software without restriction, including without limitation the rights
      // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      // copies of the Software, and to permit persons to whom the Software is
      // furnished to do so, subject to the following conditions:
      //
      // The above copyright notice and this permission notice shall be included in
      // all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
      // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
      // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
      // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
      // THE SOFTWARE.

      //Scratch variables
      var scratch0 = new Float32Array(16);
      var scratch1 = new Float32Array(16);

      function OrbitCamera(rotation, center, distance) {
        this.rotation = rotation;
        this.center = center;
        this.distance = distance;
      }

      var proto = OrbitCamera.prototype;

      proto.view = function(out) {
        if (!out) {
          out = mat4create();
        }
        scratch1[0] = scratch1[1] = 0.0;
        scratch1[2] = -this.distance;
        mat4fromRotationTranslation(
          out,
          quatConjugate(scratch0, this.rotation),
          scratch1
        );
        mat4translate(out, out, vec3negate(scratch0, this.center));
        return out;
      };

      proto.lookAt = function(eye, center, up) {
        mat4lookAt(scratch0, eye, center, up);
        mat3fromMat4(scratch0, scratch0);
        quatFromMat3(this.rotation, scratch0);
        vec3copy(this.center, center);
        this.distance = vec3distance(eye, center);
      };

      proto.pan = function(dpan) {
        var d = this.distance;
        scratch0[0] = -d * (dpan[0] || 0);
        scratch0[1] = d * (dpan[1] || 0);
        scratch0[2] = d * (dpan[2] || 0);
        vec3transformQuat(scratch0, scratch0, this.rotation);
        vec3add(this.center, this.center, scratch0);
      };

      proto.zoom = function(d) {
        this.distance *= Math.exp(d / 10.0);
        if (this.distance < 0.0) {
          this.distance = 0.0;
        }
      };

      function quatFromVec(out, da) {
        var x = da[0];
        var y = da[1];
        var z = da[2];
        var s = x * x + y * y;
        if (s > 1.0) {
          s = 1.0;
        }
        out[0] = -da[0];
        out[1] = da[1];
        out[2] = da[2] || Math.sqrt(1.0 - s);
        out[3] = 0.0;
      }

      proto.rotate = function(da, db) {
        quatFromVec(scratch0, da);
        quatFromVec(scratch1, db);
        quatInvert(scratch1, scratch1);
        quatMultiply(scratch0, scratch0, scratch1);
        if (quatLength(scratch0) < 1e-6) {
          return;
        }
        quatMultiply(this.rotation, this.rotation, scratch0);
        quatNormalize(this.rotation, this.rotation);
      };

      return function createOrbitCamera(eye, target, up) {
        eye = eye || [0, 0, -1];
        target = target || [0, 0, 0];
        up = up || [0, 1, 0];
        var camera = new OrbitCamera(quatCreate(), vec3create(), 1.0);
        camera.lookAt(eye, target, up);
        return camera;
      };
    }
  </script>
  <script id="699" type="application/vnd.observable.javascript">
    function reglCamera(regl, opts) {
      opts = Object.assign(
        {
          eye: opts.eye || [0, 1, -20],
          center: [0, 0, 0],
          up: [0, 1, 0],
          fovy: Math.PI / 4,
          near: 0.1,
          far: 200.0
        },
        opts
      );
      const camera = createOrbitCamera(opts.eye, opts.center, opts.up);
      const view = mat4create();
      const projection = mat4create();
      const projectionView = mat4create();
      let aspectRatio = regl._gl.canvas.width / regl._gl.canvas.height;
      let dirty = true;

      const setUniforms = regl({
        uniforms: {
          eye: () => camera.eye,
          center: () => camera.center,
          view: () => view,
          projection: () => projection,
          projectionView: () => projectionView,
          aspectRatio: () => aspectRatio
        },
        context: {
          eye: () => camera.eye,
          center: () => camera.center,
          view: () => view,
          projection: () => projection,
          projectionView: () => projectionView,
          aspectRatio: () => aspectRatio,
          dirty: () => dirty
        }
      });
      camera.tick = function(callback) {
        aspectRatio = regl._gl.canvas.width / regl._gl.canvas.height;
        camera.view(view);
        mat4perspective(projection, opts.fovy, aspectRatio, opts.near, opts.far);
        mat4multiply(projectionView, projection, view);
        setUniforms(callback);
        dirty = false;
      };
      camera.taint = function() {
        dirty = true;
      };
      camera.element = regl._gl.canvas;
      camera.projectionView = projectionView;

      return camera;
    }
  </script>
  <script id="2980" type="application/vnd.observable.javascript">
    ctx = createContext({
      eye: [0, 1, -20]
    })
  </script>
  <script id="3116" type="application/vnd.observable.javascript">
    ctx2 = createContext({
      width: Math.min(700),
      height: Math.max(400, Math.floor(Math.min(700) * 0.7)),
      eye: [0, 0, -4]
    })
  </script>
  <script id="3195" type="application/vnd.observable.javascript">
    ctx3 = createContext({
      width: Math.min(700),
      height: Math.max(400, Math.floor(Math.min(700) * 0.7)),
      eye: [0, 0, -4]
    })
  </script>
  <script id="3263" type="application/vnd.observable.javascript">
    ctx4 = createContext({
      width: Math.min(700),
      height: Math.max(400, Math.floor(Math.min(700) * 0.7)),
      eye: [0, 2, -3]
    })
  </script>
  <script id="2521" type="application/vnd.observable.javascript">
    md`## Interactions`
  </script>
  <script id="2712" type="application/vnd.observable.javascript">
    md`The class below tries to implement a simple interaction controller which I don't very much like. It allows plugging in tools which are called in sequence on event input until one of them elects to capture the event. This allows layering a vertex editing tool on top of a camera controller without a particularly special case for camera control. The downside is that it's not done well and cleanly enough to be quite the right abstraction.`
  </script>
  <script id="761" type="application/vnd.observable.javascript">
    InteractionController = {
      function InteractionController(element, toolStack) {
        this.state = 'INITIAL';
        this.initialX = null;
        this.initialY = null;
        this.previousX = null;
        this.previousY = null;
        this.captured = false;
        this.wheelCaptured = false;
        this.element = element;
        this.xy = [null, null];
        this.initialXY = [null, null];
        this.toolStack = [toolStack];
        this.capturedTool = null;
        element.tabIndex = "1";
        element.style.outline = "none";

        this.element.style.cursor = 'grab';

        this.handleMouseWheel = this._onMouseWheel.bind(this);
        this.handleMousedown = this._onMousedown.bind(this);
        this.handleMousemove = this._onMousemove.bind(this);
        this.handleWindowMousemove = this._onWindowMousemove.bind(this);
        this.handleWindowMouseup = this._onWindowMouseup.bind(this);
        this.handleKeyUp = this._onKeyUp.bind(this);
        this.capture = () => (this.captured = true);
        this.captureWheel = () => (this.captureWheel = true);

        element.addEventListener('mousedown', this.handleMousedown);
        element.addEventListener('mousemove', this.handleMousemove);
        element.addEventListener('wheel', this.handleMouseWheel);
        element.addEventListener('keyup', this.handleKeyUp);

        this.destroy = () => {
          element.removeEventListener('mousedown', this.handleMousedown);
          element.removeEventListener('mousemove', this.handleMousemove);
          element.removeEventListener('wheel', this.handleMouseWheel);
          element.removeEventListener('keyup', this.handleKeyUp);
          this._stopObservingWindow();
        };
      }

      InteractionController.prototype.pushToolStack = function(toolStack) {
        this.toolStack.unshift(toolStack);
      };

      InteractionController.prototype.popToolStack = function(tool) {
        if (this.toolStack.length < 2) return;
        this.toolStack.shift();
      };

      InteractionController.prototype.setCursor = function(cursor) {
        this.element.style.cursor = cursor;
      };

      function ControllerEvent(props) {
        Object.assign(this, props);
        this.reset();
      }

      ControllerEvent.prototype.capture = function() {
        this.captured = true;
      };

      ControllerEvent.prototype.stopPropagation = function() {
        this.propagationStopped = true;
      };

      ControllerEvent.prototype.reset = function() {
        this.captured = false;
        this.propagationStopped = false;
      };

      ControllerEvent.prototype.insideDeadZone = function(radius) {
        if (this.initialX === undefined || this.initialY === undefined)
          return false;
        if (this.x === undefined || this.x === undefined) return false;
        const dx = this.x - this.initialX;
        const dy = this.y - this.initialY;
        return dx * dx + dy * dy < radius * radius;
      };

      InteractionController.prototype._consumeEvent = function(
        originalEvent,
        isInitial
      ) {
        const previousX = this.xy[0];
        const previousY = this.xy[1];
        if (isInitial) {
          this.initialXY[0] = this.xy[0];
          this.initialXY[1] = this.xy[1];
        }
        mouseEventOffset(originalEvent, this.element, this.xy);
        return {
          x: this.xy[0],
          y: this.xy[1],
          deltaX: this.xy[0] - previousX,
          deltaY: this.xy[1] - previousY,
          previousX,
          previousY,
          initialX: this.initialXY[0],
          initialY: this.initialXY[1],
          originalEvent
        };
      };

      InteractionController.prototype._delegate = function(eventName, vars, tool) {
        const context = new ControllerEvent(vars);
        const toolStack = tool ? [tool] : this.toolStack[0];
        for (var i = 0; i < toolStack.length; i++) {
          const tool = toolStack[i];
          if (!tool[eventName]) continue;
          tool[eventName].bind(this)(context);
          if (context.captured) {
            this.capturedTool = tool;
            return context;
          }
          if (context.propagationStopped) {
            break;
          }
        }
      };

      InteractionController.prototype._startObservingWindow = function() {
        this.setCursor('grabbing');
        window.addEventListener('mousemove', this.handleWindowMousemove);
        window.addEventListener('mouseup', this.handleWindowMouseup);
      };

      InteractionController.prototype._stopObservingWindow = function() {
        this.setCursor(null);
        window.removeEventListener('mousemove', this.handleWindowMousemove);
        window.removeEventListener('mousemove', this.handleWindowMouseup);
      };

      InteractionController.prototype._onMouseWheel = function(originalEvent) {
        this._delegate(
          'wheel',
          Object.assign(this._consumeEvent(originalEvent), {
            deltaX: originalEvent.deltaX,
            deltaY: originalEvent.deltaY
          })
        );
      };

      InteractionController.prototype._onMousedown = function(originalEvent) {
        this._startObservingWindow();
        const props = this._consumeEvent(originalEvent, true);
        this._delegate('beginPress', props);
      };

      InteractionController.prototype._onKeyUp = function(originalEvent) {
        this._delegate('keyUp', { originalEvent });
      };

      InteractionController.prototype._onMousemove = function(originalEvent) {
        if (this.capturedTool) return;
        this._delegate('passiveMove', this._consumeEvent(originalEvent));
      };

      InteractionController.prototype._onWindowMousemove = function(originalEvent) {
        if (this.capturedTool) {
          this._delegate(
            'capturedMove',
            this._consumeEvent(originalEvent),
            this.capturedTool
          );
        }
      };

      InteractionController.prototype._onWindowMouseup = function(originalEvent) {
        this._stopObservingWindow();
        if (this.capturedTool) {
          const props = this._consumeEvent(originalEvent);
          this._delegate('endPress', props);
          this._delegate('endCapture', props, this.capturedTool);
          this.capturedTool = null;
        }
      };

      return InteractionController;
    }
  </script>
  <script id="784" type="application/vnd.observable.javascript">
    function createInteractions(state, camera, invalidation) {
      const interactions = new InteractionController(camera.element, [
        createVertexTool(state, camera),
        createCameraTool(state, camera)
      ]);
      invalidation.then(interactions.destroy);
      return interactions;
    }
  </script>
  <script id="1031" type="application/vnd.observable.javascript">
    function getClosestPointIndex(
      graph,
      projectionView,
      mousePosition,
      viewportSize
    ) {
      const vertices = graph.vertices;
      const projected = vec3create();
      const uv = vec2create();
      let minIndex = -1;
      let minDistance = Infinity;
      for (var i = 0; i < vertices.length; i++) {
        vec3transformMat4(projected, vertices[i], projectionView);
        if (projected[2] < -1 || projected[2] > 1) continue;
        uv[0] = (0.5 + 0.5 * projected[0]) * viewportSize[0];
        uv[1] = (0.5 - 0.5 * projected[1]) * viewportSize[1];
        var dx = mousePosition[0] - uv[0];
        var dy = mousePosition[1] - uv[1];
        var r2 = dx * dx + dy * dy;
        if (r2 < minDistance * minDistance) {
          minDistance = Math.sqrt(r2);
          minIndex = i;
        }
      }
      return { index: minIndex, distance: minDistance };
    }
  </script>
  <script id="1038" type="application/vnd.observable.javascript">
    function createState(graph) {
      return {
        graph,
        state: 'MOVE_VERTICES',
        selectedVertexIndex: -1,
        hoverVertexIndex: -1,
        activeVertexIndex: -1,
        deadZoneRadius: 4
      };
    }
  </script>
  <script id="1547" type="application/vnd.observable.javascript">
    function createVertexTool(state, camera) {
      const graph = state.graph;
      const element = camera.element;
      let exitedDeadZone = false;
      let candidateEdge;

      const viewportSize = [element.offsetWidth, element.offsetHeight];
      function updateViewportSize() {
        viewportSize[0] = element.offsetWidth;
        viewportSize[1] = element.offsetHeight;
      }

      function getClosestPoint(x, y) {
        updateViewportSize();
        return getClosestPointIndex(
          graph,
          camera.projectionView,
          [x, y],
          viewportSize
        );
      }

      return {
        keyUp: function(event) {
          switch (event.originalEvent.keyCode) {
            case 8: // backspace
              if (state.selectedVertexIndex >= 0) {
                var idx = deleteVertex(graph, state.selectedVertexIndex);
                state.selectedVertexIndex = idx;
                state.hoverVertexIndex = -1;
                state.activeVertexIndex = -1;
                state.spawnVertexIndex = idx;
                candidateEdge = null;
                camera.taint();
                event.originalEvent.preventDefault();
              }
              break;
            case 32: // space
              state.selectedVertexIndex = -1;
              state.activeVertexIndex = -1;
              camera.taint();
              event.originalEvent.preventDefault();
              break;
            case 67: // 'c'
              var idx = collapseVertex(graph, state.selectedVertexIndex);
              state.selectedVertexIndex = idx;
              state.hoverVertexIndex = -1;
              state.activeVertexIndex = -1;
              state.spawnVertexIndex = idx;
              candidateEdge = null;
              camera.taint();
              event.originalEvent.preventDefault();
              break;

            case 83: // 's'
              var idx = splitVertex(graph, state.selectedVertexIndex);
              state.selectedVertexIndex = idx;
              state.hoverVertexIndex = -1;
              state.activeVertexIndex = -1;
              state.spawnVertexIndex = idx;
              candidateEdge = null;
              camera.taint();
              event.originalEvent.preventDefault();
              break;

            case 69: // 'e'
              var idx = explodeVertex(graph, state.selectedVertexIndex);
              state.selectedVertexIndex = idx;
              state.hoverVertexIndex = -1;
              state.activeVertexIndex = -1;
              state.spawnVertexIndex = idx;
              candidateEdge = null;
              camera.taint();
              event.originalEvent.preventDefault();
              break;

            default:
            //console.log(event.originalEvent.keyCode);
          }
        },
        beginPress: function(event) {
          //console.log('begin press', state);
          exitedDeadZone = false;
          const closestPoint = getClosestPoint(event.x, event.y);
          if (closestPoint.index >= 0 && closestPoint.distance < 25) {
            if (
              state.selectedVertexIndex >= 0 &&
              state.selectedVertexIndex !== closestPoint.index
            ) {
              candidateEdge = [state.selectedVertexIndex, closestPoint.index];
            }
            state.activeVertexIndex = closestPoint.index;
            state.selectedVertexIndex = closestPoint.index;
            state.spawnVertexIndex = closestPoint.index;
            camera.taint();
            this.setCursor('move');
            event.capture();
          }
        },
        endPress: function(event) {
          //console.log('end press', state, exitedDeadZone);
          if (!exitedDeadZone && event.insideDeadZone(5)) {
            const closestPoint = getClosestPoint(event.x, event.y);
            if (closestPoint.index >= 0 && closestPoint.distance < 25) {
              if (candidateEdge) {
                addEdge(graph, candidateEdge);
              }
              event.stopPropagation();
              state.selectedVertexIndex = closestPoint.index;
              camera.taint();
            } else if (state.spawnVertexIndex >= 0) {
              updateViewportSize();
              var projected = vec3create();
              var projectionViewInverse = mat4invert(
                mat4create(),
                camera.projectionView
              );
              var p = graph.vertices[state.spawnVertexIndex];
              vec3transformMat4(projected, p, camera.projectionView);
              projected[0] = (2.0 * event.x) / viewportSize[0] - 1.0;
              projected[1] = 1.0 - (2.0 * event.y) / viewportSize[1];
              const newVertex = vec3transformMat4(
                vec3create(),
                projected,
                projectionViewInverse
              );
              computeAdjacency(graph);
              if (graph.edgeAdjacency[state.spawnVertexIndex * 3 + 2] === -1) {
                graph.vertices.push(newVertex);
                graph.edges.push([
                  state.spawnVertexIndex,
                  graph.vertices.length - 1
                ]);
                delete graph.vertexAdjacency;
                delete graph.edgeAdjacency;
                camera.taint();
                state.spawnVertexIndex = state.selectedVertexIndex =
                  graph.vertices.length - 1;
                event.stopPropagation();
              }
            }
          }
          state.activeVertexIndex = -1;
          state.candidateEdge = null;
        },
        passiveMove: function(event) {
          const closestPoint = getClosestPoint(event.x, event.y);
          if (closestPoint.index >= 0 && closestPoint.distance < 25) {
            state.hoverVertexIndex = closestPoint.index;
            camera.taint();
            this.setCursor('move');
          } else {
            state.hoverVertexIndex = -1;
            this.setCursor(null);
            camera.taint();
          }
        },
        capturedMove: function(event) {
          //console.log('captured move');
          if (event.insideDeadZone(5)) return;
          exitedDeadZone = true;
          updateViewportSize();
          var projected = vec3create();
          var projectionViewInverse = mat4invert(
            mat4create(),
            camera.projectionView
          );
          camera.taint();
          state.selectedVertexIndex = state.activeVertexIndex;
          var p = graph.vertices[state.selectedVertexIndex];
          vec3transformMat4(projected, p, camera.projectionView);
          projected[0] = (2.0 * event.x) / viewportSize[0] - 1.0;
          projected[1] = 1.0 - (2.0 * event.y) / viewportSize[1];
          vec3transformMat4(p, projected, projectionViewInverse);
        },
        endCapture: function(event) {}
      };
    }
  </script>
  <script id="1541" type="application/vnd.observable.javascript">
    function createCameraTool(state, camera) {
      const graph = state.graph;
      const element = camera.element;
      return {
        keyUp: function(event) {
          switch (event.originalEvent.keyCode) {
            case 65: // a
              if (state.selectedVertexIndex >= 0) {
                const vertex = graph.vertices[state.selectedVertexIndex];
                vec3copy(camera.center, vertex);
                camera.taint();
              } else {
                vec3copy(camera.center, computeCentroid(graph));
                camera.taint();
              }
              break;
          }
        },
        beginPress: function(event) {
          event.capture();
          this.setCursor('grabbing');
        },
        endPress: function(event) {
          if (event.insideDeadZone(5)) {
            state.selectedVertexIndex = -1;
            camera.taint();
          }
        },
        capturedMove: function(event) {
          if (event.originalEvent.shiftKey) {
            camera.pan([
              event.deltaX / element.offsetWidth,
              event.deltaY / element.offsetHeight
            ]);
          } else {
            camera.rotate(
              [
                -(event.previousX / element.offsetWidth - 0.5),
                -(event.previousY / element.offsetHeight - 0.5)
              ],
              [
                -(event.x / element.offsetWidth - 0.5),
                -(event.y / element.offsetHeight - 0.5)
              ]
            );
          }
          camera.taint();
        },
        wheel: function(event) {
          event.originalEvent.preventDefault();
          camera.zoom(event.deltaY * 0.03);
          camera.taint();
        },
        endCapture: function() {
          this.setCursor(null);
        }
      };
    }
  </script>
  <script id="2486" type="application/vnd.observable.javascript">
    md`## Imports`
  </script>
  <script id="13" type="application/vnd.observable.javascript">
    import { button, checkbox, slider, select } from '@jashkenas/inputs'
  </script>
  <script id="677" type="application/vnd.observable.javascript">
    import { mat3fromMat4 } from '@rreusser/gl-mat3'
  </script>
  <script id="21" type="application/vnd.observable.javascript">
    import {
      vec3fromValues,
      vec3dot,
      vec3cross,
      vec3normalize,
      vec3length,
      vec3distance,
      vec3set,
      vec3copy,
      vec3sub,
      vec3scaleAndAdd,
      vec3scale,
      vec3add,
      vec3transformQuat,
      vec3negate,
      vec3transformMat4
    } from '@rreusser/gl-vec3'
  </script>
  <script id="662" type="application/vnd.observable.javascript">
    import {
      quatMultiply,
      quatNormalize,
      quatInvert,
      quatLength,
      quatCreate,
      quatFromMat3,
      quatConjugate
    } from '@rreusser/gl-quat'
  </script>
  <script id="682" type="application/vnd.observable.javascript">
    import {
      mat4lookAt,
      mat4fromRotationTranslation,
      mat4create,
      mat4translate,
      mat4perspective,
      mat4multiply,
      mat4invert
    } from '@rreusser/gl-mat4'
  </script>
  <script id="1034" type="application/vnd.observable.javascript">
    import { vec2length, vec2create } from '@rreusser/gl-vec2'
  </script>
  <script id="1369" type="application/vnd.observable.javascript">
    import { createIcosphere } from '@rreusser/icosphere'
  </script>
  <script id="3409" type="application/vnd.observable.javascript">
    import { tweet } from "@mbostock/tweet"
  </script>
  <script id="1256" type="application/vnd.observable.javascript">
    function vec3create() {
      return [0, 0, 0];
    }
  </script>
  <script id="7" type="application/vnd.observable.javascript">
    createREGL = require('regl')
  </script>
  <script id="978" type="application/vnd.observable.javascript">
    // Retrieved from: https://github.com/mattdesl/mouse-event-offset
    //
    // The MIT License (MIT) Copyright (c) 2014 Matt DesLauriers
    //
    // Permission is hereby granted, free of charge, to any person obtaining a copy
    // of this software and associated documentation files (the "Software"), to deal
    // in the Software without restriction, including without limitation the rights
    // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    // copies of the Software, and to permit persons to whom the Software is
    // furnished to do so, subject to the following conditions:
    //
    // The above copyright notice and this permission notice shall be included in
    // all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    // THE SOFTWARE.
    mouseEventOffset = {
      var rootPosition = { left: 0, top: 0 };

      function mouseEventOffset(ev, target, out) {
        target = target || ev.currentTarget || ev.srcElement;
        if (!Array.isArray(out)) {
          out = [0, 0];
        }
        var cx = ev.clientX || 0;
        var cy = ev.clientY || 0;
        var rect = getBoundingClientOffset(target);
        out[0] = cx - rect.left;
        out[1] = cy - rect.top;
        return out;
      }

      function getBoundingClientOffset(element) {
        if (
          element === window ||
          element === document ||
          element === document.body
        ) {
          return rootPosition;
        } else {
          return element.getBoundingClientRect();
        }
      }
      return mouseEventOffset;
    }
  </script>
  <script id="1372" type="application/vnd.observable.javascript">
    icosphere = createIcosphere(0)
  </script>
  <script id="2469" type="application/vnd.observable.javascript">
    html`
    <style>
    kbd {
      background-color: #eee;
      border-radius: 3px;
      border: 1px solid #b4b4b4;
      box-shadow: 0 1px 1px rgba(0, 0, 0, .2), 0 2px 0 0 rgba(255, 255, 255, .7) inset;
      color: #333;
      display: inline-block;
      font-size: .85em;
      font-weight: 700;
      line-height: 1;
      padding: 2px 4px;
      white-space: nowrap;
    }
    figcaption {
      color: black;
      font-size: 1em;
      font-family: serif;
      font-style: italic;
      margin-top: 1em;
      max-width: 600px;
      text-align: left;
      margin-left: auto;
      margin-right: auto;
      text-align: center;
    }
    figcaption > p {
    display: inline-block;
      max-width: 600px;
      margin: auto;
      text-align: left;
    }
    h2 {
      padding-top: 1em;
    }
    figure {
      padding: 2em 0;
    }
    figure canvas {
      border: 1px solid #eee !important;
    }
    figure img {
      margin-left: auto;
      margin-right: auto;
      display: block;
    }
    </style>
    `
  </script>
  <script id="3878" type="application/vnd.observable.javascript">
    md`## License`
  </script>
  <script id="3873" type="application/vnd.observable.javascript">
    LICENSE = "mit"
    /*
    Copyright (c) 2020 Ricky Reusser

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
    */
  </script>
</notebook>
