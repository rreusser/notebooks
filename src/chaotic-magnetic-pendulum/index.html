<!doctype html>
<notebook theme="air">
  <title>Chaotic Magnetic Pendulum</title>
  <script id="1" type="text/markdown">
    # Chaotic Magnetic Pendulum
  </script>
  <script id="4" type="text/x-typescript">
    const figure = html`<figure>
      ${stack.element}
      <figcaption>Drag points to adjust magnet positions. Use mouse wheel to zoom, drag background to pan.</figcaption>
    </figure>`;

    display(expandable(figure, {
      width: Math.min(width, 640),
      height: Math.min(640, width),
      toggleOffset: [-3, -14],
      onResize(el, w, h) {
        stack.resize(w, h);
        axes.updateScales(
          stack.elements.plot.scale("x"),
          stack.elements.plot.scale("y")
        );
        regl.dirty = true;
      }
    }));
  </script>
  <script id="30" type="text/x-typescript">
    const h = view(Inputs.range([1e-3 * 0, 1], {
      label: "pendulum height, h",
      value: 0.5
    }))
    const b = view(Inputs.range([1e-8, 1], { label: "friction", value: 0.2 }))
    const tolerance = view(Inputs.range([1e-6, 1e-2], {
      transform: Math.log,
      label: "tolerance",
      value: 3e-4
    }))
    const steps = view(Inputs.range([0, 200], {
      label: "integration steps",
      value: 120,
      step: 1
    }))
    const N = view(Inputs.range([2, 10], {
      label: "Magnet count",
      value: 3,
      step: 1
    }))
    const opts = view(Inputs.checkbox([
      "Draw trajectory",
    ], {
      value: ["Draw trajectory"]
    }));
  </script>
  <script id="9" type="text/markdown">
    The plot above represents a top-down view of a chaotic [magnetic pendulum](https://simple.wikipedia.org/wiki/Magnetic_pendulum). The black dots represent attracting magnets. Click and drag to move them. Each point on the plot represents the starting position of a pendulum. A pendulum is released from rest, and a bit of friction ensures it eventually comes to rest at one of the magnets. Color indicates which.
  </script>
  <script id="10" type="text/markdown">
    For two-dimensional position ${tex`\mathbf{x}`}, friction ${tex`b`}, and magnets ${tex`\mathbf{X}_n`}, the pendulum moves according to the equations
  </script>
  <script id="11" type="text/markdown">
    ${tex.block`
    \frac{d^2 \mathbf{x}}{dt^2} + b \frac{d\mathbf{x}}{dt} + \mathbf{x} = \sum_{n=1}^{${N}} \frac{\mathbf{X}_n - x}{\left(|\mathbf{X}_n - \mathbf{x}|^2 + h^2\right)^{5/2}}.
    `}
  </script>
  <script id="12" type="text/markdown">
    Pendulum height ${tex`h`} means the bottom of the pendulum is elevated slightly above the magnets so that it doesn't experience infinite acceleration when it gets close.
  </script>
  <script id="13" type="text/markdown">
    For more information, see [The Magnetic Pendulum](https://chalkdustmagazine.com/features/the-magnetic-pendulum/) or [Gravity Fractals](https://www.youtube.com/watch?v=LavXSS5Xtbg&ab_channel=2swap).
  </script>
  <script id="35" type="text/markdown">
    ## Implementation
  </script>
  <script id="38" type="text/markdown">
    The trajectory when the mouse is moved—corresponding to *one* trajectory—is computed on the CPU, while the colorful background field—corresponding to *every* trajectory—is iterated on the GPU.
  </script>
  <script id="40" type="text/markdown">
    In both formats, the biggest challenge is computing trajectories efficiently. The pendulum may change direction quickly and so needs a small time step, but the pendulum can take a long time to come to a rest. These competing priorities make efficient evaluation essential.
  </script>
  <script id="39" type="text/markdown">
    Both therefore use the adaptive RK4(5) method. The CPU variant is implemented in [@rreusser/integration#ode45](https://observablehq.com/@rreusser/integration#ode45). Adaptive means that the timestep is modified on each step to maximize the step size while controlling the error. This is done through careful construction of the [Runge-Kutta](https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods) method using coefficients of the [Cash-Karp method](https://en.wikipedia.org/wiki/Cash%E2%80%93Karp_method). The coefficients allow the same derivative evaluations to produce both a fifth order and so-called *embedded* fourth order estimate of the next state. The difference between the estimates produces an error estimate, which can subsequently be worked backwards into the timestep required to achieve a specified error threshold.
  </script>
  <script id="50" type="text/markdown">
    To get started, we define the derivative function
  </script>
  <script id="49" type="text/x-typescript">
    const iDeriv = Array.from({length: N}).map((_, i) => i);
    const glslDeriv = `vec4 deriv (vec4 y) {
      vec2 pos = y.xy;
      vec2 vel = y.zw;
      ${iDeriv.map(i => `vec2 r${i} = p${i} - pos;`).join('\n  ')}
      ${iDeriv.map(i => `float d${i} = dot(r${i}, r${i}) + h2;`).join('\n  ')}
      vec2 force = ${iDeriv.map(i => `r${i} / (d${i} * d${i} * sqrt(d${i}))`).join(' +\n               ')};
      return vec4(vel, force - b * vel - pos);
    }`
  </script>
  <script id="55" type="text/markdown">
    ```glsl
    ${glslDeriv}
    ```
  </script>
  <script id="47" type="text/markdown">
    The GLSL variant of `ode45` is reproduced below. It's mostly equivalent to the CPU variant except modified for the limitations of GLSL control flow.
  </script>
  <script id="42" type="text/markdown">
    ```glsl
    const float safety = 0.95;
    const float maxDecrease = 0.02;
    const float maxIncrease = 50.0;

    vec4 ode45 (vec4 y, inout float dt) {
      // Fifth order estimate using constants for the Cash-Karp method
      vec4 k1 = deriv(y);
      vec4 k2 = deriv(y + dt * 0.2 * k1);
      vec4 k3 = deriv(y + dt * (0.075 * k1 + 0.225 * k2));
      vec4 k4 = deriv(y + dt * (0.3 * k1 - 0.9 * k2 + 1.2 * k3));
      vec4 k5 = deriv(y + dt * (
        -0.203703703703703703 * k1 +
        2.5 * k2 -
        2.592592592592592592 * k3 +
        1.296296296296296296 * k4
      ));
      vec4 k6 = deriv(y + dt * (
        0.029495804398148148 * k1 +
        0.341796875 * k2 +
        0.041594328703703703 * k3 +
        0.400345413773148148 * k4 +
        0.061767578125 * k5
      ));

      // Estimate the error using the embedded fourth order method
      vec4 tmp = dt * (
        0.004293774801587301 * k1 -
        0.018668586093857832 * k3 +
        0.034155026830808080 * k4 +
        0.019321986607142857 * k5 -
        0.039102202145680406 * k6
      );
      float err2 = dot(tmp, tmp);

      // Wasteful, but only accept the step if error is within tolerance
      bool accept = err2 <= tol2;
      if (accept) y += dt * (
        0.097883597883597883 * k1 +
        0.402576489533011272 * k3 +
        0.210437710437710437 * k4 +
        0.289102202145680406 * k6
      );

      // Either way, adjust dt according to the estimate
      dt *= clamp(
        safety * pow(tol2 / err2, accept ? 0.125 : 0.1),
        maxDecrease,
        maxIncrease
      );

      return y;
    }
    ```
  </script>
  <script id="48" type="text/markdown">
    Note that if the error threshold is not achieved (that is, if we need to reduce the time step to keep error under control), then we simply throw out the timestep entirely. This is very wasteful! *C'est la vie*.
  </script>
  <script id="43" type="text/markdown">
    Given zero velocity and starting position `xy`, the final iteration loop is reproduced below. We start by packing the state into a `vec4`. We update the state ${steps} times, overwriting the state and mutating `dt` on each step. The iteration is quite straightfoward, but GLSL 1.00 does not permit loop bounds to be computed at runtime, so we have to hard-code the loop extents into the shader.
  </script>
  <script id="45" type="text/markdown">
    ```glsl
    vec4 y = vec4(xy, vec2(0));
    float dt = 0.01;
    for (int i = 0; i < ${steps}; i++) y = ode45(y, dt);
    ```
  </script>
  <script id="52" type="text/markdown">
    The final step is to choose a weighted average of color depending on how close it ends up to each magnet at the end of the integration loop. Has it actually come to a rest? Is it close to any of the magnets? Who knows! Or more specifically, subject to the reasonable limitations of GLSL fragment shaders, we can't really know, so we just do our best and go with it.

    I've chosen a rainbow color palette from [Inigo Quilez](https://iquilezles.org/articles/palettes/) and used a [quasirandom sequence](https://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/) from Martin Roberts to distribute the colors somewhat randomly so that adjacent colors around the unit circle aren't also adjacent around the color wheel.
  </script>
  <script id="67" type="text/x-typescript">
    const iPalette = Array.from({length: N}).map((_, i) => i);
    const glslPalette = `float quasirandom (int n) {
      return fract(0.5 + ${1.0 / 1.6180339887498948482} * float(n));
    }
    vec3 palette(float t) {
      const vec3 a = vec3(0.5, 0.5, 0.5);
      const vec3 b = vec3(0.5, 0.5, 0.5);
      const vec3 c = vec3(1.0, 1.0, 1.0);
      const vec3 d = vec3(0.00, 0.33, 0.67);
      return a + b * cos(6.283185 * (c * t + d));
    }`;
    const glslScheme = `vec3 computeWeightedColor (vec2 y) {
      ${iPalette.map(i => `vec2 r${i} = y - p${i};`).join('\n  ')}
      ${iPalette.map(i => `float w${i} = 1.0 / dot(r${i}, r${i}); w${i} *= w${i};`).join('\n  ')}
      return (
        ${
          iPalette.map(i => {
            const theta = Math.PI * 2 * i / N;
            const a = 0.5 + 0.5 * Math.cos(theta);
            const b = 0.5 + 0.5 * Math.cos(theta + Math.PI * 2 / 3);
            const c = 0.5 + 0.5 * Math.cos(theta + Math.PI * 4 / 3);
            return `w${i} * mix(palette(0.63 + quasirandom(${i})), vec3(0.9), 0.35)`;
          }).join(' +\n    ')
        }
      ) / (${iPalette.map(i => `w${i}`).join(' + ')});
    }`;
  </script>
  <script id="68" type="text/markdown">
    ```glsl
    ${glslPalette}
    ```
  </script>
  <script id="69" type="text/markdown">
    ```glsl
    ${glslScheme}
    ```
  </script>
  <script id="53" type="text/markdown">
    That's it. Once in place, adaptive methods are just great. It's a pretty handy function which you're free to lift and use. (The source is MIT Licensed.) You can view the live notebook [on Observable](https://observablehq.com/@rreusser/magnetic-pendulum).
  </script>
  <script id="7" type="text/x-typescript">
    import createREGL from 'npm:regl'
    import { ode45 } from "observable:@rreusser/integration"
  </script>
  <script id="2" type="text/x-typescript">
    import { createElementStack } from './lib/element-stack.js'
    import { reglElement, reglAxesViewport } from './lib/regl-canvas.js'
    import { createZoomableAxes } from './lib/zoomable-axes.js'
    import { expandable } from './lib/expandable.js'
  </script>
  <script id="29" type="text/x-typescript">
    function createPlot(width, height, xDomain = [-3, 3], yDomain = [-3, 3]) {
      return Plot.plot({
        width,
        height,
        marginTop: 5,
        marginRight: 10,
        marginLeft: 30,
        marginBottom: 20,
        style: { backgroundColor: "transparent", maxWidth: "none", position: "absolute" },
        x: { domain: xDomain, grid: true, tickSpacing: 100 },
        y: { domain: yDomain, grid: true, tickSpacing: 100 }
      });
    }
  </script>
  <script id="5" type="text/x-typescript">
    const stack = createElementStack({
      layers: [{
        id: 'regl',
        element: reglElement(createREGL, {
          attributes: { depthStencil: false, preserveDrawingBuffer: true }
        })
      }, {
        id: 'plot',
        element: ({ width, height }) => createPlot(width, height)
      }, {
        id: 'svg',
        element: ({ current, width, height }) =>
          (current ? d3.select(current) : d3.create("svg"))
            .attr("width", width)
            .attr("height", height)
            .node()
      }]
    });
  </script>
  <script id="8" type="text/x-typescript">
    const axes = createZoomableAxes({
      d3,
      element: stack.elements.svg,
      xScale: stack.elements.plot.scale("x"),
      yScale: stack.elements.plot.scale("y"),
      aspectRatio: 1,
      onChange: ({ xDomain, yDomain }) => {
        regl.dirty = true;
        const newPlot = createPlot(stack.width, stack.height, xDomain, yDomain);
        stack.elements.plot.replaceWith(newPlot);
        stack.elements.plot = newPlot;
        stack.dispatchEvent(new CustomEvent('update'));
      }
    });
  </script>
  <script id="18" type="text/x-typescript">
    const regl = stack.elements.regl.value;
    regl.dirty = true;
  </script>
  <script id="27" type="text/x-typescript">
    const magnets = Array.from({length: N}).map((_, i) => ({
      index: i,
      x: Math.sin(2 * Math.PI * i / N),
      y: Math.cos(2 * Math.PI * i / N)
    }));
  </script>
  <script id="24" type="text/x-typescript">
    function deriv(yp, [x, y, u, v]) {
      let fx = 0.0;
      let fy = 0.0;

      for (let i = 0; i < magnets.length; i++) {
        const dx = magnets[i].x - x;
        const dy = magnets[i].y - y;
        const d = dx * dx + dy * dy + h * h;
        const inv = 1.0 / (d * d * Math.sqrt(d));
        fx += dx * inv;
        fy += dy * inv;
      }

      yp[0] = u;
      yp[1] = v;
      yp[2] = fx - b * u - x;
      yp[3] = fy - b * v - y;
    }
    function computeTrajectory([x, y]) {
      if (!~opts.indexOf("Draw trajectory") || isNaN(x)) return [];
      const state = { y: [x, y, 0, 0], t: 0 };
      const history = [{ x: state.y[0], y: state.y[1] }];
      for (let i = 0; i < 2000 && !state.limitReached; i++) {
        ode45(state, deriv, { tLimit: 50, tolerance: 2e-6 });
        history.push({ x: state.y[0], y: state.y[1] });
      }
      return history;
    };
  </script>
  <script id="26" type="text/x-typescript">
    // SVG interaction for trajectories and magnet controls
    {
      const svg = d3.select(stack.elements.svg);

      // Add clipPath for viewport
      const defs = svg.selectAll('defs').data([0]).join('defs');
      const clipRect = defs.selectAll('clipPath#viewport-clip')
        .data([0])
        .join('clipPath')
        .attr('id', 'viewport-clip')
        .selectAll('rect')
        .data([0])
        .join('rect');

      // Clipped group for content
      const clippedGroup = svg.selectAll('g.clipped')
        .data([0])
        .join('g')
        .attr('class', 'clipped')
        .attr('clip-path', 'url(#viewport-clip)');

      svg.on("mousemove", (event) => {
        updateTrajectory(computeTrajectory([
          axes.xScale.invert(event.offsetX),
          axes.yScale.invert(event.offsetY)
        ]));
      });

      function makeline(data) {
        return d3.line()
          .x(({ x }) => axes.xScale(x))
          .y(({ y }) => axes.yScale(y))(data);
      }

      function updateTrajectory(trajectory) {
        clippedGroup
          .selectAll(".trajectorybg")
          .data([trajectory || []])
          .join(
            (enter) =>
              enter
                .append("path")
                .style("fill", "none")
                .style("stroke-width", 5)
                .style("stroke", "rgba(255,255,255,0.6)")
                .attr("class", "trajectorybg")
                .attr("d", makeline),
            (update) => update.attr("d", makeline)
          );
        clippedGroup
          .selectAll(".trajectory")
          .data([trajectory || []])
          .join(
            (enter) =>
              enter
                .append("path")
                .style("fill", "none")
                .style("stroke-width", 2)
                .style("stroke", "blue")
                .attr("class", "trajectory")
                .attr("d", makeline),
            (update) => update.attr("d", makeline)
          );
      }

      function updatePositions() {
        // Update clip rect to match viewport
        const [x0, x1] = axes.xRange;
        const [y0, y1] = axes.yRange;
        clipRect
          .attr('x', Math.min(x0, x1))
          .attr('y', Math.min(y0, y1))
          .attr('width', Math.abs(x1 - x0))
          .attr('height', Math.abs(y1 - y0));

        clippedGroup.selectAll("circle.magnet")
          .attr("cx", d => axes.xScale(d.x))
          .attr("cy", d => axes.yScale(d.y));
      }

      updateTrajectory([]);
      clippedGroup
        .selectAll("circle.magnet")
        .data(magnets)
        .join(
          (enter) =>
            enter
              .append("circle")
              .attr("class", "magnet")
              .attr("r", 5)
              .style("fill", "black")
              .style("stroke", "white")
              .style("stroke-width", 2)
              .style("cursor", "move")
              .call(
                d3.drag()
                  .subject(function(event, d) {
                    return { x: axes.xScale(d.x), y: axes.yScale(d.y) };
                  })
                  .on('start', function() { d3.select(this).attr('cursor', 'grabbing'); })
                  .on("drag", function(event, d) {
                    d.x = axes.xScale.invert(event.x);
                    d.y = axes.yScale.invert(event.y);
                    updatePositions();
                    regl.dirty = true;
                  })
                  .on('end', function() { d3.select(this).attr('cursor', 'move'); })
              )
        );

      updatePositions();
      stack.addEventListener('update', updatePositions);
    }
  </script>
  <script id="21" type="text/x-typescript">
    const magnetUniforms = {};
    for (let i = 0; i < N; i++) {
      magnetUniforms[`p${i}`] = (_, { magnets }) => [magnets[i].x, magnets[i].y];
    }

    const drawField = regl({
      vert: `
        precision highp float;
        attribute vec2 uv;
        varying vec2 xy;
        uniform mat4 viewInverse;
        void main () {
          xy = (viewInverse * vec4(uv, 0, 1)).xy;
          gl_Position = vec4(uv, 0, 1);
        }`,
      frag: `
        precision highp float;
        varying vec2 xy;
        uniform float h2, b, tol2;
        uniform vec2 ${Object.keys(magnetUniforms).join(', ')};
        uniform bool discardFails;

        ${glslDeriv}

        const float safety = 0.95;
        const float maxDecrease = 0.02;
        const float maxIncrease = 50.0;

        vec4 rk45 (vec4 y, inout float dt) {
          // Fifth order estimate using constants for the Cash-Karp method
          vec4 k1 = deriv(y);
          vec4 k2 = deriv(y + dt * 0.2 * k1);
          vec4 k3 = deriv(y + dt * (0.075 * k1 + 0.225 * k2));
          vec4 k4 = deriv(y + dt * (0.3 * k1 - 0.9 * k2 + 1.2 * k3));
          vec4 k5 = deriv(y + dt * (-0.203703703703703703 * k1 + 2.5 * k2 - 2.592592592592592592 * k3 + 1.296296296296296296 * k4));
          vec4 k6 = deriv(y + dt * (0.029495804398148148 * k1 + 0.341796875 * k2 + 0.041594328703703703 * k3 + 0.400345413773148148 * k4 + 0.061767578125 * k5));

          // Estimate the error using the embedded fourth order method
          vec4 tmp = dt * (0.004293774801587301 * k1 - 0.018668586093857832 * k3 + 0.034155026830808080 * k4 + 0.019321986607142857 * k5 - 0.039102202145680406 * k6);
          float err2 = dot(tmp, tmp);

          // Wasteful, but only accept the step if error is within tolerance
          bool accept = err2 <= tol2;
          if (accept || !discardFails) y += dt * (0.097883597883597883 * k1 + 0.402576489533011272 * k3 + 0.210437710437710437 * k4 + 0.289102202145680406 * k6);

          // Either way, adjust dt according to the estimate
          dt *= clamp(safety * pow(tol2 / err2, accept ? 0.125 : 0.1), maxDecrease, maxIncrease);

          return y;
        }

        ${glslPalette}
        ${glslScheme}

        void main () {
          vec4 y = vec4(xy, vec2(0));
          float dtCurrent = 0.01;
          for (int i = 0; i < ${steps}; i++) y = rk45(y, dtCurrent);
          gl_FragColor = vec4(computeWeightedColor(y.xy), 1);
        }`,
      attributes: {
        uv: [-4, -4, 4, -4, 0, 4]
      },
      uniforms: {
        viewInverse: regl.prop('viewInverse'),
        h2: (_, { h }) => h * h,
        b: regl.prop("b"),
        tol2: (_, { tolerance }) => tolerance * tolerance,
        discardFails: regl.prop('discard'),
        ...magnetUniforms
      },
      depth: { enable: false },
      scissor: { enable: true, box: reglAxesViewport(axes) },
      viewport: reglAxesViewport(axes),
      count: 3
    })
  </script>
  <script id="20" type="text/x-typescript">
    let loop = regl.frame(() => {
      if (!regl.dirty) return;
      try {
        drawField({
          viewInverse: axes.viewInverse,
          h, b, magnets, tolerance,
          discard: !opts.includes('Use steps which exceed tolerance')
        });
        regl.dirty = false;
      } catch (e) {
        console.error(e);
        if (loop) loop.cancel();
        loop = null;
      }
    });
    invalidation.then(() => {
      if (loop) loop.cancel();
      loop = null;
    });
  </script>
  <script id="59" type="text/x-typescript">
    function srgbToLinear(c) {
      return c <= 0.04045
        ? c / 12.92
        : Math.pow((c + 0.055) / 1.055, 2.4);
    }

    function hexToLinearRgb(hex) {
      hex = hex.replace(/^#/, "");
      if (hex.length === 3) {
        hex = hex.split("").map(c => c + c).join("");
      }

      const r = srgbToLinear(parseInt(hex.slice(0, 2), 16) / 255);
      const g = srgbToLinear(parseInt(hex.slice(2, 4), 16) / 255);
      const b = srgbToLinear(parseInt(hex.slice(4, 6), 16) / 255);

      return [r, g, b];
    }
  </script>
  <script id="60" type="text/x-typescript">
    const colorScheme = d3.schemeCategory10.map(hexToLinearRgb).map(([r, g, b]) => `vec3(${r},${g},${b})`);
  </script>
</notebook>
