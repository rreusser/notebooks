<!doctype html>
<notebook theme="air">
  <title>Aligning 3D Scans</title>

  <script id="header" type="text/markdown">
# Aligning 3D Scans
  </script>


  <script id="styles" type="text/html">
    <style>
      figcaption {
        max-width: 350px;
        margin: 0 auto;
        text-align: left;
      }
    </style>
  </script>

  <script id="intro" type="text/markdown">
  *The following is a post I wrote in 2018, when I worked at a now-defunct company called Standard Cyborg. Data was a bit messy, so I had to think through how to automate some pieces like just oriented 3D scans upward. In this post, I worked through what's almost an embarrassing realization that you can end up at [Principal Component Analysis](https://en.wikipedia.org/wiki/Principal_component_analysis) (PCA) from first principles and some algebra. But I was delighted to dig myself in deeper and deeper to some intuitive reasoning that actually led to a simple answer, so I wrote it up and here we are.*

At [Standard Cyborg](https://www.standardcyborg.com), we use 3D scans from a number of different sources to design sockets for prosthetic devices. Even in the best of circumstances in which we're able to keep track of the physical "up" direction from acquisition through to the design phase, "physical up" isn't really a useful direction since the limb could have been in any orientation during scanning (or any orientation *relative to the scanner*). We'd like to automatically orient incoming scans vertically so that they're easy to work with.
  </script>

  <script id="figure1-container" type="text/x-typescript">
    const figure1Container = html`<figure id="figure1">
      <div id="figure1-canvas" style="position: relative; overflow: hidden; width: 100%; max-width: 500px; height: 300px; margin: 0 auto;"></div>
      <figcaption>Not an actual scan of a knee, but the below the knee (BK) scans users process tend to look very similar and tend to enter the system in no particular orientation.</figcaption>
    </figure>`;
    display(figure1Container);
  </script>

  <script id="text-1" type="text/markdown">
Working with 3D models isn't exactly new territory. Before throwing math at this, we should stop to consider whether a nice [arcball camera](https://en.wikibooks.org/wiki/OpenGL_Programming/Modern_OpenGL_Tutorial_Arcball) (or—*shudder*—x/y/z rotation handles!) would allow users to orient scans as they see fit, removing orientation as any concern of ours. We know so much about this problem though! In a broad sense, we know what the scans look like and how users will be modifying them, and we know that even the most grizzled power users find extra degrees of rotational freedom cumbersome and frustrating when they're not required for the task at hand. At the very worst, we find automatic alignment a great preprocessing step that helps users, doesn't hurt what's already arbitrary, and in many cases nails it right away.

The question remains then what alignment could possibly mean. There are an infinite number of valid meanings and corresponding solutions. The solution I describe here only addresses a particular meaning that happens to solve our little micro-problem quite well. It's not new or novel—an alternate title for this article was "In which I discover the ellipsoid!"—and I'm only taking the trouble to describe it because I was so delighted to pick a heuristic out of the sky, find cause to break out some math, and actually end up with a function which runs robustly in a couple milliseconds.

## Choosing an axis

Most of the scans for which people use our software (and limbs in general, really) are basically cylindrical tubes so that the longest axis makes a decent first cut for orienting the scan.
  </script>

  <script id="figure2-container" type="text/x-typescript">
    const figure2Container = html`<figure id="figure2">
      <div id="figure2-canvas" style="position: relative; overflow: hidden; width: 100%; max-width: 500px; height: 400px; margin: 0 auto;"></div>
      <figcaption>Orienting a scan by the longest axis isn't entirely without merit, but it's not very robust.</figcaption>
    </figure>`;
    display(figure2Container);
  </script>

  <script id="text-2" type="text/markdown">
This orientation seems friendlier than what we started with, but it doesn't take long to spot some problems. For one, we haven't said anything about how to actually compute the longest axis ([Principal Component Analysis](https://en.wikipedia.org/wiki/Principal_component_analysis) (PCA) feels relevant?). More importantly though, if the scan had roughly equal proportions, the longest axis would be entirely arbitrary even for a cylinder with plainly obvious orientation.
  </script>

  <script id="figure3-container" type="text/x-typescript">
    const figure3Container = html`<figure id="figure3" style="text-align: center;">
      <div style="display: inline-block; vertical-align: middle;">
        <div id="figure3-canvas" style="position: relative; overflow: hidden; width: 350px; height: 350px;"></div>
      </div>
      <div id="figure3-controls" style="text-align: left; margin-left: auto; margin-right: auto; display: inline-block; min-width: 280px; vertical-align: middle;"></div>
      <figcaption>We'd like it if our algorithm always picked the axis of the cylinder, but the longest axis doesn't accomplish that.</figcaption>
    </figure>`;
    display(figure3Container);
  </script>

  <script id="text-3" type="text/markdown">
Failure of this basic sanity check suggests the overall orientation of these scans isn't so much defined by the position of the surface as by its orientation. Without agonizing over why, I decided a better option would be to select an alignment axis as perpendicular as possible to the surface normals. Hazarding a guess at stating that mathematically, I'd call that the axis which minimizes the sum of the squares of the dot products of the alignment axis with the surface normal vectors.
  </script>

  <script id="figure6-container" type="text/x-typescript">
    const figure6Container = html`<figure id="figure6">
      <div id="figure6-canvas" style="position: relative; overflow: hidden; width: 100%; max-width: 500px; height: 400px; margin: 0 auto;"></div>
      <figcaption>As an educated guess, we instead aim to find an <span style="color:#cc334b">alignment axis</span> as perpendicular as possible to the <span style="color:#384e73">surface normal vectors</span>.</figcaption>
    </figure>`;
    display(figure6Container);
  </script>

  <script id="text-4" type="text/markdown">
## As perpendicular as possible

The statement above is a mouthful which requires a bit of unpacking. If we're going to tackle this as a minimization problem, we at least know we'll need to roll up the ideas above into an objective function.

Let's start with the dot products. Recall the dot product between vectors ${tex`\vec{a}`} and ${tex`\vec{b}`} is equal to
${tex.block`\vec{a} \cdot \vec{b} = a b \cos \theta,`}
where ${tex`a`} and ${tex`b`} are the magnitudes of the two vectors, respectively, and ${tex`\theta`} is the angle between them. All we really need to know here is that if two vectors are perpendicular, their dot product is zero.

We can talk about a single surface normal vector, but somehow we need to aggregate information across all faces. Let's call a surface normal vector of the ${tex`i^{th}`} mesh face ${tex`\vec{n}_i`} and a candidate axis of alignment ${tex`\vec{\xi}`} (the Greek letter "xi", pronounced "*ksee*", which I'm selecting because it's fun to write, isn't likely to get confused with anything, and is fun to call "tornado" instead). My supposition is that if we dot the two, square the result, sum over the faces and call it ${tex`f(\vec{\xi})`}, i.e.
${tex.block`f(\vec{\xi}) = \sum_{i = 1}^{n_{faces}} \left(\vec{\xi} \cdot \vec{n}_i\right)^2,`}
then the best alignment is the one which minimizes ${tex`f(\vec{\xi})`}.

We might have a reasonable objective function here, but to see why it feels like it should work, consider a cylinder. The axis of the cylinder is always perpendicular to the surface normal vectors. Assuming for simplicity that the vectors are all normalized, then the magnitudes drop out and ${tex`f(\vec{\xi}) = \sum \cos^2(90^\circ) = \sum 0 = 0`}. The axis of a cylinder minimizes ${tex`f(\vec{\xi})`} even when it's not the longest axis, thus fixing the failed sanity check above. (If you want to be fancy, I think you could say we're solving the same principal axis problem but in the tangent space instead, though I don't think that interpretation is likely to help most people.)

(Why the square? On a strictly mathematical basis, the dot product may be either positive or negative which would cause the minimization to diverge to ${tex`-\infty`}. The square keeps ${tex`f(\vec{\xi})`} non-negative so that we can meaningfully minimize it.)
  </script>

  <script id="figure4-container" type="text/x-typescript">
    const figure4Container = html`<figure id="figure4">
      <div id="figure4-canvas" style="position: relative; overflow: hidden; width: 100%; max-width: 500px; height: 350px; margin: 0 auto;"></div>
      <figcaption>The surface normal vectors of a cylinder are everywhere perpendicular to its axis so that ${tex`f(\vec{\xi}) = 0`}. A cylinder passes the test!</figcaption>
    </figure>`;
    display(figure4Container);
  </script>

  <script id="text-5" type="text/markdown">
A bit more precisely, if the faces comprising the mesh aren't uniformly distributed, the sum will be biased toward clusters of vertices and their associated normals. Instead of a sum over normal vectors ${tex`\vec{n}_i`}, what we really want is an area-weighted sum. In fact what we *really* want is just an integral over the surface (call it ${tex`S`}) with respect to the differential area vector (call it ${tex`d\vec{A}`}). We define ${tex`d\vec{A} \equiv \vec{n} dA`} as parallel to the surface normal but with magnitude equal to the area of a differential surface element. The continuous limit of ${tex`f(\vec{\xi})`} is then
${tex.block`f(\vec{\xi}) = \int_S \left(\vec{\xi} \cdot d\vec{A}\right)^2.`}

While we're being precise, we assumed implicitly that the axis of alignment was a nonzero vector, but let's now make that explicit in order to avoid the trivial solution ${tex`\vec{\xi} = \vec{0} = (0, 0, 0)`} which *always* minimizes ${tex`f(\vec{\xi}) = 0`}. Constraining ${tex`\vec{\xi}`} to be a unit vector will do just fine.

Fully stating our problem, we want to find the argument ${tex`\vec{\xi}`} which minimizes ${tex`f(\vec{\xi})`} subject to the constraint that ${tex`\vec{\xi}`} is a unit vector:
${tex.block`\begin{array}{l} \begin{array}{c} \phantom{\small{0}} \\ \mathrm{argmin} \\ \small{\vec{\xi} \in \mathbb{R}^3} \end{array} \displaystyle \! \! \int_S \left(\vec{\xi} \cdot d\vec{A}\right)^2 \\ \phantom{\small 0} \\ \;\; \mathrm{subject\;to} \;\; |\vec{\xi}| = 1.\end{array}`}

For piecewise constant faces with surface normal ${tex`d\vec{A}_i`} (magnitude equal to the face's area, recall), we can recast this as a discrete summation and arrive at our final problem statement,
${tex.block`\begin{array}{l} \begin{array}{c} \phantom{\small{0}} \\ \mathrm{argmin} \\ \small{\vec{\xi} \in \mathbb{R}^3} \end{array} \displaystyle \! \! \sum \limits_{i = 1}^{n_{faces}} \left(\xi_x dA_{i, x} + \xi_y dA_{i, y} + \xi_z dA_{i, z}\right)^2 \\ \phantom{\small 0} \\ \;\; \mathrm{subject\; to} \; \xi_x^2 + \xi_y^2 + \xi_z^2 = 1.\end{array}`}

As for the areas, Eric Arnebäck has a nice article about [Computing the Area of a Convex Polygon](https://erkaman.github.io/posts/area_convex_polygon.html). It covers triangles. And for you geometry sorcerers and sorceresses, the answer is yes. We're fitting an ellipsoid now. The rest of the article is me realizing I'm looking for an ellipsoid.

## Computing it

The problem above is a [constrained optimization problem](https://en.wikipedia.org/wiki/Constrained_optimization). Those can be a bit challenging to solve since you often only want to explore the solution space in directions which keep the constraints satisfied. It took me a while to recall, but if I learned one thing about constrained optimization in engineering (sadly I didn't learn much more), I learned that [the method of Lagrange multipliers](https://en.wikipedia.org/wiki/Lagrange_multiplier) exists to transform constrained optimization problems into unconstrained problems. The method works like this. Instead solving the problem
${tex.block`\begin{array}{l}\mathrm{minimize} \; f(\vec{\xi}) \\ \mathrm{subject\;to} \; g(\vec{\xi}) = \vec{0},\end{array}`}
we solve the problem
${tex.block`\mathrm{minimize} \; \mathcal{L}(\vec{\xi}, \lambda) = f(\vec{\xi}) - \lambda \cdot g(\vec{\xi})`}
where ${tex`\lambda`} is an auxiliary parameter (the "Lagrange multiplier") that drives objective function toward satisfying the constraint. With just a bit of handwaving, we can demonstrate that setting the partial derivatives of ${tex`\mathcal{L}`} equal to zero yields
${tex.block`0 = \frac{\partial \mathcal{L}(\vec{\xi}, \lambda)}{\partial \lambda} = - g(\vec{\xi})`}
${tex.block`0 = g(\vec{\xi})`}
which confirms the constraint is satisfied, and
${tex.block`\vec{0} = \nabla \mathcal{L}(\vec{\xi}, \lambda) = \nabla f(\vec{\xi}) - \lambda \nabla g(\vec{\xi})`}
${tex.block`\nabla f(\vec{\xi})  = \lambda \nabla g(\vec{\xi}) = \vec{0},`}
with the final leap of faith equality to zero taken since ${tex`g(\vec{\xi}) = 0`} is a [stationary point](https://en.wikipedia.org/wiki/Stationary_point). This step then enforces the original objective function, though I haven't adequately justified it here. [Wikipedia actually has a pretty good explanation](https://en.wikipedia.org/wiki/Lagrange_multiplier) which I'd be foolish to try to outdo.

It only takes the tiniest modification to state our problem in the canonical form of a Lagrange-multiplier-ready problem,
${tex.block`\begin{array}{l} \begin{array}{c} \phantom{\small{0}} \\ \mathrm{argmin} \\ \small{\vec{\xi} \in \mathbb{R}^3} \end{array} \displaystyle \! \! \sum \limits_{i = 1}^{n_{faces}} \left(\xi_x dA_{i, x} + \xi_y dA_{i, y} + \xi_z dA_{i, z}\right)^2 \\ \phantom{\small 0} \\ \;\; \mathrm{subject\;to} \; g(\vec{\xi}) = \xi_x^2 + \xi_y^2 + \xi_z^2 - 1 = 0.\end{array}`}
Applying the method, we arrive at the unconstrained problem
${tex.block`\begin{array}{c} \phantom{\small{0}} \\ \small{\phantom{0}} \\ \mathrm{argmin} \\ \small{\vec{\xi} \in \mathbb{R}^3} \\ \small{\lambda \in \mathbb{R}} \end{array} \displaystyle \! \! \sum \limits_{i = 1}^{n_{faces}} \left(\xi_x dA_{i, x} + \xi_y dA_{i, y} + \xi_z dA_{i, z}\right)^2 - \lambda(\xi_x^2 + \xi_y^2 + \xi_z^2 - 1).`}

Taking the partial derivatives with respect to ${tex`\xi_x`}, ${tex`\xi_y`}, and ${tex`\xi_z`} as well as ${tex`\lambda`} and equating to zero isn't particularly tedious. The result is a system of four simultaneous equations,
${tex.block`\left\{\begin{array}{l}
0 = \xi_x \sum dA_{i,x} dA_{i,x} + \xi_y \sum dA_{i,y} dA_{i,x} + \xi_z \sum dA_{i,z} dA_{i,x}  - \lambda \xi_x \\
0 = \xi_x \sum dA_{i,x} dA_{i,y} + \xi_y \sum dA_{i,y} dA_{i,y} + \xi_z \sum dA_{i,z} dA_{i,y} - \lambda \xi_y  \\
0 = \xi_x \sum dA_{i,x} dA_{i,z} + \xi_y \sum dA_{i,y} dA_{i,z} + \xi_z \sum dA_{i,z} dA_{i,z} - \lambda \xi_z  \\
0 = \xi_x^2 + \xi_y^2  + \xi_z^2 - 1 \end{array}\right.`}

It suddenly feels hopeless, especially since the fourth equation is a bit nonlinear in ${tex`\vec{\xi}`}. Let's cut down on the visual noise by defining
${tex.block`A_{xy} = \sum \limits_{i = 1}^{n_{faces}} dA_{i, x} dA_{i, y}`}
as well as the analogous definitions for all pairwise combinations of axes. With these definitions, the above equation looks a bit more manageable, yielding
${tex.block`\left\{\begin{array}{l}
0 = \xi_x A_{xx} + \xi_y A_{yx} + \xi_z A_{zx} - \lambda \xi_x \\
0 = \xi_x A_{xy} + \xi_y A_{yy} + \xi_z A_{zy} - \lambda \xi_y \\
0 = \xi_x A_{xz} + \xi_y A_{yz} + \xi_z A_{zz} - \lambda \xi_z \\
0 = \xi_x^2 + \xi_y^2  + \xi_z^2 - 1. \end{array}\right.`}

Neglecting the last equation for a moment, we can state the first three as a matrix multiplication,
${tex.block`
\left[\begin{array}{ccc}
A_{xx} & A_{yx} & A_{zx} \\
A_{xy} & A_{yy} & A_{zy} \\
A_{xz} & A_{yz} & A_{zz} \\
\end{array}\right]
\left[\begin{array}{c}\xi_x \\ \xi_y \\ \xi_z \end{array}\right] = \lambda
\left[\begin{array}{c}\xi_x \\ \xi_y \\ \xi_z \end{array}\right].
`}

This is just the standard form of an [eigenvalue problem](https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors),
${tex.block`\mathbf{A} \vec{\xi} = \lambda \vec{\xi},`}
and what's more, its eigenvectors ${tex`\vec{\xi}`} are normalized by convention, which implicitly satisfies the constraint ${tex`|\vec{\xi}| = 1`}. Eigenvalues are simple and easy to compute, [even in JavaScript](https://github.com/mljs/matrix). We've solved it! Upon solving, we get three eigenvalues and corresponding unit eigenvectors which are identically the model axes and associated inverse strengths along the respective eigenvectors.

As a final bonus, recall—or discover today!—that [the eigenvalues of a symmetric positive-definite matrix are real and orthogonal](https://en.wikipedia.org/wiki/Positive-definite_matrix#Characterizations), i.e. mutually perpendicular. And there are three of them. So we don't just get unit vectors out of this, we get a three dimensional rotation matrix which can be applied directly to the model.

## Does it work?

Wonderfully! Robustly! Efficiently! The only nontrivial numerical part is the eigenvalue computation, but it's only a small 3x3 matrix you can farm out to any old numerical library.

The main caveat is that eigenvalues are only unique up to a sign so that we need to check for reflections and apply some slightly ad-hoc heuristics to disambiguate the sign. In particular, I'm just using the total summed area vector to see if we can put the open end in a consistent direction. There's room for improvement.

You can see the final result below. Note that the two remaining axes also align the knee!

**Update:** Eric Arnebäck [asked about noise](https://twitter.com/erkaman2/status/1024296231508602881). I've added a noise slider below and have removed a square root in the scaling so that the magnitudes are a bit more separated. The noise is not IID noise so take it with a grain of salt, but it hopefully gives some indication of the approach's ability to reject noise.
  </script>

  <script id="figure5-container" type="text/x-typescript">
    const figure5Container = html`<figure id="figure5" style="text-align: center;">
      <div style="display: inline-block; vertical-align: middle;">
        <div id="figure5-canvas" style="position: relative; overflow: hidden; width: 400px; height: 500px;"></div>
      </div>
      <div id="figure5-controls" style="text-align: left; margin-left: auto; margin-right: auto; display: inline-block; min-width: 300px; vertical-align: middle;"></div>
      <figcaption>Adjust the sliders and observe the effect it has upon the computed alignment.</figcaption>
    </figure>`;
    display(figure5Container);
  </script>

  <script id="conclusions" type="text/markdown">
## Conclusions

At the end of the day, I rather suspect I've rederived a pretty standard technique for talking about the shape of a surface. I hope you'll forgive me if my satisfaction isn't diminished though since opportunities to legitimately break out Lagrange multipliers are so rare! And as part of my day job no less.

There's room for improvement in the final disambiguation of signs, but frankly once we've solved the main problem of figuring out a rough alignment, the subsequent algorithms have a significantly easier time making sense of the scan.
  </script>

  <script id="imports" type="text/x-typescript">
    // Vendor bundles (rollup-bundled ESM versions of CJS packages)
    import nurbs from './vendor/nurbs.js'
    import createCamera from './vendor/regl-camera.js'
    import { mat4, vec3 } from './vendor/gl-matrix.js'

    // regl has ESM on npm
    import createREGL from 'npm:regl@2.1.1'

    // Local lib imports
    import { createDrawMesh } from './lib/draw-mesh.js'
    import { createDrawVectors } from './lib/draw-vectors.js'
    import { createDrawNormals } from './lib/draw-normals.js'
    import { unindex, meshNurbsSurface, createBuffers } from './lib/mesh-utils.js'
    import { calculatePrincipalAxesAndCentroid } from './lib/calculate-principal-axes.js'
    import { angleNormals } from './lib/angle-normals.js'

    // Helper to add scroll-based rotation effect
    function addScrollRotation(camera, rotationFactor = 0.0008) {
      let previousScrollPosition = window.scrollY;
      window.addEventListener('scroll', () => {
        const element = camera.element;
        if (!element) return;
        const rect = element.getBoundingClientRect();
        const isOnscreen = rect.top < window.innerHeight && rect.bottom > 0;
        if (isOnscreen) {
          const dScroll = window.scrollY - previousScrollPosition;
          camera.state.dtheta += dScroll * rotationFactor;
          camera.taint();
        }
        previousScrollPosition = window.scrollY;
      });
    }
  </script>

  <script id="figure1-setup" type="text/x-typescript">
    // Figure 1: Basic knee mesh
    figure1Container;
    {
      const container = document.getElementById('figure1-canvas');
      const regl = createREGL({
        container,
        pixelRatio: Math.min(window.devicePixelRatio, 2),
        extensions: ['oes_element_index_uint', 'oes_standard_derivatives'],
        attributes: { antialias: true, preserveDrawingBuffer: true }
      });

      const drawMesh = createDrawMesh(regl);
      const camera = createCamera(regl, {
        center: [0, 0, 0],
        distance: 2.6,
        theta: 1.0,
        phi: 0.6,
        damping: 0,
        noScroll: true,
        noZoom: true,
      });
      addScrollRotation(camera);

      // Create knee-like spline surface
      const spline = nurbs({
        points: [
          {y: -1.0, r1: 1e-4, r2: 1e-4, x: 0.2, rot: -0.2},
          {y: -1.0, r1: 0.45, r2: 0.45, x: 0.2, rot: -0.2},
          {y: -0.3, r1: 0.55, r2: 0.55, x: 0.1, rot: -0.1},
          {y: 0.1, r1: 0.69, r2: 0.65, x: -0.05, rot: 0.0},
          {y: 0.4, r1: 0.75, r2: 0.7, x: 0.05, rot: 0.2},
          {y: 0.8, r1: 0.8, r2: 0.9, x: 0.3, rot: 0.5},
        ].map(s => [
          [s.x + s.r1, s.y - s.rot * s.r1, 0],
          [s.x, s.y, s.r2],
          [s.x - s.r1, s.y + s.rot * s.r1, 0],
          [s.x, s.y, -s.r2]
        ]),
        boundary: ['clamped', 'closed'],
        degree: [3, 4]
      });

      // Apply rotation to randomize orientation
      const m = mat4.create();
      mat4.rotate(m, m, -Math.PI * 0.5, [0, 1, 0]);
      mat4.rotate(m, m, Math.PI, [-1, 1, -0.5]);
      spline.transform(m);

      const surface = meshNurbsSurface({}, spline, {
        computeNormals: true,
        computeUvs: true,
        divisions: [50, 70],
        unwrapV: true,
      }, { vec3 });
      const modelData = createBuffers(regl, unindex(surface), {
        borderWidth: 1.5,
        borderColor: [0.1, 0.2, 0.3, 1.0],
      });

      regl.frame(() => {
        camera(() => {
          regl.clear({ color: [1, 1, 1, 1], depth: 1 });
          drawMesh(modelData);
        });
      });
    }
  </script>

  <script id="figure2-setup" type="text/x-typescript">
    // Figure 2: Knee mesh with longest axis
    figure2Container;
    {
      const container = document.getElementById('figure2-canvas');
      const regl = createREGL({
        container,
        pixelRatio: Math.min(window.devicePixelRatio, 2),
        extensions: ['oes_element_index_uint', 'oes_standard_derivatives', 'angle_instanced_arrays'],
        attributes: { antialias: true, preserveDrawingBuffer: true }
      });

      const drawMesh = createDrawMesh(regl);
      const drawVectors = createDrawVectors(regl);
      const camera = createCamera(regl, {
        center: [0.1, 0.1, 0],
        distance: 4.0,
        theta: 1.0,
        phi: 0.3,
        damping: 0,
        noScroll: true,
        noZoom: true,
      });
      addScrollRotation(camera);

      // Create knee-like spline surface (no rotation - shows natural orientation)
      const spline = nurbs({
        points: [
          {y: -1.0, r1: 1e-4, r2: 1e-4, x: 0.05, rot: -0.2},
          {y: -1.0, r1: 0.45, r2: 0.45, x: 0.05, rot: -0.2},
          {y: -0.3, r1: 0.55, r2: 0.55, x: -0.05, rot: -0.1},
          {y: 0.1, r1: 0.69, r2: 0.65, x: -0.2, rot: 0.0},
          {y: 0.4, r1: 0.75, r2: 0.7, x: -0.1, rot: 0.2},
          {y: 0.8, r1: 0.8, r2: 0.9, x: 0.15, rot: 0.5},
        ].map(s => [
          [s.x + s.r1, s.y - s.rot * s.r1, 0],
          [s.x, s.y, s.r2],
          [s.x - s.r1, s.y + s.rot * s.r1, 0],
          [s.x, s.y, -s.r2]
        ]),
        boundary: ['clamped', 'closed'],
        degree: [3, 4]
      });

      const surface = meshNurbsSurface({}, spline, {
        computeNormals: true,
        computeUvs: true,
        divisions: [50, 70],
        unwrapV: true,
      }, { vec3 });
      const modelData = createBuffers(regl, unindex(surface), {
        borderWidth: 1.5,
        borderColor: [0.1, 0.2, 0.3, 1.0],
      });

      // Vertical axis line (longest axis)
      const axisData = {
        vertices: regl.buffer([
          0.0, -1.4, 0,  0.0, 1.4, 0,
        ]),
        count: 1,
        lineWidth: 2.0,
        lineColor: [0.8, 0.2, 0.3, 1.0],
        arrowheadWidth: 12,
        arrowheadLength: 24,
        depth: true,
      };

      regl.frame(() => {
        camera(() => {
          regl.clear({ color: [1, 1, 1, 1], depth: 1 });
          drawMesh(modelData);
          drawVectors(axisData);
        });
      });
    }
  </script>

  <script id="figure3-setup" type="text/x-typescript">
    // Figure 3: Cylinder with adjustable dimensions
    figure3Container;
    {
      const container = document.getElementById('figure3-canvas');
      const controlsContainer = document.getElementById('figure3-controls');

      // Create sliders (matching original IDL values)
      const lengthInput = Inputs.range([0.1, 1.3], { value: 0.3, step: 0.01, label: "Length" });
      const widthInput = Inputs.range([0.1, 1.3], { value: 0.7, step: 0.01, label: "Width" });
      const depthInput = Inputs.range([0.1, 1.3], { value: 0.5, step: 0.01, label: "Depth" });
      controlsContainer.appendChild(lengthInput);
      controlsContainer.appendChild(widthInput);
      controlsContainer.appendChild(depthInput);

      const regl = createREGL({
        container,
        pixelRatio: Math.min(window.devicePixelRatio, 2),
        extensions: ['oes_element_index_uint', 'oes_standard_derivatives', 'angle_instanced_arrays'],
        attributes: { antialias: true, preserveDrawingBuffer: true }
      });

      const drawMesh = createDrawMesh(regl);
      const drawVectors = createDrawVectors(regl);
      const camera = createCamera(regl, {
        center: [0, 0, 0],
        distance: 2.5,
        theta: 0.8,
        phi: 0.4,
        damping: 0,
        noScroll: true,
        noZoom: true,
      });
      addScrollRotation(camera);

      // Create cylinder spline
      function createCylinderSpline(length, width, depth) {
        return nurbs({
          points: [
            {y: -length * 0.5, r1: width, r2: depth, x: 0.0, rot: 0.0},
            {y: length * 0.5, r1: width, r2: depth, x: 0.0, rot: 0.0},
          ].map(s => [
            [s.x + s.r1, s.y - s.rot * s.r1, 0],
            [s.x, s.y, s.r2],
            [s.x - s.r1, s.y + s.rot * s.r1, 0],
            [s.x, s.y, -s.r2]
          ]),
          boundary: ['clamped', 'closed'],
          degree: [1, 4]
        });
      }

      // Get axis vertices based on which dimension is largest
      function getAxisVertices(length, width, depth) {
        if (length > width && length > depth) {
          return new Float32Array([0, -1, 0,  0, 1, 0]);
        } else if (width > depth) {
          return new Float32Array([-1, 0, 0,  1, 0, 0]);
        } else {
          return new Float32Array([0, 0, -1,  0, 0, 1]);
        }
      }

      let spline = createCylinderSpline(0.3, 0.7, 0.5);
      let surface = meshNurbsSurface({}, spline, {
        computeNormals: true,
        computeUvs: true,
        divisions: [1, 50],
        unwrapV: true,
      }, { vec3 });

      const modelData = createBuffers(regl, unindex(surface), {
        borderWidth: 1.5,
        borderColor: [0.1, 0.2, 0.3, 1.0],
        drawOpenEdges: true,
      });

      const axisBuffer = regl.buffer(getAxisVertices(0.3, 0.7, 0.5));
      const axisData = {
        vertices: axisBuffer,
        count: 1,
        lineWidth: 1.5,
        lineColor: [0.8, 0.2, 0.3, 1.0],
        depth: true,
      };

      // Update function for slider changes
      function updateCylinder() {
        const length = lengthInput.value;
        const width = widthInput.value;
        const depth = depthInput.value;
        spline = createCylinderSpline(length, width, depth);
        surface = meshNurbsSurface(surface, spline, {
          computeNormals: true,
          computeUvs: true,
          divisions: [1, 50],
          unwrapV: true,
        }, { vec3 });
        const unindexed = unindex(surface);
        modelData.vertices(unindexed.vertices);
        modelData.normals(unindexed.normals);
        modelData.uvs(unindexed.uvs);
        axisBuffer(getAxisVertices(length, width, depth));
      }

      // Watch for slider changes
      lengthInput.addEventListener('input', updateCylinder);
      widthInput.addEventListener('input', updateCylinder);
      depthInput.addEventListener('input', updateCylinder);

      regl.frame(() => {
        camera(() => {
          regl.clear({ color: [1, 1, 1, 1], depth: 1 });
          drawMesh(modelData);
          drawVectors(axisData);
        });
      });
    }
  </script>

  <script id="figure4-setup" type="text/x-typescript">
    // Figure 4: Cylinder with surface normals showing perpendicularity to axis
    figure4Container;
    {
      const container = document.getElementById('figure4-canvas');
      const regl = createREGL({
        container,
        pixelRatio: Math.min(window.devicePixelRatio, 2),
        extensions: ['oes_element_index_uint', 'oes_standard_derivatives', 'angle_instanced_arrays'],
        attributes: { antialias: true, preserveDrawingBuffer: true }
      });

      const drawMesh = createDrawMesh(regl);
      const drawVectors = createDrawVectors(regl);
      const drawNormals = createDrawNormals(regl);
      const camera = createCamera(regl, {
        center: [0, 0.2, 0],
        distance: 3.0,
        theta: 0.3 + Math.PI / 2,
        phi: 0.5,
        damping: 0,
        noScroll: true,
        noZoom: true,
      });
      addScrollRotation(camera);

      // Create a short, wide cylinder
      const spline = nurbs({
        points: [
          {y: -0.2, r1: 0.9, r2: 0.9, x: 0.0, rot: 0.0},
          {y: 0.2, r1: 0.9, r2: 0.9, x: 0.0, rot: 0.0},
        ].map(s => [
          [s.x + s.r1, s.y - s.rot * s.r1, 0],
          [s.x, s.y, s.r2],
          [s.x - s.r1, s.y + s.rot * s.r1, 0],
          [s.x, s.y, -s.r2]
        ]),
        boundary: ['clamped', 'closed'],
        degree: [1, 4]
      });

      // Full resolution mesh for rendering
      const surface = meshNurbsSurface({}, spline, {
        computeNormals: true,
        computeUvs: true,
        divisions: [1, 50],
        unwrapV: true,
      }, { vec3 });
      const modelData = createBuffers(regl, unindex(surface), {
        borderWidth: 1.5,
        borderColor: [0.1, 0.2, 0.3, 1.0],
        drawOpenEdges: true,
      });

      // Subsampled mesh for normal visualization
      const subsampledSurface = meshNurbsSurface({}, spline, {
        computeNormals: true,
        divisions: [2, 9],
      }, { vec3 });
      const subsampledData = unindex(subsampledSurface);
      const normalData = {
        vertices: regl.buffer(subsampledData.vertices),
        normals: regl.buffer(subsampledData.normals),
        count: subsampledData.vertices.length / 3,
        lineWidth: 1,
        arrowheadLength: 7,
        arrowheadWidth: 4,
        scale: 0.2,
        lineColor: [0.22, 0.31, 0.45, 1],
      };

      // Vertical axis line
      const axisData = {
        vertices: regl.buffer([0.0, -1.1, 0, 0.0, 1.1, 0]),
        count: 1,
        lineWidth: 2.0,
        lineColor: [0.8, 0.2, 0.3, 1.0],
        arrowheadWidth: 15,
        arrowheadLength: 30,
        depth: true,
      };

      regl.frame(() => {
        camera(() => {
          regl.clear({ color: [1, 1, 1, 1], depth: 1 });
          drawMesh(modelData);
          drawVectors(axisData);
          drawNormals(normalData);
        });
      });
    }
  </script>

  <script id="figure6-setup" type="text/x-typescript">
    // Figure 6: Knee mesh with surface normals showing the alignment concept
    figure6Container;
    {
      const container = document.getElementById('figure6-canvas');
      const regl = createREGL({
        container,
        pixelRatio: Math.min(window.devicePixelRatio, 2),
        extensions: ['oes_element_index_uint', 'oes_standard_derivatives', 'angle_instanced_arrays'],
        attributes: { antialias: true, preserveDrawingBuffer: true }
      });

      const drawMesh = createDrawMesh(regl);
      const drawVectors = createDrawVectors(regl);
      const drawNormals = createDrawNormals(regl);
      const camera = createCamera(regl, {
        center: [0.1, -0.1, 0],
        distance: 4.0,
        theta: 1.0,
        phi: 0.3,
        damping: 0,
        noScroll: true,
        noZoom: true,
      });
      addScrollRotation(camera);

      // Create knee-like spline surface
      const spline = nurbs({
        points: [
          {y: -1.0, r1: 1e-4, r2: 1e-4, x: 0.05, rot: -0.2},
          {y: -1.0, r1: 0.45, r2: 0.45, x: 0.05, rot: -0.2},
          {y: -0.3, r1: 0.55, r2: 0.55, x: -0.05, rot: -0.1},
          {y: 0.1, r1: 0.69, r2: 0.65, x: -0.2, rot: 0.0},
          {y: 0.4, r1: 0.75, r2: 0.7, x: -0.1, rot: 0.2},
          {y: 0.8, r1: 0.8, r2: 0.9, x: 0.15, rot: 0.5},
        ].map(s => [
          [s.x + s.r1, s.y - s.rot * s.r1, 0],
          [s.x, s.y, s.r2],
          [s.x - s.r1, s.y + s.rot * s.r1, 0],
          [s.x, s.y, -s.r2]
        ]),
        boundary: ['clamped', 'closed'],
        degree: [3, 4]
      });

      // Full resolution mesh for rendering
      const surface = meshNurbsSurface({}, spline, {
        computeNormals: true,
        computeUvs: true,
        divisions: [50, 70],
        unwrapV: true,
      }, { vec3 });
      const modelData = createBuffers(regl, unindex(surface), {
        borderWidth: 1.5,
        borderColor: [0.1, 0.2, 0.3, 1.0],
      });

      // Subsampled mesh for normal visualization
      const subsampledSurface = meshNurbsSurface({}, spline, {
        computeNormals: true,
        divisions: [6, 9],
      }, { vec3 });
      const subsampledData = unindex(subsampledSurface);
      const normalData = {
        vertices: regl.buffer(subsampledData.vertices),
        normals: regl.buffer(subsampledData.normals),
        count: subsampledData.vertices.length / 3,
        lineWidth: 1,
        arrowheadLength: 7,
        arrowheadWidth: 4,
        scale: 0.2,
        lineColor: [0.22, 0.31, 0.45, 1],
      };

      // Vertical axis line (alignment axis)
      const axisData = {
        vertices: regl.buffer([0.0, -1.4, 0, 0.0, 1.4, 0]),
        count: 1,
        lineWidth: 2.5,
        lineColor: [0.8, 0.2, 0.3, 1.0],
        arrowheadWidth: 10,
        arrowheadLength: 20,
        depth: true,
      };

      regl.frame(() => {
        camera(() => {
          regl.clear({ color: [1, 1, 1, 1], depth: 1 });
          drawMesh(modelData);
          drawVectors(axisData);
          drawNormals(normalData);
        });
      });
    }
  </script>

  <script id="figure5-setup" type="text/x-typescript">
    // Figure 5: Final result with sliders - computes principal axes
    figure5Container;
    {
      const container = document.getElementById('figure5-canvas');
      const controlsContainer = document.getElementById('figure5-controls');

      // Create sliders (matching original IDL values)
      const curvatureInput = Inputs.range([0.0, 1.0], { value: 0.5, step: 0.01, label: "Curvature" });
      const radiusInput = Inputs.range([0.5, 1.3], { value: 1.0, step: 0.01, label: "Radius" });
      const lengthInput = Inputs.range([0.3, 1.2], { value: 1.0, step: 0.01, label: "Length" });
      const noiseInput = Inputs.range([0.0, 1.0], { value: 0.1, step: 0.01, label: "Noise" });
      controlsContainer.appendChild(curvatureInput);
      controlsContainer.appendChild(radiusInput);
      controlsContainer.appendChild(lengthInput);
      controlsContainer.appendChild(noiseInput);

      const regl = createREGL({
        container,
        pixelRatio: Math.min(window.devicePixelRatio, 2),
        extensions: ['oes_element_index_uint', 'oes_standard_derivatives', 'angle_instanced_arrays'],
        attributes: { antialias: true, preserveDrawingBuffer: true }
      });

      const drawMesh = createDrawMesh(regl);
      const drawVectors = createDrawVectors(regl);
      const camera = createCamera(regl, {
        center: [0.1, 0.1, 0],
        distance: 4.2,
        theta: 0.3 + Math.PI / 2,
        phi: 0.3,
        damping: 0,
        noScroll: true,
        noZoom: true,
      });
      addScrollRotation(camera, -0.0008);

      // Create spline with parameters
      function createSpline(curvature, radius, length) {
        const c = curvature * 1.5 * length;
        return nurbs({
          points: [
            {y: -1.0 * length, r1: 1e-4, r2: 1e-4, x: 0.05 * c, rot: -0.2 * c},
            {y: -1.0 * length, r1: 0.45 * radius, r2: 0.45 * radius, x: 0.05 * c, rot: -0.2 * c},
            {y: -0.3 * length, r1: 0.55 * radius, r2: 0.55 * radius, x: -0.05 * c, rot: -0.1 * c},
            {y: 0.1 * length, r1: 0.69 * radius, r2: 0.65 * radius, x: -0.2 * c, rot: 0.0 * c},
            {y: 0.4 * length, r1: 0.75 * radius, r2: 0.7 * radius, x: -0.1 * c, rot: 0.2 * c},
            {y: 0.8 * length, r1: 0.8 * radius, r2: 0.9 * radius, x: 0.15 * c, rot: 0.5 * c},
          ].map(s => [
            [s.x + s.r1, s.y - s.rot * s.r1, 1e-4],
            [s.x, s.y, s.r2],
            [s.x - s.r1, s.y + s.rot * s.r1, 0],
            [s.x, s.y, -s.r2]
          ]),
          boundary: ['clamped', 'closed'],
          degree: [3, 4]
        });
      }

      // Gaussian random number generator
      function randn() {
        let u = 0, v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
      }

      let spline = createSpline(0.5, 1.0, 1.0);
      let surface = meshNurbsSurface({}, spline, {
        computeNormals: true,
        computeUvs: true,
        divisions: [50, 70],
        unwrapV: false,
      }, { vec3 });

      // Generate noise once
      const noise = new Float32Array(surface.vertices.length);
      for (let i = 0; i < noise.length; i++) {
        noise[i] = randn() * 0.02;
      }

      const modelData = createBuffers(regl, unindex(surface), {
        borderWidth: 1.5,
        borderColor: [0.1, 0.2, 0.3, 1.0],
      });

      // Initialize axes buffer with placeholder
      const axisBuffer = regl.buffer(new Float32Array(18));
      const axisData = {
        vertices: axisBuffer,
        count: 3,
        lineWidth: 1.5,
        lineColor: [0.8, 0.2, 0.3, 1.0],
        depth: true,
      };

      // Update function
      function updateModel() {
        const curvature = curvatureInput.value;
        const radius = radiusInput.value;
        const length = lengthInput.value;
        const noiseAmount = noiseInput.value;

        spline = createSpline(curvature, radius, length);
        surface = meshNurbsSurface(surface, spline, {
          computeNormals: true,
          computeUvs: true,
          divisions: [50, 70],
          unwrapV: false,
        }, { vec3 });

        // Apply noise to vertices
        const verts = new Float32Array(surface.vertices.length);
        for (let i = 0; i < verts.length; i++) {
          verts[i] = surface.vertices[i] + noise[i] * noiseAmount;
        }

        // Recompute normals after noise
        const normals = angleNormals(surface.faces, verts);

        // Set up mesh for principal axes calculation
        const meshForAlign = {
          faces: surface.faces,
          vertices: verts,
          count: surface.faces.length / 3,
        };

        // Calculate principal axes
        const alignment = calculatePrincipalAxesAndCentroid([meshForAlign], { vec3 });
        const m = alignment.matrix;
        const c = alignment.centroid;
        let s0 = Math.pow(alignment.strengths[0], 2);
        let s1 = Math.pow(alignment.strengths[1], 2);
        let s2 = Math.pow(alignment.strengths[2], 2);

        const smax = Math.max(s0, s1, s2);
        s0 *= -1.4 / smax;
        s1 *= -1.4 / smax;
        s2 *= -1.4 / smax;

        // Update axis vertices
        axisBuffer([
          c[0] - m[0] * s0, c[1] - m[1] * s0, c[2] - m[2] * s0,
          c[0] + m[0] * s0, c[1] + m[1] * s0, c[2] + m[2] * s0,
          c[0] - m[4] * s1, c[1] - m[5] * s1, c[2] - m[6] * s1,
          c[0] + m[4] * s1, c[1] + m[5] * s1, c[2] + m[6] * s1,
          c[0] - m[8] * s2, c[1] - m[9] * s2, c[2] - m[10] * s2,
          c[0] + m[8] * s2, c[1] + m[9] * s2, c[2] + m[10] * s2,
        ]);

        // Update model data with noisy vertices and recomputed normals
        const unindexed = unindex({ ...surface, vertices: verts, normals });
        modelData.vertices(unindexed.vertices);
        modelData.normals(unindexed.normals);
        modelData.uvs(unindexed.uvs);
      }

      // Initial update
      updateModel();

      // Watch for slider changes
      curvatureInput.addEventListener('input', updateModel);
      radiusInput.addEventListener('input', updateModel);
      lengthInput.addEventListener('input', updateModel);
      noiseInput.addEventListener('input', updateModel);

      regl.frame(() => {
        camera(() => {
          regl.clear({ color: [1, 1, 1, 1], depth: 1 });
          drawMesh(modelData);
          drawVectors(axisData);
        });
      });
    }
  </script>

</notebook>
