<!doctype html>
<notebook theme="air">
  <title>WebGPU Simple Visualization Test</title>
  <script id="1" type="text/markdown">
    # WebGPU Simple Visualization Test

    Single cell that does everything in order.
  </script>
  <script id="2" type="module">
    import { createWebGPUContext } from './webgpu-context.js';

    console.log('[Step 1] Creating WebGPU context...');
    const context = await createWebGPUContext();
    const device = context.device;
    console.log('[Step 1] ✓ Device created');

    // Cleanup when notebook is closed
    invalidation.then(() => {
      console.log('[Cleanup] Destroying device');
      device.destroy();
    });

    display('hello!');
  </script>
  <script id="3" type="module">
    const N = [256, 256];
  </script>
  <script id="4" type="module">
    const rangeMax = view(Inputs.range([0.1, 2], {
      step: 0.1,
      value: 1.0,
      label: 'Range max'
    }));
  </script>
  <script id="5" type="module">
    import { createSimulationBuffers, destroySimulationBuffers } from './buffers.js';

    console.log('[Step 2] Creating buffers...');
    const buffers = createSimulationBuffers({ N, device });
    console.log('[Step 2] ✓ Buffers created');
  </script>
  <script id="6" type="module">
    import { createKSPipelines } from './pipeline.js';

    console.log('[Step 3] Creating pipelines...');
    const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
    const pipelines = await createKSPipelines(device, canvasFormat);
    console.log('[Step 3] ✓ Pipelines created');
  </script>
  <script id="7" type="module">
    import { performInitialization } from './execute.js';

    console.log('[Step 4] Initializing simulation...');
    const dx = [(2.0 * Math.PI) / N[0], (2.0 * Math.PI) / N[1]];
    const ctx = {
      device,
      pipelines,
      buffers,
      config: { N, dx, dt: 0.18, nu: [0.002418, 0.002418] }
    };
    await performInitialization(ctx, 1);
    console.log('[Step 4] ✓ Initialization complete');
  </script>
  <script id="8" type="module">
    console.log('[Step 5] Setting up canvas...');
    const canvas = html`<canvas width="512" height="512" style="width: 100%; max-width: 512px; height: auto; image-rendering: pixelated;"></canvas>`;
    display(canvas);

    const ctx2d = canvas.getContext('webgpu');
    ctx2d.configure({
      device: device,
      format: canvasFormat
    });
    console.log('[Step 5] ✓ Canvas configured');
  </script>
  <script id="9" type="module">
    console.log('[Step 6] Creating colorscale...');
    function createColorscaleTexture(device, interpolator) {
      const size = 256;
      const colors = d3.quantize(interpolator, size);
      const data = new Uint8Array(size * 4);
      for (let i = 0; i < size; i++) {
        const color = d3.rgb(colors[i]);
        data[i * 4 + 0] = color.r;
        data[i * 4 + 1] = color.g;
        data[i * 4 + 2] = color.b;
        data[i * 4 + 3] = 255;
      }
      const texture = device.createTexture({
        size: [size, 1, 1],
        format: 'rgba8unorm',
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
      });
      device.queue.writeTexture(
        { texture },
        data,
        { bytesPerRow: size * 4 },
        { width: size, height: 1 }
      );
      return texture;
    }

    const colorscaleTexture = createColorscaleTexture(device, d3.interpolateMagma);
    const sampler = device.createSampler({
      magFilter: 'linear',
      minFilter: 'linear',
      addressModeU: 'clamp-to-edge'
    });
    console.log('[Step 6] ✓ Colorscale created');
  </script>
  <script id="10" type="module">
    // Wait for initialization
    ctx;

    console.log('[Step 7] Creating visualization uniform buffer, rangeMax:', rangeMax);
    const visualizeParamsBuffer = device.createBuffer({
      size: 32,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    const visualizeParamsData = new Uint32Array(8);
    visualizeParamsData[0] = N[0];
    visualizeParamsData[1] = N[1];
    new Float32Array(visualizeParamsData.buffer)[2] = 0.0;  // range min
    new Float32Array(visualizeParamsData.buffer)[3] = rangeMax;  // range max
    visualizeParamsData[4] = 0;  // invert
    device.queue.writeBuffer(visualizeParamsBuffer, 0, visualizeParamsData);
    console.log('[Step 7] ✓ Uniform buffer created with rangeMax:', rangeMax);

    // Cleanup this buffer when cell re-runs
    invalidation.then(() => {
      visualizeParamsBuffer.destroy();
    });
  </script>
  <script id="11" type="module">
    console.log('[Step 8] Creating bind group...');
    const visualizeBindGroup = device.createBindGroup({
      layout: pipelines.bindGroupLayouts.visualize,
      entries: [
        { binding: 0, resource: { buffer: buffers.V[0] } },
        { binding: 1, resource: { buffer: visualizeParamsBuffer } },
        { binding: 2, resource: colorscaleTexture.createView() },
        { binding: 3, resource: sampler }
      ]
    });
    console.log('[Step 8] ✓ Bind group created');
  </script>
  <script id="12" type="module">
    console.log('[Step 9] Rendering with rangeMax:', rangeMax);
    const currentTexture = ctx2d.getCurrentTexture();
    const view = currentTexture.createView();

    const encoder = device.createCommandEncoder();
    const pass = encoder.beginRenderPass({
      colorAttachments: [{
        view,
        loadOp: 'clear',
        storeOp: 'store',
        clearValue: { r: 0, g: 0, b: 0, a: 1 }
      }]
    });

    pass.setPipeline(pipelines.visualize);
    pass.setBindGroup(0, visualizeBindGroup);
    pass.draw(3, 1, 0, 0);
    pass.end();

    device.queue.submit([encoder.finish()]);
    console.log('[Step 9] ✓ Render submitted');

    await device.queue.onSubmittedWorkDone();
    console.log('[Step 9] ✓ Render complete');

    console.log('=== ALL STEPS COMPLETE ===');

    // Signal to debug system that notebook is ready
    window.__debugClient?.signalReady();
  </script>
</notebook>
