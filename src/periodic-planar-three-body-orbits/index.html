<!doctype html>
<notebook theme="air">
  <title>Periodic Planar Three-Body Orbits</title>
  <script id="1" type="text/markdown">
    # Periodic Planar Three-Body Orbits
  </script>
  <script id="2" type="text/x-typescript">
    import createREGL from 'npm:regl@2.1.1';
    import createDrawLines from 'npm:regl-gpu-lines@2.4.1';
    import { createElementStack } from './lib/element-stack.js';
    import { reglElement, reglAxesViewport } from './lib/regl-canvas.js';
    import { createZoomableAxes } from './lib/zoomable-axes.js';
    import { expandable } from './lib/expandable.js';

    import {
      planarThreeBodyDerivative,
      computeShape,
      computeFreeGroupWord,
      integrateTrajectory,
      parseInitialConditions,
      decodeHash
    } from './three-body-physics.js';
    import { createInitialConditionsFigure } from './initial-conditions-figure.js';
    import { createJacobiCoordsFigure, computeShapeFromPositions } from './jacobi-coords-figure.js';
    import { createShapeSphere, createOrbitShapeSphere, createIcosphere, getCollisionPoints } from './shape-sphere.js';
    import { createShapeProjection2D, computeProjectedBounds } from './shape-projection.js';
  </script>
  <script id="3" type="text/x-typescript">
    import { ode45 } from 'observable:@rreusser/integration';
    import {
      threeBodyInitialConditions,
      references,
      sequenceUrls
    } from 'observable:@rreusser/periodic-three-body-initial-conditions';
  </script>
  <script id="4" type="text/x-typescript">
    const orbitCount = Object.keys(threeBodyInitialConditions)
      .flatMap(group => Object.keys(threeBodyInitialConditions[group])
        .flatMap(seq => Object.keys(threeBodyInitialConditions[group][seq]).length))
      .reduce((a, b) => a + b, 0);

    display(md`This notebook collects ${orbitCount.toLocaleString()} periodic solutions of the planar [three-body problem](https://en.wikipedia.org/wiki/Three-body_problem) in which three bodies experience mutual gravitational attraction according to [Newton's law of universal gravitation](https://en.wikipedia.org/wiki/Newton%27s_law_of_universal_gravitation), ${tex.block`F=G{\frac {m_{1}m_{2}}{r^{2}}}.`}

    Three-body orbits don't have a closed-form analytical solution and aren't in general periodic, but by reducing the dimensionality of the problem through symmetries and performing a lot of numerical searching, a number of authors have found and published large sets of initial conditions for periodic solutions.`);
  </script>
  <script id="5" type="text/markdown">
    ## Governing equations

    The vector form of Newton's law of gravitation for the force on body 2 exerted by body 1 is ${tex.block`\mathbf{F}_2 = m_2\mathbf{\ddot{x}}_{2} = -\frac{Gm_1m_2(\mathbf{x}_2 - \mathbf{x}_1)}{||\mathbf{x}_2 - \mathbf{x}_1||^3},`} where ${tex`\mathbf{x}_1`} and ${tex`\mathbf{x}_2`} and ${tex`m_1`} and ${tex`m_2`} are the vector positions and masses of bodies ${tex`1`} and ${tex`2`}, respectively, and ${tex`\mathbf{\ddot{x}}_{2}`} is the acceleration of body ${tex`2`}. Given state ${tex`\mathbf{y}`}, we compute the time derivative ${tex`\mathbf{\dot{y}}`}.
  </script>
  <script id="6" type="text/markdown">
    ## Time integration

    Since we only seek to integrate a single period of the orbit, we don't require excessive accuracy and opt for an adaptive Runge-Kutta scheme which adjusts the time step to maintain a specified accuracy. Since the bodies move very slowly when far apart but very quickly when passing by each other, adaptive methods are dramatically more efficient than fixed step methods.

    In particular, we use the [Butcher tableau](https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods#Explicit_Runge.E2.80.93Kutta_methods) of the [Cash-Karp](https://en.wikipedia.org/wiki/Cash–Karp_method) scheme to integrate with fifth order accuracy with a fourth order embedded error estimate. "Embedded" means the same derivative evaluations can be combined differently to produce both fourth and fifth order estimates of the next time step. The difference between the two yields an estimate of the accuracy, which in turn tells how much we should increase or decrease the size of the time step to maintain the same overall accuracy.

    This scheme is adequate for integrating the trajectories with reasonable accuracy and efficiency, but a higher order scheme or more advanced techniques might be worthwhile if we actually wanted to *locate* periodic orbits.

    Please note that essentially *all* periodic, planar, three-body orbits except for some figure eights are unstable! For the convenience of visualization, this notebook tabulates a single period and repeats it. Therefore the orbits on this page repeat infinitely, while actual ongoing time integration would show relatively fast divergence.
  </script>
  <script id="8" type="text/markdown">
    ## Initial conditions
  </script>
  <script id="9" type="text/x-typescript">
    // Initial conditions figure showing bodies with velocity arrows
    (() => {
      if (!initialConditions) return;
      const figure = document.createElement('figure');
      figure.style.maxWidth = '350px';
      figure.style.margin = '0 auto';
      const svg = createInitialConditionsFigure(d3, initialConditions, drawingParams, {
        width: Math.min(width, 350)
      });
      figure.appendChild(svg);
      const caption = document.createElement('figcaption');
      caption.innerHTML = `Initial conditions for the ${initialConditions.name} planar three-body orbit.`;
      figure.appendChild(caption);
      display(figure);
    })();
  </script>
  <script id="11" type="text/x-typescript">
    const selectedConditionsInput = (() => {
      const form = document.createElement('form');
      form.className = 'orbit-selector';

      const hashParts = decodeHash(window.location.hash);
      let currentGroup = hashParts.group || 'Šuvakov';
      let currentSequence = hashParts.sequence || 'III - Yin Yang';
      let currentOrbit = hashParts.orbit || 'III.15.A.β';

      const sequencesByGroup = Object.keys(threeBodyInitialConditions).map(group => ({
        label: group,
        options: Object.keys(threeBodyInitialConditions[group]).map(seq => ({
          label: seq,
          value: `${group}: ${seq}`
        }))
      }));

      const seqLabel = document.createElement('label');
      seqLabel.innerHTML = '<small><em>Sequence</em></small><br>';
      const seqSelect = document.createElement('select');
      seqSelect.name = 'sequence';
      sequencesByGroup.forEach(group => {
        const optgroup = document.createElement('optgroup');
        optgroup.label = group.label;
        group.options.forEach(opt => {
          const option = document.createElement('option');
          option.value = opt.value;
          option.textContent = opt.label;
          if (opt.value === `${currentGroup}: ${currentSequence}`) option.selected = true;
          optgroup.appendChild(option);
        });
        seqSelect.appendChild(optgroup);
      });
      seqLabel.appendChild(seqSelect);

      const orbitLabel = document.createElement('label');
      orbitLabel.innerHTML = '<small><em>Orbit</em></small><br>';
      const orbitSelect = document.createElement('select');
      orbitSelect.name = 'orbit';
      orbitLabel.appendChild(orbitSelect);

      function updateOrbitOptions() {
        orbitSelect.innerHTML = '';
        const orbits = Object.keys(threeBodyInitialConditions[currentGroup]?.[currentSequence] || {});
        orbits.forEach(orbit => {
          const option = document.createElement('option');
          option.value = orbit;
          option.textContent = orbit;
          if (orbit === currentOrbit) option.selected = true;
          orbitSelect.appendChild(option);
        });
        if (!orbits.includes(currentOrbit) && orbits.length > 0) {
          currentOrbit = orbits[0];
          orbitSelect.value = currentOrbit;
        }
      }

      updateOrbitOptions();

      const title = document.createElement('div');
      title.innerHTML = '<strong style="font-size:0.9rem">Initial conditions</strong>';
      form.appendChild(title);

      const container = document.createElement('div');
      container.style.cssText = 'display:flex;gap:1em;flex-wrap:wrap;';
      container.appendChild(seqLabel);
      container.appendChild(orbitLabel);
      form.appendChild(container);

      // Handle sequence changes - rebuild orbit options
      seqSelect.onchange = () => {
        const [group, seq] = seqSelect.value.split(': ');
        currentGroup = group;
        currentSequence = seq;
        updateOrbitOptions();
        currentOrbit = orbitSelect.value;
        form.value = { group: currentGroup, sequence: currentSequence, orbit: currentOrbit };
        form.dispatchEvent(new CustomEvent('input', { bubbles: true }));
      };

      // Handle orbit changes directly
      orbitSelect.onchange = () => {
        currentOrbit = orbitSelect.value;
        form.value = { group: currentGroup, sequence: currentSequence, orbit: currentOrbit };
        form.dispatchEvent(new CustomEvent('input', { bubbles: true }));
      };

      form.value = { group: currentGroup, sequence: currentSequence, orbit: currentOrbit };
      return form;
    })();

    const selectedConditions = Generators.input(selectedConditionsInput);
  </script>
  <script id="902" type="text/markdown">
    The initial conditions in this notebook are obtained from Milovan Šuvakov's [Three-body Gallery](http://three-body.ipb.ac.rs/) as well as from the listing of [Xiaoming Li and Shijun Liao](http://numericaltank.sjtu.edu.cn/three-body/three-body.htm). The initial conditions presented here fall into a few couple categories but all have zero net translational and angular momentum.

    For more information as well as an excellent and approachable overview of the techniques used to locate the orbits, see Šuvakov and Dmitrašinović's [A guide to hunting periodic three-body orbits](https://ui.adsabs.harvard.edu/abs/2014AmJPh..82..609S).
  </script>
  <script id="102" type="text/x-typescript">
    const drawingParams = {
      animate: true,
      lineOpacity: 1.0,
      lineWidth: 2.5,
      lineBorderWidth: 1,
      pointSize: 10,
      speed: 5,
      color: [[0.63, 0.83, 0.18], [0.18, 0.63, 0.83], [0.83, 0.18, 0.63]],
      borderColor: [[1, 1, 1], [1, 1, 1], [1, 1, 1]],
      strokeColor: [[1, 1, 1], [1, 1, 1], [1, 1, 1]]
    };
  </script>
  <script id="12" type="text/x-typescript">
    const initialConditions = (() => {
      const { group, sequence, orbit } = selectedConditions;
      const conditions = threeBodyInitialConditions[group]?.[sequence]?.[orbit];
      return parseInitialConditions(conditions, orbit, drawingParams.color);
    })();
  </script>
  <script id="7" type="text/x-typescript">
    const trajectory = integrateTrajectory(ode45, initialConditions);
  </script>
  <script id="202" type="text/x-typescript">
    const shapeTrajectory = (() => {
      const result = [];
      const masses = initialConditions?.m || [1, 1, 1];
      for (let i = 0; i < trajectory.t.length; i++) {
        result.push(...computeShape(trajectory.position, masses, i));
      }
      return result;
    })();
  </script>
  <script id="204" type="text/x-typescript">
    const freeGroupWord = computeFreeGroupWord(shapeTrajectory);
  </script>
  <script id="101" type="text/x-typescript">
    const controlsContainer = html`<div class="plot-controls">
      <details>
        <summary style="cursor:pointer;font-size:0.85em;color:#666;">Display options</summary>
        <div class="controls-inner" style="padding-top:0.5em;"></div>
      </details>
    </div>`;

    const controlsInner = controlsContainer.querySelector('.controls-inner');
    function ctrl(input) {
      controlsInner.appendChild(input);
      return Generators.input(input);
    }

    const animate = ctrl(Inputs.toggle({ label: 'Animate', value: true }));
    const lineOpacity = ctrl(Inputs.range([0, 1], { label: 'Line opacity', value: 0.7, step: 0.01 }));
    const lineWidth = ctrl(Inputs.range([0.5, 6], { label: 'Line width', value: 2.5, step: 0.1 }));
    const pointSize = ctrl(Inputs.range([4, 20], { label: 'Point size', value: 10, step: 1 }));
    const animSpeed = ctrl(Inputs.range([0.05, 20], { label: 'Speed', value: 5, step: 0.05 }));
  </script>
  <script id="103" type="text/x-typescript">
    drawingParams.animate = animate;
    drawingParams.lineOpacity = lineOpacity;
    drawingParams.lineWidth = lineWidth;
    drawingParams.pointSize = pointSize;
    drawingParams.speed = animSpeed;
    if (stack?.elements?.regl?.value) stack.elements.regl.value.dirty = true;
  </script>
  <script id="104" type="text/x-typescript">
    function createPlot(width, height, xDomain = [-2, 2], yDomain = [-2, 2]) {
      return Plot.plot({
        width,
        height,
        marginTop: 20,
        marginRight: 10,
        marginLeft: 40,
        marginBottom: 20,
        style: { backgroundColor: 'transparent', maxWidth: 'none', position: 'absolute', top: '0', left: '0' },
        x: { domain: xDomain, tickSpacing: 100 },
        y: { domain: yDomain, tickSpacing: 100 },
        marks: [
          Plot.ruleX([0], { stroke: '#0002' }),
          Plot.ruleY([0], { stroke: '#0002' })
        ]
      });
    }
  </script>
  <script id="105" type="text/x-typescript">
    const stack = createElementStack({
      layers: [{
        id: 'regl',
        element: reglElement(createREGL, {
          optionalExtensions: ['ANGLE_instanced_arrays'],
          attributes: { antialias: true, preserveDrawingBuffer: true }
        })
      }, {
        id: 'plot',
        element: ({ width, height }) => createPlot(width, height)
      }, {
        id: 'svg',
        element: ({ current, width, height }) =>
          (current ? d3.select(current) : d3.create("svg"))
            .attr("width", width)
            .attr("height", height)
            .style("position", "absolute")
            .style("top", "0")
            .style("left", "0")
            .node()
      }]
    });
  </script>
  <script id="106" type="text/x-typescript">
    const axes = createZoomableAxes({
      d3,
      element: stack.elements.svg,
      xScale: stack.elements.plot.scale('x'),
      yScale: stack.elements.plot.scale('y'),
      aspectRatio: 1,
      scaleExtent: [0.01, 10000],
      onChange: ({ xDomain, yDomain }) => {
        const newPlot = createPlot(stack.width, stack.height, xDomain, yDomain);
        stack.elements.plot.replaceWith(newPlot);
        stack.elements.plot = newPlot;
        stack.dispatchEvent(new CustomEvent('update'));
        if (stack.elements.regl?.value) stack.elements.regl.value.dirty = true;
      }
    });
  </script>
  <script id="205" type="text/x-typescript">
    display(selectedConditionsInput);
  </script>
  <script id="107" type="text/x-typescript">
    display(expandable(stack.element, {
      width: Math.min(width, 640),
      height: Math.min(480, width * 0.7),
      controls: ['.orbit-selector', '.orbit-metadata', '.plot-controls'],
      onResize(el, w, h) {
        stack.resize(w, h);
        axes.updateScales(stack.elements.plot.scale('x'), stack.elements.plot.scale('y'));
        if (stack.elements.regl?.value) stack.elements.regl.value.dirty = true;
      }
    }));
  </script>
  <script id="904" type="text/x-typescript">
    display(metadataContainer);
  </script>
  <script id="903" type="text/x-typescript">
    display(controlsContainer);
  </script>
  <script id="108" type="text/x-typescript">
    (() => {
      const regl = stack.elements.regl.value;
      if (!regl) return;

      // Create buffer with sentinel values at start and end for proper line caps
      const SENTINEL = 1e10;
      const n = trajectory.t.length;
      const positionsWithSentinels = new Float32Array(9 + trajectory.position.length + 9);
      // Start sentinel
      positionsWithSentinels.fill(SENTINEL, 0, 9);
      // Copy trajectory data
      positionsWithSentinels.set(trajectory.position, 9);
      // End sentinel
      positionsWithSentinels.fill(SENTINEL, 9 + trajectory.position.length);

      const positionsBuffer = regl.buffer(positionsWithSentinels);
      const pointsBufferData = new Float32Array(9);
      const pointsBuffer = regl.buffer(pointsBufferData);

      const drawLines = createDrawLines(regl, {
        vert: `
          precision highp float;

          #pragma lines: attribute vec3 position;
          #pragma lines: position = getPosition(position);
          #pragma lines: width = getWidth();

          uniform mat4 view;
          uniform float timeScale, timeShift;
          uniform float width;

          vec4 getPosition(vec3 p) {
            // Detect sentinel value and return vec4(0) to trigger line cap
            if (p.x > 1e9) return vec4(0);
            return view * vec4(p.xy, (p.z * timeScale - timeShift) * 2.0 - 1.0, 1.0);
          }

          float getWidth() {
            return width;
          }
        `,
        frag: `
          precision highp float;
          varying vec3 lineCoord;
          uniform vec3 color, borderColor;
          uniform float opacity, width, borderWidth;
          void main() {
            float sdf = length(lineCoord.xy) * width;
            vec3 c = mix(color, borderColor, smoothstep(width - borderWidth - 1.0, width - borderWidth + 1.0, sdf));
            gl_FragColor = vec4(c * opacity, opacity);
          }
        `,
        uniforms: {
          view: () => axes.view,
          timeScale: regl.prop('timeScale'),
          timeShift: regl.prop('timeShift'),
          color: regl.prop('color'),
          borderColor: regl.prop('borderColor'),
          opacity: () => drawingParams.lineOpacity,
          width: (ctx) => ctx.pixelRatio * drawingParams.lineWidth,
          borderWidth: (ctx) => ctx.pixelRatio * drawingParams.lineBorderWidth
        },
        depth: { enable: true },
        blend: {
          enable: true,
          func: { src: 'one', dst: 'zero' }
        },
        viewport: reglAxesViewport(axes),
        scissor: { enable: true, box: reglAxesViewport(axes) }
      });

      const drawPoints = regl({
        vert: `
          precision highp float;
          attribute vec3 position;
          uniform mat4 view;
          uniform float pointSize, pixelRatio;
          void main() {
            gl_Position = view * vec4(position.xy, 0, 1);
            gl_PointSize = pointSize * pixelRatio;
          }
        `,
        frag: `
          precision highp float;
          uniform vec3 color, strokeColor;
          void main() {
            float r = length(gl_PointCoord * 2.0 - 1.0);
            if (r > 1.0) discard;
            vec3 c = r > 0.7 ? strokeColor : color;
            gl_FragColor = vec4(c, 1.0);
          }
        `,
        attributes: {
          position: { buffer: pointsBuffer, stride: 12, offset: regl.prop('offset') }
        },
        uniforms: {
          view: () => axes.view,
          pointSize: regl.prop('pointSize'),
          pixelRatio: regl.context('pixelRatio'),
          color: regl.prop('color'),
          strokeColor: regl.prop('strokeColor')
        },
        count: 1,
        primitive: 'points',
        depth: { enable: false },
        viewport: reglAxesViewport(axes),
        scissor: { enable: true, box: reglAxesViewport(axes) }
      });

      function binarySearch(arr, val) {
        let lo = 0, hi = arr.length - 1;
        while (lo < hi) {
          const mid = (lo + hi) >> 1;
          if (arr[mid] < val) lo = mid + 1;
          else hi = mid;
        }
        return Math.max(0, lo - 1);
      }

      regl.dirty = true;

      const frame = regl.frame(ctx => {
        if (!regl.dirty) return;
        regl.dirty = false;

        const tPeriod = trajectory.t[trajectory.t.length - 1];
        // timeShift ranges -1 to 1: at -1 lines are above clip (entering), at 1 below (exiting)
        // When not animating lines, adjust scale/shift to keep z in [-0.999, 0.999] to avoid clip boundary issues
        const clipEps = 0.0005;
        let timeShift, timeScale;
        if (drawingParams.animate) {
          const ts = ctx.time * drawingParams.speed;
          timeShift = ((ts % (tPeriod * 2)) / tPeriod) - 1;
          timeScale = 1 / tPeriod;
        } else {
          timeShift = -clipEps;
          timeScale = (1 - 2 * clipEps) / tPeriod;
        }

        regl.clear({ color: [0, 0, 0, 0], depth: 1 });

        for (let i = 0; i < 3; i++) {
          drawLines({
            join: 'bevel',
            insertCaps: true,
            vertexCount: trajectory.t.length + 2, // +2 for sentinel entries
            vertexAttributes: {
              // offset: 36 bytes for start sentinel + i*12 for each body
              position: { buffer: positionsBuffer, stride: 36, offset: i * 12 }
            },
            timeScale,
            timeShift,
            color: drawingParams.color[i],
            borderColor: drawingParams.borderColor[i]
          });
        }

        const t = trajectory.t;
        const y = trajectory.position;
        // Point position: always animate based on ctx.time, independent of line animation
        const pointTime = (ctx.time * drawingParams.speed) % tPeriod;
        const idx = binarySearch(t, pointTime);
        const idx1 = Math.min(t.length - 1, idx + 1);
        const frac = (pointTime - t[idx]) / (t[idx1] - t[idx] || 1);

        // Always draw animated points
        for (let j = 0; j < 9; j++) {
          pointsBufferData[j] = (1 - frac) * y[idx * 9 + j] + frac * y[idx1 * 9 + j];
        }
        pointsBuffer.subdata(pointsBufferData);

        for (let i = 0; i < 3; i++) {
          drawPoints({
            offset: i * 12,
            pointSize: (initialConditions?.pointSize?.[i] || 1) * drawingParams.pointSize,
            color: drawingParams.color[i],
            strokeColor: drawingParams.strokeColor[i]
          });
        }

        regl.dirty = true; // Always keep animating for points
      });

      invalidation.then(() => frame.cancel());
    })();
  </script>
  <script id="109" type="text/x-typescript">
    const metadataContainer = (() => {
      const { group, sequence, orbit } = selectedConditions;
      const conditions = threeBodyInitialConditions[group]?.[sequence]?.[orbit];
      if (!conditions) return html`<div class="orbit-metadata"></div>`;

      const p = conditions.x;
      const m = conditions.m || [1, 1, 1];
      const ref = references[conditions.ref];
      const isUnequalMass = m[0] !== m[1] || m[0] !== m[2];

      const hashValue = `#group=${encodeURIComponent(group)}&sequence=${encodeURIComponent(sequence)}&orbit=${encodeURIComponent(orbit)}`;
      const seqName = `${group} - ${sequence.replace(/i\.c\./, 'isosceles collinear')}`;

      return html`<div class="orbit-metadata">
        <details open="">
          <summary style="cursor:pointer;font-size:0.85em;color:#666;">Orbit details</summary>
          <div style="border:1px solid #ccc;padding:0 10px;margin-top:0.5em;box-sizing:border-box;max-width:100%;">
            <small><dl class="inline-flex">
              <dt>Sequence</dt><dd><a href="${sequenceUrls[group]?.[sequence] || '#'}">${seqName}${isUnequalMass ? ' (unequal mass)' : ''}</a></dd>
              <dt>Orbit</dt><dd>${conditions.url ? html`<a href="${conditions.url}">${tex`${initialConditions.name}`}</a>` : tex`${initialConditions.name}`}</dd>
              <dt>Initial positions</dt><dd>${tex`((${p[0][0]}, ${p[0][1]}), (${p[1][0]}, ${p[1][1]}), (${p[2][0]}, ${p[2][1]}))`}</dd>
              <dt>Masses</dt><dd>${tex`(${m[0]}, ${m[1]}, ${m[2]})`}</dd>
              <dt>Free group element</dt><dd style="word-break:break-all;">${freeGroupWord}</dd>
              <dt>Period</dt><dd>${conditions.T}</dd>
              <dt>Discovered</dt><dd>${conditions.year}</dd>
              <dt>Reference</dt><dd>${ref.authors}, <em>${ref.title}</em></dd>
              <dt>Share</dt><dd><a href="${hashValue}">link to this orbit</a></dd>
            </dl></small>
          </div>
        </details>
      </div>`;
    })();
  </script>
  <script id="200" type="text/markdown">
    ## Orbit classification

    It'd be fine to stop right here, but the rest of this notebook will try to communicate how we start to talk about classifying the orbits since without some means of classification, we really just have a large puddle of orbits. We'll use the topological approach described by Montgomery in [The N-body problem, the braid group, and action-minimizing periodic solutions](https://ui.adsabs.harvard.edu/abs/1998Nonli..11..363M/abstract), though I've found [the works of Šuvakov, Dmitrašinović, et al.](http://three-body.ipb.ac.rs/ref.php) much more helpful and approachable.

    Since the interesting aspects of a particular orbit are invariant under translation, rotation, and scaling, we seek a representation which removes the uninteresting aspects. We therefore start with a commonly used coordinate system for n-body problems called [*Jacobi coordinates*](https://en.wikipedia.org/wiki/Jacobi_coordinates). To compute Jacobi coordinates, we start with a single body and aggregate the remaining bodies one at a time, computing as each successive Jacobi coordinate the vector from one additional body to the center of mass of the currently aggregated bodies. The final coordinate is the center of mass of the whole system (which we discard since the overall system, at worst, moves with constant velocity).
  </script>
  <script id="201" type="text/markdown">
    ### Shape space

    Jacobi coordinates remove net translation and reduce the degrees of freedom in position from six to four. We can further reduce the dimensionality to two by defining the *shape vector* ${tex.block`
    \begin{aligned}
    \mathbf{n} &= (n_x, n_y, n_z) \\
    &= \left( \frac{2 \mathbf{r}_1 \cdot \mathbf{r}_2}{R^2}, \frac{r_1^2 - r_2^2}{R^2}, \frac{2 (\mathbf{r}_1 \times \mathbf{r}_2) \cdot \mathbf{e}_z}{R^2}\right)
    \end{aligned}
    `} where ${tex`\mathbf{r}_1`} and ${tex`\mathbf{r}_2`} are the Jacobi coordinates, ${tex`\mathbf{e}_z`} is the unit vector along the z-axis, and ${tex`R = \sqrt{r_1^2 + r_2^2}`}. The vector ${tex`\mathbf{n}`} lives on the unit sphere and describes the configuration of the system in a manner invariant to rotation, translation and overall size.

    Move the points below and observe a corresponding behavior on the shape sphere:
    - Pairwise collisions place the shape at one of three points, marked on the shape sphere in red, green, and blue
    - Collinear configurations, called *syzygies*, lie on the equator
  </script>
  <script id="210" type="text/x-typescript">
    // Interactive Jacobi coordinates figure linked to shape sphere
    (() => {
      if (!initialConditions) return;

      // Fixed size, only shrink on narrow screens
      const figWidth = Math.min(width, 480);

      const container = document.createElement('div');
      container.style.display = 'flex';
      container.style.flexDirection = 'column';
      container.style.gap = '20px';

      // Create Jacobi coords figure
      const jacobiW = figWidth;
      const jacobiFig = createJacobiCoordsFigure(d3, initialConditions, drawingParams, {
        width: jacobiW,
        height: jacobiW * 0.7
      });

      const jacobiWrapper = document.createElement('figure');
      jacobiWrapper.style.margin = '0';
      jacobiWrapper.appendChild(jacobiFig.node);
      const jacobiCaption = document.createElement('figcaption');
      jacobiCaption.textContent = 'Jacobi coordinates. Drag the masses to see the effect in shape space.';
      jacobiWrapper.appendChild(jacobiCaption);
      container.appendChild(jacobiWrapper);

      // Create shape sphere canvas
      const sphereW = figWidth;
      const sphereH = sphereW * 0.7;
      const canvas = document.createElement('canvas');
      canvas.id = 'interactive-shape-sphere';
      canvas.width = sphereW * devicePixelRatio;
      canvas.height = sphereH * devicePixelRatio;
      canvas.style.width = `${sphereW}px`;
      canvas.style.height = `${sphereH}px`;
      canvas.style.cursor = 'grab';

      const sphereWrapper = document.createElement('figure');
      sphereWrapper.style.margin = '0';
      sphereWrapper.appendChild(canvas);
      const sphereCaption = document.createElement('figcaption');
      sphereCaption.textContent = 'Shape sphere with collision points. Drag to rotate.';
      sphereWrapper.appendChild(sphereCaption);
      container.appendChild(sphereWrapper);

      // Create regl context and shape sphere
      const sphereRegl = createREGL({ canvas, extensions: ['ANGLE_instanced_arrays', 'OES_standard_derivatives'], attributes: { antialias: true } });
      const shapeSphere = createShapeSphere(sphereRegl, { theta: 0.7, phi: 0.3 });

      // Initialize
      shapeSphere.setPunctures(initialConditions.m);
      shapeSphere.setShape(jacobiFig.getShape());
      shapeSphere.render(sphereW, sphereH);

      // Link Jacobi figure to shape sphere
      jacobiFig.addEventListener('input', () => {
        shapeSphere.setShape(jacobiFig.getShape());
        shapeSphere.render(sphereW, sphereH);
      });

      // Drag to rotate
      let isDragging = false, lastX = 0, lastY = 0;
      canvas.addEventListener('mousedown', e => {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
        canvas.style.cursor = 'grabbing';
      });
      window.addEventListener('mousemove', e => {
        if (!isDragging) return;
        shapeSphere.rotate((e.clientX - lastX) * 0.01, (e.clientY - lastY) * 0.01);
        shapeSphere.render(sphereW, sphereH);
        lastX = e.clientX;
        lastY = e.clientY;
      });
      window.addEventListener('mouseup', () => {
        isDragging = false;
        canvas.style.cursor = 'grab';
      });

      display(container);

      // Cleanup
      invalidation.then(() => {
        shapeSphere.destroy();
        sphereRegl.destroy();
      });
    })();
  </script>
  <script id="211" type="text/markdown">
    We return to the ${tex`${initialConditions?.name || ''}`} orbit and plot it on the shape sphere below.

    Since all orbits here are collision-free, the trajectory meanders about on the surface of the sphere but never passes through any of the three pairwise collision points. In fact we can imagine continuously deforming a trajectory to find similar nearby orbits just as long as we don't ever pass over the collision points and create an invalid orbit. In topology, these forbidden missing points are called *punctures*, and a family of orbits we can obtain through continuous deformation without passing over the punctures corresponds the concept of the [*fundamental group*](https://en.wikipedia.org/wiki/Fundamental_group) from algebraic topology. Algebraic topology is a topic well beyond my expertise, so I'll tread lightly here and not pretend to know more about it.
  </script>
  <script id="212" type="text/x-typescript">
    // Shape sphere with orbit trajectory and stereographic projection
    (() => {
      if (!shapeTrajectory || !initialConditions) return;

      const figWidth = Math.min(width, 480);
      const figHeight = figWidth * 0.8;

      const canvas = document.createElement('canvas');
      canvas.id = 'orbit-shape-sphere';
      canvas.width = figWidth * devicePixelRatio;
      canvas.height = figHeight * devicePixelRatio;
      canvas.style.width = `${figWidth}px`;
      canvas.style.height = `${figHeight}px`;
      canvas.style.cursor = 'grab';

      const figure = document.createElement('figure');
      figure.appendChild(canvas);
      const caption = document.createElement('figcaption');
      caption.innerHTML = `Shape sphere trajectory of the <em>${initialConditions.name}</em> orbit, with the shape sphere turned on its side and projected onto a plane.`;
      figure.appendChild(caption);

      // Create regl and visualization
      const orbitRegl = createREGL({
        canvas,
        attributes: { antialias: true, preserveDrawingBuffer: true },
        extensions: ['ANGLE_instanced_arrays', 'OES_standard_derivatives']
      });
      const orbitSphere = createOrbitShapeSphere(orbitRegl, shapeTrajectory, initialConditions.m, {
        theta: 0.7,
        phi: 0.1
      }, createDrawLines);

      orbitSphere.render(figWidth, figHeight);

      // Drag to rotate
      let isDragging = false, lastX = 0, lastY = 0;
      canvas.addEventListener('mousedown', e => {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
        canvas.style.cursor = 'grabbing';
      });
      window.addEventListener('mousemove', e => {
        if (!isDragging) return;
        orbitSphere.rotate((e.clientX - lastX) * 0.01, (e.clientY - lastY) * 0.01);
        orbitSphere.render(figWidth, figHeight);
        lastX = e.clientX;
        lastY = e.clientY;
      });
      window.addEventListener('mouseup', () => {
        isDragging = false;
        canvas.style.cursor = 'grab';
      });

      display(figure);

      invalidation.then(() => {
        orbitSphere.destroy();
        orbitRegl.destroy();
      });
    })();
  </script>
  <script id="213" type="text/x-typescript">
    // Compute bounds for the shape projection plot
    const projBounds = trajectory && initialConditions
      ? computeProjectedBounds(trajectory, initialConditions.m)
      : { minX: -2, maxX: 2, minY: -2, maxY: 2 };

    // Make bounds square with aspect ratio 1
    const projRangeX = projBounds.maxX - projBounds.minX;
    const projRangeY = projBounds.maxY - projBounds.minY;
    const projRange = Math.max(projRangeX, projRangeY);
    const projCenterX = (projBounds.minX + projBounds.maxX) / 2;
    const projCenterY = (projBounds.minY + projBounds.maxY) / 2;
    const projXDomain = [projCenterX - projRange / 2, projCenterX + projRange / 2];
    const projYDomain = [projCenterY - projRange / 2, projCenterY + projRange / 2];
  </script>
  <script id="214" type="text/x-typescript">
    function createProjPlot(width, height, xDomain = projXDomain, yDomain = projYDomain) {
      return Plot.plot({
        width,
        height,
        marginTop: 20,
        marginRight: 10,
        marginLeft: 50,
        marginBottom: 40,
        style: { backgroundColor: 'transparent', maxWidth: 'none', position: 'absolute', top: '0', left: '0' },
        x: { domain: xDomain, tickSpacing: 80, label: 'n₁ / (1 - n₂)' },
        y: { domain: yDomain, tickSpacing: 80, label: 'n₃ / (1 - n₂)' },
        marks: [
          Plot.ruleX([0], { stroke: '#0002' }),
          Plot.ruleY([0], { stroke: '#0002' })
        ]
      });
    }
  </script>
  <script id="215" type="text/x-typescript">
    const projStack = createElementStack({
      layers: [{
        id: 'regl',
        element: reglElement(createREGL, {
          optionalExtensions: ['ANGLE_instanced_arrays'],
          attributes: { antialias: true, preserveDrawingBuffer: true }
        })
      }, {
        id: 'plot',
        element: ({ width, height }) => createProjPlot(width, height)
      }]
    });
  </script>
  <script id="216" type="text/x-typescript">
    const projAxes = createZoomableAxes({
      d3,
      element: projStack.element,
      xScale: projStack.elements.plot.scale('x'),
      yScale: projStack.elements.plot.scale('y'),
      aspectRatio: 1,
      scaleExtent: [0.1, 100],
      onChange: ({ xDomain, yDomain }) => {
        const newPlot = createProjPlot(projStack.width, projStack.height, xDomain, yDomain);
        projStack.elements.plot.replaceWith(newPlot);
        projStack.elements.plot = newPlot;
        projStack.dispatchEvent(new CustomEvent('update'));
        if (projStack.elements.regl?.value) projStack.elements.regl.value.dirty = true;
      }
    });
  </script>
  <script id="907" type="text/markdown">
    Three dimensional space is still a bit much to work with, so we additionally turn the shape sphere on its side and project the orbit stereographically about one puncture onto a plane below. Two punctures are visible while the third (about which we projected) is removed to infinity.

    The figure below shows the orbit projected into the two-dimensional plane. Two punctures are visible while the the puncture about which we projected is removed to infinity. The shape trajectory now lies in a flat two dimensional plane, looping around the two projected punctures but never passing through them.
  </script>
  <script id="217" type="text/x-typescript">
    const projFigure = document.createElement('figure');
    projFigure.appendChild(projStack.element);
    const projCaption = document.createElement('figcaption');
    projCaption.innerHTML = `Stereographic projection of the shape sphere trajectory. The two visible collision points are marked. The third (blue) is at the pole of projection (infinity).`;
    projFigure.appendChild(projCaption);

    display(expandable(projFigure, {
      width: Math.min(width, 640),
      height: Math.min(400, Math.floor(width * 0.625)),
      onResize(el, w, h) {
        projStack.resize(w, h);
        projAxes.updateScales(projStack.elements.plot.scale('x'), projStack.elements.plot.scale('y'));
        if (projStack.elements.regl?.value) projStack.elements.regl.value.dirty = true;
      }
    }));
  </script>
  <script id="218" type="text/x-typescript">
    // Render the 2D shape projection
    (() => {
      const regl = projStack.elements.regl.value;
      if (!regl || !trajectory || !initialConditions) return;

      const projection = createShapeProjection2D(
        regl,
        trajectory,
        initialConditions.m,
        projAxes,
        reglAxesViewport,
        { speed: drawingParams.speed },
        createDrawLines
      );

      regl.dirty = true;

      const frame = regl.frame(ctx => {
        if (!regl.dirty) return;
        regl.dirty = false;

        projection.render(ctx.time);
        regl.dirty = true; // Keep animating
      });

      invalidation.then(() => {
        frame.cancel();
        projection.destroy();
      });
    })();
  </script>
  <script id="219" type="text/markdown">
    ### Free group word

    From here, our task is conceptually simple. We walk along the projected shape of the orbit and note every time it completes a loop, either clockwise or counterclockwise, around one of the two punctures. The result is a [*free group word*](https://en.wikipedia.org/wiki/Free_group) and (at last!) identifies our orbit in the topological sense. We record an ${tex`a`} for clockwise loops around the righthand puncture and ${tex`a^{-1}`} (which we abbreviate as ${tex`A`}) for counterclockwise loops. Similarly we record ${tex`b`} and ${tex`B`}, respectively, for counterclockwise and clockwise loops around the lefthand puncture.
  </script>
  <script id="220" type="text/x-typescript">
    // Free group elements diagram
    (() => {
      const w = Math.min(width, 350);
      const h = Math.floor(w * 0.7);

      const svg = d3.create('svg')
        .attr('id', 'free-group-elements')
        .attr('width', w)
        .attr('height', h)
        .style('max-width', '100%')
        .style('height', 'auto');

      const lineColor = '#49a1c9';
      const axisColor = '#666';

      // Create arrowheads
      const arrowId = `arrow-fg-${Math.random().toString(36).slice(2)}`;
      const axisArrowId = `arrow-ax-${Math.random().toString(36).slice(2)}`;
      const defs = svg.append('defs');

      defs.append('marker')
        .attr('id', arrowId)
        .attr('viewBox', '0 -5.5 13 11')
        .attr('refX', 12)
        .attr('refY', 0)
        .attr('markerWidth', 13)
        .attr('markerHeight', 11)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M0,-5.5L13,0L0,5.5')
        .attr('fill', lineColor);

      defs.append('marker')
        .attr('id', axisArrowId)
        .attr('viewBox', '0 -4 10 8')
        .attr('refX', 9)
        .attr('refY', 0)
        .attr('markerWidth', 10)
        .attr('markerHeight', 8)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M0,-4L10,0L0,4')
        .attr('fill', axisColor);

      const xrange = 3;
      const axisExtent = 0.9;
      const x = d3.scaleLinear().domain([-xrange, xrange]).range([0, w]);
      const y = d3.scaleLinear().domain([-xrange * h / w, xrange * h / w]).range([h, 0]);
      const line = d3.line().x(d => x(d[0])).y(d => y(d[1]));

      // Axes
      svg.append('g')
        .selectAll('path')
        .data([
          [[-xrange * axisExtent, 0], [xrange * axisExtent, 0]],
          [[0, -xrange * axisExtent * h / w], [0, xrange * axisExtent * h / w]]
        ])
        .join('path')
        .attr('d', line)
        .attr('stroke', axisColor)
        .attr('fill', 'none')
        .attr('stroke-width', 1)
        .attr('marker-start', `url(#${axisArrowId})`)
        .attr('marker-end', `url(#${axisArrowId})`);

      // Circle strokes (white background)
      svg.append('g')
        .selectAll('circle')
        .data([[-1, 0], [1, 0]])
        .join('circle')
        .attr('cx', d => x(d[0]))
        .attr('cy', d => y(d[1]))
        .attr('r', x(1) - x(0))
        .attr('stroke', 'white')
        .attr('stroke-width', 5)
        .attr('fill', 'none');

      // Circles
      svg.append('g')
        .selectAll('circle')
        .data([[-1, 0], [1, 0]])
        .join('circle')
        .attr('cx', d => x(d[0]))
        .attr('cy', d => y(d[1]))
        .attr('r', x(1) - x(0))
        .attr('stroke', lineColor)
        .attr('stroke-width', 2)
        .attr('fill', 'none');

      // Puncture points
      svg.append('g')
        .selectAll('circle')
        .data([[-1, 0], [1, 0]])
        .join('circle')
        .attr('cx', d => x(d[0]))
        .attr('cy', d => y(d[1]))
        .attr('r', 6)
        .attr('fill', (d, i) => i === 0 ? '#e6332a' : '#33cc55')
        .attr('stroke', 'white')
        .attr('stroke-width', 2);

      // Center point
      svg.append('circle')
        .attr('cx', x(0))
        .attr('cy', y(0))
        .attr('r', 4)
        .attr('fill', lineColor);

      // Arrowheads on circles
      svg.append('g')
        .selectAll('path')
        .data([
          [[1, 1], [1.001, 1]],
          [[-1, 1], [-1.001, 1]],
          [[-1, -1], [-0.999, -1]],
          [[1, -1], [0.999, -1]]
        ])
        .join('path')
        .attr('d', line)
        .attr('stroke', lineColor)
        .attr('fill', 'none')
        .attr('stroke-width', 1.5)
        .attr('marker-end', `url(#${arrowId})`);

      // Labels
      svg.append('g')
        .selectAll('text')
        .data([{ xy: [-1, 1], text: 'b' }, { xy: [1, 1], text: 'a' }])
        .join('text')
        .text(d => d.text)
        .attr('x', d => x(d.xy[0]))
        .attr('y', d => y(d.xy[1]))
        .attr('font-size', '17px')
        .attr('font-family', 'serif')
        .attr('font-style', 'italic')
        .attr('dx', -3)
        .attr('dy', -10);

      const figure = document.createElement('figure');
      figure.appendChild(svg.node());
      const caption = document.createElement('figcaption');
      caption.innerHTML = `Our free group elements, <em>a</em> and <em>b</em>.`;
      figure.appendChild(caption);

      display(figure);
    })();
  </script>
  <script id="206" type="text/markdown">
    Though conceptually simple, reading these elements is somewhat tedious. In their paper [A guide to hunting periodic three-body orbits](https://ui.adsabs.harvard.edu/abs/2014AmJPh..82..609S), Šuvakov and Dmitrašinović present a "free group word reading algorithm". Following the algorithm, we track every crossing of the shape sphere equator, which corresponds to collinear configurations (*syzygies*). We track the direction of each crossing and which body is in the middle, then convert the information via a lookup table into the free group word.
  </script>
  <script id="207" type="text/x-typescript">
    display(md`For the ${tex`${initialConditions?.name || ''}`} orbit, we compute the free group word: *<span style="word-break:break-all">${freeGroupWord}</span>*.

    Many patterns lie within. Figure-eight orbits, for example, follow a repeating *BabA* pattern. Other classes of orbits follow more complicated patterns. To preempt an issue you may have noticed, *yes*, there is indeed ambiguity in this classification. We could have chosen one of the other puncture points about which to project. For some families of orbits this makes a difference; for others it does not. Orbits are similarly equivalent under time reversal so that the free group word *Ab* is equivalent to *Ba*. Šuvakov and Dmitrašinović have a much more detailed discussion of these considerations in their paper [Linear stability of periodic three-body orbits with zero angular momentum and topological dependence of Kepler's third law: a numerical test](https://arxiv.org/abs/1705.03728). It's worth a read!`);
  </script>
  <script id="906" type="text/markdown">
    ## Future work
  </script>
  <script id="905" type="text/markdown">

    In a future notebook, I'd love to implement a search algorithm to actually locate periodic orbits. From the abstract of the paper mentioned above, [A guide to hunting periodic three-body orbits](https://ui.adsabs.harvard.edu/abs/2014AmJPh..82..609S),

    > The recent discovery of thirteen new and distinct three-body periodic planar orbits suggests that many more such orbits remain undiscovered. Searches in two-dimensional subspaces of the full four-dimensional space of initial conditions require computing resources that are available to many students, and the required level of computational and numerical expertise is also at the advanced undergraduate level. We discuss the methods for solving the planar three-body equations of motion, as well as some basic strategies and tactics for searches of periodic orbits. Our discussion should allow interested undergraduates to start their own searches. Users can submit new three-body orbits to a wiki-based website.

    The [wiki appears either defunct or in progress](http://www.orbitopedia.org/), but the exploration sounds fun!

    Comments? Question? [Let me know](https://twitter.com/rickyreusser/status/1185354588280348672).
  </script>
  <script id="900" type="text/x-typescript">
    display(html`<style>
      .observablehq dl.inline-flex {
        display: flex;
        flex-flow: row wrap;
        max-width: 640px;
      }
      .observablehq dl.inline-flex dt {
        flex: 0 0 25%;
        min-width: 130px;
        font-weight: 600;
        margin: 0;
      }
      .observablehq dl.inline-flex dd {
        flex: 0 0 75%;
        margin: 0 0 0 auto;
      }
      .orbit-selector select {
        margin-top: 0.25em;
      }
      @media (max-width: 590px) {
        .observablehq dl.inline-flex dt { flex: 0 0 100%; }
        .observablehq dl.inline-flex dd { flex: 0 0 95%; }
      }
    </style>`);
  </script>
</notebook>
