<!doctype html>
<notebook theme="air">
  <title>Sloan Digital Sky Survey</title>
  <script id="intro" type="text/markdown">
# Sloan Digital Sky Survey

This notebook visualizes galaxies from the [Sloan Digital Sky Survey](https://www.sdss.org/) (SDSS). The data spans redshifts from ${tex`z = 0.02`} to ${tex`z = 0.5`}, corresponding to comoving distances from roughly 85 megaparsecs to over 1.9 gigaparsecs. Data loads progressively in chunks, with galaxies appearing as each chunk arrives.

Each point represents a galaxy, colored by its spectroscopic redshift. The color mapping follows the physical intuition of cosmological redshift: nearby galaxies appear blue-white while distant galaxies appear progressively redder. This mirrors how light from distant objects is stretched to longer wavelengths as it travels through expanding space.

The striking filamentary structure you see is the **cosmic web**, the large-scale structure of the universe. Galaxies cluster along dense filaments and sheets surrounding vast, nearly empty voids. This web-like pattern emerges from gravitational instability amplifying tiny density fluctuations in the early universe.
  </script>
  <script id="webgpu-setup" type="module">
import { createWebGPUContext } from './lib/webgpu-canvas.js';

const { device, canvasFormat } = await createWebGPUContext({
  optionalFeatures: ['shader-f16']
});

invalidation.then(() => device.destroy());
  </script>
  <script id="load-data" type="module">
const metadata = await fetch('./galaxies.json').then(r => r.json());

// Decode float16 to float32
function decodeFloat16(uint16) {
  const sign = (uint16 >> 15) & 0x1;
  const exp = (uint16 >> 10) & 0x1f;
  const frac = uint16 & 0x3ff;
  if (exp === 0) {
    return (sign ? -1 : 1) * Math.pow(2, -14) * (frac / 1024);
  } else if (exp === 31) {
    return frac ? NaN : (sign ? -Infinity : Infinity);
  }
  return (sign ? -1 : 1) * Math.pow(2, exp - 15) * (1 + frac / 1024);
}

// Global chunk loader with queue-based concurrency control
const CONCURRENCY = 1;
const NUM_DISTANCE_BINS = 100;
const chunkLoader = {
  queue: [],           // Pending chunk indices
  inFlight: new Set(), // Currently loading
  promises: new Map(), // index -> {promise, resolve, reject}
  chunks: new Array(metadata.chunks.length).fill(null),
  loadedCount: 0,
  // Histogram of galaxy counts by distance (binned by sqrt(x²+y²+z²))
  distanceHistogram: new Uint32Array(NUM_DISTANCE_BINS),
  maxDistance: 0,      // Track max distance seen

  // Request a chunk by index, returns promise that resolves when loaded
  request(index) {
    // Already loaded - return immediately
    if (this.chunks[index]) {
      return Promise.resolve(this.chunks[index]);
    }
    // Already requested - return existing promise
    if (this.promises.has(index)) {
      return this.promises.get(index).promise;
    }
    // Create new promise and queue the request
    let resolve, reject;
    const promise = new Promise((res, rej) => { resolve = res; reject = rej; });
    this.promises.set(index, { promise, resolve, reject });
    this.queue.push(index);
    this.processQueue();
    return promise;
  },

  // Process queue up to concurrency limit
  processQueue() {
    while (this.queue.length > 0 && this.inFlight.size < CONCURRENCY) {
      const index = this.queue.shift();
      if (this.chunks[index] || this.inFlight.has(index)) continue;
      this.inFlight.add(index);
      this.loadChunk(index);
    }
  },

  // Actually fetch and create GPU buffer for a chunk
  async loadChunk(index) {
    const chunkInfo = metadata.chunks[index];
    try {
      const response = await fetch(`./${chunkInfo.file}`);
      const arrayBuffer = await response.arrayBuffer();
      const galaxyData = new Uint16Array(arrayBuffer);

      const buffer = device.createBuffer({
        label: `galaxy-chunk-${index}`,
        size: arrayBuffer.byteLength,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
      });
      device.queue.writeBuffer(buffer, 0, galaxyData);

      // Compute distance histogram from this chunk
      // Data format: float16x4 (x, y, z, redshift_norm) - 4 uint16 per vertex
      const maxDist = Math.max(
        Math.abs(metadata.bounds.min[0]), Math.abs(metadata.bounds.max[0]),
        Math.abs(metadata.bounds.min[1]), Math.abs(metadata.bounds.max[1]),
        Math.abs(metadata.bounds.min[2]), Math.abs(metadata.bounds.max[2])
      ) * 1.5;  // Add some margin
      if (maxDist > this.maxDistance) this.maxDistance = maxDist;

      for (let i = 0; i < galaxyData.length; i += 4) {
        const x = decodeFloat16(galaxyData[i]);
        const y = decodeFloat16(galaxyData[i + 1]);
        const z = decodeFloat16(galaxyData[i + 2]);
        const dist = Math.sqrt(x * x + y * y + z * z);
        const bin = Math.min(NUM_DISTANCE_BINS - 1, Math.floor(dist / maxDist * NUM_DISTANCE_BINS));
        this.distanceHistogram[bin]++;
      }

      const chunk = { buffer, count: chunkInfo.count };
      this.chunks[index] = chunk;
      this.loadedCount += chunk.count;
      this.inFlight.delete(index);

      const { resolve } = this.promises.get(index);
      resolve(chunk);

      renderState.dirty = true;
      console.log(`Loaded chunk ${index + 1}/${metadata.chunks.length}: ${chunk.count.toLocaleString()} galaxies (z=${chunkInfo.redshiftRange[0]}-${chunkInfo.redshiftRange[1]})`);

      // Process more from queue
      this.processQueue();
    } catch (err) {
      this.inFlight.delete(index);
      const { reject } = this.promises.get(index);
      reject(err);
      this.processQueue();
    }
  }
};

// Convenience: request all chunks needed for a given redshift
function loadChunksForRedshift(targetZ) {
  const epsilon = 0.001;  // Tolerance for floating point comparison
  for (let i = 0; i < metadata.chunks.length; i++) {
    const [chunkZMin] = metadata.chunks[i].redshiftRange;
    if (chunkZMin < targetZ - epsilon) {
      chunkLoader.request(i);
    }
  }
}

// Expose loadState for compatibility with progress display
const loadState = {
  get loadedCount() { return chunkLoader.loadedCount; },
  get totalCount() { return metadata.totalCount; },
  get chunks() { return chunkLoader.chunks; },
  get loadingIndices() { return chunkLoader.inFlight; }
};

// Initial load for z <= 0.3
loadChunksForRedshift(0.3);

invalidation.then(() => {
  for (const chunk of chunkLoader.chunks) {
    if (chunk) chunk.buffer.destroy();
  }
});
  </script>
  <script id="main-canvas" type="module">
import { expandable } from './lib/expandable.js';

const dpr = window.devicePixelRatio || 1;
const canvasWidth = Math.min(800, width);
const canvasHeight = Math.max(500, canvasWidth * 0.7);

const canvas = document.createElement('canvas');
canvas.id = 'sdss-canvas';
canvas.width = Math.floor(canvasWidth * dpr);
canvas.height = Math.floor(canvasHeight * dpr);
canvas.style.width = `${canvasWidth}px`;
canvas.style.height = `${canvasHeight}px`;
canvas.style.background = '#000';

const gpuContext = canvas.getContext('webgpu');
gpuContext.configure({
  device,
  format: canvasFormat,
  alphaMode: 'premultiplied'
});

const renderState = { dirty: true };

const figure = html`<figure style="margin: 0;" id="sdss-figure">
  ${canvas}
</figure>`;

display(expandable(figure, {
  width: canvasWidth,
  height: canvasHeight,
  controls: '.sdss-controls',
  onResize(el, w, h) {
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = `${w}px`;
    canvas.style.height = `${h}px`;
    gpuContext.configure({
      device,
      format: canvasFormat,
      alphaMode: 'premultiplied'
    });
    renderState.dirty = true;
  }
}));
  </script>
  <script id="range-slider-import" type="module">
import { rangeSlider, interval } from 'observable:@mootari/range-slider';
  </script>
  <script id="controls" type="module">
const controlsContainer = html`<div class="sdss-controls"></div>`;

function ctrl(input) {
  controlsContainer.appendChild(input);
  return Generators.input(input);
}

const pointSizeInput = Inputs.range([0.5, 8], {
  value: 1,
  label: 'Point size',
  step: 0.1,
  transform: Math.log
});
const pointSize = ctrl(pointSizeInput);

const exposureInput = Inputs.range([0.1, 10], {
  value: 0.6,
  label: 'Exposure',
  step: 0.01,
  transform: Math.log
});
const exposure = ctrl(exposureInput);

const whitePointInput = Inputs.range([1, 50], {
  value: 20,
  label: 'White point',
  step: 1,
});
const whitePoint = ctrl(whitePointInput);

const [zMin, zMax] = metadata.redshiftRange.map(x => +x.toFixed(4));
const redshiftRangeInput = interval([zMin, zMax], {
  value: [zMin, 0.3],  // Start with full min, max at 0.3
  step: 0.01,
  label: 'Redshift (z)'
});
const redshiftRange = ctrl(redshiftRangeInput);

display(controlsContainer);
  </script>
  <script id="cosmic-scale-info" type="module">
// Comoving distance lookup table (Planck18 cosmology)
// z → comoving distance in Mpc
const comovingDistanceTable = [
  [0.00, 0], [0.02, 85], [0.05, 212], [0.10, 421],
  [0.15, 627], [0.20, 828], [0.25, 1025], [0.30, 1219],
  [0.40, 1596], [0.50, 1960], [0.60, 2311], [0.70, 2650],
  [0.80, 2977], [1.00, 3395], [2.00, 5765], [5.00, 8715],
  [10.0, 10000], [1100, 46500]  // CMB / observable universe edge
];

function zToComovingDistance(z) {
  for (let i = 1; i < comovingDistanceTable.length; i++) {
    if (z <= comovingDistanceTable[i][0]) {
      const [z0, d0] = comovingDistanceTable[i - 1];
      const [z1, d1] = comovingDistanceTable[i];
      const t = (z - z0) / (z1 - z0);
      return d0 + t * (d1 - d0);
    }
  }
  return comovingDistanceTable[comovingDistanceTable.length - 1][1];
}

// Lookback time in billions of years (approximate, Planck18)
const lookbackTimeTable = [
  [0.00, 0], [0.02, 0.27], [0.05, 0.67], [0.10, 1.29],
  [0.20, 2.45], [0.30, 3.45], [0.40, 4.32], [0.50, 5.08],
  [0.60, 5.75], [0.70, 6.34], [0.80, 6.87], [1.00, 7.79],
  [2.00, 10.4], [5.00, 12.5], [1100, 13.8]
];

function zToLookbackTime(z) {
  for (let i = 1; i < lookbackTimeTable.length; i++) {
    if (z <= lookbackTimeTable[i][0]) {
      const [z0, t0] = lookbackTimeTable[i - 1];
      const [z1, t1] = lookbackTimeTable[i];
      const t = (z - z0) / (z1 - z0);
      return t0 + t * (t1 - t0);
    }
  }
  return lookbackTimeTable[lookbackTimeTable.length - 1][1];
}

const OBSERVABLE_UNIVERSE_RADIUS = 46500;  // Mpc (comoving)
const UNIVERSE_AGE = 13.8;  // Gyr

// Reactive display
redshiftRange;  // Dependency

const [zLo, zHi] = redshiftRange;
const dLo = zToComovingDistance(zLo);
const dHi = zToComovingDistance(zHi);
const tLo = zToLookbackTime(zLo);
const tHi = zToLookbackTime(zHi);

const volumeFraction = Math.pow(dHi / OBSERVABLE_UNIVERSE_RADIUS, 3) * 100;
const distanceFraction = (dHi / OBSERVABLE_UNIVERSE_RADIUS) * 100;

const formatDist = d => d >= 1000 ? `${(d/1000).toFixed(2)} Gpc` : `${d.toFixed(0)} Mpc`;
const formatTime = t => t.toFixed(2);

display(html`<p style="font-size: 14px; color: #555; line-height: 1.6; max-width: 640px;">
<strong>Current selection:</strong> ${tex`z = ${zLo.toFixed(2)}`} to ${tex`z = ${zHi.toFixed(2)}`}<br>
<strong>Comoving distance:</strong> ${formatDist(dLo)} to ${formatDist(dHi)}<br>
<strong>Lookback time:</strong> ${formatTime(tLo)} to ${formatTime(tHi)} billion years ago<br>
<strong>Cosmic scale:</strong> ${distanceFraction.toFixed(1)}% of the way to the edge of the observable universe (${volumeFraction.toFixed(3)}% by volume)
</p>`);
  </script>
  <script id="lazy-load-trigger" type="module">
// When redshift range changes, trigger loading of additional chunks
redshiftRange;  // Reactive dependency
loadChunksForRedshift(redshiftRange[1]);  // Load based on max value
  </script>
  <script id="loading-progress" type="module">
const progressEl = html`<div style="font-size: 14px; color: #666; margin-top: 8px;"></div>`;
display(progressEl);

let lastLoaded = 0;
let lastLoadingSize = 0;
const updateInterval = setInterval(() => {
  const isLoading = loadState.loadingIndices.size > 0;
  if (loadState.loadedCount !== lastLoaded || loadState.loadingIndices.size !== lastLoadingSize) {
    lastLoaded = loadState.loadedCount;
    lastLoadingSize = loadState.loadingIndices.size;
    if (isLoading) {
      progressEl.textContent = `Loading... ${loadState.loadedCount.toLocaleString()} galaxies loaded`;
    } else {
      progressEl.textContent = `Loaded ${loadState.loadedCount.toLocaleString()} galaxies`;
    }
  }
}, 100);

invalidation.then(() => clearInterval(updateInterval));
  </script>
  <script id="distance-histogram" type="module">
// Reactive plot that updates as chunks load
const histogramContainer = html`<div id="histogram-container"></div>`;
display(histogramContainer);

let lastCount = 0;
const histogramInterval = setInterval(() => {
  if (chunkLoader.loadedCount === lastCount) return;
  lastCount = chunkLoader.loadedCount;

  // Build histogram data array
  const binWidth = chunkLoader.maxDistance / NUM_DISTANCE_BINS;
  const data = Array.from(chunkLoader.distanceHistogram, (count, i) => ({
    distance: (i + 0.5) * binWidth,  // Bin center in Mpc
    count
  })).filter(d => d.count > 0);

  // Clear and redraw
  histogramContainer.innerHTML = '';
  histogramContainer.appendChild(
    Plot.plot({
      width: Math.min(640, width),
      height: 200,
      marginLeft: 60,
      x: {
        label: "Distance (Mpc)",
        tickFormat: d => d >= 1000 ? `${(d/1000).toFixed(1)}k` : d
      },
      y: {
        label: "Galaxy count",
        tickFormat: d => d >= 1000 ? `${(d/1000).toFixed(0)}k` : d
      },
      marks: [
        Plot.rectY(data, {
          x1: d => d.distance - binWidth/2,
          x2: d => d.distance + binWidth/2,
          y: "count",
          fill: "#4a9eff"
        }),
        Plot.ruleY([0])
      ]
    })
  );
}, 200);

invalidation.then(() => clearInterval(histogramInterval));
  </script>
  <script id="camera-setup" type="module">
import { createCameraController } from './lib/camera-controller.js';

const bounds = metadata.bounds;
const dataRange = Math.max(
  bounds.max[0] - bounds.min[0],
  bounds.max[1] - bounds.min[1],
  bounds.max[2] - bounds.min[2]
);

// Earth is at the origin - galaxies radiate outward from us
const center = [0, 0, 0];

// Create camera controller attached to the canvas
const cameraController = createCameraController(canvas, {
  center,
  distance: dataRange * 0.4,
  phi: 1.2,
  theta: 0.0,
  fov: Math.PI / 4,
  near: dataRange * 0.001,
  far: dataRange * 10
});

invalidation.then(() => cameraController.destroy());
  </script>
  <script id="render-pipeline" type="module">
// Shader for rendering galaxy points as instanced quads with additive blending
const shaderCode = /* wgsl */`
struct Uniforms {
  projectionView: mat4x4f,
  pointSize: f32,
  brightness: f32,
  aspectRatio: f32,
  cameraDistance: f32,
  referenceDistance: f32,
  referencePointSize: f32,
  minRedshiftNorm: f32,
  maxRedshiftNorm: f32,
  dataZMin: f32,       // Actual z range of the data (for denormalizing)
  dataZMax: f32,
  _pad: vec2f,
}

@group(0) @binding(0) var<uniform> uniforms: Uniforms;

struct VertexOutput {
  @builtin(position) position: vec4f,
  @location(0) redshift: f32,
  @location(1) uv: vec2f,
}

// Quad vertices for triangle strip: 4 vertices make a quad
const quadVertices = array<vec2f, 4>(
  vec2f(-1.0, -1.0),
  vec2f( 1.0, -1.0),
  vec2f(-1.0,  1.0),
  vec2f( 1.0,  1.0)
);

@vertex
fn vertexMain(
  @builtin(vertex_index) vertexIndex: u32,
  // Instance data: float16x4 (x, y, z, normalized_redshift)
  @location(0) instanceData: vec4<f32>
) -> VertexOutput {
  var output: VertexOutput;

  // Get quad corner from vertex index
  let corner = quadVertices[vertexIndex];

  // Transform galaxy position to clip space
  let worldPos = vec4f(instanceData.xyz, 1.0);
  let clipPos = uniforms.projectionView * worldPos;

  // Expand quad in screen space (size in pixels)
  let size = uniforms.pointSize / vec2f(uniforms.aspectRatio, 1.0);
  let offset = corner * size * clipPos.w * 0.001;

  output.position = clipPos + vec4f(offset, 0.0, 0.0);
  output.redshift = instanceData.w;
  output.uv = corner;

  return output;
}

// Color by absolute redshift value (not normalized storage value)
// Uses a fixed scale: z=0 is blue-white, z=1.0 is deep red
fn redshiftColor(zNorm: f32) -> vec3f {
  // Denormalize to get actual redshift value
  let z = uniforms.dataZMin + zNorm * (uniforms.dataZMax - uniforms.dataZMin);

  // Map z to color using fixed scale (z=0 to z=1.0)
  // This ensures same physical redshift always gets same color
  let t = clamp(z, 0.0, 1.0);

  // Blue-white to red gradient
  let blue = vec3f(0.7, 0.85, 1.0);   // Nearby: blue-white
  let red = vec3f(1.0, 0.2, 0.05);    // Distant: deep red

  // Use a power curve for more dramatic color separation
  let curve = pow(t, 0.7);

  return mix(blue, red, curve);
}

@fragment
fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {
  // Filter by redshift range
  if (input.redshift < uniforms.minRedshiftNorm || input.redshift > uniforms.maxRedshiftNorm) {
    discard;
  }

  // Circular falloff from center of point
  let dist = length(input.uv);
  if (dist > 1.0) {
    discard;
  }

  // Soft gaussian-like falloff for nice glow effect
  let falloff = exp(-dist * dist * 2.0);

  // Scale brightness by camera distance to maintain perceived brightness when zooming
  // As we zoom out, points become denser on screen, so reduce brightness to compensate
  // Use gamma-aware scaling: perceived brightness ~ luminance^(1/gamma)
  let distanceRatio = uniforms.cameraDistance / uniforms.referenceDistance;
  let distanceScale = pow(distanceRatio, -0.9);  // Inverse: dimmer when zoomed out

  // Compensate for point size: use linear scaling rather than area (size²)
  // because the gaussian falloff concentrates perceived brightness at the center
  let sizeRatio = uniforms.pointSize / uniforms.referencePointSize;
  let sizeScale = 1.0 / sizeRatio;

  let color = redshiftColor(input.redshift);
  let intensity = uniforms.brightness * falloff * distanceScale * sizeScale;

  return vec4f(color * intensity, intensity);
}
`;

const shaderModule = device.createShaderModule({
  label: 'galaxy-shader',
  code: shaderCode
});

const uniformBuffer = device.createBuffer({
  label: 'galaxy-uniforms',
  size: 112, // mat4x4f (64) + 10 floats (40) + vec2f pad (8)
  usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
});

const bindGroupLayout = device.createBindGroupLayout({
  entries: [{
    binding: 0,
    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
    buffer: { type: 'uniform' }
  }]
});

const bindGroup = device.createBindGroup({
  layout: bindGroupLayout,
  entries: [{
    binding: 0,
    resource: { buffer: uniformBuffer }
  }]
});

const pipelineLayout = device.createPipelineLayout({
  bindGroupLayouts: [bindGroupLayout]
});

const pipeline = device.createRenderPipeline({
  label: 'galaxy-pipeline',
  layout: pipelineLayout,
  vertex: {
    module: shaderModule,
    entryPoint: 'vertexMain',
    buffers: [{
      // Instance buffer: one entry per galaxy
      arrayStride: 8, // 4 x float16
      stepMode: 'instance',
      attributes: [{
        shaderLocation: 0,
        offset: 0,
        format: 'float16x4'
      }]
    }]
  },
  fragment: {
    module: shaderModule,
    entryPoint: 'fragmentMain',
    targets: [{
      format: 'rgba16float',  // Render to HDR texture
      blend: {
        // Additive blending for overlapping points
        color: {
          srcFactor: 'src-alpha',
          dstFactor: 'one',
          operation: 'add'
        },
        alpha: {
          srcFactor: 'one',
          dstFactor: 'one',
          operation: 'add'
        }
      }
    }]
  },
  primitive: {
    topology: 'triangle-strip'
  }
});

// Tonemap shader with extended Reinhard and exposure control
const tonemapShaderCode = /* wgsl */`
@group(0) @binding(0) var hdrTexture: texture_2d<f32>;
@group(0) @binding(1) var texSampler: sampler;
@group(0) @binding(2) var<uniform> tonemapParams: vec4f;  // x=exposure, y=whitePoint

struct VertexOutput {
  @builtin(position) position: vec4f,
  @location(0) uv: vec2f,
}

@vertex
fn vertexMain(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {
  // Fullscreen triangle
  var pos = array<vec2f, 3>(
    vec2f(-1.0, -1.0),
    vec2f( 3.0, -1.0),
    vec2f(-1.0,  3.0)
  );
  var output: VertexOutput;
  output.position = vec4f(pos[vertexIndex], 0.0, 1.0);
  output.uv = (pos[vertexIndex] + 1.0) * 0.5;
  output.uv.y = 1.0 - output.uv.y;  // Flip Y for texture coordinates
  return output;
}

// Extended Reinhard tonemap on scalar: x * (1 + x/white²) / (1 + x)
fn reinhardExtendedLuminance(x: f32, white: f32) -> f32 {
  let white2 = white * white;
  return x * (1.0 + x / white2) / (1.0 + x);
}

@fragment
fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {
  let hdr = textureSample(hdrTexture, texSampler, input.uv);

  let exposure = tonemapParams.x;
  let whitePoint = tonemapParams.y;

  // Apply exposure
  let exposed = hdr.rgb * exposure;

  // Compute luminance (Rec. 709 coefficients)
  let luminance = dot(exposed, vec3f(0.2126, 0.7152, 0.0722));

  // Tonemap luminance only, then scale color to preserve saturation
  let tonemappedLum = reinhardExtendedLuminance(luminance, whitePoint);
  let scale = select(tonemappedLum / luminance, 0.0, luminance < 0.0001);
  let ldr = exposed * scale;

  return vec4f(ldr, 1.0);
}
`;

const tonemapShaderModule = device.createShaderModule({
  label: 'tonemap-shader',
  code: tonemapShaderCode
});

const tonemapUniformBuffer = device.createBuffer({
  label: 'tonemap-uniforms',
  size: 16,  // vec4f
  usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
});

const tonemapBindGroupLayout = device.createBindGroupLayout({
  entries: [
    { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'float' } },
    { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: { type: 'filtering' } },
    { binding: 2, visibility: GPUShaderStage.FRAGMENT, buffer: { type: 'uniform' } }
  ]
});

const tonemapPipelineLayout = device.createPipelineLayout({
  bindGroupLayouts: [tonemapBindGroupLayout]
});

const tonemapPipeline = device.createRenderPipeline({
  label: 'tonemap-pipeline',
  layout: tonemapPipelineLayout,
  vertex: {
    module: tonemapShaderModule,
    entryPoint: 'vertexMain'
  },
  fragment: {
    module: tonemapShaderModule,
    entryPoint: 'fragmentMain',
    targets: [{ format: canvasFormat }]
  },
  primitive: {
    topology: 'triangle-list'
  }
});

const hdrSampler = device.createSampler({
  magFilter: 'linear',
  minFilter: 'linear'
});

// HDR texture state - will be created/resized in render loop
const hdrState = {
  texture: null,
  bindGroup: null,
  width: 0,
  height: 0
};

function ensureHdrTexture(width, height) {
  if (hdrState.width === width && hdrState.height === height && hdrState.texture) {
    return;
  }

  if (hdrState.texture) {
    hdrState.texture.destroy();
  }

  hdrState.texture = device.createTexture({
    label: 'hdr-texture',
    size: [width, height],
    format: 'rgba16float',
    usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
  });

  hdrState.bindGroup = device.createBindGroup({
    layout: tonemapBindGroupLayout,
    entries: [
      { binding: 0, resource: hdrState.texture.createView() },
      { binding: 1, resource: hdrSampler },
      { binding: 2, resource: { buffer: tonemapUniformBuffer } }
    ]
  });

  hdrState.width = width;
  hdrState.height = height;
}

invalidation.then(() => {
  uniformBuffer.destroy();
  tonemapUniformBuffer.destroy();
  if (hdrState.texture) hdrState.texture.destroy();
});
  </script>
  <script id="render-loop" type="module">
import { createFrameLoop } from './lib/frame-loop.js';

// Reactive dependencies - when these change, this cell re-runs
pointSize; exposure; whitePoint; redshiftRange;

// Mark dirty so we re-render with new control values
renderState.dirty = true;

// Pre-allocate uniform data buffer
const uniformData = new ArrayBuffer(112);
const uniformF32 = new Float32Array(uniformData);

// Data redshift range (for denormalizing in shader)
const [dataZMin, dataZMax] = metadata.redshiftRange;

// Tonemap uniform buffer
const tonemapData = new Float32Array(4);

// Reference distance for brightness scaling (initial camera distance)
const referenceDistance = dataRange * 0.8;

const loop = createFrameLoop(() => {
  const aspectRatio = canvas.width / canvas.height;
  const { projectionView, dirty: cameraDirty } = cameraController.update(aspectRatio);

  if (!renderState.dirty && !cameraDirty) return;
  if (!loadState.chunks.some(c => c !== null)) return;  // Nothing loaded yet

  // Ensure HDR texture matches canvas size
  ensureHdrTexture(canvas.width, canvas.height);

  // Update uniforms
  uniformF32.set(projectionView, 0);
  uniformF32[16] = pointSize * dpr;
  uniformF32[17] = 0.5;  // Fixed base brightness (exposure controls overall level)
  uniformF32[18] = aspectRatio;
  uniformF32[19] = cameraController.state.distance;
  uniformF32[20] = referenceDistance;
  uniformF32[21] = 2.0 * dpr;  // Reference point size (default value)
  uniformF32[22] = (redshiftRange[0] - zMin) / (zMax - zMin);  // minRedshiftNorm
  uniformF32[23] = (redshiftRange[1] - zMin) / (zMax - zMin);  // maxRedshiftNorm
  uniformF32[24] = dataZMin;  // Actual z range for denormalizing colors
  uniformF32[25] = dataZMax;
  device.queue.writeBuffer(uniformBuffer, 0, uniformData);

  const encoder = device.createCommandEncoder();

  // Pass 1: Render galaxies to HDR texture with additive blending
  const hdrPass = encoder.beginRenderPass({
    colorAttachments: [{
      view: hdrState.texture.createView(),
      loadOp: 'clear',
      storeOp: 'store',
      clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 }
    }]
  });

  hdrPass.setPipeline(pipeline);
  hdrPass.setBindGroup(0, bindGroup);

  // Draw all loaded chunks (shader discards points outside redshift range)
  for (const chunk of loadState.chunks) {
    if (chunk) {
      hdrPass.setVertexBuffer(0, chunk.buffer);
      hdrPass.draw(4, chunk.count);
    }
  }

  hdrPass.end();

  // Update tonemap uniforms
  tonemapData[0] = exposure;
  tonemapData[1] = whitePoint;
  device.queue.writeBuffer(tonemapUniformBuffer, 0, tonemapData);

  // Pass 2: Tonemap HDR to screen
  const screenPass = encoder.beginRenderPass({
    colorAttachments: [{
      view: gpuContext.getCurrentTexture().createView(),
      loadOp: 'clear',
      storeOp: 'store',
      clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 }
    }]
  });

  screenPass.setPipeline(tonemapPipeline);
  screenPass.setBindGroup(0, hdrState.bindGroup);
  screenPass.draw(3);  // Fullscreen triangle

  screenPass.end();

  device.queue.submit([encoder.finish()]);

  renderState.dirty = false;
});

invalidation.then(() => loop.cancel());
  </script>
  <script id="cosmology-notes" type="text/markdown">
## Cosmological parameters

Galaxy positions are computed using the [Planck 2018](https://arxiv.org/abs/1807.06209) ${tex`\Lambda`}CDM cosmology via [Astropy](https://www.astropy.org/):

- ${tex`H_0 = 67.66 \text{ km/s/Mpc}`} — Hubble constant (expansion rate today)
- ${tex`\Omega_m = 0.310`} — matter density (dark + baryonic) as a fraction of critical density
- ${tex`\Omega_\Lambda = 0.690`} — dark energy density as a fraction of critical density

Comoving distances and lookback times shown above are interpolated from values computed with this cosmology. The observable universe radius of 46.5 Gpc is the comoving distance to the surface of last scattering at ${tex`z \approx 1100`}.

Data source: [SDSS DR18 SpecObj](https://skyserver.sdss.org/dr18/) with `class='GALAXY'` and `zWarning=0`.
  </script>
</notebook>
