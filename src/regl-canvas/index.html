<!doctype html>
<notebook theme="air">
  <title>REGL in Observable Notebooks 2.0</title>
  <script id="1" type="text/markdown">
    # REGL in Observable Notebooks 2.0
  </script>
  <script id="11" type="text/markdown">
    This notebook wires up a simple library function for managing a [regl](https://github.com/regl-project/regl) canvas in Observable Notebooks 2.0. It works in Observable Desktop as well as with Notebook Kit.
  </script>
  <script id="28" type="text/markdown">
    The main points are:

    1. Dependency injection using `regl` from jsdelivr.net
    2. Two-phased construction: first create a canvas, then inject size dependencies
  </script>
  <script id="30" type="text/markdown">
    To avoid recreating WebGL contexts, I previously used the `this` variable of Observable JavaScript to access the previous cell return value, but this leans heavily into statefullness within Observable‚Äôs stateless evaluation model, and more critically, I don‚Äôt actually know how to accomplish this in Notebook 2.0‚Äôs Vanilla JavaScript model. This is probably for the best.
  </script>
  <script id="31" type="text/markdown">
    So, we‚Äôre left with a simple workaround. First, create a canvas with no size, then obtain the final `regl` instance as we inject the canvas dimension dependencies via `.attachResize()`. Note that this is a two-step process like the following, so that the final `regl` instance is used *after* the size is applied.
  </script>
  <script id="42" type="module">
    html`<span style="color:green">Good üëç:</span>`
  </script>
  <script id="37" type="module">
    dot`digraph {
      "reglCanvas()" -> "_regl"
      "_regl" -> "regl"[label=" .attachResize()"]
    }`
  </script>
  <script id="43" type="text/markdown">
    If we did the following, we would fine that the execution order is indeterminate and we don‚Äôt always operate on a properly resized canvas.
  </script>
  <script id="39" type="module">
    html`<span style="color:red">Bad üëé:</span>`
  </script>
  <script id="38" type="module">
    dot`digraph {
      "reglCanvas()" -> "_regl"
      "reglCanvas()" -> "regl"[label=" .attachResize()"]
    }`
  </script>
  <script id="34" type="text/markdown">
    Is it really worth this trouble to avoid creating extra WebGL contexts? Well, *yes*. Without this, and especially if you have more than one context, you can expect lost contexts and blank diagrams as the number of window resize events exceeds the maximum number of WebGL contexts, typically sixteen.
  </script>
  <script id="44" type="text/markdown">
    One other small thing I learned along the way is that, for somewhat obvious security reasons, Observable Desktop cannot import files from parent directories. This limits the ability to have notebooks categorized within directories import library functions. A simple workaround? Symbolic links. In particular, I added a symbolic link called `lib` within the notebook directory which trivially points to `../lib`. This allows both Observable Desktop as well as the Vite-based preview and build scripts to correctly resolve the import.
  </script>
  <script id="32" type="text/markdown">
    ## Implementation
  </script>
  <script id="23" type="text/markdown">
    ```js
    ${await FileAttachment('./lib/regl-canvas.js').text()}```
  </script>
  <script id="35" type="text/markdown">
    ## Example
  </script>
  <script id="14" type="module" pinned="">
    import { reglCanvas } from './lib/regl-canvas.js'
  </script>
  <script id="26" type="module" pinned="">
    import createREGL from 'npm:regl@2.1.1'
  </script>
  <script id="15" type="module" pinned="">
    // Instantiate the context without a size
    const _regl = view(reglCanvas(createREGL, {pixelRatio: 1}))
  </script>
  <script id="22" type="module" pinned="">
    // Pass the context through the resize function
    const regl = _regl.attachResize(width, width * 0.3)
  </script>
  <script id="19" type="module" pinned="">
    // Start using the context
    regl.poll();
    regl.clear({color: [0.8, 0.9, 1, 1]});
  </script>
</notebook>
