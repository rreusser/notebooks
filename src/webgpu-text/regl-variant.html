<!doctype html>
<notebook theme="air">
  <title>Text Rendering vFinal</title>
  <script id="1059" type="text/markdown">
    # Text Rendering vFinal
  </script>
  <script id="17" type="application/vnd.observable.javascript">
    import { reglCanvas } from "@rreusser/regl-canvas"
  </script>
  <script id="670" type="application/vnd.observable.javascript">
    import { mat4create } from "@rreusser/gl-mat4"
  </script>
  <script id="8" type="application/vnd.observable.javascript">
    Roboto = ({
      metadata: await FileAttachment(`Roboto-msdf-range-8.json`).json(),
      image: await FileAttachment(`Roboto-msdf-range-8.png`).image()
    })
  </script>
  <script id="91" type="application/vnd.observable.javascript">
    draw = {
      createDrawText, txt, span1, span2, span3;

      regl.poll();
      regl.clear({ color: [1, 1, 1, 1] });
      txt.render({ projectionView: mat4create() });
    }
  </script>
  <script id="64" type="application/vnd.observable.javascript">
    txt = {
      const txt = new TextRenderer(regl);
      txt.registerFont(Roboto);
      invalidation.then(() => txt.destroy());
      return txt;
    }
  </script>
  <script id="15" type="application/vnd.observable.javascript">
    viewof regl = reglCanvas(this, {
      width: 256,
      height: 256,
      pixelRatio: 2,
      extensions: ["OES_standard_derivatives", "ANGLE_instanced_arrays"]
    })
  </script>
  <script id="413" type="application/vnd.observable.javascript">
    viewof str1 = Inputs.text({ value: "hello" })
  </script>
  <script id="870" type="application/vnd.observable.javascript">
    viewof str2 = Inputs.text({ value: "comma" })
  </script>
  <script id="873" type="application/vnd.observable.javascript">
    viewof str3 = Inputs.text({ value: "world" })
  </script>
  <script id="507" type="application/vnd.observable.javascript" pinned="">
    span1 = {
      const span = txt.createSpan(str1, {
        position: [0, 0.2, 0],
        offset: [0, 0],
        anchor: "start",
        baseline: "bottom",
        haloWidth: 1,
        fontSize: 11
      });
      invalidation.then(() => span.destroy());
      return span;
    }
  </script>
  <script id="868" type="application/vnd.observable.javascript">
    span2 = {
      const span = txt.createSpan(str2, {
        position: [0, 0.1, 0],
        anchor: "middle"
      });
      invalidation.then(() => span.destroy());
      return span;
    }
  </script>
  <script id="876" type="application/vnd.observable.javascript">
    span3 = {
      const span = txt.createSpan(str3, { position: [0, 0.0, 0], anchor: "end" });
      invalidation.then(() => span.destroy());
      return span;
    }
  </script>
  <script id="969" type="application/vnd.observable.javascript">
    md`## Implementation`
  </script>
  <script id="23" type="application/vnd.observable.javascript">
    class Font {
      constructor(renderer, metadata, image) {
        this.renderer = renderer;
        this.name = metadata.name;
        this.atlas = metadata.atlas;
        this.glyphs = new Map(metadata.glyphs.map((g) => [g.unicode, g]));
        this.placements = new GlyphPlacements(renderer, this);
        this.texture = this.renderer.regl.texture({
          data: image,
          format: "rgba",
          type: "uint8",
          min: "linear",
          mag: "linear",
          flipY: metadata.atlas.yOrigin === "bottom" ? true : false
        });
      }

      destroy() {
        if (this.texture) {
          this.texture.destroy();
          this.texture = null;
        }
        this.placements.destroy();
      }
    }
  </script>
  <script id="721" type="application/vnd.observable.javascript">
    class PlacementRange {
      constructor(glyphPlacements, start, end) {
        this.glyphPlacements = glyphPlacements;
        this.start = start;
        this.end = end;
        this.delete = false;
      }
      queueDeletion() {
        this.delete = true;
      }
      get size() {
        if (!isFinite(this.start)) return;
        return this.end - this.start + 1;
      }
    }
  </script>
  <script id="61" type="application/vnd.observable.javascript">
    class GlyphPlacements {
      // Layout:
      //   attr         type      size  bytes      range
      //   position     float32   3     12 bytes   0-11
      //   planeBounds  float32   4     16 bytes   12-27
      //   atlasBounds  float32   4     16 bytes   28-43
      //   haloWidth    float32   1     4 bytes    44-47
      //   color        uint8     4     4 bytes    48-51
      //   haloColor    uint8     4     4 bytes    52-55
      static layout = [
        { name: "position", type: "float32", size: 3 },
        { name: "planeBounds", type: "float32", size: 4 },
        { name: "atlasBounds", type: "float32", size: 4 },
        { name: "haloWidth", type: "float32", size: 1 },
        { name: "color", type: "uint8", size: 1 },
        { name: "haloColor", type: "uint8", size: 1 }
      ];

      static bytesPerGlyph = 56;

      static anchorShift = {
        start: 0,
        middle: -0.5,
        end: -1
      };

      static baselineShift = {
        bottom: 0,
        center: -0.5,
        top: -1
      };

      constructor(renderer, font) {
        this.renderer = renderer;
        this.atlas = font.atlas;
        this.glyphs = font.glyphs;
        this.capacity = 1024;
        this.uint8 = new Uint8Array(this.capacity * GlyphPlacements.bytesPerGlyph);
        this.float32 = new Float32Array(this.uint8.buffer);
        this.count = 0;
        this.ranges = [];
        this.buffer = renderer.regl.buffer(this.uint8);
      }

      clear() {
        for (const range of this.ranges) {
          // This won't do anything but will mark them cleared so they
          // can't be double-deleted once existing spans are cleared
          range.queueDeletion();
        }
        this.ranges.length = 0;
        this.count = 0;
      }

      destroy() {
        this.clear();
        if (this.buffer) this.buffer.destroy();
        this.buffer = null;
      }

      ensureCapacity(desiredSize) {
        let reinit = false;
        while (this.capacity < desiredSize) {
          this.capacity *= 2;
          reinit = true;
        }
        if (!reinit) return;

        const cur = this.uint8;
        this.uint8 = new Uint8Array(this.capacity * GlyphPlacements.bytesPerGlyph);
        this.float32 = new Float32Array(this.uint8.buffer);
        this.uint8.set(cur);
        this.buffer(this.uint8);
      }

      place(string, style) {
        this.ensureCapacity(this.count + string.length);
        let start = this.count;
        let end = this.count - 1;

        let cursor = 0;
        for (const char of string) {
          const { index, advance } = this._placeChar(char, cursor, style);
          if (index >= 0) end = index;
          cursor += advance;
        }
        const range = new PlacementRange(this, start, end);
        this.ranges.push(range);
        this._applyAlignment(range, cursor, style);
        return range;
      }

      _applyAlignment(range, cursor, style) {
        const horizontalShift =
          GlyphPlacements.anchorShift[style.anchor] * cursor * style.fontSize;
        const verticalShift =
          GlyphPlacements.baselineShift[style.baseline] * style.fontSize;

        const step32 =
          GlyphPlacements.bytesPerGlyph / Float32Array.BYTES_PER_ELEMENT;
        let i32 = range.start * step32;
        for (let i = range.start; i <= range.end; i++, i32 += step32) {
          this.float32[i32 + 3] += horizontalShift;
          this.float32[i32 + 4] += verticalShift;
        }
      }

      _placeChar(
        char,
        cursor,
        { position, offset, fontSize, color, haloColor, haloWidth }
      ) {
        const index = this.count;
        const glyph = this.glyphs.get(char.charCodeAt(0));

        if (!glyph.planeBounds || !glyph.atlasBounds) {
          return { index: -1, advance: glyph.advance };
        }
        const i32 =
          (GlyphPlacements.bytesPerGlyph / Float32Array.BYTES_PER_ELEMENT) * index;
        const i8 =
          (GlyphPlacements.bytesPerGlyph / Uint8Array.BYTES_PER_ELEMENT) * index;

        // Position
        this.float32[i32 + 0] = position[0];
        this.float32[i32 + 1] = position[1];
        this.float32[i32 + 2] = position[2];

        // Plane bounds
        this.float32[i32 + 3] =
          fontSize * (cursor + glyph.planeBounds.left) + offset[0];
        this.float32[i32 + 4] = fontSize * glyph.planeBounds.bottom + offset[1];
        this.float32[i32 + 5] =
          fontSize * (glyph.planeBounds.right - glyph.planeBounds.left);
        this.float32[i32 + 6] =
          fontSize * (glyph.planeBounds.top - glyph.planeBounds.bottom);

        // Atlas bounds
        this.float32[i32 + 7] = glyph.atlasBounds.left / this.atlas.width;
        this.float32[i32 + 8] = glyph.atlasBounds.bottom / this.atlas.height;
        this.float32[i32 + 9] =
          (glyph.atlasBounds.right - glyph.atlasBounds.left) / this.atlas.width;
        this.float32[i32 + 10] =
          (glyph.atlasBounds.top - glyph.atlasBounds.bottom) / this.atlas.height;

        this.float32[i32 + 11] = haloWidth;

        this.uint8[i8 + 48] = color[0];
        this.uint8[i8 + 49] = color[1];
        this.uint8[i8 + 50] = color[2];
        this.uint8[i8 + 51] = color[3];

        this.uint8[i8 + 52] = haloColor[0];
        this.uint8[i8 + 53] = haloColor[1];
        this.uint8[i8 + 54] = haloColor[2];
        this.uint8[i8 + 55] = haloColor[3];

        this.count++;

        return { index, advance: glyph.advance };
      }

      flushDeletions() {
        let delta = 0;
        let shift = 0;
        for (let i = 0; i < this.ranges.length; i++) {
          const placement = this.ranges[i];
          if (placement.delete) {
            delta += placement.size;
            shift++;
            continue;
          }

          if (delta) {
            const byteStart = placement.start * GlyphPlacements.bytesPerGlyph;
            const byteEnd = (placement.end + 1) * GlyphPlacements.bytesPerGlyph;
            const byteDelta = delta * GlyphPlacements.bytesPerGlyph;
            for (let j = byteStart; j < byteEnd; j++) {
              this.uint8[j - byteDelta] = this.uint8[j];
            }
            placement.start -= delta;
            placement.end -= delta;
          }
          if (shift) {
            this.ranges[i - shift] = this.ranges[i];
          }
        }

        this.count -= delta;
        this.ranges.length -= shift;
      }

      updateBuffer() {
        this.flushDeletions();
        this.buffer.subdata(
          this.uint8.subarray(0, this.count * GlyphPlacements.bytesPerGlyph)
        );
      }
    }
  </script>
  <script id="11" type="application/vnd.observable.javascript">
    class TextRenderer {
      constructor(regl, { fonts = [] } = {}) {
        if (!regl.hasExtension("ANGLE_instanced_arrays")) {
          throw new Error(
            "TextRenderer: ANGLE_instanced_arrays extension not loaded"
          );
        }
        if (!regl.hasExtension("OES_standard_derivatives")) {
          throw new Error(
            "TextRenderer: OES_standard_derivatives extension not loaded"
          );
        }
        this.fontStore = new Map();
        this.regl = regl;
        this.draw = createDrawText(regl);
        this.elements = new Set();
        for (const font of fonts) {
          this.registerFont(font);
        }
      }

      registerFont({ metadata, image }) {
        this.fontStore.set(metadata.name, new Font(this, metadata, image));
      }

      getFont(name) {
        if (name) {
          return this.fontStore.get(name);
        } else if (this.fontStore.size === 1) {
          return [...this.fontStore.values()][0];
        }
      }

      placeGlyphs() {
        for (const element of this.elements.values()) {
          if (element.placement) continue;
          element.placeGlyphs();
        }
      }

      createSpan(textContent, style = {}) {
        const defaultStyle = {
          position: [0, 0, 0],
          offset: [0, 0],
          font: null,
          fontSize: 12,
          color: [0, 0, 0, 1],
          haloWidth: 0,
          haloColor: [1, 1, 1, 1],
          baseline: "bottom",
          anchor: "start"
        };
        const span = new Span(this, textContent, { ...defaultStyle, ...style });
        this.elements.add(span);
        return span;
      }

      removeAll() {
        for (const span of this.elements) {
          span.remove();
        }
      }

      destroy() {
        for (const font of this.fontStore.values()) {
          font.destroy();
        }
        // In case of internal inconsistency, ensure all attribute buffers
        // are fully cleared as well
        for (const font of this.fontStore.values()) {
          font.placements.clear();
        }
      }

      render({ projectionView = null } = {}) {
        this.placeGlyphs();
        for (const font of this.fontStore.values()) {
          font.placements.updateBuffer();
          this.draw({ font, projectionView });
        }
      }
    }
  </script>
  <script id="30" type="application/vnd.observable.javascript">
    class Span {
      constructor(renderer, textContent, style) {
        this.textContent = textContent;
        this.changed = false;
        this.renderer = renderer;
        this.placement = null;
        this.style = style;
      }

      computeFont() {
        const font = this.renderer.getFont(this.style.font);
        if (!font) {
          throw new Error(`Font not found: ${JSON.stringify(this.style.font)}`);
        }
        return font;
      }

      placeGlyphs() {
        if (this.placement) return;
        this.placement = this.computeFont().placements.place(
          this.textContent,
          this.style
        );
      }

      destroy() {
        if (this.placement) {
          this.placement.queueDeletion();
        }
        this.placement = null;
        this.renderer.elements.delete(this);
      }
    }
  </script>
  <script id="269" type="application/vnd.observable.javascript">
    function createDrawText(regl) {
      const defaultProjection = mat4create();
      return regl({
        vert: `
          precision highp float;

          uniform mat4 projectionView;
          uniform vec2 resolution;
          uniform float pixelRatio;
          uniform vec2 positioning;

          attribute float haloWidth;
          attribute vec2 uv, offset;
          attribute vec3 position;
          attribute vec4 planeBounds, atlasBounds;
          attribute vec4 color, haloColor;

          varying float vHaloWidth;
          varying vec2 texCoord;
          varying vec4 vColor, vHaloColor;

          void main () {
            vHaloWidth = haloWidth * pixelRatio;
            vColor = color;
            vHaloColor = haloColor;

            gl_Position = projectionView * vec4(position, 1);
            gl_Position.xyz /= gl_Position.w;
            gl_Position.xy += 2.0 * pixelRatio * (
                  planeBounds.xy + uv * planeBounds.zw
                ) / resolution;
            gl_Position.xyz *= gl_Position.w;

            texCoord = atlasBounds.xy + uv * atlasBounds.zw;

            gl_PointSize = 2.0;
          }`,
        frag: `
          #extension GL_OES_standard_derivatives : enable
          precision highp float;

          uniform sampler2D tex;
          uniform vec2 unitRange;
          uniform float distanceRange;
          uniform float pixelRatio;

          varying float vHaloWidth;
          varying vec2 texCoord;
          varying vec4 vColor, vHaloColor;

          float screenPxRange() {
              vec2 screenTexSize = vec2(1.0) / fwidth(texCoord);
              return max(0.5 * dot(unitRange, screenTexSize), 1.0);
          }

          float median(float r, float g, float b) {
            return max(min(r, g), min(max(r, g), b));
          }

          float linearstep (float a, float b, float x) {
            return clamp((x - a) / (b - a), 0.0, 1.0);
          }

          void main() {
            vec4 msd = texture2D(tex, texCoord);

            float px = screenPxRange();
            float sdf = median(msd.r, msd.g, msd.b);

            float screenPxDistance = px * (sdf - 0.5);
            float textOpacity = clamp(screenPxDistance + 0.5, 0.0, 1.0);

            vec4 col = vColor;

            if (vHaloWidth > 0.0) {
              float haloPxDistance = px * (sdf - 0.5) + min(vHaloWidth, 0.5 * screenPxRange() - 1.0);
              float haloOpacity = clamp(haloPxDistance + 0.5, 0.0, 1.0);
              col = mix(vHaloColor, col, textOpacity);
              col.a = max(haloOpacity, textOpacity);
            } else {
              col.a *= textOpacity;
            }
            if (col.a == 0.0) discard;

            gl_FragColor = col;
          }`,
        uniforms: {
          projectionView: (ctx, props) => props.projectionView ?? defaultProjection,
          resolution: (ctx) => [ctx.viewportWidth, ctx.viewportHeight],
          pixelRatio: regl.context("pixelRatio"),
          distanceRange: regl.prop("font.atlas.distanceRange"),
          unitRange: (ctx, { font: { atlas } }) => [
            atlas.distanceRange / atlas.width,
            atlas.distanceRange / atlas.height
          ],
          tex: regl.prop("font.texture")
        },
        attributes: {
          uv: {
            divisor: 0,
            buffer: new Uint8Array([0, 0, 1, 0, 0, 1, 1, 1])
          },
          position: {
            divisor: 1,
            buffer: regl.prop("font.placements.buffer"),
            stride: GlyphPlacements.bytesPerGlyph,
            offset: 0,
            type: "float32",
            size: 3
          },
          planeBounds: {
            divisor: 1,
            buffer: regl.prop("font.placements.buffer"),
            stride: GlyphPlacements.bytesPerGlyph,
            offset: 12,
            type: "float32",
            size: 4
          },
          atlasBounds: {
            divisor: 1,
            buffer: regl.prop("font.placements.buffer"),
            stride: GlyphPlacements.bytesPerGlyph,
            offset: 28,
            type: "float32",
            size: 4
          },
          haloWidth: {
            divisor: 1,
            buffer: regl.prop("font.placements.buffer"),
            stride: GlyphPlacements.bytesPerGlyph,
            offset: 44,
            type: "float32",
            size: 1
          },
          color: {
            divisor: 1,
            buffer: regl.prop("font.placements.buffer"),
            stride: GlyphPlacements.bytesPerGlyph,
            offset: 48,
            type: "uint8",
            size: 4
          },
          haloColor: {
            divisor: 1,
            buffer: regl.prop("font.placements.buffer"),
            stride: GlyphPlacements.bytesPerGlyph,
            offset: 52,
            type: "uint8",
            size: 4
          }
        },
        blend: {
          enable: true,
          func: {
            srcRGB: "src alpha",
            srcAlpha: 1,
            dstRGB: "one minus src alpha",
            dstAlpha: 1
          },
          equation: {
            rgb: "add",
            alpha: "add"
          }
        },
        depth: { enable: false },
        primitive: "triangle strip",
        instances: regl.prop("font.placements.count"),
        count: 4
      });
    }
  </script>
</notebook>
