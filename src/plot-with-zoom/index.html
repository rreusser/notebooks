<!doctype html>
<notebook theme="air">
  <title>Plot with Zoom</title>
  <script id="1" type="text/markdown">
    # Plot with Zoom
  </script>
  <script id="2" type="text/markdown">
    This notebook sets up a zoomable 2D plot using d3.zoom. It stacks multiple layers (a [regl](https://github.com/regl-project/regl) WebGL  canvas, an [Observable Plot](https://observablehq.com/plot/), and an SVG) so that zoom and pan stay in sync across all of them. The goal is to generalize it to other interactive figures in a similar manner.
  </script>
  <script id="3" type="text/markdown">
    The key components are:

    - **Element stack**: A small helper that manages multiple absolutely positioned layers within a container. Each layer can be a canvas, SVG, or any DOM element. The stack handles resizing all layers together and persists resources like WebGL contexts across reactive updates.
    - **Zoomable axes**: A rendering-agnostic zoom controller built on d3.zoom. It tracks the current view as orthographic matrices and exposes d3 scales for coordinate conversion. When the view changes, it notifies listeners so each layer can update accordingly.
    - **Expandable wrapper**: The plot can be expanded to fill most of the viewport by clicking the toggle button in the corner. This is useful for exploring detail without leaving the page.
  </script>
  <script id="4" type="text/x-typescript" pinned="">
    const figure = html`<figure>
      ${stack.element}
      <figcaption>Use mouse wheel to zoom, drag to pan.</figcaption>
    </figure>`;

    display(expandable(figure, {
      width: Math.min(width, 640),
      height: Math.min(480, width),
      onResize(el, w, h) {
        stack.resize(w, h);
        axes.updateScales(
          stack.elements.plot.scale("x"),
          stack.elements.plot.scale("y")
        );
        regl.dirty = true;
      }
    }));
  </script>
  <script id="16" type="text/markdown">
    The code above performs final display of the figure we develop below. The focus here is managing the expandable section, in particular instantiating the content and managing what happens when resized.
  </script>
  <script id="5" type="text/x-typescript">
    import * as d3 from 'npm:d3'
    import createREGL from 'npm:regl'
    import { createElementStack } from './lib/element-stack.js'
    import { reglElement, reglAxesViewport } from './lib/regl-canvas.js'
    import { createZoomableAxes } from './lib/zoomable-axes.js'
    import { createPolarDomainColoringShader } from './domain-coloring.js'
    import { collapseCodeBlocks } from './lib/collapsible-code.js'
    import { expandable } from './lib/expandable.js'
  </script>
  <script id="19" type="text/markdown">
    The first major step is to instantiate the stack container. This is a persistent container that will hold the plot. This awful statefulness is critical when using WebGL, because a cell dependency on the page `width` would trigger reinsantiation of the WebGL context, which inevitably leads to lost WebGL contexts and much gnashing of teeth.
  </script>
  <script id="18" type="text/x-typescript" pinned="">
    const stackContainer = document.createElement('div');
  </script>
  <script id="20" type="text/markdown">
    Next, we configure the stack. The `reglElement` helper returns a function which receives the current regl element as an argument, thus preventing reinstantiation.
  </script>
  <script id="7" type="text/x-typescript" pinned="">
    const stack = createElementStack({
      container: stackContainer,
      layers: {
        regl: reglElement(createREGL, {
          extensions: ['OES_standard_derivatives'],
          attributes: { depthStencil: false, preserveDrawingBuffer: true }
        }),
        plot: ({ width, height, xDomain=[-2, 2], yDomain=[-2, 2] }) =>
          Plot.plot({
            width,
            height,
            marginTop: 20,
            marginRight: 10,
            marginLeft: 40,
            marginBottom: 20,
            style: { backgroundColor: "transparent", maxWidth: "none" },
            x: { domain: xDomain, tickSpacing: 100 },
            y: { domain: yDomain, tickSpacing: 100 },
            marks: [
              Plot.ruleX([0], { stroke: "#0002" }),
              Plot.ruleY([0], { stroke: "#0002" })
            ]
          }),
        svg: ({ current, width, height }) =>
          (current ? d3.select(current) : d3.create("svg")).attr("width", width).attr("height", height).node()
      }
    });
  </script>
  <script id="8" type="text/x-typescript" pinned="">
    const axes = createZoomableAxes({
      d3,
      element: stack.elements.svg,
      xScale: stack.elements.plot.scale("x"),
      yScale: stack.elements.plot.scale("y"),
      aspectRatio: 1,
      onChange: ({ xDomain, yDomain }) => {
        regl.dirty = true;
        stack.update({ plot: { xDomain, yDomain } });
      }
    });
  </script>
  <script id="9" type="text/markdown">
    As a test case, we render a [domain coloring](https://en.wikipedia.org/wiki/Domain_coloring) of a Möbius transformation. The function maps complex numbers according to

    ${tex.block`f(z) = \frac{(z - a)(b - m)}{(z - b)(a - m)}`}

    where ${tex`a`}, ${tex`m`}, and ${tex`b`} are control points you can drag to explore the transformation. By construction, ${tex`f(a) = 0`}, ${tex`f(b) = \infty`}, and ${tex`f(m) = 1`}. Möbius transformations are conformal (angle-preserving) and map circles to circles, though some of those circles may have infinite radius (i.e., lines).
  </script>
  <script id="10" type="text/x-typescript" pinned="">
    // Control points for the complex function f(z) = (z - a)(b - m) / (z - b)(a - m)
    const controlPoints = {
      a: { x: -1, y: 0.5 },
      m: { x: 0, y: 0 },
      b: { x: 1, y: -0.5 }
    };
  </script>
  <script id="11" type="text/x-typescript" pinned="">
    const regl = stack.elements.regl.value;
    regl.dirty = true;
  </script>
  <script id="12" type="text/x-typescript" pinned="">
    const drawGradient = regl({
      vert: `
        precision highp float;
        attribute vec2 uv;
        varying vec2 z;
        uniform mat4 viewInverse;
        void main () {
          z = (viewInverse * vec4(uv, 0, 1)).xy;
          gl_Position = vec4(uv, 0, 1);
        }`,
      frag: `
        #extension GL_OES_standard_derivatives : enable
        precision highp float;
        varying vec2 z;
        uniform vec2 a, m, b;
        uniform float pixelRatio;

        vec2 cmul(vec2 a, vec2 b) { return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }
        vec2 cdiv(vec2 a, vec2 b) { return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / dot(b, b); }
        vec2 f(vec2 z) { return cdiv(cmul(z - a, b - m), cmul(z - b, a - m)); }

        ${createPolarDomainColoringShader()}

        void main () {
          vec2 w = f(z);

          gl_FragColor = domainColoring(
            vec4(w, fwidth(w) * pixelRatio),
            vec2(2.0, 2.0),    // steps
            vec2(0.1),         // scale
            vec2(0.1, 0.1),    // gridOpacity
            vec2(0.35, 0.15),  // shadingOpacity
            0.25,              // lineWidth
            0.4,               // lineFeather
            vec3(0),           // gridColor
            4.0                // contrastPower
          );
        }`,
      uniforms: {
        viewInverse: regl.prop('viewInverse'),
        pixelRatio: regl.context('pixelRatio'),
        a: regl.prop('a'),
        m: regl.prop('m'),
        b: regl.prop('b'),
      },
      attributes: { uv: [-4, -4, 4, -4, 0, 4] },
      depth: { enable: false },
      scissor: { enable: true, box: reglAxesViewport(axes) },
      viewport: reglAxesViewport(axes),
      count: 3,
    });
  </script>
  <script id="13" type="text/x-typescript" pinned="">
    // Create SVG circles for draggable control points
    {
      const svg = d3.select(stack.elements.svg);

      const circleData = [
        { id: 'a', point: controlPoints.a, color: 'rgb(51, 85, 238)', label: 'a' },
        { id: 'm', point: controlPoints.m, color: 'rgb(51, 85, 238)', label: 'm' },
        { id: 'b', point: controlPoints.b, color: 'rgb(51, 85, 238)', label: 'b' }
      ];

      const circles = svg.selectAll('circle.control')
        .data(circleData, d => d.id)
        .join('circle')
        .attr('class', 'control')
        .attr('r', 6)
        .attr('fill', d => d.color)
        .attr('stroke', '#fff')
        .attr('stroke-width', 2)
        .attr('cursor', 'move')
        .call(d3.drag()
          .on('start', function() { d3.select(this).attr('cursor', 'grabbing'); })
          .on('drag', function(event, d) {
            d.point.x = axes.xScale.invert(event.x);
            d.point.y = axes.yScale.invert(event.y);
            updatePositions();
            regl.dirty = true;
          })
          .on('end', function() { d3.select(this).attr('cursor', 'move'); })
        );

      const labels = svg.selectAll('text.label')
        .data(circleData, d => d.id)
        .join('text')
        .attr('class', 'label')
        .attr('text-anchor', 'middle')
        .attr('font-family', 'serif')
        .attr('font-size', '18px')
        .attr('font-style', 'italic')
        .attr('fill', '#333')
        .style('text-shadow', [[-1, 0, 2.5], [1, 0, 2.5], [0, 1, 2.5], [0, -1, 2.5]].map(([i, j, sh]) => `${i}px ${j}px ${sh}px white`).join(', '))
        .text(d => d.label);

      function updatePositions() {
        circles
          .attr('cx', d => axes.xScale(d.point.x))
          .attr('cy', d => axes.yScale(d.point.y));
        labels
          .attr('x', d => axes.xScale(d.point.x) + 8)
          .attr('y', d => axes.yScale(d.point.y) + 18);
      }

      updatePositions();
      stack.addEventListener('update', updatePositions);
    }
  </script>
  <script id="14" type="text/x-typescript" pinned="">
    let loop = regl.frame(() => {
      try {
        if (!regl.dirty) return;
        drawGradient({
          viewInverse: axes.viewInverse,
          a: [controlPoints.a.x, controlPoints.a.y],
          m: [controlPoints.m.x, controlPoints.m.y],
          b: [controlPoints.b.x, controlPoints.b.y]
        });
        regl.dirty = false;
      } catch (e) {
        loop.cancel();
        loop = undefined;
      }
    });

    invalidation.then(() => loop?.cancel());
  </script>
  <script id="15" type="text/x-typescript">
    collapseCodeBlocks({
      maxHeight: 500
    });
  </script>
</notebook>
