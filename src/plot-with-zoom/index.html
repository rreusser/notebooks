<!doctype html>
<notebook theme="air">
  <title>Plot with Zoom</title>
  <script id="1" type="text/markdown">
    # Plot with Zoom

    A template for 2D plots with mouse wheel zooming using d3.zoom.
  </script>
  <script id="2" type="text/x-typescript">
    import * as d3 from 'npm:d3'
    import createREGL from 'npm:regl'
    import { initializeElementStack, createElementStack } from './lib/element-stack.js'
    import { reglElement, reglAxesViewport } from './lib/regl-canvas.js'
    import { createZoomableAxes } from './lib/zoomable-axes.js'
  </script>
  <script id="3" type="text/x-typescript">
    const stackEl = initializeElementStack();
  </script>
  <script id="4" type="text/x-typescript" pinned="">
    const plotWidth = Math.min(width, 640);
    const plotHeight = Math.min(240, width);

    // Plot configuration
    const plotConfig = {
      marginTop: 0,
      marginRight: 5,
      marginLeft: 22,
      marginBottom: 20,
      style: { backgroundColor: "transparent", maxWidth: "none" }
    };

    // Helper to create Plot with given domains
    function createPlot({width, height, xDomain=[-3, 3], yDomain=[-3, 3]}) {
      return Plot.plot({
        width,
        height,
        ...plotConfig,
        x: { domain: xDomain, grid: true, tickSpacing: 100 },
        y: { domain: yDomain, grid: true, tickSpacing: 100 }
      });
    }

    // Create element stack
    const el = createElementStack({
      container: stackEl,
      width: plotWidth,
      height: plotHeight,
      layers: {
        regl: reglElement(createREGL, {attributes: { depthStencil: false }}),
        plot: ({ width, height }) => createPlot({width, height}),
        svg: ({ current, width, height }) =>
          (current ? d3.select(current) : d3.create("svg")).attr("width", width).attr("height", height).node()
      }
    });
    const stack = el.value;
    const regl = stack.regl.value;

    regl.dirty = true;

    const axes = createZoomableAxes({
      d3,
      element: stack.svg,
      xScale: stack.plot.scale("x"),
      yScale: stack.plot.scale("y"),
      aspectRatio: 1,
      onChange: ({ xDomain, yDomain }) => {
        regl.dirty = true;
        stackEl.update({
          plot: ({ width, height }) => createPlot({width, height, xDomain, yDomain})
        });
      }
    });

    display(html`<figure>
      ${el}
      <figcaption>Use mouse wheel to zoom, drag to pan.</figcaption>
    </figure>`);
  </script>
  <script id="5" type="text/x-typescript" pinned="">
    const drawGradient = regl({
      vert: `
        precision highp float;
        attribute vec2 uv;
        varying vec2 xy;
        uniform mat4 viewInverse;
        void main () {
          xy = (viewInverse * vec4(uv, 0, 1)).xy;
          gl_Position = vec4(uv, 0, 1);
        }`,
      frag: `
        precision highp float;
        varying vec2 xy;

        void main () {
          float r = length(xy);
          vec3 color = 0.5 + 0.5 * cos(r * 2.0 + vec3(0.0, 2.1, 4.2));

          vec2 grid = abs(fract(xy) - 0.5);
          float line = smoothstep(0.02, 0.0, min(grid.x, grid.y));
          color = mix(color, vec3(0.2), line * 0.5);

          gl_FragColor = vec4(color, 1);
        }`,
      uniforms: {
        viewInverse: regl.prop('viewInverse')
      },
      attributes: { uv: [-4, -4, 4, -4, 0, 4] },
      count: 3,
      depth: { enable: false },
      scissor: { enable: true, box: reglAxesViewport(axes) },
      viewport: reglAxesViewport(axes)
    });
  </script>
  <script id="6" type="text/x-typescript" pinned="">
    let loop = regl.frame(() => {
      if (!regl.dirty) return;
      drawGradient({ viewInverse: axes.viewInverse });
      regl.dirty = false;
    });

    invalidation.then(() => loop?.cancel());
  </script>
</notebook>
