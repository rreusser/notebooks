<!doctype html>
<notebook theme="air">
  <title>HTML+CSS Periodic Three-Body Orbits</title>
  <script id="1" type="text/markdown">
    # HTML+CSS Periodic Three-Body Orbits
  </script>
  <script id="2" type="module">
    import ndarray from 'npm:ndarray';
    import ndarrayFFT from 'npm:ndarray-fft';
    import { sprintf } from 'npm:sprintf-js';
    import { ode45 } from 'observable:@rreusser/integration';
    import {
      threeBodyInitialConditions
    } from 'observable:@rreusser/periodic-three-body-initial-conditions';
  </script>
  <script id="3" type="module">
    {
      const iframe = document.createElement("iframe");
      const src =
        "<c><h><d><j>•</d><e><f><j>•</f><g><j>•<style>*{position:absolute}c,e{animation:q 5s infinite linear}e{animation-duration:1s}c{top:50vh;left:50vw}j{font-size:80px;transform:translate(-50%,-50%)}h{transform:translatex(20vw)}d{transform:translatex(-60vw)}f{transform:translatex(8vw)}g{transform:translatex(-8vw)}@keyframes q{to{transform:rotate(1turn)}}";
      iframe.srcdoc = src;
      iframe.style.width = "300px";
      iframe.style.height = "300px";
      iframe.style.border = "1px solid #eee";

      const codeEl = document.createElement("pre");
      codeEl.style.width = "100%";
      codeEl.style.wordBreak = "break-all";
      codeEl.style.whiteSpace = "pre-wrap";
      codeEl.style.fontSize = "0.85em";
      const codeInner = document.createElement("code");
      codeInner.textContent = src;
      codeEl.appendChild(codeInner);

      const figure = document.createElement("figure");
      const row = document.createElement("div");
      row.style.display = "flex";
      row.style.flexWrap = "wrap";
      row.style.gap = "1em";
      row.style.justifyContent = "center";
      const left = document.createElement("div");
      left.style.flex = "0 0 auto";
      left.appendChild(iframe);
      const right = document.createElement("div");
      right.style.flex = "1 1 300px";
      right.appendChild(codeEl);
      row.appendChild(left);
      row.appendChild(right);
      figure.appendChild(row);
      const caption = document.createElement("figcaption");
      caption.textContent = "The most concise physically accurate orbit I could code-golf, in 350 bytes.";
      figure.appendChild(caption);
      display(figure);
    }
  </script>
  <script id="4" type="text/markdown">
    This notebook reworks my [Periodic Planar Three-Body Orbits](https://observablehq.com/@rreusser/periodic-planar-three-body-orbits) notebook with a bit of an odd goal: to animate periodic planar three-body orbits using pure HTML and CSS, without any JavaScript, and without fully enumerating every point along the paths.

    The method is straightforward though a bit tedious. We integrate an orbit with fixed temporal spacing, assign the x and y components of each point along the trajectory to real and imaginary components in the complex plane, and compute the Discrete Fourier Transform (DFT). Then we threshold the frequency components, represent each frequency component as a rotating complex phasor, and convert to CSS transforms!
  </script>
  <script id="5" type="text/markdown">
    For a delightful illustration of the method, see Mike Bostock's [Fourier Series - Zoom](https://observablehq.com/@mbostock/fourier-series-zoom) notebook in which he illustrates drawing a portrait using the sum of complex phasors.

    The most challenging aspect was converting the phasors to CSS, but in the end I was able to represent them as a chain of transforms in the style `transform(\${re}px, \${im}px) rotate(\${f}deg)` where `re` and `im` are precisely the DFT components, and the frequency `f` is the component's frequency relative to the sum total of all parent rotations, so that the rotational speed of the component is correct. *(Thanks, [Fabian Iwand](https://observablehq.com/@mootari) for digging up the [CSS transform interpolation specification](https://drafts.csswg.org/css-transforms/#interpolation-of-transforms) and confirming that parallel lists of transforms are matched up and interpolated one transform at a time!)*

    Realistically, complex orbits require quite a few frequency components and actually end up quite large, but you can get a lovely figure-eight in just a little over two kilobytes. The rest of this notebook walks through the computation step by step.
  </script>
  <script id="9" type="module">
    const initialConditions = (() => {
      const { group, sequence, orbit } = selectedConditions;
      const conditions = threeBodyInitialConditions[group]?.[sequence]?.[orbit];
      if (!conditions) return null;

      const p = conditions.x;
      const v = conditions.v;
      const m = conditions.m || [1, 1, 1];

      return {
        y0: [p[0][0], p[0][1], v[0][0], v[0][1],
             p[1][0], p[1][1], v[1][0], v[1][1],
             p[2][0], p[2][1], v[2][0], v[2][1]],
        period: conditions.T,
        m
      };
    })();
  </script>
  <script id="10" type="module">
    function planarThreeBodyDerivative(yp, y, t) {
      let dx, dy, r3;
      const m0 = initialConditions.m[0];
      const m1 = initialConditions.m[1];
      const m2 = initialConditions.m[2];

      (yp[0] = y[2]), (yp[1] = y[3]);
      (yp[4] = y[6]), (yp[5] = y[7]);
      (yp[8] = y[10]), (yp[9] = y[11]);

      dx = y[4] - y[0];
      dy = y[5] - y[1];
      r3 = Math.pow(dx * dx + dy * dy, 1.5);
      (dx /= r3), (dy /= r3);
      yp[2] = dx * m1;
      yp[3] = dy * m1;
      yp[6] = -dx * m0;
      yp[7] = -dy * m0;

      dx = y[8] - y[0];
      dy = y[9] - y[1];
      r3 = Math.pow(dx * dx + dy * dy, 1.5);
      (dx /= r3), (dy /= r3);
      yp[2] += dx * m2;
      yp[3] += dy * m2;
      yp[10] = -dx * m0;
      yp[11] = -dy * m0;

      dx = y[8] - y[4];
      dy = y[9] - y[5];
      r3 = Math.pow(dx * dx + dy * dy, 1.5);
      (dx /= r3), (dy /= r3);
      yp[6] += dx * m2;
      yp[7] += dy * m2;
      yp[10] -= dx * m1;
      yp[11] -= dy * m1;
    }

    function tabulateOrbit({ n }) {
      const history = [
        { x: [], y: [] },
        { x: [], y: [] },
        { x: [], y: [] }
      ];

      const state = {
        t: 0,
        y: initialConditions.y0.slice()
      };

      function storeStep(state) {
        history[0].x.push(state.y[0]);
        history[0].y.push(state.y[1]);
        history[1].x.push(state.y[4]);
        history[1].y.push(state.y[5]);
        history[2].x.push(state.y[8]);
        history[2].y.push(state.y[9]);
      }

      storeStep(state);

      const config = { tolerance: 1e-9 };
      for (let i = 0; i < n - 1; i++) {
        let step = 0;
        config.t = (i / n) * initialConditions.period;
        config.tLimit = ((i + 1) / n) * initialConditions.period;
        state.limitReached = false;
        while (step++ < 1000 && !state.limitReached) {
          ode45(state, planarThreeBodyDerivative, config);
        }
        storeStep(state);
      }
      return history;
    }
  </script>
  <script id="11" type="module">
    const trajectory = tabulateOrbit({ n });
  </script>
  <script id="35" type="text/markdown">
    ## Select and integrate an orbit
  </script>
  <script id="12" type="text/markdown">
    We start by selecting initial conditions and integrating the trajectory. The integrator uses an adaptive Runge-Kutta scheme (Cash-Karp) which adjusts the time step to maintain accuracy, saving the output at fixed temporal spacing. This is important because the bodies move slowly when far apart but very quickly during close encounters, so adaptive integration is dramatically more efficient than fixed step methods. The Broucke orbits and the Figure-Eight orbits compress particularly well.

    With the trajectory computed, we take the DFT of each body's path, treating x and y as the real and imaginary parts of a complex signal. We then threshold the frequency components to keep only the significant ones. The plot below shows the filtered orbit overlaid on the original integrated trajectory in gray. Adjust the threshold to control how many frequency components are retained and observe the tradeoff between fidelity and the number of CSS transforms required.
  </script>
  <script id="13" type="module">
    function fft(x, y) {
      const xfft = ndarray(x.slice());
      const yfft = ndarray(y.slice());
      ndarrayFFT(1, xfft, yfft);
      const scale = (v) => v / n;
      return [xfft.data.map(scale), yfft.data.map(scale)];
    }

    function ifft(re, im) {
      const x = ndarray(re.slice());
      const y = ndarray(im.slice());
      ndarrayFFT(-1, x, y);
      const scale = (v) => v * n;
      return [x.data.map(scale), y.data.map(scale)];
    }

    function fftfreq(i, n, dx) {
      return (i < Math.floor((n + 1) / 2) ? i / (n * dx) : -(n - i) / (n * dx)) * Math.PI * 2;
    }
  </script>
  <script id="33" type="text/x-typescript">
    const selectedConditionsInput = (() => {
      const form = document.createElement('form');
      form.className = 'orbit-selector';

      let currentGroup = 'Šuvakov';
      let currentSequence = 'V - Figure 8';
      let currentOrbit = 'V.1.A';

      const sequencesByGroup = Object.keys(threeBodyInitialConditions).map(group => ({
        label: group,
        options: Object.keys(threeBodyInitialConditions[group]).map(seq => ({
          label: seq,
          value: `${group}: ${seq}`
        }))
      }));

      const seqLabel = document.createElement('label');
      seqLabel.innerHTML = '<small><em>Sequence</em></small><br>';
      const seqSelect = document.createElement('select');
      seqSelect.name = 'sequence';
      sequencesByGroup.forEach(group => {
        const optgroup = document.createElement('optgroup');
        optgroup.label = group.label;
        group.options.forEach(opt => {
          const option = document.createElement('option');
          option.value = opt.value;
          option.textContent = opt.label;
          if (opt.value === `${currentGroup}: ${currentSequence}`) option.selected = true;
          optgroup.appendChild(option);
        });
        seqSelect.appendChild(optgroup);
      });
      seqLabel.appendChild(seqSelect);

      const orbitLabel = document.createElement('label');
      orbitLabel.innerHTML = '<small><em>Orbit</em></small><br>';
      const orbitSelect = document.createElement('select');
      orbitSelect.name = 'orbit';
      orbitLabel.appendChild(orbitSelect);

      function updateOrbitOptions() {
        orbitSelect.innerHTML = '';
        const orbits = Object.keys(threeBodyInitialConditions[currentGroup]?.[currentSequence] || {});
        orbits.forEach(orbit => {
          const option = document.createElement('option');
          option.value = orbit;
          option.textContent = orbit;
          if (orbit === currentOrbit) option.selected = true;
          orbitSelect.appendChild(option);
        });
        if (!orbits.includes(currentOrbit) && orbits.length > 0) {
          currentOrbit = orbits[0];
          orbitSelect.value = currentOrbit;
        }
      }

      updateOrbitOptions();

      const title = document.createElement('div');
      title.innerHTML = '<strong style="font-size:0.9rem">Initial conditions</strong>';
      form.appendChild(title);

      const container = document.createElement('div');
      container.style.cssText = 'display:flex;gap:1em;flex-wrap:wrap;';
      container.appendChild(seqLabel);
      container.appendChild(orbitLabel);
      form.appendChild(container);

      seqSelect.onchange = () => {
        const [group, seq] = seqSelect.value.split(': ');
        currentGroup = group;
        currentSequence = seq;
        updateOrbitOptions();
        currentOrbit = orbitSelect.value;
        form.value = { group: currentGroup, sequence: currentSequence, orbit: currentOrbit };
        form.dispatchEvent(new CustomEvent('input', { bubbles: true }));
      };

      orbitSelect.onchange = () => {
        currentOrbit = orbitSelect.value;
        form.value = { group: currentGroup, sequence: currentSequence, orbit: currentOrbit };
        form.dispatchEvent(new CustomEvent('input', { bubbles: true }));
      };

      form.value = { group: currentGroup, sequence: currentSequence, orbit: currentOrbit };
      return form;
    })();

    display(selectedConditionsInput);
    const selectedConditions = Generators.input(selectedConditionsInput);
  </script>
  <script id="14" type="module">
    const dt = 1 / n;
    const nfft = Math.floor(n / 2) + 1;
    const freq = new Array(n).fill(0).map((_, i) => fftfreq(i, n, 1.0 / n));
    const trajectoryFFT = trajectory.map((orbit) => fft(orbit.x, orbit.y));
    const trajectoryFFTMag = trajectoryFFT.map(([re, im]) =>
      re.map((_, i) => Math.hypot(re[i], im[i]))
    );
  </script>
  <script id="15" type="module">
    const trajectoryFFTMask = trajectoryFFTMag.map((fftMag) =>
      fftMag.map((x) => (x > threshold ? 1 : 0))
    );

    const filteredTrajectoryFFT = trajectoryFFT.map(([re, im], i) => {
      const m = trajectoryFFTMask[i];
      const mask = (x, j) => x * m[j];
      return [re.map(mask), im.map(mask)];
    });

    const filteredTrajectory = filteredTrajectoryFFT.map((orbit) =>
      ifft(orbit[0], orbit[1])
    );
  </script>
  <script id="16" type="module">
    {
      const colors = [colorA, colorB, colorC];

      const originalData = trajectory.flatMap((path, i) => {
        const pts = path.x.map((x, j) => ({ x, y: path.y[j], body: i }));
        pts.push({ x: path.x[0], y: path.y[0], body: i });
        return pts;
      });

      const filteredData = filteredTrajectory.flatMap(([fx, fy], i) => {
        const pts = fx.map((x, j) => ({ x, y: fy[j], body: i }));
        pts.push({ x: fx[0], y: fy[0], body: i });
        return pts;
      });

      // Compute data bounds and enforce equal axis scaling
      const allData = [...originalData, ...filteredData];
      const xExtent = d3.extent(allData, d => d.x);
      const yExtent = d3.extent(allData, d => d.y);
      const plotWidth = Math.min(width, 640);
      const plotHeight = 400;
      const ml = 40, mr = 20, mt = 20, mb = 30;
      const dataW = plotWidth - ml - mr;
      const dataH = plotHeight - mt - mb;
      const xRange = xExtent[1] - xExtent[0];
      const yRange = yExtent[1] - yExtent[0];
      const xCenter = (xExtent[0] + xExtent[1]) / 2;
      const yCenter = (yExtent[0] + yExtent[1]) / 2;
      const scale = Math.max(xRange / dataW, yRange / dataH);
      const pad = 1.05;
      const xDomain = [xCenter - scale * dataW / 2 * pad, xCenter + scale * dataW / 2 * pad];
      const yDomain = [yCenter - scale * dataH / 2 * pad, yCenter + scale * dataH / 2 * pad];

      const plot = Plot.plot({
        width: plotWidth,
        height: plotHeight,
        marginLeft: ml, marginRight: mr, marginTop: mt, marginBottom: mb,
        x: { domain: xDomain },
        y: { domain: yDomain },
        color: { domain: [0, 1, 2], range: colors },
        marks: [
          Plot.line(originalData, {
            x: "x", y: "y", z: "body",
            stroke: "#ccc", strokeWidth: 1.5
          }),
          Plot.line(filteredData, {
            x: "x", y: "y", z: "body", stroke: "body"
          })
        ]
      });

      const figure = document.createElement("figure");
      figure.appendChild(plot);
      const caption = document.createElement("figcaption");
      caption.textContent = "Filtered orbit (colored) overlaid on the integrated trajectory (gray).";
      figure.appendChild(caption);
      display(figure);
    }
  </script>
  <script id="34" type="text/x-typescript">
    const n = view(Inputs.range([10, 10000], {
      label: "Steps",
      transform: Math.log,
      step: 1,
      value: 1000
    }));
  </script>
  <script id="17" type="module">
    const threshold = view(Inputs.range([1e-10, 10], {
      value: 0.0001,
      label: "Threshold",
      transform: Math.log
    }));
  </script>
  <script id="18" type="module">
    {
      let count = 0;
      filteredTrajectoryFFT.forEach(([re, im]) => {
        const thresh2 = threshold * threshold;
        for (let i = 0; i < re.length; i++) {
          const mag2 = re[i] * re[i] + im[i] * im[i];
          if (mag2 >= thresh2) count++;
        }
      });
      display(md`Non-zero frequency components: **${count}**`);
    }
  </script>
  <script id="19" type="module">
    {
      const colors = [colorA, colorB, colorC];
      const plotWidth = Math.min(width, 640);

      // Frequency spectrum data
      const spectrumData = trajectoryFFTMag.flatMap((orbit, i) =>
        orbit.map((mag, j) => ({
          freq: freq[j],
          mag,
          body: i,
          active: trajectoryFFTMask[i][j] === 1
        }))
      );

      const spectrumPlot = Plot.plot({
        width: plotWidth,
        height: 200,
        marginBottom: 30,
        x: { label: "Frequency", domain: [-Math.PI / dt, Math.PI / dt] },
        y: { label: "Magnitude", type: "log" },
        marks: [
          Plot.dot(spectrumData.filter(d => !d.active), {
            x: "freq", y: "mag", fill: "#bbb", r: 2
          }),
          Plot.dot(spectrumData.filter(d => d.active), {
            x: "freq", y: "mag",
            fill: d => colors[d.body],
            r: 2
          }),
          Plot.ruleY([threshold], { stroke: "#888", strokeDasharray: "4,4" })
        ]
      });

      // Error data
      const t = new Array(n).fill(0).map((_, i) => (initialConditions.period * i) / n);
      const errorData = trajectory.flatMap(({ x, y }, i) => {
        const [fx, fy] = filteredTrajectory[i];
        return x.map((xv, j) => ({
          t: t[j],
          error: Math.hypot(xv - fx[j], y[j] - fy[j]),
          body: i
        }));
      });

      const errorPlot = Plot.plot({
        width: plotWidth,
        height: 200,
        marginTop: 20,
        x: { label: "Time" },
        y: { label: "Position error", type: "log", domain: [1e-8, 3] },
        marks: [
          Plot.dot(errorData, {
            x: "t", y: "error", fill: d => colors[d.body], r: 1.5
          })
        ]
      });

      const figure = document.createElement("figure");
      figure.appendChild(spectrumPlot);
      figure.appendChild(errorPlot);
      const caption = document.createElement("figcaption");
      caption.textContent = "Top: frequency components (positive = counterclockwise, negative = clockwise). Bottom: absolute position error of filtered trajectory.";
      figure.appendChild(caption);
      display(figure);
    }
  </script>
  <script id="20" type="text/markdown">
    ## Convert to CSS

    Finally, we convert the filtered frequency components into CSS keyframe animations. Each retained component becomes a nested `rotate` and `translate` transform. The `from` state starts with zero rotation and the `to` state applies the component's frequency as a full rotation, so that the browser interpolates the rotation smoothly over the animation's duration. The result is a pure HTML+CSS animation with no JavaScript at runtime.
  </script>
  <script id="21" type="module">
    const container = document.createElement("div");
    container.id = "spinner-container";
    container.style.border = "1px solid #ddd";
    container.style.display = "inline-block";
    container.innerHTML = threeBodyHTML;
    display(container);
  </script>
  <script id="22" type="module">
    const speed = view(Inputs.range([0.1, 10], {
      value: 1,
      label: "Speed",
      step: 0.01,
      transform: Math.log
    }));
  </script>
  <script id="23" type="module">
    const size = view(Inputs.range([20, 360], {
      value: 256,
      label: "Div size, px",
      step: 1
    }));
  </script>
  <script id="24" type="module">
    const radius = view(Inputs.range([5, 50], {
      value: 20,
      label: "Body radius, px",
      step: 1,
      transform: Math.log
    }));
  </script>
  <script id="25" type="module">
    const precision = view(Inputs.range([0, 5], {
      value: 2,
      label: "Precision, digits",
      step: 1
    }));
  </script>
  <script id="26" type="module">
    const trailCount = view(Inputs.range([0, 12], {
      value: 4,
      label: "Trail segments",
      step: 1
    }));
  </script>
  <script id="27" type="module">
    const trailSpacing = view(Inputs.range([0.01, 0.5], {
      value: 0.05,
      label: "Trail spacing, s",
      step: 0.01,
      transform: Math.log
    }));
  </script>
  <script id="28" type="module">
    const colorA = view(Inputs.color({ value: "#a0d323", label: "Color A" }));
  </script>
  <script id="29" type="module">
    const colorB = view(Inputs.color({ value: "#23a0d3", label: "Color B" }));
  </script>
  <script id="30" type="module">
    const colorC = view(Inputs.color({ value: "#d323a0", label: "Color C" }));
  </script>
  <script id="31" type="module">
    const duration = initialConditions.period / (speed * 2.5);
    let transformCount = 0;
    let range = 0;
    trajectory.forEach(({ x, y }) => {
      for (let i = 0; i < n; i++) {
        range = Math.max(range, Math.abs(x[i]), Math.abs(y[i]));
      }
    });

    const css = [];
    for (let i = 0; i < filteredTrajectoryFFT.length; i++) {
      const fftData = filteredTrajectoryFFT[i];
      const len = fftData[0].length;
      const nfft = Math.floor((len + 1) / 2);
      const froms = [];
      const tos = [];

      function unitize(value, units) {
        return parseFloat(value) === 0 ? value : `${value}${units}`;
      }
      let accumRotation = 0;
      function assemble(intfreq, idx) {
        const f = freq[idx];
        const re = fftData[0][idx];
        const im = fftData[1][idx];
        const r2 = re * re + im * im;
        const rad = (size * 0.4) / range;
        const fmt = precision === 0 ? "%.0f" : `%.${precision}g`;
        const x = sprintf(fmt, parseFloat((re * rad).toFixed(precision)));
        const y = sprintf(fmt, parseFloat((im * rad).toFixed(precision)));
        if (Math.hypot(parseFloat(x), parseFloat(y)) === 0) return;
        if (r2 < threshold * threshold) return;
        const rotDiff = intfreq - accumRotation;
        accumRotation += rotDiff;
        function translate(x, y) {
          x = unitize(x, "px");
          y = unitize(y, "px");
          if (x === "0") return `translatey(${y})`;
          if (y === "0") return `translatex(${x})`;
          return `translate(${x},${y})`;
        }
        const tr = translate(x, y);
        froms.push(`rotate(0)${tr}`);
        tos.push(`rotate(${rotDiff}turn)${tr}`);
      }

      for (let j = nfft - 1; j > 0; j--) {
        assemble(-j, len - j);
      }
      for (let j = 0; j < nfft; j++) {
        assemble(j, j);
      }
      transformCount += froms.length;
      css.push([froms.join(""), tos.join("")]);
    }

    const elemsPerBody = 1 + trailCount;
    const totalElems = 3 * elemsPerBody;
    const bodyColors = [colorA, colorB, colorC];

    // Per-body CSS rules: assign animation-name + color to each element
    const bodyRules = [];
    for (let b = 0; b < 3; b++) {
      for (let t = 0; t < elemsPerBody; t++) {
        const idx = b * elemsPerBody + t + 1; // 1-based nth-child
        const opacity = t === 0 ? 1 : (1 - t / elemsPerBody).toFixed(2);
        const delay = t === 0 ? '' : `animation-delay:${(t * trailSpacing / speed).toFixed(3)}s;`;
        const trailRadius = t === 0 ? radius : Math.max(2, radius * (1 - 0.4 * t / elemsPerBody));
        const sizeRule = (trailRadius !== radius) ? `width:${trailRadius.toFixed(1)}px;height:${trailRadius.toFixed(1)}px;` : '';
        bodyRules.push(`.threebody-o>div:nth-child(${idx}){background:${bodyColors[b]};animation-name:threebody-${b};opacity:${opacity};${delay}}`);
        if (sizeRule) {
          bodyRules.push(`.threebody-o>div:nth-child(${idx}):after{${sizeRule}}`);
        }
      }
    }

    // Mass-based radius overrides (only for the lead element of unequal-mass bodies)
    const massRadiusRules = initialConditions.m
      .map((m, i) => {
        if (m === 1) return "";
        const r = (radius * Math.sqrt(m) + 0.5).toFixed(0);
        const idx = i * elemsPerBody + 1;
        return `.threebody-o>div:nth-child(${idx}):after{width:${r}px;height:${r}px}`;
      })
      .filter((x) => x)
      .join("\n");

    // Generate child divs
    const divs = new Array(totalElems).fill("<div></div>").join("");

    const threeBodyHTML = `<style>
    .threebody{width:${size}px;height:${size}px;position:relative}
    .threebody-o{position:absolute;top:50%;left:50%}
    .threebody-o>div{position:absolute;animation:${duration}s infinite linear}
    .threebody-o>div:after{content:'';position:absolute;width:${radius}px;height:${radius}px;border-radius:100%;transform:translate(-50%,-50%);background:inherit}
    ${bodyRules.join("\n")}
    ${massRadiusRules}
    ${css.map(([from, to], i) => `@keyframes threebody-${i}{from{transform:${from}}to{transform:${to}}}`).join("\n")}
    </style>
    <div class="threebody"><div class="threebody-o">${divs}</div></div>`;

    display(md`Total bytes (HTML + CSS): **${threeBodyHTML.length}** bytes
    Total CSS rotation transforms: **${transformCount}**`);

    {
      const { collapseCodeBlocks } = await import('./lib/collapsible-code.js');
      const pre = document.createElement("pre");
      const code = document.createElement("code");
      code.textContent = threeBodyHTML;
      pre.appendChild(code);
      display(pre);
      collapseCodeBlocks({ maxHeight: 300, skip: ['cell-3'] });
    }
  </script>
  <script id="32" type="module">
    display(html`<style>
      .orbit-selector select {
        margin-top: 0.25em;
      }
    </style>`);
  </script>
</notebook>
