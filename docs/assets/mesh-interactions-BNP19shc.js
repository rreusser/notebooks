import{vec3 as o,mat4 as a}from"https://cdn.jsdelivr.net/npm/gl-matrix@3.4.3/+esm";class f{constructor(e,t,s,h={}){this.element=e,this.mesh=t,this.controller=s,this.camera=s.camera,this.projectionView=s.projectionView,this.selectedVertexIndex=-1,this.hoverVertexIndex=-1,this.activeVertexIndex=-1,this.isDragging=!1,this.dragMode=null,this.initialMousePos=[0,0],this.currentMousePos=[0,0],this.previousMousePos=[0,0],this.deadZoneRadius=5,this.exitedDeadZone=!1,this.touchStartedOnVertex=!1,this.touchVertexIndex=-1,this.candidateEdge=null,this.dirty=!0,this.onChange=h.onChange||(()=>{}),this._onMouseDown=this._onMouseDown.bind(this),this._onMouseMove=this._onMouseMove.bind(this),this._onMouseUp=this._onMouseUp.bind(this),this._onClick=this._onClick.bind(this),this._onKeyDown=this._onKeyDown.bind(this),this._onKeyUp=this._onKeyUp.bind(this),this._onTouchStart=this._onTouchStart.bind(this),this._onTouchMove=this._onTouchMove.bind(this),this._onTouchEnd=this._onTouchEnd.bind(this),this._setup()}_setup(){const e=this.element;e.tabIndex=1,e.style.outline="none",e.addEventListener("mousedown",this._onMouseDown),e.addEventListener("mousemove",this._onMouseMove),e.addEventListener("click",this._onClick),e.addEventListener("keydown",this._onKeyDown),e.addEventListener("keyup",this._onKeyUp),e.addEventListener("touchstart",this._onTouchStart,{passive:!1}),e.addEventListener("touchmove",this._onTouchMove,{passive:!1}),e.addEventListener("touchend",this._onTouchEnd)}destroy(){const e=this.element;e.removeEventListener("mousedown",this._onMouseDown),e.removeEventListener("mousemove",this._onMouseMove),e.removeEventListener("click",this._onClick),e.removeEventListener("keydown",this._onKeyDown),e.removeEventListener("keyup",this._onKeyUp),e.removeEventListener("touchstart",this._onTouchStart),e.removeEventListener("touchmove",this._onTouchMove),e.removeEventListener("touchend",this._onTouchEnd),window.removeEventListener("mousemove",this._onMouseMove),window.removeEventListener("mouseup",this._onMouseUp)}_getMousePos(e,t=[0,0]){const s=this.element.getBoundingClientRect();return t[0]=e.clientX-s.left,t[1]=e.clientY-s.top,t}_insideDeadZone(){const e=this.currentMousePos[0]-this.initialMousePos[0],t=this.currentMousePos[1]-this.initialMousePos[1];return Math.sqrt(e*e+t*t)<this.deadZoneRadius}_getClosestVertex(e,t){const s=this.mesh,h=this.projectionView,n=this.element.offsetWidth,r=this.element.offsetHeight,i=o.create();let d=-1,u=1/0;for(let c=0;c<s.vertexCount;c++){const M=s.getPosition(c);if(o.transformMat4(i,M,h),i[2]<-1||i[2]>1)continue;const V=(.5+.5*i[0])*n,p=(.5-.5*i[1])*r,x=e-V,l=t-p,g=Math.sqrt(x*x+l*l);g<u&&(u=g,d=c)}return{index:d,distance:u}}_onMouseDown(e){this._getMousePos(e,this.initialMousePos),this.currentMousePos[0]=this.initialMousePos[0],this.currentMousePos[1]=this.initialMousePos[1],this.previousMousePos[0]=this.initialMousePos[0],this.previousMousePos[1]=this.initialMousePos[1],this.exitedDeadZone=!1;const t=this._getClosestVertex(this.initialMousePos[0],this.initialMousePos[1]);t.index>=0&&t.distance<25&&(e.preventDefault(),e.stopPropagation(),e.stopImmediatePropagation(),this.element.focus(),this.selectedVertexIndex>=0&&this.selectedVertexIndex!==t.index&&(this.candidateEdge=[this.selectedVertexIndex,t.index]),this.activeVertexIndex=t.index,this.selectedVertexIndex=t.index,this.dragMode="vertex",this.element.style.cursor="move",this.isDragging=!0,this.dirty=!0,window.addEventListener("mousemove",this._onMouseMove),window.addEventListener("mouseup",this._onMouseUp))}_onMouseMove(e){if(this.previousMousePos[0]=this.currentMousePos[0],this.previousMousePos[1]=this.currentMousePos[1],this._getMousePos(e,this.currentMousePos),!this.isDragging){const t=this._getClosestVertex(this.currentMousePos[0],this.currentMousePos[1]),s=t.index>=0&&t.distance<25?t.index:-1;s!==this.hoverVertexIndex&&(this.hoverVertexIndex=s,this.element.style.cursor=s>=0?"move":"grab",this.dirty=!0);return}!this.exitedDeadZone&&!this._insideDeadZone()&&(this.exitedDeadZone=!0),this.dragMode==="vertex"&&this.exitedDeadZone&&this._dragVertex()}_onMouseUp(e){if(window.removeEventListener("mousemove",this._onMouseMove),window.removeEventListener("mouseup",this._onMouseUp),!!this.isDragging){if(this._getMousePos(e,this.currentMousePos),!this.exitedDeadZone&&this._insideDeadZone()){const t=this._getClosestVertex(this.currentMousePos[0],this.currentMousePos[1]);this.dragMode==="vertex"&&(t.index>=0&&t.distance<25?(this.candidateEdge&&this.mesh.addEdge(this.candidateEdge[0],this.candidateEdge[1]),this.selectedVertexIndex=t.index):this.selectedVertexIndex>=0&&this._spawnVertex())}this.isDragging=!1,this.dragMode=null,this.activeVertexIndex=-1,this.candidateEdge=null,this.element.style.cursor=this.hoverVertexIndex>=0?"move":"grab",this.dirty=!0,this.onChange()}}_onClick(e){const t=this._getMousePos(e),s=this._getClosestVertex(t[0],t[1]);s.index>=0&&s.distance<25?(this.selectedVertexIndex=s.index,this.element.focus(),this.dirty=!0):this.selectedVertexIndex>=0&&(this.mesh.degree(this.selectedVertexIndex)<3?(this.currentMousePos[0]=t[0],this.currentMousePos[1]=t[1],this._spawnVertex(),this.element.focus()):(this.selectedVertexIndex=-1,this.dirty=!0)),this.onChange()}_getTouchPos(e,t=[0,0]){const s=this.element.getBoundingClientRect();return t[0]=e.clientX-s.left,t[1]=e.clientY-s.top,t}_onTouchStart(e){if(e.touches.length!==1){this.touchStartedOnVertex=!1,this.touchVertexIndex=-1;return}const t=this._getTouchPos(e.touches[0]),s=this._getClosestVertex(t[0],t[1]);s.index>=0&&s.distance<35?(e.stopImmediatePropagation(),e.preventDefault(),this.touchStartedOnVertex=!0,this.touchVertexIndex=s.index,this.initialMousePos[0]=t[0],this.initialMousePos[1]=t[1],this.currentMousePos[0]=t[0],this.currentMousePos[1]=t[1],this.exitedDeadZone=!1,this.selectedVertexIndex>=0&&this.selectedVertexIndex!==s.index&&(this.candidateEdge=[this.selectedVertexIndex,s.index]),this.activeVertexIndex=s.index,this.selectedVertexIndex=s.index,this.isDragging=!0,this.dragMode="vertex",this.dirty=!0):(this.touchStartedOnVertex=!1,this.touchVertexIndex=-1)}_onTouchMove(e){if(!this.touchStartedOnVertex||e.touches.length!==1)return;e.preventDefault(),e.stopImmediatePropagation();const t=this._getTouchPos(e.touches[0]);this.previousMousePos[0]=this.currentMousePos[0],this.previousMousePos[1]=this.currentMousePos[1],this.currentMousePos[0]=t[0],this.currentMousePos[1]=t[1],!this.exitedDeadZone&&!this._insideDeadZone()&&(this.exitedDeadZone=!0),this.exitedDeadZone&&this.activeVertexIndex>=0&&this._dragVertex()}_onTouchEnd(e){if(this.touchStartedOnVertex&&e.touches.length===0){if(!this.exitedDeadZone&&this._insideDeadZone()){const t=this._getClosestVertex(this.currentMousePos[0],this.currentMousePos[1]);t.index>=0&&t.distance<35&&(this.candidateEdge&&this.mesh.addEdge(this.candidateEdge[0],this.candidateEdge[1]),this.selectedVertexIndex=t.index)}this.touchStartedOnVertex=!1,this.touchVertexIndex=-1,this.isDragging=!1,this.dragMode=null,this.activeVertexIndex=-1,this.candidateEdge=null,this.dirty=!0,this.onChange()}}_onKeyDown(e){switch(e.code){case"Space":case"Backspace":e.preventDefault(),e.stopPropagation();break}}_onKeyUp(e){switch(e.code){case"Backspace":if(this.selectedVertexIndex>=0){const t=this.mesh.deleteVertex(this.selectedVertexIndex);this.selectedVertexIndex=t,this.hoverVertexIndex=-1,this.activeVertexIndex=-1,this.dirty=!0,e.preventDefault(),e.stopPropagation()}break;case"Space":this.selectedVertexIndex=-1,this.activeVertexIndex=-1,this.dirty=!0,e.preventDefault(),e.stopPropagation();break;case"KeyC":if(this.selectedVertexIndex>=0){const t=this.mesh.collapseVertex(this.selectedVertexIndex);this.selectedVertexIndex=t,this.hoverVertexIndex=-1,this.activeVertexIndex=-1,this.dirty=!0,e.preventDefault(),e.stopPropagation()}break;case"KeyS":if(this.selectedVertexIndex>=0){const t=this.mesh.splitVertex(this.selectedVertexIndex);this.selectedVertexIndex=t,this.hoverVertexIndex=-1,this.activeVertexIndex=-1,this.dirty=!0,e.preventDefault(),e.stopPropagation()}break;case"KeyE":if(this.selectedVertexIndex>=0){const t=this.mesh.explodeVertex(this.selectedVertexIndex);this.selectedVertexIndex=t,this.hoverVertexIndex=-1,this.activeVertexIndex=-1,this.dirty=!0,e.preventDefault(),e.stopPropagation()}break;case"KeyA":if(this.selectedVertexIndex>=0){const t=this.mesh.getPosition(this.selectedVertexIndex);o.copy(this.camera.center,t)}else{const t=this.mesh.computeCentroid();o.copy(this.camera.center,t)}this.dirty=!0,e.preventDefault(),e.stopPropagation();break}this.onChange()}_dragVertex(){const e=this.element.offsetWidth,t=this.element.offsetHeight,s=this.projectionView,h=this.mesh.getPosition(this.activeVertexIndex),n=o.create();o.transformMat4(n,h,s),n[0]=2*this.currentMousePos[0]/e-1,n[1]=1-2*this.currentMousePos[1]/t;const r=a.create();a.invert(r,s);const i=o.create();o.transformMat4(i,n,r),this.mesh.setPosition(this.activeVertexIndex,i[0],i[1],i[2]),this.dirty=!0}_spawnVertex(){if(this.mesh.degree(this.selectedVertexIndex)>=3)return;const e=this.element.offsetWidth,t=this.element.offsetHeight,s=this.projectionView,h=this.mesh.getPosition(this.selectedVertexIndex),n=o.create();o.transformMat4(n,h,s),n[0]=2*this.currentMousePos[0]/e-1,n[1]=1-2*this.currentMousePos[1]/t;const r=a.create();a.invert(r,s);const i=o.create();o.transformMat4(i,n,r);const d=this.mesh.addVertex(i[0],i[1],i[2]);this.mesh.addEdge(this.selectedVertexIndex,d),this.selectedVertexIndex=d,this.dirty=!0}}export{f as MeshInteractions,f as default};
