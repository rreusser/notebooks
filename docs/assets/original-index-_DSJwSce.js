const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/pipeline-B5gOFiyC.js","assets/fft-CcaOZiHL.js","assets/execute-Cl-DJhJU.js","assets/buffers-GrqrZRML.js"])))=>i.map(i=>d[i]);
import{d,_ as E}from"./index-ByB2dbry.js";d({root:document.getElementById("cell-1"),expanded:[],variables:[]},{id:1,body:(e,n)=>e`
This notebook implements a GPU-accelerated solver for the two-dimensional [Kuramoto-Sivashinsky equation](https://encyclopediaofmath.org/wiki/Kuramoto-Sivashinsky_equation) using **WebGPU compute shaders**.

The KSE is one of the simplest PDEs to exhibit chaotic behavior:

${n.block`u_t + \frac{1}{2}|\nabla u|^2 + \nabla^2 u + \nabla^4 u = 0`}

## Key Improvements over WebGL

This WebGPU implementation offers significant performance improvements:
- **FFT**: 4 passes vs 16 passes per 2D transform (using Stockham algorithm)
- **Compute shaders**: Process entire scanlines instead of individual pixels
- **Expected speedup**: 3-5x faster than WebGL implementation

## Implementation

The solution uses a 2nd-order Backward Differentiation Formula (BDF2) in the spatial frequency domain, following [A. Kalogirou's thesis](https://spiral.imperial.ac.uk/bitstream/10044/1/25067/1/Kalogirou-A-2013-PhD-Thesis.pdf), Appendix F.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});d({root:document.getElementById("cell-2"),expanded:[],variables:[]},{id:2,body:async(e,n)=>{const{isWebGPUAvailable:t}=await E(()=>import("./webgpu-context-BoQcYhON.js"),[]).then(a=>{if(!("isWebGPUAvailable"in a))throw new SyntaxError("export 'isWebGPUAvailable' not found");return a});return t()||e(n`<div style="color: #a00; padding: 16px; border: 2px solid #a00; border-radius: 4px; margin: 16px 0;">
    <strong>WebGPU Not Available</strong><br>
    This notebook requires WebGPU support. Please use a compatible browser (Chrome 113+, Edge 113+, or Safari 18+).
  </div>`),{isWebGPUAvailable:t}},inputs:["display","html"],outputs:["isWebGPUAvailable"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});d({root:document.getElementById("cell-3"),expanded:[],variables:[]},{id:3,body:async e=>{const{createWebGPUContext:n}=await E(()=>import("./webgpu-context-BoQcYhON.js"),[]).then(o=>{if(!("createWebGPUContext"in o))throw new SyntaxError("export 'createWebGPUContext' not found");return o}),t=await n(),a=t.device,i=t.adapter;return e.then(()=>{a.destroy()}),{createWebGPUContext:n,context:t,device:a,adapter:i}},inputs:["invalidation"],outputs:["createWebGPUContext","context","device","adapter"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});d({root:document.getElementById("cell-4"),expanded:[],variables:[]},{id:4,body:()=>({N:[256,256]}),inputs:[],outputs:["N"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});d({root:document.getElementById("cell-5"),expanded:[],variables:[]},{id:5,body:(e,n,t,a)=>{const i=e(n.range([1,t[0]/2],{step:.01,value:64,label:a`Horizontal domain size, <i>L<sub>x</sub></i>`})),o=e(n.range([.1,10],{step:.01,value:1,label:a`Aspect ratio, <i>L<sub>x</sub>/L<sub>y</sub></i>`}));return{Lx:i,aspectRatio:o}},inputs:["view","Inputs","N","html"],outputs:["Lx","aspectRatio"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});d({root:document.getElementById("cell-21"),expanded:[],variables:[]},{id:21,body:(e,n)=>({L:[e,e/n]}),inputs:["Lx","aspectRatio"],outputs:["L"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});d({root:document.getElementById("cell-6"),expanded:[],variables:[]},{id:6,body:(e,n,t)=>{const a=[Math.pow(Math.PI/e[0],2),Math.pow(Math.PI/e[1],2)];return n(t`<div style="margin: 12px 0;">
  The factors ν₁ and ν₂ describe the length scale relative to domain size.
  Chaotic behavior occurs when they are very small.
  <div style="margin-top: 8px; font-family: monospace;">
    ν₁ = (π/L<sub>x</sub>)² = ${a[0].toFixed(6)}<br>
    ν₂ = (π/L<sub>y</sub>)² = ${a[1].toFixed(6)}
  </div>
</div>`),{nu:a}},inputs:["L","display","html"],outputs:["nu"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});d({root:document.getElementById("cell-7"),expanded:[],variables:[]},{id:7,body:(e,n,t)=>{const a=e(n.checkbox(["Simulate"],{value:["Simulate"]})),i=e(n.range([.001,.2],{step:.001,value:.18,label:t`Time step, Δt/ν₁`})),o=e(n.range([1,8],{step:1,value:1,label:"Initial condition periods, n"})),r=e(n.button("Restart"));return{simulate:a,dt:i,n:o,restart:r}},inputs:["view","Inputs","html"],outputs:["simulate","dt","n","restart"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});d({root:document.getElementById("cell-8"),expanded:[],variables:[]},{id:8,body:(e,n)=>{const t=e(n.range([-16,16],{step:.1,value:[0,1],label:"Colorscale range"})),a=e(n.select(["Magma","Viridis","Cividis","Inferno","Plasma","Greys","RdBu"],{value:"Magma",label:"Color scale"})),i=e(n.checkbox(["invert colorscale"],{value:[]}));return{range:t,colorscaleName:a,invert:i}},inputs:["view","Inputs"],outputs:["range","colorscaleName","invert"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});d({root:document.getElementById("cell-9"),expanded:[],variables:[]},{id:9,body:(e,n,t)=>{const a=e`<canvas width="512" height="${512/n}" style="width: 100%; max-width: 512px; height: auto; image-rendering: pixelated;"></canvas>`;return a.height=Math.floor(512/n),t(a),{canvas:a}},inputs:["html","aspectRatio","display"],outputs:["canvas"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});d({root:document.getElementById("cell-10"),expanded:[],variables:[]},{id:10,body:async(e,n,t)=>{const{createSimulationBuffers:a,destroySimulationBuffers:i}=await E(()=>import("./buffers-GrqrZRML.js"),[]).then(r=>{if(!("createSimulationBuffers"in r))throw new SyntaxError("export 'createSimulationBuffers' not found");if(!("destroySimulationBuffers"in r))throw new SyntaxError("export 'destroySimulationBuffers' not found");return r}),o=a({N:e,device:n});return t.then(()=>{i(o)}),{createSimulationBuffers:a,destroySimulationBuffers:i,buffers:o}},inputs:["N","device","invalidation"],outputs:["createSimulationBuffers","destroySimulationBuffers","buffers"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});d({root:document.getElementById("cell-11"),expanded:[],variables:[]},{id:11,body:async(e,n,t)=>{const{createKSPipelines:a}=await E(()=>import("./pipeline-B5gOFiyC.js"),__vite__mapDeps([0,1])).then(r=>{if(!("createKSPipelines"in r))throw new SyntaxError("export 'createKSPipelines' not found");return r}),i=navigator.gpu.getPreferredCanvasFormat(),o=await a(e,i);return o.initialize?n(t`<div style="color: green; font-size: 13px; margin: 8px 0;">
    ✓ All pipelines created successfully
  </div>`):n(t`<div style="color: red; padding: 8px; background: #fee; border-radius: 4px; margin: 8px 0;">
    <strong>Pipeline Error:</strong> Initialize pipeline was not created!
  </div>`),{createKSPipelines:a,canvasFormat:i,pipelines:o}},inputs:["device","display","html"],outputs:["createKSPipelines","canvasFormat","pipelines"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});d({root:document.getElementById("cell-12"),expanded:[],variables:[]},{id:12,body:(e,n,t,a)=>{function i(r,c){const m=e.quantize(c,256),p=new Uint8Array(256*4);for(let s=0;s<256;s++){const l=e.rgb(m[s]);p[s*4+0]=l.r,p[s*4+1]=l.g,p[s*4+2]=l.b,p[s*4+3]=255}const x=r.createTexture({size:[256,1,1],format:"rgba8unorm",usage:n.TEXTURE_BINDING|n.COPY_DST});return r.queue.writeTexture({texture:x},p,{bytesPerRow:256*4},{width:256,height:1}),x}const o={Magma:i(t,e.interpolateMagma),Viridis:i(t,e.interpolateViridis),Cividis:i(t,e.interpolateCividis),Inferno:i(t,e.interpolateInferno),Plasma:i(t,e.interpolatePlasma),Greys:i(t,e.interpolateGreys),RdBu:i(t,e.interpolateRdBu)};return a.then(()=>{Object.values(o).forEach(r=>r.destroy())}),{createColorscaleTexture:i,colorscales:o}},inputs:["d3","GPUTextureUsage","device","invalidation"],outputs:["createColorscaleTexture","colorscales"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});d({root:document.getElementById("cell-13"),expanded:[],variables:[]},{id:13,body:e=>({sampler:e.createSampler({magFilter:"linear",minFilter:"linear",addressModeU:"clamp-to-edge"})}),inputs:["device"],outputs:["sampler"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});d({root:document.getElementById("cell-14"),expanded:[],variables:[]},{id:14,body:async(e,n,t,a,i,o,r,c,v,m,p)=>{const{performInitialization:x}=await E(()=>import("./execute-Cl-DJhJU.js"),__vite__mapDeps([2,3,1])).then(f=>{if(!("performInitialization"in f))throw new SyntaxError("export 'performInitialization' not found");return f}),s=[2*Math.PI/t[0],2*Math.PI/t[1]],l=a*i[0],g={device:o,pipelines:r,buffers:c,config:{N:t,dx:s,dt:l,nu:i}};o.pushErrorScope("validation"),o.pushErrorScope("out-of-memory"),await x(g,v);const y=await o.popErrorScope(),b=await o.popErrorScope();return y&&m(p`<div style="color: red; padding: 8px; background: #fee; border-radius: 4px; margin: 8px 0;">
    <strong>Validation Error:</strong> ${y.message}
  </div>`),b&&m(p`<div style="color: red; padding: 8px; background: #fee; border-radius: 4px; margin: 8px 0;">
    <strong>Out of Memory Error:</strong> ${b.message}
  </div>`),m(p`<div style="color: #666; font-size: 13px; margin: 8px 0;">
  ✓ Simulation initialized with n=${v}<br>
  Expected value range: approximately [-3, 3]<br>
  <strong>Tip:</strong> Adjust colorscale range to [-4, 4] to see initial pattern clearly
</div>`),console.log("[Cell 14] Initialization complete, declaring initialized=true"),{performInitialization:x,dx:s,scaledDt:l,ctx:g,validationError:y,oomError:b,initialized:!0}},inputs:["restart","Lx","N","dt","nu","device","pipelines","buffers","n","display","html"],outputs:["performInitialization","dx","scaledDt","ctx","validationError","oomError","initialized"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});d({root:document.getElementById("cell-15"),expanded:[],variables:[]},{id:15,body:async(e,n,t,a,i,o,r)=>{await n.queue.onSubmittedWorkDone();const c=n.createBuffer({size:256*256*2*Float32Array.BYTES_PER_ELEMENT,usage:t.MAP_READ|t.COPY_DST}),v=n.createCommandEncoder();v.copyBufferToBuffer(a.V[0],0,c,0,c.size),n.queue.submit([v.finish()]),await n.queue.onSubmittedWorkDone(),await c.mapAsync(i.READ);const m=new Float32Array(c.getMappedRange()),p=[],x=[0,128,256,1e3,5e3,1e4,3e4,5e4,6e4,65535];for(const u of x)p.push({idx:u,real:m[u*2],imag:m[u*2+1]});let s=1/0,l=-1/0,g=0,y=0;for(let u=0;u<256*256;u++){const f=m[u*2];f<s&&(s=f),f>l&&(l=f),g+=f,Math.abs(f)>1e-4&&y++}const b=g/(256*256);return c.unmap(),c.destroy(),o(r`<div style="font-family: monospace; font-size: 12px; background: #f5f5f5; padding: 12px; margin: 8px 0; border-radius: 4px;">
  <strong>V[0] Buffer Debug:</strong><br>
  Min: ${s.toFixed(4)}, Max: ${l.toFixed(4)}, Mean: ${b.toFixed(4)}<br>
  Non-zero values: ${y} / ${256*256}<br>
  <br>
  Samples at specific indices (real, imag):<br>
  ${p.map(u=>`[${u.idx}]: (${u.real.toFixed(4)}, ${u.imag.toFixed(4)})`).join("<br>")}
  <br><br>
  ${s===0&&l===0?'<span style="color: red;">⚠️ All zeros - initialization compute shader did not run!</span>':'<span style="color: green;">✓ Buffer has data</span>'}
</div>`),{stagingBuffer:c,encoder:v,data:m,samples:p,positions:x,min:s,max:l,sum:g,nonZeroCount:y,mean:b}},inputs:["ctx","device","GPUBufferUsage","buffers","GPUMapMode","display","html"],outputs:["stagingBuffer","encoder","data","samples","positions","min","max","sum","nonZeroCount","mean"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});d({root:document.getElementById("cell-16"),expanded:[],variables:[]},{id:16,body:(e,n,t,a,i,o,r,c,v,m,p,x,s)=>{console.log("[Cell 16] Starting render loop setup after initialization complete");const l=n.getContext("webgpu");l.configure({device:t,format:navigator.gpu.getPreferredCanvasFormat()}),console.log("[Cell 16] Canvas context configured");const g=t.createBuffer({size:32,usage:a.UNIFORM|a.COPY_DST});let y=null,b=null,u=null,f=null,B=0,w=null;function I(){B===0&&console.log("[Render] First frame executing");const S=!b||b[0]!==i[0]||b[1]!==i[1],_=!u||u!==o.includes("invert colorscale");if(S||_){const h=new Uint32Array(8);h[0]=r[0],h[1]=r[1],new Float32Array(h.buffer)[2]=i[0],new Float32Array(h.buffer)[3]=i[1],h[4]=o.includes("invert colorscale")?1:0,t.queue.writeBuffer(g,0,h),b=[i[0],i[1]],u=o.includes("invert colorscale")}(!f||y!==c)&&(y=c,f=t.createBindGroup({layout:v.bindGroupLayouts.visualize,entries:[{binding:0,resource:{buffer:m.V[0]}},{binding:1,resource:{buffer:g}},{binding:2,resource:p[c].createView()},{binding:3,resource:x}]}));const C=l.getCurrentTexture().createView(),z=t.createCommandEncoder(),P=z.beginRenderPass({colorAttachments:[{view:C,loadOp:"clear",storeOp:"store",clearValue:{r:0,g:0,b:0,a:1}}]});P.setPipeline(v.visualize),P.setBindGroup(0,f),P.draw(3,1,0,0),P.end(),t.queue.submit([z.finish()]),B++,w=requestAnimationFrame(I)}return console.log("[Cell 16] Starting requestAnimationFrame loop"),w=requestAnimationFrame(I),s.then(()=>{w!==null&&cancelAnimationFrame(w),g.destroy()}),{ctx2d:l,visualizeParamsBuffer:g,currentColorscale:y,currentRange:b,currentInvert:u,visualizeBindGroup:f,frameCount:B,frameId:w,render:I}},inputs:["initialized","canvas","device","GPUBufferUsage","range","invert","N","colorscaleName","pipelines","buffers","colorscales","sampler","invalidation"],outputs:["ctx2d","visualizeParamsBuffer","currentColorscale","currentRange","currentInvert","visualizeBindGroup","frameCount","frameId","render"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});
