const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/pipeline-DLROI3QM.js","assets/fft-Chkx7JT6.js"])))=>i.map(i=>d[i]);
import{d as v,_ as q}from"./index-ByB2dbry.js";v({root:document.getElementById("cell-2"),expanded:[],variables:[]},{id:2,body:async n=>{const{createWebGPUContext:e}=await q(()=>import("./webgpu-context-CA7EEXHP.js"),[]).then(u=>{if(!("createWebGPUContext"in u))throw new SyntaxError("export 'createWebGPUContext' not found");return u}),t=await e(),a=t.device,o=navigator.gpu.getPreferredCanvasFormat();return n.then(()=>a.destroy()),{createWebGPUContext:e,context:t,device:a,canvasFormat:o}},inputs:["invalidation"],outputs:["createWebGPUContext","context","device","canvasFormat"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-3"),expanded:[],variables:[]},{id:3,body:(n,e)=>{const t=n.select([64,128,256,512,1024,2048],{value:512,label:"Resolution",format:o=>`${o}Ã—${o}`}),a=e(t);return{resolutionInput:t,resolution:a}},inputs:["Inputs","view"],outputs:["resolutionInput","resolution"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-4"),expanded:[],variables:[]},{id:4,body:n=>{const e=n,t=e*e*2*4,a=e*e*4*4,o=Math.ceil(e/16),u=1/e;return{N:e,vec2Size:t,vec4Size:a,workgroups:o,dx:u}},inputs:["resolution"],outputs:["N","vec2Size","vec4Size","workgroups","dx"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-5"),expanded:[],variables:[]},{id:5,body:async(n,e,t)=>{const[{createFluidPipelines:a},{executeFFT2D:o}]=await Promise.all([q(()=>import("./pipeline-DLROI3QM.js"),__vite__mapDeps([0,1])).then(s=>{if(!("createFluidPipelines"in s))throw new SyntaxError("export 'createFluidPipelines' not found");return s}),q(()=>import("./fft-Chkx7JT6.js"),[]).then(s=>{if(!("executeFFT2D"in s))throw new SyntaxError("export 'executeFFT2D' not found");return s})]),u=await a(n,e,t);function c(s,y,l,p){o({device:n,pipelines:u.fft,input:s,output:y,temp:l,N:t,forward:p,splitNormalization:!0})}return{createFluidPipelines:a,executeFFT2D:o,pipelines:u,runFFT2D:c}},inputs:["device","canvasFormat","N"],outputs:["createFluidPipelines","executeFFT2D","pipelines","runFFT2D"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-6"),expanded:[],variables:[]},{id:6,body:(n,e,t,a,o)=>{const u=n.STORAGE|n.COPY_SRC|n.COPY_DST,c=e.createBuffer({label:"velocity",size:t,usage:u}),s=e.createBuffer({label:"velocityTemp",size:t,usage:u}),y=e.createBuffer({label:"u",size:a,usage:u}),l=e.createBuffer({label:"v",size:a,usage:u}),p=e.createBuffer({label:"uHat",size:a,usage:u}),m=e.createBuffer({label:"vHat",size:a,usage:u}),F=[0,1].map(w=>e.createBuffer({label:`fftTemp[${w}]`,size:a,usage:u})),B=e.createBuffer({label:"dye",size:a,usage:u}),h=e.createBuffer({label:"dyeTemp",size:a,usage:u}),b=o*o*4,i=e.createBuffer({label:"vorticity",size:b,usage:u});return{bufferUsage:u,velocity:c,velocityTemp:s,uBuffer:y,vBuffer:l,uHat:p,vHat:m,fftTemp:F,dye:B,dyeTemp:h,vorticitySize:b,vorticityBuffer:i}},inputs:["GPUBufferUsage","device","vec4Size","vec2Size","N"],outputs:["bufferUsage","velocity","velocityTemp","uBuffer","vBuffer","uHat","vHat","fftTemp","dye","dyeTemp","vorticitySize","vorticityBuffer"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-7"),expanded:[],variables:[]},{id:7,body:(n,e,t)=>{const a=n.createBuffer({label:"simParams",size:32,usage:e.UNIFORM|e.COPY_DST}),o=n.createBuffer({label:"forceParams",size:48,usage:e.UNIFORM|e.COPY_DST}),u=n.createBuffer({label:"projectParams",size:16,usage:e.UNIFORM|e.COPY_DST});n.queue.writeBuffer(u,0,new Uint32Array([t,t]));const c=n.createBuffer({label:"visParams",size:24,usage:e.UNIFORM|e.COPY_DST}),s=n.createBuffer({label:"vorticityParams",size:16,usage:e.UNIFORM|e.COPY_DST}),y=n.createBuffer({label:"boundaryParams",size:24,usage:e.UNIFORM|e.COPY_DST}),l=n.createBuffer({label:"buoyancyParams",size:16,usage:e.UNIFORM|e.COPY_DST});return{simParamsBuffer:a,forceParamsBuffer:o,projectParamsBuffer:u,visParamsBuffer:c,vorticityParamsBuffer:s,boundaryParamsBuffer:y,buoyancyParamsBuffer:l}},inputs:["device","GPUBufferUsage","N"],outputs:["simParamsBuffer","forceParamsBuffer","projectParamsBuffer","visParamsBuffer","vorticityParamsBuffer","boundaryParamsBuffer","buoyancyParamsBuffer"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-8"),expanded:[],variables:[]},{id:8,body:(n,e)=>{const t=n.range([1e-5,.01],{step:1e-5,value:15e-5,transform:Math.log,label:"Viscosity"}),a=e(t),o=n.range([.9,1],{step:.001,value:.99,label:"Dye persistence"}),u=e(o),c=n.range([.01,.15],{step:.005,value:.03,label:"Force radius"}),s=e(c),y=n.range([0,1],{step:.01,value:.5,label:"Force damping"}),l=e(y),p=n.range([0,50],{step:.1,value:20,label:"Vorticity confinement"}),m=e(p),F=n.range([-5,5],{step:.01,value:5,label:"Buoyancy"}),B=e(F),h=n.range([0,10],{step:1,value:5,label:"Wall thickness (cells)"}),b=e(h),i=n.checkbox(["Top/bottom","Left/right"],{label:"Walls"}),w=e(i),g=n.range([.001,.05],{step:.001,value:1/60,label:"Timestep (dt)"}),T=e(g),I=n.select(["Interactive","Rayleigh-Taylor","Kelvin-Helmholtz"],{value:"Rayleigh-Taylor",label:"Initial conditions"}),P=e(I),A=n.range([1,16],{step:1,value:8,label:"Perturbation periods"}),x=e(A),C=n.range([.001,.05],{step:.001,value:.005,label:"Perturbation amplitude"}),k=e(C),_=n.button("Restart"),D=e(_),$=n.toggle({label:"Simulate",value:!0}),G=e($);return{viscosityInput:t,viscosity:a,dyeDecayInput:o,dyeDecay:u,forceRadiusInput:c,forceRadius:s,forceDampingInput:y,forceDamping:l,vorticityInput:p,vorticityConfinement:m,buoyancyInput:F,buoyancy:B,wallThicknessInput:h,wallThickness:b,wallsEnabledInput:i,wallsEnabled:w,timestepInput:g,timestep:T,initialConditionInput:I,initialCondition:P,perturbationPeriodsInput:A,perturbationPeriods:x,perturbationAmplitudeInput:C,perturbationAmplitude:k,restartInput:_,restart:D,simulateInput:$,simulate:G}},inputs:["Inputs","view"],outputs:["viscosityInput","viscosity","dyeDecayInput","dyeDecay","forceRadiusInput","forceRadius","forceDampingInput","forceDamping","vorticityInput","vorticityConfinement","buoyancyInput","buoyancy","wallThicknessInput","wallThickness","wallsEnabledInput","wallsEnabled","timestepInput","timestep","initialConditionInput","initialCondition","perturbationPeriodsInput","perturbationPeriods","perturbationAmplitudeInput","perturbationAmplitude","restartInput","restart","simulateInput","simulate"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-9"),expanded:[],variables:[]},{id:9,body:(n,e,t,a,o,u,c,s,y,l,p,m,F,B,h,b,i)=>{n(e`<div id="fluid-controls">
  ${t}
  ${a}
  ${o}
  ${u}
  ${c}
  ${s}
  ${y}
  ${l}
  ${p}
  ${m}
  ${F}
  ${B}
  ${h}
  ${b}
  ${i}
</div>`)},inputs:["display","html","resolutionInput","initialConditionInput","perturbationPeriodsInput","perturbationAmplitudeInput","restartInput","simulateInput","viscosityInput","dyeDecayInput","timestepInput","forceRadiusInput","forceDampingInput","vorticityInput","buoyancyInput","wallThicknessInput","wallsEnabledInput"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-10"),expanded:[],variables:[]},{id:10,body:(n,e,t,a,o)=>{const u=Math.min(n,640),c=e`<canvas
  id="fluid-canvas"
  width="${u*window.devicePixelRatio}"
  height="${u*window.devicePixelRatio}"
  style="width: ${u}px; height: ${u}px; cursor: crosshair;">
</canvas>`,s=c.getContext("webgpu");return s.configure({device:t,format:a,alphaMode:"opaque"}),o(c),{canvasSize:u,canvas:c,gpuContext:s}},inputs:["width","html","device","canvasFormat","display"],outputs:["canvasSize","canvas","gpuContext"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-11"),expanded:[],variables:[]},{id:11,body:n=>{const e={down:!1,x:0,y:0,prevX:0,prevY:0,dx:0,dy:0};function t(a){const o=n.getBoundingClientRect();return{x:(a.clientX-o.left)/o.width,y:(a.clientY-o.top)/o.height}}return n.addEventListener("pointerdown",a=>{e.down=!0;const o=t(a);e.x=o.x,e.y=o.y,e.prevX=o.x,e.prevY=o.y,n.setPointerCapture(a.pointerId)}),n.addEventListener("pointermove",a=>{const o=t(a);e.prevX=e.x,e.prevY=e.y,e.x=o.x,e.y=o.y,e.down&&(e.dx=e.x-e.prevX,e.dy=e.y-e.prevY)}),n.addEventListener("pointerup",a=>{e.down=!1,e.dx=0,e.dy=0,n.releasePointerCapture(a.pointerId)}),n.addEventListener("pointerleave",()=>{e.down=!1,e.dx=0,e.dy=0}),n.addEventListener("touchstart",a=>a.preventDefault(),{passive:!1}),n.addEventListener("touchmove",a=>a.preventDefault(),{passive:!1}),{mouseState:e,getMousePos:t}},inputs:["canvas"],outputs:["mouseState","getMousePos"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-12"),expanded:[],variables:[]},{id:12,body:()=>({simParams:{viscosity:5e-5,dyeDecay:.998,forceRadius:.03,forceDamping:.15,vorticityConfinement:2,buoyancy:5,wallThicknessX:0,wallThicknessY:0,dt:.016666666666666666}}),inputs:[],outputs:["simParams"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-13"),expanded:[],variables:[]},{id:13,body:(n,e,t,a,o,u,c,s,y,l)=>{l.viscosity=n,l.dyeDecay=e,l.dt=y,l.forceRadius=t,l.forceDamping=a,l.vorticityConfinement=o,l.buoyancy=u,l.wallThicknessX=s.includes("Left/right")?c:0,l.wallThicknessY=s.includes("Top/bottom")?c:0},inputs:["viscosity","dyeDecay","forceRadius","forceDamping","vorticityConfinement","buoyancy","wallThickness","wallsEnabled","timestep","simParams"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-14"),expanded:[],variables:[]},{id:14,body:(n,e,t,a,o,u)=>{n==="Rayleigh-Taylor"?(e.value=5,e.dispatchEvent(new t("input")),a.value=["Top/bottom"],a.dispatchEvent(new t("input")),o.value=1,o.dispatchEvent(new t("input")),u.value=.5,u.dispatchEvent(new t("input"))):n==="Kelvin-Helmholtz"&&(e.value=5,e.dispatchEvent(new t("input")),a.value=["Top/bottom"],a.dispatchEvent(new t("input")),o.value=1,o.dispatchEvent(new t("input")))},inputs:["initialCondition","wallThicknessInput","Event","wallsEnabledInput","dyeDecayInput","buoyancyInput"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-15"),expanded:[],variables:[]},{id:15,body:(n,e,t,a,o,u,c,s,y,l)=>{const p=new Float32Array(o*o*4),m=new Float32Array(o*o*2);if(e==="Interactive")p.fill(0),m.fill(0);else if(e==="Rayleigh-Taylor")for(let B=0;B<o;B++)for(let h=0;h<o;h++){const b=B*o+h,i=h/o,w=B/o,g=.5+a*Math.sin(2*Math.PI*t*i);if(w<g){const T=(g-w)/.03,I=Math.min(1,T);m[b*2]=I,m[b*2+1]=0}else m[b*2]=0,m[b*2+1]=0;p[b*4]=0,p[b*4+1]=0,p[b*4+2]=0,p[b*4+3]=0}else if(e==="Kelvin-Helmholtz")for(let h=0;h<o;h++)for(let b=0;b<o;b++){const i=h*o+b,w=b/o,g=h/o,T=.5+a*Math.sin(2*Math.PI*t*w),I=(g-T)/.1,P=Math.tanh(I)*.5;if(p[i*4]=P,p[i*4+1]=0,p[i*4+2]=a*Math.sin(2*Math.PI*t*w)*Math.exp(-I*I),p[i*4+3]=0,g<T){const A=(T-g)/.03,x=Math.min(1,A);m[i*2]=x,m[i*2+1]=0}else m[i*2]=0,m[i*2+1]=0}return u.queue.writeBuffer(c,0,p),u.queue.writeBuffer(s,0,p),u.queue.writeBuffer(y,0,m),u.queue.writeBuffer(l,0,m),{velocityData:p,dyeData:m}},inputs:["restart","initialCondition","perturbationPeriods","perturbationAmplitude","N","device","velocity","velocityTemp","dye","dyeTemp"],outputs:["velocityData","dyeData"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-16"),expanded:[],variables:[]},{id:16,body:(n,e,t,a,o,u,c,s,y,l)=>{function p(){const i=new ArrayBuffer(32);new Uint32Array(i,0,2).set([n,n]),new Float32Array(i,8,1).set([e.dt]),new Float32Array(i,12,1).set([e.viscosity]),new Float32Array(i,16,1).set([e.dyeDecay]),new Float32Array(i,20,1).set([e.wallThicknessX]),new Float32Array(i,24,1).set([e.wallThicknessY]),t.queue.writeBuffer(a,0,i)}function m(){const i=o.dx/e.dt,w=-o.dy/e.dt,g=new ArrayBuffer(48);new Uint32Array(g,0,2).set([n,n]),new Float32Array(g,8,2).set([o.x,1-o.y]),new Float32Array(g,16,2).set([i,w]),new Float32Array(g,24,1).set([e.forceRadius]),new Float32Array(g,28,1).set([o.down?1:0]),new Float32Array(g,32,1).set([e.forceDamping]),t.queue.writeBuffer(u,0,g)}function F(){const i=new ArrayBuffer(24);new Uint32Array(i,0,2).set([n,n]),new Float32Array(i,8,1).set([1]),new Float32Array(i,12,1).set([0]),new Float32Array(i,16,1).set([e.wallThicknessX]),new Float32Array(i,20,1).set([e.wallThicknessY]),t.queue.writeBuffer(c,0,i)}function B(){const i=new ArrayBuffer(16);new Uint32Array(i,0,2).set([n,n]),new Float32Array(i,8,1).set([e.vorticityConfinement]),new Float32Array(i,12,1).set([e.dt]),t.queue.writeBuffer(s,0,i)}function h(){const i=new ArrayBuffer(24);new Uint32Array(i,0,2).set([n,n]),new Float32Array(i,8,1).set([0]),new Float32Array(i,12,1).set([e.wallThicknessX]),new Float32Array(i,16,1).set([e.wallThicknessY]),t.queue.writeBuffer(y,0,i)}function b(){const i=new ArrayBuffer(16);new Uint32Array(i,0,2).set([n,n]),new Float32Array(i,8,1).set([e.buoyancy]),new Float32Array(i,12,1).set([e.dt]),t.queue.writeBuffer(l,0,i)}return{updateSimUniforms:p,updateForceUniforms:m,updateVisUniforms:F,updateVorticityUniforms:B,updateBoundaryUniforms:h,updateBuoyancyUniforms:b}},inputs:["N","simParams","device","simParamsBuffer","mouseState","forceParamsBuffer","visParamsBuffer","vorticityParamsBuffer","boundaryParamsBuffer","buoyancyParamsBuffer"],outputs:["updateSimUniforms","updateForceUniforms","updateVisUniforms","updateVorticityUniforms","updateBoundaryUniforms","updateBuoyancyUniforms"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-17"),expanded:[],variables:[]},{id:17,body:(n,e,t,a,o,u,c,s,y,l,p,m,F,B,h,b,i,w,g,T,I,P,A,x,C,k,_,D,$,G,R)=>{function E(){if(n.wallThicknessX>0||n.wallThicknessY>0){e();const f=t.createBindGroup({layout:a.bindGroupLayouts.enforceBoundary,entries:[{binding:0,resource:{buffer:o}},{binding:1,resource:{buffer:u}},{binding:2,resource:{buffer:c}}]}),d=t.createCommandEncoder(),r=d.beginComputePass();r.setPipeline(a.enforceBoundary),r.setBindGroup(0,f),r.dispatchWorkgroups(s,s),r.end(),t.queue.submit([d.finish()])}}async function z(){y(),l(),E();{const f=t.createBindGroup({layout:a.bindGroupLayouts.addForce,entries:[{binding:0,resource:{buffer:o}},{binding:1,resource:{buffer:u}},{binding:2,resource:{buffer:p}}]}),d=t.createCommandEncoder(),r=d.beginComputePass();r.setPipeline(a.addForce),r.setBindGroup(0,f),r.dispatchWorkgroups(s,s),r.end(),t.queue.submit([d.finish()])}{const f=t.createBindGroup({layout:a.bindGroupLayouts.advect,entries:[{binding:0,resource:{buffer:o}},{binding:1,resource:{buffer:o}},{binding:2,resource:{buffer:m}},{binding:3,resource:{buffer:F}}]}),d=t.createCommandEncoder(),r=d.beginComputePass();r.setPipeline(a.advectVelocity),r.setBindGroup(0,f),r.dispatchWorkgroups(s,s),r.end(),t.queue.submit([d.finish()])}{const f=t.createCommandEncoder();f.copyBufferToBuffer(m,0,o,0,B),t.queue.submit([f.finish()])}E();{const f=t.createBindGroup({layout:a.bindGroupLayouts.advectScalar,entries:[{binding:0,resource:{buffer:o}},{binding:1,resource:{buffer:u}},{binding:2,resource:{buffer:h}},{binding:3,resource:{buffer:F}}]}),d=t.createCommandEncoder(),r=d.beginComputePass();r.setPipeline(a.advectScalar),r.setBindGroup(0,f),r.dispatchWorkgroups(s,s),r.end(),t.queue.submit([d.finish()])}{const f=t.createCommandEncoder();f.copyBufferToBuffer(h,0,u,0,b),t.queue.submit([f.finish()])}{const f=t.createBindGroup({layout:a.bindGroupLayouts.splitVelocity,entries:[{binding:0,resource:{buffer:o}},{binding:1,resource:{buffer:i}},{binding:2,resource:{buffer:w}},{binding:3,resource:{buffer:g}}]}),d=t.createCommandEncoder(),r=d.beginComputePass();r.setPipeline(a.splitVelocity),r.setBindGroup(0,f),r.dispatchWorkgroups(s,s),r.end(),t.queue.submit([d.finish()])}T(i,I,P,!0),T(w,A,P,!0);{const f=t.createBindGroup({layout:a.bindGroupLayouts.projectFFT,entries:[{binding:0,resource:{buffer:I}},{binding:1,resource:{buffer:A}},{binding:2,resource:{buffer:F}}]}),d=t.createCommandEncoder(),r=d.beginComputePass();r.setPipeline(a.projectFFT),r.setBindGroup(0,f),r.dispatchWorkgroups(s,s),r.end(),t.queue.submit([d.finish()])}T(I,i,P,!1),T(A,w,P,!1);{const f=t.createBindGroup({layout:a.bindGroupLayouts.mergeVelocity,entries:[{binding:0,resource:{buffer:i}},{binding:1,resource:{buffer:w}},{binding:2,resource:{buffer:o}},{binding:3,resource:{buffer:g}}]}),d=t.createCommandEncoder(),r=d.beginComputePass();r.setPipeline(a.mergeVelocity),r.setBindGroup(0,f),r.dispatchWorkgroups(s,s),r.end(),t.queue.submit([d.finish()])}if(E(),n.vorticityConfinement>0){x();{const f=t.createBindGroup({layout:a.bindGroupLayouts.computeVorticity,entries:[{binding:0,resource:{buffer:o}},{binding:1,resource:{buffer:C}},{binding:2,resource:{buffer:k}}]}),d=t.createCommandEncoder(),r=d.beginComputePass();r.setPipeline(a.computeVorticity),r.setBindGroup(0,f),r.dispatchWorkgroups(s,s),r.end(),t.queue.submit([d.finish()])}{const f=t.createBindGroup({layout:a.bindGroupLayouts.applyVorticity,entries:[{binding:0,resource:{buffer:o}},{binding:1,resource:{buffer:C}},{binding:2,resource:{buffer:k}}]}),d=t.createCommandEncoder(),r=d.beginComputePass();r.setPipeline(a.applyVorticity),r.setBindGroup(0,f),r.dispatchWorkgroups(s,s),r.end(),t.queue.submit([d.finish()])}}if(n.buoyancy!==0){_();const f=t.createBindGroup({layout:a.bindGroupLayouts.applyBuoyancy,entries:[{binding:0,resource:{buffer:o}},{binding:1,resource:{buffer:u}},{binding:2,resource:{buffer:D}}]}),d=t.createCommandEncoder(),r=d.beginComputePass();r.setPipeline(a.applyBuoyancy),r.setBindGroup(0,f),r.dispatchWorkgroups(s,s),r.end(),t.queue.submit([d.finish()])}E()}function S(){$();const f=t.createBindGroup({layout:a.bindGroupLayouts.visualize,entries:[{binding:0,resource:{buffer:o}},{binding:1,resource:{buffer:u}},{binding:2,resource:{buffer:G}}]}),d=t.createCommandEncoder(),r=d.beginRenderPass({colorAttachments:[{view:R.getCurrentTexture().createView(),loadOp:"clear",storeOp:"store",clearValue:{r:0,g:0,b:0,a:1}}]});r.setPipeline(a.visualize),r.setBindGroup(0,f),r.draw(6),r.end(),t.queue.submit([d.finish()])}return{enforceBoundaries:E,step:z,render:S}},inputs:["simParams","updateBoundaryUniforms","device","pipelines","velocity","dye","boundaryParamsBuffer","workgroups","updateSimUniforms","updateForceUniforms","forceParamsBuffer","velocityTemp","simParamsBuffer","vec4Size","dyeTemp","vec2Size","uBuffer","vBuffer","projectParamsBuffer","runFFT2D","uHat","fftTemp","vHat","updateVorticityUniforms","vorticityBuffer","vorticityParamsBuffer","updateBuoyancyUniforms","buoyancyParamsBuffer","updateVisUniforms","visParamsBuffer","gpuContext"],outputs:["enforceBoundaries","step","render"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-18"),expanded:[],variables:[]},{id:18,body:(n,e,t,a,o,u)=>{let c=null,s=!1;async function y(){if(!s)try{a&&await n(),e(),o.dx=0,o.dy=0,c=requestAnimationFrame(y)}catch(l){s=!0,console.error("Animation loop error:",l)}}return c=requestAnimationFrame(y),u.then(()=>{s=!0,c!==null&&(cancelAnimationFrame(c),c=null)}),{animFrameId:c,hasError:s,animationLoop:y}},inputs:["step","render","canvas","simulate","mouseState","invalidation"],outputs:["animFrameId","hasError","animationLoop"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-19"),expanded:[],variables:[]},{id:19,body:(n,e)=>n`## Algorithm

The Stable Fluids algorithm solves the incompressible Navier-Stokes equations:

${e.block`\frac{\partial \mathbf{u}}{\partial t} = -(\mathbf{u} \cdot \nabla)\mathbf{u} + \nu \nabla^2 \mathbf{u} - \nabla p + \mathbf{f}`}

subject to the incompressibility constraint ${e`\nabla \cdot \mathbf{u} = 0`}.

Each timestep consists of four stages:

1. **Add forces**: Apply external forces (mouse input) to the velocity field
2. **Advect**: Move the velocity field along itself using semi-Lagrangian advection
3. **Diffuse**: Apply viscous diffusion (done in frequency domain as multiplication)
4. **Project**: Make velocity divergence-free by subtracting the gradient of pressure

The key insight is that projection can be done efficiently in frequency domain. The velocity ${e`\hat{\mathbf{u}}(\mathbf{k})`} is decomposed into components parallel and perpendicular to the wavenumber ${e`\mathbf{k}`}. The divergence-free projection removes the parallel component:

${e.block`\hat{\mathbf{u}}_{\perp} = \hat{\mathbf{u}} - \mathbf{k}\frac{\mathbf{k} \cdot \hat{\mathbf{u}}}{|\mathbf{k}|^2}`}

This makes the algorithm unconditionally stable regardless of timestep size.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});v({root:document.getElementById("cell-20"),expanded:[],variables:[]},{id:20,body:(n,e)=>n`## Implementation Details

### Grid Layout

Velocities are **cell-centered** (collocated), not staggered. Cell ${e`(i,j)`} stores both velocity components ${e`(u, v)`} at physical position ${e`(i+0.5, j+0.5)`}. Velocity is stored as \`vec4<f32>\` with layout \`(u_re, u_im, v_re, v_im)\` to accommodate FFT operations. In the spatial domain, the imaginary parts are zero.

### Simulation Loop

Each timestep executes these stages in order:

1. **Add forces** (mouse interaction)
2. **Advect velocity** (semi-Lagrangian)
3. **Advect dye**
4. **Project + diffuse** (FFT-based)
5. **Vorticity confinement**
6. **Buoyancy**
7. **Boundary enforcement**

### FFT-Based Projection and Diffusion

The FFT is used to efficiently solve the pressure projection and diffusion in frequency domain:

1. **Split** the interleaved velocity into separate ${e`u`} and ${e`v`} complex buffers
2. **Forward FFT** on both components
3. **Project and diffuse** in frequency domain:
   - Compute wavenumber ${e`\mathbf{k}`} with frequencies ${e`0, 1, \ldots, N/2-1, -N/2, \ldots, -1`} scaled by ${e`2\pi`}
   - Remove component parallel to ${e`\mathbf{k}`}: ${e.block`\hat{u} \leftarrow \hat{u} - k_x \frac{\mathbf{k} \cdot \hat{\mathbf{u}}}{|\mathbf{k}|^2}, \quad \hat{v} \leftarrow \hat{v} - k_y \frac{\mathbf{k} \cdot \hat{\mathbf{u}}}{|\mathbf{k}|^2}`}
   - Apply implicit diffusion by multiplying by ${e`\frac{1}{1 + \nu |\mathbf{k}|^2 \Delta t}`}
   - Zero the DC component (${e`\mathbf{k} = 0`})
4. **Inverse FFT** to return to spatial domain
5. **Merge** back into interleaved velocity buffer

### Forcing Model

The force uses a **velocity-matching model** rather than direct impulse injection:

${e.block`\mathbf{f} = (\mathbf{v}_{\text{target}} - \mathbf{v}) \cdot \text{damping} \cdot \text{falloff}`}

where ${e`\mathbf{v}_{\text{target}} = \Delta\mathbf{x}_{\text{mouse}} / \Delta t`} is computed from mouse velocity, and the falloff is Gaussian: ${e`\exp(-r^2 / 2\sigma^2)`}.

Dye injection uses a **hard circle** (step function) rather than Gaussian for sharper smoke edges.

### Semi-Lagrangian Advection

For each grid cell, trace backward through the velocity field to find the departure point:

${e.block`\mathbf{x}_{\text{back}} = \mathbf{x} - \mathbf{u}(\mathbf{x}) \cdot N \cdot \Delta t`}

Then sample the source field at ${e`\mathbf{x}_{\text{back}}`} using **monotone cubic interpolation** (Fedkiw et al., "Visual Simulation of Smoke", SIGGRAPH 2001). The factor of ${e`N`} converts velocity from normalized to grid units.

The monotone cubic interpolation uses Hermite interpolation with slope limiting to prevent overshoot:

${e.block`f(t) = a_3 t^3 + a_2 t^2 + a_1 t + a_0`}

where the slopes ${e`d_k = (f_{k+1} - f_{k-1})/2`} are set to zero when they differ in sign from ${e`\Delta_k = f_{k+1} - f_k`}. This preserves monotonicity and eliminates spurious oscillations that can arise with standard cubic interpolation.

### Vorticity Confinement

Two-pass process to counteract numerical dissipation of rotational motion:

**Pass 1**: Compute vorticity (curl) using central differences:
${e.block`\omega = \frac{\partial v}{\partial x} - \frac{\partial u}{\partial y}`}

**Pass 2**: Apply confinement force in the direction perpendicular to the vorticity gradient:
${e.block`\mathbf{N} = \frac{\nabla|\omega|}{|\nabla|\omega||}, \quad \mathbf{f} = \varepsilon (\mathbf{N} \times \omega)`}

In 2D, the cross product gives ${e`\mathbf{f} = \varepsilon (N_y \omega, -N_x \omega)`}. This force points toward vortex centers, amplifying rotational structures.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});
