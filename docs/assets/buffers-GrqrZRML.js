function S(a){const{N:t,device:e}=a,[f,s]=t,u=f*s*2*Float32Array.BYTES_PER_ELEMENT,n=f*s*2*Float32Array.BYTES_PER_ELEMENT,o=f*s*4*Float32Array.BYTES_PER_ELEMENT,c=f*s*4*Float32Array.BYTES_PER_ELEMENT,i=[0,1,2].map(r=>e.createBuffer({label:`V[${r}] buffer (spatial domain)`,size:u,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC})),U=[0,1,2].map(r=>e.createBuffer({label:`Vhat[${r}] buffer (frequency domain)`,size:n,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC})),B=[0,1].map(r=>e.createBuffer({label:`ABhat[${r}] buffer (nonlinear terms)`,size:o,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC})),P=[0,1].map(r=>e.createBuffer({label:`FFT temp[${r}] buffer`,size:c,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC})),l=e.createBuffer({label:"Simulation parameters",size:64,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),E=e.createBuffer({label:"FFT parameters",size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});return{V:i,Vhat:U,ABhat:B,fftTemp:P,params:l,fftParams:E}}function g(a){a.V.forEach(t=>t.destroy()),a.Vhat.forEach(t=>t.destroy()),a.ABhat.forEach(t=>t.destroy()),a.fftTemp.forEach(t=>t.destroy()),a.params.destroy(),a.fftParams.destroy()}function T(a){const t=a[0];for(let e=0;e<a.length-1;e++)a[e]=a[e+1];a[a.length-1]=t}function G(a,t,e){const f=new Float32Array([e.dx[0],e.dx[1],e.dt,0,e.nu[0],e.nu[1],0,0]);a.queue.writeBuffer(t,0,f)}function d(a,t,e){const f=new Uint32Array([e.N,e.direction===1?1:4294967295]);a.queue.writeBuffer(t,0,f)}export{S as createSimulationBuffers,T as cycleBuffers,g as destroySimulationBuffers,d as updateFFTParams,G as updateSimulationParams};
