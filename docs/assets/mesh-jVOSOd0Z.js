class P{constructor(){this.positions=new Float32Array(0),this.vertexCount=0,this._positionCapacity=0,this.neighbors=new Int32Array(0),this.edges=new Uint32Array(0),this.edgeCount=0,this._edgeCapacity=0,this._faces=null}static fromJSON(t){const s=new P,{vertices:i,edges:e}=t;s._ensureVertexCapacity(i.length),s._ensureEdgeCapacity(e.length);for(const n of i)s._addVertexInternal(n[0],n[1],n[2]);for(const n of e)s._addEdgeInternal(n[0],n[1]);return s}toJSON(){const t=[];for(let i=0;i<this.vertexCount;i++){const e=i*3;t.push([this.positions[e],this.positions[e+1],this.positions[e+2]])}const s=[];for(let i=0;i<this.edgeCount;i++){const e=i*2;s.push([this.edges[e],this.edges[e+1]])}return{vertices:t,edges:s}}clone(){return P.fromJSON(this.toJSON())}_ensureVertexCapacity(t){if(t<=this._positionCapacity)return;const s=Math.max(t,this._positionCapacity*2,64),i=new Float32Array(s*3);this.positions.length>0&&i.set(this.positions),this.positions=i;const e=new Int32Array(s*3);e.fill(-1),this.neighbors.length>0&&e.set(this.neighbors),this.neighbors=e,this._positionCapacity=s}_ensureEdgeCapacity(t){if(t<=this._edgeCapacity)return;const s=Math.max(t,this._edgeCapacity*2,64),i=new Uint32Array(s*2);this.edges.length>0&&i.set(this.edges),this.edges=i,this._edgeCapacity=s}_addVertexInternal(t,s,i){this._ensureVertexCapacity(this.vertexCount+1);const e=this.vertexCount,n=e*3;return this.positions[n]=t,this.positions[n+1]=s,this.positions[n+2]=i,this.neighbors[n]=-1,this.neighbors[n+1]=-1,this.neighbors[n+2]=-1,this.vertexCount++,e}_addEdgeInternal(t,s){this._ensureEdgeCapacity(this.edgeCount+1);const i=this.edgeCount,e=i*2;return this.edges[e]=t,this.edges[e+1]=s,this.edgeCount++,this._addNeighbor(t,s),this._addNeighbor(s,t),i}_addNeighbor(t,s){const i=t*3;for(let e=0;e<3;e++)if(this.neighbors[i+e]===-1)return this.neighbors[i+e]=s,!0;throw new Error(`Vertex ${t} already has 3 neighbors`)}_removeNeighbor(t,s){const i=t*3;for(let e=0;e<3;e++)if(this.neighbors[i+e]===s)return this.neighbors[i+e]=-1,this._compactNeighbors(t),!0;return!1}_compactNeighbors(t){const s=t*3,i=[this.neighbors[s],this.neighbors[s+1],this.neighbors[s+2]].filter(e=>e!==-1);this.neighbors[s]=i[0]??-1,this.neighbors[s+1]=i[1]??-1,this.neighbors[s+2]=i[2]??-1}addVertex(t,s,i){return this._faces=null,this._addVertexInternal(t,s,i)}getPosition(t,s=[0,0,0]){const i=t*3;return s[0]=this.positions[i],s[1]=this.positions[i+1],s[2]=this.positions[i+2],s}setPosition(t,s,i,e){const n=t*3;this.positions[n]=s,this.positions[n+1]=i,this.positions[n+2]=e}degree(t){const s=t*3;let i=0;return this.neighbors[s]!==-1&&i++,this.neighbors[s+1]!==-1&&i++,this.neighbors[s+2]!==-1&&i++,i}getNeighbors(t,s=[]){const i=t*3;return s.length=0,this.neighbors[i]!==-1&&s.push(this.neighbors[i]),this.neighbors[i+1]!==-1&&s.push(this.neighbors[i+1]),this.neighbors[i+2]!==-1&&s.push(this.neighbors[i+2]),s}getNeighbor(t,s){return this.neighbors[t*3+s]}deleteVertex(t){if(t<0||t>=this.vertexCount)return-1;this._faces=null;const s=t*3;let i=this.neighbors[s];const e=this.getNeighbors(t);for(const o of e)this._removeEdgeBetween(t,o);const n=this.vertexCount-1;if(t!==n){const o=n*3;this.positions[s]=this.positions[o],this.positions[s+1]=this.positions[o+1],this.positions[s+2]=this.positions[o+2],this.neighbors[s]=this.neighbors[o],this.neighbors[s+1]=this.neighbors[o+1],this.neighbors[s+2]=this.neighbors[o+2],this._remapVertex(n,t),i===n&&(i=t)}return this.vertexCount--,i>=this.vertexCount&&(i=-1),i}_removeEdgeBetween(t,s){for(let i=0;i<this.edgeCount;i++){const e=i*2,n=this.edges[e],o=this.edges[e+1];if(n===t&&o===s||n===s&&o===t){const h=this.edgeCount-1;i!==h&&(this.edges[e]=this.edges[h*2],this.edges[e+1]=this.edges[h*2+1]),this.edgeCount--;break}}this._removeNeighbor(t,s),this._removeNeighbor(s,t)}_remapVertex(t,s){for(let i=0;i<this.vertexCount;i++){const e=i*3;for(let n=0;n<3;n++)this.neighbors[e+n]===t&&(this.neighbors[e+n]=s)}for(let i=0;i<this.edgeCount;i++){const e=i*2;this.edges[e]===t&&(this.edges[e]=s),this.edges[e+1]===t&&(this.edges[e+1]=s)}}addEdge(t,s){return this.hasEdge(t,s)||this.degree(t)>=3||this.degree(s)>=3?-1:(this._faces=null,this._addEdgeInternal(t,s))}hasEdge(t,s){const i=t*3;return this.neighbors[i]===s||this.neighbors[i+1]===s||this.neighbors[i+2]===s}getEdge(t,s=[0,0]){const i=t*2;return s[0]=this.edges[i],s[1]=this.edges[i+1],s}deleteEdge(t){if(t<0||t>=this.edgeCount)return!1;this._faces=null;const s=t*2,i=this.edges[s],e=this.edges[s+1];this._removeNeighbor(i,e),this._removeNeighbor(e,i);const n=this.edgeCount-1;return t!==n&&(this.edges[s]=this.edges[n*2],this.edges[s+1]=this.edges[n*2+1]),this.edgeCount--,!0}stoneWales(t){if(t<0||t>=this.edgeCount)return-1;const s=this.getEdge(t),i=s[0],e=s[1];if(this.degree(i)!==3||this.degree(e)!==3)return-1;const n=this.getNeighbors(i).filter(y=>y!==e),o=this.getNeighbors(e).filter(y=>y!==i);if(n.length!==2||o.length!==2)return-1;const h=n[0],r=n[1],c=o[0],g=o[1],l=this.getPosition(i),u=this.getPosition(e),m=this.getPosition(h);this.getPosition(r);const w=this.getPosition(c),N=this.getPosition(g),f=[u[0]-l[0],u[1]-l[1],u[2]-l[2]],a=[l[0]-m[0],l[1]-m[1],l[2]-m[2]],d=[f[1]*a[2]-f[2]*a[1],f[2]*a[0]-f[0]*a[2],f[0]*a[1]-f[1]*a[0]],p=[d[1]*f[2]-d[2]*f[1],d[2]*f[0]-d[0]*f[2],d[0]*f[1]-d[1]*f[0]],b=[w[0]-u[0],w[1]-u[1],w[2]-u[2]],C=[N[0]-u[0],N[1]-u[1],N[2]-u[2]],V=b[0]*p[0]+b[1]*p[1]+b[2]*p[2],A=C[0]*p[0]+C[1]*p[1]+C[2]*p[2];let _,E;return V>A?(_=h,E=c):(_=h,E=g),this._removeEdgeBetween(i,_),this._removeEdgeBetween(e,E),this._addEdgeInternal(i,E),this._addEdgeInternal(e,_),this._faces=null,this.findEdge(i,e)}findEdge(t,s){for(let i=0;i<this.edgeCount;i++){const e=i*2,n=this.edges[e],o=this.edges[e+1];if(n===t&&o===s||n===s&&o===t)return i}return-1}collapseVertex(t){if(this.degree(t)!==2)return t;this._faces=null;const s=this.neighbors[t*3],i=this.neighbors[t*3+1];this.deleteVertex(t);let e=s,n=i;const o=this.vertexCount;return s===o&&(e=t<o?t:s),i===o&&(n=t<o?t:i),s===this.vertexCount&&t<this.vertexCount&&(e=t),i===this.vertexCount&&t<this.vertexCount&&(n=t),e>=0&&n>=0&&e<this.vertexCount&&n<this.vertexCount&&this.addEdge(e,n),e>=0&&e<this.vertexCount?e:-1}splitVertex(t){if(this.degree(t)!==2)return t;this._faces=null;const s=this.neighbors[t*3],i=this.getPosition(t),e=this.getPosition(s),n=this.addVertex(.5*(i[0]+e[0]),.5*(i[1]+e[1]),.5*(i[2]+e[2]));return this._removeEdgeBetween(t,s),this._addEdgeInternal(t,n),this._addEdgeInternal(n,s),n}explodeVertex(t){const s=this.getNeighbors(t);if(s.length<=1)return t;this._faces=null;const i=this.getPosition(t);for(let e=1;e<s.length;e++){const n=s[e],o=this.addVertex(i[0],i[1],i[2]);this._removeEdgeBetween(t,n),this._addEdgeInternal(o,n)}return t}computeCentroid(t=[0,0,0]){t[0]=0,t[1]=0,t[2]=0;for(let s=0;s<this.vertexCount;s++){const i=s*3;t[0]+=this.positions[i],t[1]+=this.positions[i+1],t[2]+=this.positions[i+2]}return this.vertexCount>0&&(t[0]/=this.vertexCount,t[1]/=this.vertexCount,t[2]/=this.vertexCount),t}translate(t,s,i){for(let e=0;e<this.vertexCount;e++){const n=e*3;this.positions[n]+=t,this.positions[n+1]+=s,this.positions[n+2]+=i}}center(){const t=this.computeCentroid();this.translate(-t[0],-t[1],-t[2])}_findAllCycles(t=8){const s=new Set,i=this;function e(n){const o=Math.min(...n),h=n.indexOf(o),r=[...n.slice(h),...n.slice(0,h)],c=[r[0],...r.slice(1).reverse()],g=r.join(","),l=c.join(",");return g<l?g:l}for(let n=0;n<this.vertexCount;n++){let o=function(h,r,c){if(!(r.length>t))for(const g of i.getNeighbors(h))g===n&&r.length>=3?s.add(e(r)):g>n&&!c.has(g)&&(c.add(g),r.push(g),o(g,r,c),r.pop(),c.delete(g))};o(n,[n],new Set([n]))}return[...s].map(n=>n.split(",").map(Number))}extractAllFaces(t=8){const s=this._findAllCycles(t);s.sort((n,o)=>n.length-o.length);const i=new Map,e=[];for(const n of s){let o=!0;const h=[];for(let r=0;r<n.length;r++){const c=n[r],g=n[(r+1)%n.length],l=c<g?`${c},${g}`:`${g},${c}`;if(h.push(l),(i.get(l)||0)>=2){o=!1;break}}if(o){e.push(n);for(const r of h)i.set(r,(i.get(r)||0)+1)}}return e}extractFaces(){return this._faces!==null?this._faces:(this._faces=this.extractAllFaces(8),this._faces)}_computeSignedArea(t){if(t.length<3)return 0;let s=0,i=0,e=0;for(const a of t){const d=a*3;s+=this.positions[d],i+=this.positions[d+1],e+=this.positions[d+2]}s/=t.length,i/=t.length,e/=t.length;let n=0,o=0,h=0;const r=t.length;for(let a=0;a<r;a++){const d=t[a],p=t[(a+1)%r],b=d*3,C=p*3,V=this.positions[b],A=this.positions[b+1],_=this.positions[b+2],E=this.positions[C],y=this.positions[C+1],B=this.positions[C+2];n+=(A-y)*(_+B),o+=(_-B)*(V+E),h+=(V-E)*(A+y)}let c=0,g=0,l=0;for(let a=0;a<this.vertexCount;a++){const d=a*3;c+=this.positions[d],g+=this.positions[d+1],l+=this.positions[d+2]}c/=this.vertexCount,g/=this.vertexCount,l/=this.vertexCount;const u=s-c,m=i-g,w=e-l,N=n*u+o*m+h*w,f=Math.sqrt(n*n+o*o+h*h)*.5;return N>=0?f:-f}forEachEdge(t){for(let s=0;s<this.edgeCount;s++){const i=s*2;t(this.edges[i],this.edges[i+1],s)}}forEachAngle(t){for(let s=0;s<this.vertexCount;s++){const i=s*3,e=this.neighbors[i],n=this.neighbors[i+1],o=this.neighbors[i+2];e!==-1&&n!==-1&&t(s,e,n),n!==-1&&o!==-1&&t(s,n,o),o!==-1&&e!==-1&&t(s,o,e)}}getTorsionVertices(t){const s=t*2,i=this.edges[s],e=this.edges[s+1];if(this.degree(i)<3||this.degree(e)<3)return null;const n=this.getNeighbors(i).filter(h=>h!==e),o=this.getNeighbors(e).filter(h=>h!==i);return n.length!==2||o.length!==2?null:{a:i,b:e,c:n[0],d:n[1],e:o[0],f:o[1]}}}export{P as Mesh,P as default};
