import{packSimpleLSAOUniforms as y}from"./lsao-simple-pipeline-BJYmQjK3.js";async function O({device:e,pipeline:B,bindGroupLayout:m,terrainData:o,tileSize:f,pixelSize:b,workgroupSize:P=128,directions:u=[[1,0],[-1,0],[0,1],[0,-1]]}){const n=f+2,i=f*f;if(o.length!==n*n)throw new Error(`Terrain data size mismatch: expected ${n}Ã—${n}, got ${o.length}`);const s=e.createBuffer({size:o.byteLength,label:"Terrain buffer",usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Float32Array(s.getMappedRange()).set(o),s.unmap();const t=e.createBuffer({size:i*Float32Array.BYTES_PER_ELEMENT,label:"AO output buffer",usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Float32Array(t.getMappedRange()).fill(0),t.unmap();const p=256,c=e.createBuffer({size:p*u.length,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),E=1/u.length;for(let r=0;r<u.length;r++){const d=y({tileSize:[f,f],step:u[r],buffer:1,pixelSize:b,normalization:E});e.queue.writeBuffer(c,r*p,d)}const U=e.createBindGroup({layout:m,label:"Simple LSAO bind group",entries:[{binding:0,resource:{buffer:c,offset:0,size:p}},{binding:1,resource:{buffer:s}},{binding:2,resource:{buffer:t}}]}),l=e.createCommandEncoder({label:"Simple LSAO encoder"});l.clearBuffer(t);const g=l.beginComputePass({label:"Simple LSAO compute pass"});g.setPipeline(B);const A=Math.ceil(f/P);for(let r=0;r<u.length;r++)g.setBindGroup(0,U,[r*p]),g.dispatchWorkgroups(A);g.end();const a=e.createBuffer({size:i*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,label:"Staging buffer"});l.copyBufferToBuffer(t,0,a,0,i*Float32Array.BYTES_PER_ELEMENT),e.queue.submit([l.finish()]),await a.mapAsync(GPUMapMode.READ);const S=new Float32Array(a.getMappedRange()).slice();return a.unmap(),s.destroy(),t.destroy(),c.destroy(),a.destroy(),S}export{O as computeSimpleLSAO};
