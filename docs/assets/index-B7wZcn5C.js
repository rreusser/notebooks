const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/pipeline-BKuBCIhX.js","assets/fft-CMRdeOur.js"])))=>i.map(i=>d[i]);
import{d as c,_ as S}from"./index-ByB2dbry.js";import"./comments-I77vOiCB.js";c({root:document.getElementById("cell-1"),expanded:[],variables:[]},{id:1,body:(t,e)=>t`
This notebook implements on the GPU a two-dimensional solution of the [Kuramoto-Sivashinsky equation](https://encyclopediaofmath.org/wiki/Kuramoto-Sivashinsky_equation) (KSE),

${e.block`u_t + \frac{1}{2}|\nabla u|^2 + \nabla^2 u + \nabla^4 u = 0.`}

The KSE arises in a number of contexts and was [dervied by Yoshiki Kuramoto and Gregory Sivashinsky](https://en.wikipedia.org/wiki/Kuramoto%E2%80%93Sivashinsky_equation) while researching laminar flame front instabilities. It's one of the simplest partial differential equations exhibiting complicated dynamics, displaying chaotic behavior in large domains. It’s particularly interseting because it’s a chaotic PDE of *one* variable. Contrast this with the [Lorenz Attractor](https://en.wikipedia.org/wiki/Lorenz_system) which is a chaotic ODE of *three* variables.

For the fully immersive version, see [the WebGL visualization here](https://rreusser.github.io/kuramoto-sivashinsky/). This page explores modernization to WebGPU and [Observable Notebook Kit](https://observablehq.com/notebook-kit/kit), as well as adding cleanup like plot axes (at last!).`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});c({root:document.getElementById("cell-10"),expanded:[],variables:[]},{id:10,body:(t,e,n,a,r)=>{const i=[t,t/e],o=[Math.pow(Math.PI/i[0],2),Math.pow(Math.PI/i[1],2)];return n(a`

As far as the simulation goes, consider a doubly periodic domain ${r`[0, L_x] \times [0, L_y]`}. The factors ${r`\nu_1 = (\pi/L_x)^2`} and ${r`\nu_2 = (\pi/L_y)^2`} describe the length scale in each dimension. Chaotic behavior occurs when these factors are small. When either factor approaches order unity, the dynamics simplify in that direction, effectively reducing the solution to one dimension. On the threshold between are some pretty weird alternating, quasiperiodic, and even traveling wave solutions.

Based on the config below, we solve the problem in the doubly periodic domain, ${r`[0, ${i[0].toFixed(1)}] \times [0, ${i[1].toFixed(1)}]`} with ${r`\nu_1 = ${o[0].toFixed(6)}`} and ${r`\nu_2 = ${o[1].toFixed(6)}.`}
`),{L:i,nu:o}},inputs:["Lx","aspectRatio","display","md","tex"],outputs:["L","nu"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-3"),expanded:[],variables:[]},{id:3,body:(t,e,n,a,r)=>{const i=t.limits.maxComputeWorkgroupSizeX,o=[32,64,128,256,512,1024],s=o.filter(p=>{if(p<=i)return!0;const b=p/i;return Number.isInteger(b)&&(b&b-1)===0}),d=s.map(p=>`${p}×${p}`),u=512,f=e.select(d,{value:`${u}×${u}`,label:"Grid size, N"}),l=n(f);return a(r`<div id="ks-grid-size">${f}</div>`),{maxWorkgroupSize:i,allSizes:o,validSizes:s,gridSizeOptions:d,defaultN:u,NInput:f,NString:l}},inputs:["device","Inputs","view","display","html"],outputs:["maxWorkgroupSize","allSizes","validSizes","gridSizeOptions","defaultN","NInput","NString"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-11"),expanded:[],variables:[]},{id:11,body:t=>({N:parseInt(t.split("×")[0])}),inputs:["NString"],outputs:["N"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-4"),expanded:[],variables:[]},{id:4,body:(t,e,n,a,r)=>{const i=t/2,o=e.range([1,i],{step:.1,transform:Math.log,value:Math.min(64,i),label:n`Domain size, ${a`L_x`}`}),s=r(o),d=e.range([1,10],{step:.01,value:1,transform:Math.log,label:n`Aspect ratio, ${a`L_x / L_y`}`}),u=r(d),f=e.range([1,8],{step:1,value:1,label:"Initial condition periods, n"}),l=r(f);return{maxLx:i,LxInput:o,Lx:s,aspectRatioInput:d,aspectRatio:u,nInput:f,n:l}},inputs:["N","Inputs","html","tex","view"],outputs:["maxLx","LxInput","Lx","aspectRatioInput","aspectRatio","nInput","n"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-6"),expanded:[],variables:[]},{id:6,body:(t,e,n,a,r,i,o)=>{const s=t.toggle({label:"Simulate",value:["Simulate"]}),d=e(s),u=t.button("Restart"),f=e(u);return n(a`<div id="ks-controls">
  ${r}
  ${i}
  ${o}
  ${s}
  ${u}
</div>`),{simulateInput:s,simulate:d,restartInput:u,restart:f}},inputs:["Inputs","view","display","html","LxInput","aspectRatioInput","nInput"],outputs:["simulateInput","simulate","restartInput","restart"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-7"),expanded:[],variables:[]},{id:7,body:(t,e,n,a,r,i,o,s,d,u)=>{const f=t({d3:e,element:n.elements.svg,xScale:n.elements.plot.scale("x"),yScale:n.elements.plot.scale("y"),aspectRatio:1,onChange:({xDomain:p,yDomain:m})=>{a.dirty=!0;const b=r(n.width,n.height,p,m,i.Lx,i.Lx/i.aspectRatio);n.elements.plot.replaceWith(b),n.elements.plot=b,n.dispatchEvent(new CustomEvent("update"))}});n.addEventListener("update",()=>{a.dirty=!0});const l=o`<figure style="margin: 0;">${n.element}</figure>`;return s(d(l,{width:Math.min(u,640),height:Math.min(u,640),toggleOffset:[-15,-16],controls:["#ks-grid-size","#ks-controls"],onResize(p,m,b){n.resize(m,b),f.updateScales(n.elements.plot.scale("x"),n.elements.plot.scale("y")),a.dirty=!0}})),{axes:f,figure:l}},inputs:["createZoomableAxes","d3","stack","simState","createPlotElement","simParams","html","display","expandable","width"],outputs:["axes","figure"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-8"),expanded:[],variables:[]},{id:8,body:(t,e)=>{t(e)},inputs:["display","statusEl"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-9"),expanded:[],variables:[]},{id:9,body:(t,e)=>{const n=t.range([0,1],{step:.01,value:.5,label:"Contrast"}),a=e(n),r=t.select(["Viridis","Magma","Inferno","Plasma","Cividis","Greys"],{value:"Magma",label:"Colorscale"}),i=e(r),o=t.toggle({label:"Invert colorscale",value:!0}),s=e(o);return{contrastInput:n,contrast:a,colorscaleNameInput:r,colorscaleName:i,invertInput:o,invert:s}},inputs:["Inputs","view"],outputs:["contrastInput","contrast","colorscaleNameInput","colorscaleName","invertInput","invert"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-13"),expanded:[],variables:[]},{id:13,body:(t,e)=>t`The equation is solved in the spatial frequency domain, with the exception of the nonlinear term ${e`\frac{1}{2}|\nabla u|^2`} which requires computing the gradient while transforming back to the spatial domain, then squaring, then transforming back to the frequency domain.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});c({root:document.getElementById("cell-14"),expanded:[],variables:[]},{id:14,body:(t,e)=>t`A few implementation notes:

- Equation (F.10) seems to be missing a factor of ${e`dt`} in the biharmonic term.
- Since all terms include derivatives, the offset of ${e`u`} has no effect and can simply be removed by zeroing out the mean (zero-wavenumber) component on every update.
- The multi-step method is initialized with the same values for both previous steps, rather than implementing a special Backward Euler initialization step.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});c({root:document.getElementById("cell-15"),expanded:[],variables:[]},{id:15,body:(t,e)=>t`The domain has size ${e`[0, 2 L_x] \times [0, 2 L_y]`}, but the equation is solved in the domain ${e`[0, 2\pi] \times [0, 2\pi]`} via the rescaling in Chapter 9 of Kalogirou's thesis,

${e.block`x \rarr \frac{L_x}{\pi} x, \;\;\; y \rarr \frac{L_y}{\pi} y, \;\;\; t \rarr \left(\frac{L_x}{\pi}\right)^2 t.`}

along with the factors ${e`\nu_1 = \left(\frac{\pi}{L_x}\right)^2`} and ${e`\nu_2 = \left(\frac{\pi}{L_y}\right)^2`}.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});c({root:document.getElementById("cell-16"),expanded:[],variables:[]},{id:16,body:(t,e)=>t`From Appendix F on page 227, the full second order spatial frequency domain update equation for solution ${e`\hat{V}`} at step ${e`n+2`} as a function of the data from previous steps ${e`n+1`} and ${e`n`} is

${e.block`\begin{aligned}
\hat{V}^{n + 2}_{k_1, k_2} =& \frac{1}{\xi_{k_1, k_2}} \left[ (2 + 2c\,dt) \hat{V}^{n+1}_{k_1,k_2} - \left(\frac{1}{2} + c\,dt\right) \hat{V}^n_{k_1,k_2} \right. \\
& + 2dt \left( \hat{A}^{n+1}_{k_1,k_2} + \frac{\nu_2}{\nu_1} \hat{B}^{n+1}_{k_1,k_2} \right) \\
& - \left. dt \left( \hat{A}^{n}_{k_1,k_2} + \frac{\nu_2}{\nu_1} \hat{B}^{n}_{k_1,k_2} \right) \right]
\end{aligned}`}

where

${e.block`\begin{aligned}
\hat{A}_{k_1,k_2} &= -\mathscr{F}\left(\frac{1}{2}\left(\frac{\partial v}{\partial x}\right)^2\right), \\
\hat{B}_{k_1,k_2} &= -\mathscr{F}\left(\frac{1}{2}\left(\frac{\partial v}{\partial y}\right)^2\right)
\end{aligned}`}

where ${e`\mathscr{F}(\cdot)`} represents the spatial Fourier Transform and ${e`v`} is the spatial domain solution.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});c({root:document.getElementById("cell-17"),expanded:[],variables:[]},{id:17,body:(t,e)=>t`Finally,

${e.block`\begin{aligned}
\xi_{k_1,k_2} =& \frac{3}{2} + c\,dt - dt\left(k_1^2 + \frac{\nu_2}{\nu_1} k_2^2 \right) \\
& + \nu_1\,dt\left(k_1^2 + \frac{\nu_2}{\nu_1} k_2^2\right)^2,
\end{aligned}`}

using the definition ${e`c = 1 + \frac{1}{\nu_1}`}.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});c({root:document.getElementById("cell-18"),expanded:[],variables:[]},{id:18,body:(t,e)=>t`At first this update equation seems imposing, but if ${e`k_1`} and ${e`k_2`} refer to a particular wavenumber then the above is a simple algebraic expression for each grid point, independent of all others. The only exceptions are the expressions for ${e`\hat{A}_{k_1,k_2}`} and ${e`\hat{B}_{k_1,k_2}`}, which represent the solution, differentiated in the frequency domain via multiplication by ${e`ik_x`} and ${e`ik_y`}, inverse-FFT'd into the spatial domain, squared, and then FFT'd back into the spatial frequency domain. From there, the rest is tedious but straightforward shuffling of buffers.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});c({root:document.getElementById("cell-19"),expanded:[],variables:[]},{id:19,body:(t,e)=>t`## WebGPU implementation

WebGPU has no built-in FFT, so this notebook implements [Cooley-Tukey](https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm) radix-2 in compute shaders: bit-reversal at the input, then ${e`\log_2 N`} butterfly stages. For grids larger than the maximum workgroup size (256 on most devices), a hierarchical four-step FFT breaks the transform into smaller pieces. Getting the indexing, normalization, and twiddle factors right is tedious, but at least FFT bugs are obvious.

Wavenumber layout in DFTs is also error-prone. The first half of the output contains positive frequencies; the second half contains negative frequencies in reverse order. A wrong sign or off-by-one index makes derivatives blow up fast.

Taking the complex FFT of real data causes numerical drift. The imaginary part should stay zero, but floating point errors leak energy into it over time, eventually destabilizing the solution. The fix is an extra pass per time step to extract the real part before transforming back. A real-valued [Hartley transform](https://en.wikipedia.org/wiki/Hartley_transform) would avoid this.

Finally, you may or may not like this, I might lose followers, etc., but I converted this notebook from WebGL 1 in part way of Claude Code, using my experimental [MCP server for Observable Notebook Kit](https://github.com/rreusser/mcp-observable-notebookkit-debug). It implements a small server which controls an in-browser dev preview over a WebSocket, querying runtime outputs, modifying control inputs, analyzing the variable dependency graph, and even analyzing image output. I'm not religious about AI in either direction. It's good at what it's good at. It's evil where it's used badly, and that's that.
`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});c({root:document.getElementById("cell-20"),expanded:[],variables:[]},{id:20,body:async t=>{const{createWebGPUContext:e}=await S(()=>import("./webgpu-context-BoQcYhON.js"),[]).then(i=>{if(!("createWebGPUContext"in i))throw new SyntaxError("export 'createWebGPUContext' not found");return i}),n=await e(),a=n.device,r=navigator.gpu.getPreferredCanvasFormat();return t.then(()=>a.destroy()),{createWebGPUContext:e,context:n,device:a,canvasFormat:r}},inputs:["invalidation"],outputs:["createWebGPUContext","context","device","canvasFormat"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-21"),expanded:[],variables:[]},{id:21,body:async()=>{const[{createKSPipelines:t},{executeFFT2D:e},{createElementStack:n},{createZoomableAxes:a},{expandable:r}]=await Promise.all([S(()=>import("./pipeline-BKuBCIhX.js"),__vite__mapDeps([0,1])).then(i=>{if(!("createKSPipelines"in i))throw new SyntaxError("export 'createKSPipelines' not found");return i}),S(()=>import("./fft-CMRdeOur.js"),[]).then(i=>{if(!("executeFFT2D"in i))throw new SyntaxError("export 'executeFFT2D' not found");return i}),S(()=>import("./element-stack-BU40TvN2.js"),[]).then(i=>{if(!("createElementStack"in i))throw new SyntaxError("export 'createElementStack' not found");return i}),S(()=>import("./zoomable-axes-BfGyq1bg.js"),[]).then(i=>{if(!("createZoomableAxes"in i))throw new SyntaxError("export 'createZoomableAxes' not found");return i}),S(()=>import("./expandable-dZkDG0zz.js"),[]).then(i=>{if(!("expandable"in i))throw new SyntaxError("export 'expandable' not found");return i})]);return{createKSPipelines:t,executeFFT2D:e,createElementStack:n,createZoomableAxes:a,expandable:r}},inputs:[],outputs:["createKSPipelines","executeFFT2D","createElementStack","createZoomableAxes","expandable"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-22"),expanded:[],variables:[]},{id:22,body:(t,e)=>{const n=t,a=n*n*2*4,r=n*n*4*4,i=Math.ceil(n/16),o=e.STORAGE|e.COPY_SRC|e.COPY_DST,s=[2*Math.PI/n,2*Math.PI/n];return{gridN:n,vec2Size:a,vec4Size:r,workgroups:i,bufferUsage:o,dx:s}},inputs:["N","GPUBufferUsage"],outputs:["gridN","vec2Size","vec4Size","workgroups","bufferUsage","dx"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-23"),expanded:[],variables:[]},{id:23,body:async(t,e,n,a,r,i,o)=>{const s=await a(r,i,t);function d(u,f,l,p){o({device:r,pipelines:s.fft,input:u,output:f,temp:l,N:t,forward:p,splitNormalization:!0})}return{pipelines:s,runFFT2D:d}},inputs:["gridN","vec2Size","dx","createKSPipelines","device","canvasFormat","executeFFT2D"],outputs:["pipelines","runFFT2D"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-24"),expanded:[],variables:[]},{id:24,body:(t,e,n,a)=>{const r=[0,1,2].map(C=>t.createBuffer({label:`Vhat[${C}]`,size:e,usage:n})),i=[0,1].map(C=>t.createBuffer({label:`ABhat[${C}]`,size:a,usage:n})),o=t.createBuffer({label:"V",size:e,usage:n}),s=[0,1].map(C=>t.createBuffer({label:`temp[${C}]`,size:e,usage:n})),d=t.createBuffer({label:"tempVec4",size:a,usage:n}),u=t.createBuffer({label:"VxVy",size:e,usage:n}),f=t.createBuffer({label:"A",size:e,usage:n}),l=t.createBuffer({label:"B",size:e,usage:n}),p=t.createBuffer({label:"Ahat",size:e,usage:n}),m=t.createBuffer({label:"Bhat",size:e,usage:n}),b=t.createBuffer({label:"Vreal",size:e,usage:n});return{Vhat:r,ABhat:i,V:o,temp:s,tempVec4:d,VxVy:u,A:f,B:l,Ahat:p,Bhat:m,Vreal:b}},inputs:["device","vec2Size","bufferUsage","vec4Size"],outputs:["Vhat","ABhat","V","temp","tempVec4","VxVy","A","B","Ahat","Bhat","Vreal"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-25"),expanded:[],variables:[]},{id:25,body:(t,e,n,a)=>{const r=t.createBuffer({size:16,usage:e.UNIFORM|e.COPY_DST}),i=t.createBuffer({size:16,usage:e.UNIFORM|e.COPY_DST});{const m=new ArrayBuffer(16);new Uint32Array(m,0,2).set([n,n]),new Float32Array(m,8,2).set(a),t.queue.writeBuffer(i,0,m)}const o=t.createBuffer({size:32,usage:e.UNIFORM|e.COPY_DST}),s=t.createBuffer({size:8,usage:e.UNIFORM|e.COPY_DST});t.queue.writeBuffer(s,0,new Uint32Array([n,n]));const d=t.createBuffer({size:8,usage:e.UNIFORM|e.COPY_DST});t.queue.writeBuffer(d,0,new Uint32Array([n,n]));const u=t.createBuffer({size:8,usage:e.UNIFORM|e.COPY_DST});t.queue.writeBuffer(u,0,new Uint32Array([n,n]));const f=t.createBuffer({size:8,usage:e.UNIFORM|e.COPY_DST});t.queue.writeBuffer(f,0,new Uint32Array([n,n]));const l=t.createBuffer({size:32,usage:e.UNIFORM|e.COPY_DST}),p=t.createBuffer({size:64,usage:e.UNIFORM|e.COPY_DST});return{initParamsBuffer:r,diffParamsBuffer:i,bdfParamsBuffer:o,extractRealParamsBuffer:s,extractMixedDerivativesParamsBuffer:d,computeABParamsBuffer:u,packABhatParamsBuffer:f,visParamsBuffer:l,viewInverseBuffer:p}},inputs:["device","GPUBufferUsage","N","dx"],outputs:["initParamsBuffer","diffParamsBuffer","bdfParamsBuffer","extractRealParamsBuffer","extractMixedDerivativesParamsBuffer","computeABParamsBuffer","packABhatParamsBuffer","visParamsBuffer","viewInverseBuffer"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-26"),expanded:[],variables:[]},{id:26,body:(t,e,n)=>{function a(s){const d=new Uint8Array(1024);for(let u=0;u<256;u++){const f=u/255,l=t.rgb(s(f));d[u*4]=Math.round(l.r),d[u*4+1]=Math.round(l.g),d[u*4+2]=Math.round(l.b),d[u*4+3]=255}return d}const r={Viridis:a(t.interpolateViridis),Magma:a(t.interpolateMagma),Inferno:a(t.interpolateInferno),Plasma:a(t.interpolatePlasma),Cividis:a(t.interpolateCividis),Greys:a(t.interpolateGreys)},i=e.createTexture({size:[256,1],format:"rgba8unorm",usage:n.TEXTURE_BINDING|n.COPY_DST}),o=e.createSampler({magFilter:"linear",minFilter:"linear"});return e.queue.writeTexture({texture:i},r.Magma,{bytesPerRow:256*4},[256,1]),{generateColorscale:a,colorscaleData:r,colorscaleTexture:i,colorscaleSampler:o}},inputs:["d3","device","GPUTextureUsage"],outputs:["generateColorscale","colorscaleData","colorscaleTexture","colorscaleSampler"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-27"),expanded:[],variables:[]},{id:27,body:(t,e,n,a,r,i)=>{const o={top:10,right:10,bottom:40,left:40};let s=null,d=null;function u({current:E,width:B,height:k}){const F=window.devicePixelRatio||1;E?s=E:(s=document.createElement("canvas"),s.style.position="absolute",d=s.getContext("webgpu"),d.configure({device:t,format:e,alphaMode:"opaque"}));const L=B-o.left-o.right,A=k-o.top-o.bottom;return s.style.left=`${o.left}px`,s.style.top=`${o.top}px`,s.style.width=`${L}px`,s.style.height=`${A}px`,s.width=Math.floor(L*F),s.height=Math.floor(A*F),d&&d.configure({device:t,format:e,alphaMode:"opaque"}),s}function f(E,B,k=[0,1],F=[0,1],L,A){return n.plot({width:E,height:B,marginTop:o.top,marginRight:o.right,marginBottom:o.bottom,marginLeft:o.left,style:{backgroundColor:"transparent",maxWidth:"none",position:"absolute"},x:{domain:k,tickSpacing:80,label:"x"},y:{domain:F,tickSpacing:80,label:"y"},marks:[n.rect([{x1:0,y1:0,x2:L,y2:A}],{x1:"x1",y1:"y1",x2:"x2",y2:"y2",stroke:"rgba(255,255,255,0.5)",strokeWidth:2,fill:"none"})]})}function l(E,B,k,F=1/0){const L=k/B,A=E-o.left-o.right,$=F-o.top-o.bottom;let z,P;B>=1?(z=A,P=Math.floor(A/B)):(P=A,z=Math.floor(A*B)),P>$&&(P=$,z=Math.floor($*B));const M=z+o.left+o.right,q=P+o.top+o.bottom;return{totalW:M,totalH:q,Lx:k,Ly:L}}const p=Math.min(a,640),m=p,b=p,C=64,_=64,T=r({width:m,height:b,layers:[{id:"canvas",element:u},{id:"plot",element:({width:E,height:B})=>f(E,B,[0,C],[0,_],C,_)},{id:"svg",element:({current:E,width:B,height:k})=>(E?i.select(E):i.create("svg")).attr("width",B).attr("height",k).style("position","absolute").node()}]});return{margins:o,canvas:s,gpuContext:d,webgpuCanvasElement:u,createPlotElement:f,computeDimensions:l,initialSize:p,initialW:m,initialH:b,initialLx:C,initialLy:_,stack:T}},inputs:["device","canvasFormat","Plot","width","createElementStack","d3"],outputs:["margins","canvas","gpuContext","webgpuCanvasElement","createPlotElement","computeDimensions","initialSize","initialW","initialH","initialLx","initialLy","stack"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-28"),expanded:[],variables:[]},{id:28,body:(t,e,n,a,r,i,o,s,d)=>{const u=a(r.width,r.height,i.xDomain,i.yDomain,e,e/t);return r.elements.plot.replaceWith(u),r.elements.plot=u,i.updateScales(r.elements.plot.scale("x"),r.elements.plot.scale("y")),o.dirty=!0,s(),d.style.visibility="visible",{newPlot:u}},inputs:["aspectRatio","Lx","initComplete","createPlotElement","stack","axes","simState","render","canvas"],outputs:["newPlot"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-29"),expanded:[],variables:[]},{id:29,body:()=>({simState:{timeLevel:0,time:0,stepCount:0,dirty:!0},simParams:{Lx:64,aspectRatio:1,n:1,range:14,colorscaleName:"Magma",invert:!1}}),inputs:[],outputs:["simState","simParams"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-30"),expanded:[],variables:[]},{id:30,body:(t,e,n,a,r,i,o)=>{o.Lx=t,o.aspectRatio=e,o.n=n,o.contrast=a,o.colorscaleName=r,o.invert=i},inputs:["Lx","aspectRatio","n","contrast","colorscaleName","invert","simParams"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-31"),expanded:[],variables:[]},{id:31,body:(t,e,n,a,r,i,o,s,d,u,f,l,p,m,b,C,_,T,E,B,k,F,L,A,$,z,P,M,q,N,W,V,K,Y)=>{function R(){const w=t.Lx,x=[w,w/t.aspectRatio],v=[Math.pow(Math.PI/x[0],2),Math.pow(Math.PI/x[1],2)],h=.18*v[0];return{L:x,nu:v,dt:h,dx:e,N:n}}function D(w){const{nu:x,dt:v}=R();if(w!==void 0){const I=new ArrayBuffer(16);new Uint32Array(I,0,2).set([n,n]),new Float32Array(I,8,1).set([w]),a.queue.writeBuffer(r,0,I)}const h=new ArrayBuffer(32);new Uint32Array(h,0,2).set([n,n]),new Float32Array(h,8,2).set(e),new Float32Array(h,16,1).set([v]),new Float32Array(h,24,2).set(x),a.queue.writeBuffer(i,0,h)}function G(){const w=t.Lx/t.aspectRatio,x=new ArrayBuffer(24);new Uint32Array(x,0,2).set([n,n]),new Float32Array(x,8,1).set([t.contrast/(1-t.contrast)]),new Uint32Array(x,12,1).set([t.invert?1:0]),new Float32Array(x,16,2).set([t.Lx,w]),a.queue.writeBuffer(o,0,x);const v=s[t.colorscaleName];v&&a.queue.writeTexture({texture:d},v,{bytesPerRow:256*4},[256,1])}async function H(w){await a.queue.onSubmittedWorkDone(),D(w);const x=a.createBindGroup({layout:u.bindGroupLayouts.initialize,entries:[{binding:0,resource:{buffer:f}},{binding:1,resource:{buffer:r}}]}),v=a.createCommandEncoder(),h=v.beginComputePass();h.setPipeline(u.initialize),h.setBindGroup(0,x),h.dispatchWorkgroups(l,l),h.end(),a.queue.submit([v.finish()]),p(f,m[0],b,!0);const I=a.createCommandEncoder();I.copyBufferToBuffer(m[0],0,m[1],0,C),I.copyBufferToBuffer(m[0],0,m[2],0,C),a.queue.submit([I.finish()]),await a.queue.onSubmittedWorkDone(),_.timeLevel=1,_.time=0,_.stepCount=0}function O(w,x){const v=m[w],h=T[x],I=a.createBindGroup({layout:u.bindGroupLayouts.differentiate,entries:[{binding:0,resource:{buffer:v}},{binding:1,resource:{buffer:E}},{binding:2,resource:{buffer:B}}]});let y=a.createCommandEncoder(),g=y.beginComputePass();g.setPipeline(u.differentiate),g.setBindGroup(0,I),g.dispatchWorkgroups(l,l),g.end(),a.queue.submit([y.finish()]);const j=a.createBindGroup({layout:u.bindGroupLayouts.extractMixedDerivatives,entries:[{binding:0,resource:{buffer:E}},{binding:1,resource:{buffer:k}},{binding:2,resource:{buffer:F}}]});y=a.createCommandEncoder(),g=y.beginComputePass(),g.setPipeline(u.extractMixedDerivatives),g.setBindGroup(0,j),g.dispatchWorkgroups(l,l),g.end(),a.queue.submit([y.finish()]),p(k,k,b,!1);const J=a.createBindGroup({layout:u.bindGroupLayouts.computeAB,entries:[{binding:0,resource:{buffer:k}},{binding:1,resource:{buffer:L}},{binding:2,resource:{buffer:A}},{binding:3,resource:{buffer:$}}]});y=a.createCommandEncoder(),g=y.beginComputePass(),g.setPipeline(u.computeAB),g.setBindGroup(0,J),g.dispatchWorkgroups(l,l),g.end(),a.queue.submit([y.finish()]),p(L,z,b,!0),p(A,P,b,!0);const Q=a.createBindGroup({layout:u.bindGroupLayouts.packABhat,entries:[{binding:0,resource:{buffer:z}},{binding:1,resource:{buffer:P}},{binding:2,resource:{buffer:h}},{binding:3,resource:{buffer:M}}]});y=a.createCommandEncoder(),g=y.beginComputePass(),g.setPipeline(u.packABhat),g.setBindGroup(0,Q),g.dispatchWorkgroups(l,l),g.end(),a.queue.submit([y.finish()])}async function Z(){D();const w=(_.timeLevel-1+3)%3,x=_.timeLevel%3,v=(_.timeLevel+1)%3;O(w,0),O(x,1);const h=a.createBindGroup({layout:u.bindGroupLayouts.bdfUpdate,entries:[{binding:0,resource:{buffer:m[w]}},{binding:1,resource:{buffer:m[x]}},{binding:2,resource:{buffer:T[0]}},{binding:3,resource:{buffer:T[1]}},{binding:4,resource:{buffer:m[v]}},{binding:5,resource:{buffer:i}}]});let I=a.createCommandEncoder(),y=I.beginComputePass();y.setPipeline(u.bdfUpdate),y.setBindGroup(0,h),y.dispatchWorkgroups(l,l),y.end(),a.queue.submit([I.finish()]),p(m[v],f,b,!1);const g=a.createBindGroup({layout:u.bindGroupLayouts.extractReal,entries:[{binding:0,resource:{buffer:f}},{binding:1,resource:{buffer:q}},{binding:2,resource:{buffer:N}}]});I=a.createCommandEncoder(),y=I.beginComputePass(),y.setPipeline(u.extractReal),y.setBindGroup(0,g),y.dispatchWorkgroups(l,l),y.end(),a.queue.submit([I.finish()]),p(q,m[v],b,!0),await a.queue.onSubmittedWorkDone(),_.timeLevel=(_.timeLevel+1)%3,_.time+=R().dt,_.stepCount++}function X(){G(),a.queue.writeBuffer(W,0,V.viewInverse);const w=m[_.timeLevel%3];p(w,f,b,!1);const x=a.createBindGroup({layout:u.bindGroupLayouts.visualize,entries:[{binding:0,resource:{buffer:f}},{binding:1,resource:{buffer:o}},{binding:2,resource:d.createView()},{binding:3,resource:K},{binding:4,resource:{buffer:W}}]}),v=a.createCommandEncoder(),h=v.beginRenderPass({colorAttachments:[{view:Y.getCurrentTexture().createView(),loadOp:"clear",storeOp:"store",clearValue:{r:0,g:0,b:0,a:1}}]});h.setPipeline(u.visualize),h.setBindGroup(0,x),h.draw(6),h.end(),a.queue.submit([v.finish()])}return{getParams:R,updateUniforms:D,updateVisUniforms:G,initialize:H,computeNonlinearTo:O,step:Z,render:X}},inputs:["simParams","dx","N","device","initParamsBuffer","bdfParamsBuffer","visParamsBuffer","colorscaleData","colorscaleTexture","pipelines","V","workgroups","runFFT2D","Vhat","temp","vec2Size","simState","ABhat","tempVec4","diffParamsBuffer","VxVy","extractMixedDerivativesParamsBuffer","A","B","computeABParamsBuffer","Ahat","Bhat","packABhatParamsBuffer","Vreal","extractRealParamsBuffer","viewInverseBuffer","axes","colorscaleSampler","gpuContext"],outputs:["getParams","updateUniforms","updateVisUniforms","initialize","computeNonlinearTo","step","render"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-32"),expanded:[],variables:[]},{id:32,body:async(t,e,n,a)=>(await n(t),a(),{initComplete:{n:t,restart:e}}),inputs:["n","restart","initialize","render"],outputs:["initComplete"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-33"),expanded:[],variables:[]},{id:33,body:(t,e,n,a,r,i)=>{let o=null,s=!1;async function d(){if(!s)try{if(a){for(let u=0;u<2;u++)await t();e(),r.dirty=!1}else r.dirty&&(e(),r.dirty=!1);o=requestAnimationFrame(d)}catch(u){s=!0,console.error("Animation loop error:",u)}}return o=requestAnimationFrame(d),i.then(()=>{s=!0,o!==null&&(cancelAnimationFrame(o),o=null)}),{animFrameId:o,hasError:s,animationLoop:d}},inputs:["step","render","initComplete","simulate","simState","invalidation"],outputs:["animFrameId","hasError","animationLoop"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-34"),expanded:[],variables:[]},{id:34,body:(t,e,n,a,r)=>{r()},inputs:["contrast","colorscaleName","invert","initComplete","render"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-35"),expanded:[],variables:[]},{id:35,body:(t,e,n)=>{const a=t`<p><em>t = <span id="sim-time">0</span>, step = <span id="sim-step">0</span></em></p>`;let r=null;function i(){const o=document.getElementById("sim-time"),s=document.getElementById("sim-step");o&&(o.textContent=e.time.toFixed(4)),s&&(s.textContent=e.stepCount),r=requestAnimationFrame(i)}return r=requestAnimationFrame(i),n.then(()=>{r!==null&&(cancelAnimationFrame(r),r=null)}),{statusEl:a,statusFrameId:r,updateStatus:i}},inputs:["html","simState","invalidation"],outputs:["statusEl","statusFrameId","updateStatus"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});
