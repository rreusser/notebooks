const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/pipeline-CmqcOzJv.js","assets/fft-Chkx7JT6.js"])))=>i.map(i=>d[i]);
import{d as T,_ as q}from"./index-ByB2dbry.js";T({root:document.getElementById("cell-2"),expanded:[],variables:[]},{id:2,body:async n=>{const{createWebGPUContext:e}=await q(()=>import("./webgpu-context-CA7EEXHP.js"),[]).then(i=>{if(!("createWebGPUContext"in i))throw new SyntaxError("export 'createWebGPUContext' not found");return i}),t=await e(),o=t.device,a=navigator.gpu.getPreferredCanvasFormat();return n.then(()=>o.destroy()),{createWebGPUContext:e,context:t,device:o,canvasFormat:a}},inputs:["invalidation"],outputs:["createWebGPUContext","context","device","canvasFormat"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-3"),expanded:[],variables:[]},{id:3,body:(n,e)=>{const t=n.select([64,128,256,512,1024,2048],{value:512,label:"Resolution",format:a=>`${a}Ã—${a}`}),o=e(t);return{resolutionInput:t,resolution:o}},inputs:["Inputs","view"],outputs:["resolutionInput","resolution"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-4"),expanded:[],variables:[]},{id:4,body:n=>{const e=n,t=e*e*2*4,o=e*e*4*4,a=Math.ceil(e/16),i=1/e;return{N:e,vec2Size:t,vec4Size:o,workgroups:a,dx:i}},inputs:["resolution"],outputs:["N","vec2Size","vec4Size","workgroups","dx"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-5"),expanded:[],variables:[]},{id:5,body:async(n,e,t)=>{const[{createFluidPipelines:o},{executeFFT2D:a}]=await Promise.all([q(()=>import("./pipeline-CmqcOzJv.js"),__vite__mapDeps([0,1])).then(s=>{if(!("createFluidPipelines"in s))throw new SyntaxError("export 'createFluidPipelines' not found");return s}),q(()=>import("./fft-Chkx7JT6.js"),[]).then(s=>{if(!("executeFFT2D"in s))throw new SyntaxError("export 'executeFFT2D' not found");return s})]),i=await o(n,e,t);function c(s,y,g,B){a({device:n,pipelines:i.fft,input:s,output:y,temp:g,N:t,forward:B,splitNormalization:!0})}return{createFluidPipelines:o,executeFFT2D:a,pipelines:i,runFFT2D:c}},inputs:["device","canvasFormat","N"],outputs:["createFluidPipelines","executeFFT2D","pipelines","runFFT2D"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-6"),expanded:[],variables:[]},{id:6,body:(n,e,t,o,a)=>{const i=n.STORAGE|n.COPY_SRC|n.COPY_DST,c=e.createBuffer({label:"velocity",size:t,usage:i}),s=e.createBuffer({label:"velocityTemp",size:t,usage:i}),y=e.createBuffer({label:"u",size:o,usage:i}),g=e.createBuffer({label:"v",size:o,usage:i}),B=e.createBuffer({label:"uHat",size:o,usage:i}),d=e.createBuffer({label:"vHat",size:o,usage:i}),l=[0,1].map(m=>e.createBuffer({label:`fftTemp[${m}]`,size:o,usage:i})),v=e.createBuffer({label:"dye",size:o,usage:i}),p=e.createBuffer({label:"dyeTemp",size:o,usage:i}),h=a*a*4,r=e.createBuffer({label:"vorticity",size:h,usage:i});return{bufferUsage:i,velocity:c,velocityTemp:s,uBuffer:y,vBuffer:g,uHat:B,vHat:d,fftTemp:l,dye:v,dyeTemp:p,vorticitySize:h,vorticityBuffer:r}},inputs:["GPUBufferUsage","device","vec4Size","vec2Size","N"],outputs:["bufferUsage","velocity","velocityTemp","uBuffer","vBuffer","uHat","vHat","fftTemp","dye","dyeTemp","vorticitySize","vorticityBuffer"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-7"),expanded:[],variables:[]},{id:7,body:(n,e,t)=>{const o=n.createBuffer({label:"simParams",size:32,usage:e.UNIFORM|e.COPY_DST}),a=n.createBuffer({label:"forceParams",size:48,usage:e.UNIFORM|e.COPY_DST}),i=n.createBuffer({label:"projectParams",size:16,usage:e.UNIFORM|e.COPY_DST});n.queue.writeBuffer(i,0,new Uint32Array([t,t]));const c=n.createBuffer({label:"visParams",size:24,usage:e.UNIFORM|e.COPY_DST}),s=n.createBuffer({label:"vorticityParams",size:16,usage:e.UNIFORM|e.COPY_DST}),y=n.createBuffer({label:"boundaryParams",size:24,usage:e.UNIFORM|e.COPY_DST}),g=n.createBuffer({label:"buoyancyParams",size:16,usage:e.UNIFORM|e.COPY_DST});return{simParamsBuffer:o,forceParamsBuffer:a,projectParamsBuffer:i,visParamsBuffer:c,vorticityParamsBuffer:s,boundaryParamsBuffer:y,buoyancyParamsBuffer:g}},inputs:["device","GPUBufferUsage","N"],outputs:["simParamsBuffer","forceParamsBuffer","projectParamsBuffer","visParamsBuffer","vorticityParamsBuffer","boundaryParamsBuffer","buoyancyParamsBuffer"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-8"),expanded:[],variables:[]},{id:8,body:(n,e)=>{const t=n.range([1e-5,.01],{step:1e-5,value:15e-5,transform:Math.log,label:"Viscosity"}),o=e(t),a=n.range([.9,1],{step:.001,value:.99,label:"Dye persistence"}),i=e(a),c=n.range([.01,.15],{step:.005,value:.03,label:"Force radius"}),s=e(c),y=n.range([0,1],{step:.01,value:.5,label:"Force damping"}),g=e(y),B=n.range([0,50],{step:.1,value:20,label:"Vorticity confinement"}),d=e(B),l=n.range([-5,5],{step:.01,value:5,label:"Buoyancy"}),v=e(l),p=n.range([0,10],{step:1,value:5,label:"Wall thickness (cells)"}),h=e(p),r=n.checkbox(["Top/bottom","Left/right"],{label:"Walls"}),m=e(r),w=n.range([.001,.05],{step:.001,value:1/60,label:"Timestep (dt)"}),F=e(w),C=n.select(["Interactive","Rayleigh-Taylor","Kelvin-Helmholtz"],{value:"Rayleigh-Taylor",label:"Initial conditions"}),I=e(C),x=n.range([1,16],{step:1,value:8,label:"Perturbation periods"}),k=e(x),$=n.range([.001,.05],{step:.001,value:.005,label:"Perturbation amplitude"}),G=e($),_=n.button("Restart"),R=e(_),D=n.toggle({label:"Simulate",value:!0}),S=e(D),L=n.range([0,60],{step:.1,value:0,label:"Stop at time (0 = never)"}),A=e(L),P=n.select(["Monotonic cubic","Linear"],{value:"Monotonic cubic",label:"Interpolation"}),E=e(P);return{viscosityInput:t,viscosity:o,dyeDecayInput:a,dyeDecay:i,forceRadiusInput:c,forceRadius:s,forceDampingInput:y,forceDamping:g,vorticityInput:B,vorticityConfinement:d,buoyancyInput:l,buoyancy:v,wallThicknessInput:p,wallThickness:h,wallsEnabledInput:r,wallsEnabled:m,timestepInput:w,timestep:F,initialConditionInput:C,initialCondition:I,perturbationPeriodsInput:x,perturbationPeriods:k,perturbationAmplitudeInput:$,perturbationAmplitude:G,restartInput:_,restart:R,simulateInput:D,simulate:S,stopTimeInput:L,stopTime:A,interpolationInput:P,interpolation:E}},inputs:["Inputs","view"],outputs:["viscosityInput","viscosity","dyeDecayInput","dyeDecay","forceRadiusInput","forceRadius","forceDampingInput","forceDamping","vorticityInput","vorticityConfinement","buoyancyInput","buoyancy","wallThicknessInput","wallThickness","wallsEnabledInput","wallsEnabled","timestepInput","timestep","initialConditionInput","initialCondition","perturbationPeriodsInput","perturbationPeriods","perturbationAmplitudeInput","perturbationAmplitude","restartInput","restart","simulateInput","simulate","stopTimeInput","stopTime","interpolationInput","interpolation"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-9"),expanded:[],variables:[]},{id:9,body:(n,e,t,o,a,i,c,s,y,g,B,d,l,v,p,h,r,m,w)=>{n(e`<div id="fluid-controls">
  ${t}
  ${o}
  ${a}
  ${i}
  ${c}
  ${s}
  ${y}
  ${g}
  ${B}
  ${d}
  ${l}
  ${v}
  ${p}
  ${h}
  ${r}
  ${m}
  ${w}
</div>`)},inputs:["display","html","resolutionInput","initialConditionInput","perturbationPeriodsInput","perturbationAmplitudeInput","stopTimeInput","viscosityInput","dyeDecayInput","timestepInput","forceRadiusInput","forceDampingInput","vorticityInput","buoyancyInput","wallThicknessInput","wallsEnabledInput","interpolationInput","simulateInput","restartInput"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-10"),expanded:[],variables:[]},{id:10,body:(n,e,t,o,a,i)=>{const c=Math.min(n,640),s=e`<canvas
  id="fluid-canvas"
  width="${c*window.devicePixelRatio}"
  height="${c*window.devicePixelRatio}"
  style="width: ${c}px; height: ${c}px; cursor: crosshair;">
</canvas>`,y=s.getContext("webgpu");return y.configure({device:t,format:o,alphaMode:"opaque",usage:a.RENDER_ATTACHMENT|a.COPY_SRC}),i(s),{canvasSize:c,canvas:s,gpuContext:y}},inputs:["width","html","device","canvasFormat","GPUTextureUsage","display"],outputs:["canvasSize","canvas","gpuContext"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-11"),expanded:[],variables:[]},{id:11,body:n=>{const e={down:!1,x:0,y:0,prevX:0,prevY:0,dx:0,dy:0};function t(o){const a=n.getBoundingClientRect();return{x:(o.clientX-a.left)/a.width,y:(o.clientY-a.top)/a.height}}return n.addEventListener("pointerdown",o=>{e.down=!0;const a=t(o);e.x=a.x,e.y=a.y,e.prevX=a.x,e.prevY=a.y,n.setPointerCapture(o.pointerId)}),n.addEventListener("pointermove",o=>{const a=t(o);e.prevX=e.x,e.prevY=e.y,e.x=a.x,e.y=a.y,e.down&&(e.dx=e.x-e.prevX,e.dy=e.y-e.prevY)}),n.addEventListener("pointerup",o=>{e.down=!1,e.dx=0,e.dy=0,n.releasePointerCapture(o.pointerId)}),n.addEventListener("pointerleave",()=>{e.down=!1,e.dx=0,e.dy=0}),n.addEventListener("touchstart",o=>o.preventDefault(),{passive:!1}),n.addEventListener("touchmove",o=>o.preventDefault(),{passive:!1}),{mouseState:e,getMousePos:t}},inputs:["canvas"],outputs:["mouseState","getMousePos"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-12"),expanded:[],variables:[]},{id:12,body:()=>({simParams:{viscosity:5e-5,dyeDecay:.998,forceRadius:.03,forceDamping:.15,vorticityConfinement:2,buoyancy:5,wallThicknessX:0,wallThicknessY:0,dt:.016666666666666666,useLinearInterp:0,time:0,stopTime:0}}),inputs:[],outputs:["simParams"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-13"),expanded:[],variables:[]},{id:13,body:(n,e,t,o,a,i,c,s,y,g,B,d)=>{d.viscosity=n,d.dyeDecay=e,d.dt=y,d.forceRadius=t,d.forceDamping=o,d.vorticityConfinement=a,d.buoyancy=i,d.wallThicknessX=s.includes("Left/right")?c:0,d.wallThicknessY=s.includes("Top/bottom")?c:0,d.useLinearInterp=g==="Linear"?1:0,d.stopTime=B},inputs:["viscosity","dyeDecay","forceRadius","forceDamping","vorticityConfinement","buoyancy","wallThickness","wallsEnabled","timestep","interpolation","stopTime","simParams"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-14"),expanded:[],variables:[]},{id:14,body:(n,e,t,o,a,i)=>{n==="Rayleigh-Taylor"?(e.value=5,e.dispatchEvent(new t("input")),o.value=["Top/bottom"],o.dispatchEvent(new t("input")),a.value=1,a.dispatchEvent(new t("input")),i.value=.5,i.dispatchEvent(new t("input"))):n==="Kelvin-Helmholtz"&&(e.value=5,e.dispatchEvent(new t("input")),o.value=["Top/bottom"],o.dispatchEvent(new t("input")),a.value=1,a.dispatchEvent(new t("input")),i.value=0,i.dispatchEvent(new t("input")))},inputs:["initialCondition","wallThicknessInput","Event","wallsEnabledInput","dyeDecayInput","buoyancyInput"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-15"),expanded:[],variables:[]},{id:15,body:(n,e,t,o,a,i,c,s,y,g,B)=>{a.time=0;const d=new Float32Array(i*i*4),l=new Float32Array(i*i*2);if(e==="Interactive")d.fill(0),l.fill(0);else if(e==="Rayleigh-Taylor")for(let p=0;p<i;p++)for(let h=0;h<i;h++){const r=p*i+h,m=h/i,w=p/i,F=.5+o*Math.sin(2*Math.PI*t*m);if(w<F){const C=(F-w)/.03,I=Math.min(1,C);l[r*2]=I,l[r*2+1]=0}else l[r*2]=0,l[r*2+1]=0;d[r*4]=0,d[r*4+1]=0,d[r*4+2]=0,d[r*4+3]=0}else if(e==="Kelvin-Helmholtz")for(let h=0;h<i;h++)for(let r=0;r<i;r++){const m=h*i+r,w=r/i,F=h/i,C=.5+o*Math.sin(2*Math.PI*t*w),I=(F-C)/.1,x=Math.tanh(I)*.5;if(d[m*4]=x,d[m*4+1]=0,d[m*4+2]=o*Math.sin(2*Math.PI*t*w)*Math.exp(-I*I),d[m*4+3]=0,F<C){const k=(C-F)/.03,$=Math.min(1,k);l[m*2]=$,l[m*2+1]=0}else l[m*2]=0,l[m*2+1]=0}return c.queue.writeBuffer(s,0,d),c.queue.writeBuffer(y,0,d),c.queue.writeBuffer(g,0,l),c.queue.writeBuffer(B,0,l),{velocityData:d,dyeData:l}},inputs:["restart","initialCondition","perturbationPeriods","perturbationAmplitude","simParams","N","device","velocity","velocityTemp","dye","dyeTemp"],outputs:["velocityData","dyeData"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-16"),expanded:[],variables:[]},{id:16,body:(n,e,t,o,a,i,c,s,y,g)=>{function B(){const r=new ArrayBuffer(32);new Uint32Array(r,0,2).set([n,n]),new Float32Array(r,8,1).set([e.dt]),new Float32Array(r,12,1).set([e.viscosity]),new Float32Array(r,16,1).set([e.dyeDecay]),new Float32Array(r,20,1).set([e.wallThicknessX]),new Float32Array(r,24,1).set([e.wallThicknessY]),new Uint32Array(r,28,1).set([e.useLinearInterp]),t.queue.writeBuffer(o,0,r)}function d(){const r=a.dx/e.dt,m=-a.dy/e.dt,w=new ArrayBuffer(48);new Uint32Array(w,0,2).set([n,n]),new Float32Array(w,8,2).set([a.x,1-a.y]),new Float32Array(w,16,2).set([r,m]),new Float32Array(w,24,1).set([e.forceRadius]),new Float32Array(w,28,1).set([a.down?1:0]),new Float32Array(w,32,1).set([e.forceDamping]),t.queue.writeBuffer(i,0,w)}function l(){const r=new ArrayBuffer(24);new Uint32Array(r,0,2).set([n,n]),new Float32Array(r,8,1).set([1]),new Float32Array(r,12,1).set([0]),new Float32Array(r,16,1).set([e.wallThicknessX]),new Float32Array(r,20,1).set([e.wallThicknessY]),t.queue.writeBuffer(c,0,r)}function v(){const r=new ArrayBuffer(16);new Uint32Array(r,0,2).set([n,n]),new Float32Array(r,8,1).set([e.vorticityConfinement]),new Float32Array(r,12,1).set([e.dt]),t.queue.writeBuffer(s,0,r)}function p(){const r=new ArrayBuffer(24);new Uint32Array(r,0,2).set([n,n]),new Float32Array(r,8,1).set([0]),new Float32Array(r,12,1).set([e.wallThicknessX]),new Float32Array(r,16,1).set([e.wallThicknessY]),t.queue.writeBuffer(y,0,r)}function h(){const r=new ArrayBuffer(16);new Uint32Array(r,0,2).set([n,n]),new Float32Array(r,8,1).set([e.buoyancy]),new Float32Array(r,12,1).set([e.dt]),t.queue.writeBuffer(g,0,r)}return{updateSimUniforms:B,updateForceUniforms:d,updateVisUniforms:l,updateVorticityUniforms:v,updateBoundaryUniforms:p,updateBuoyancyUniforms:h}},inputs:["N","simParams","device","simParamsBuffer","mouseState","forceParamsBuffer","visParamsBuffer","vorticityParamsBuffer","boundaryParamsBuffer","buoyancyParamsBuffer"],outputs:["updateSimUniforms","updateForceUniforms","updateVisUniforms","updateVorticityUniforms","updateBoundaryUniforms","updateBuoyancyUniforms"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-17"),expanded:[],variables:[]},{id:17,body:(n,e,t,o,a,i,c,s,y,g,B,d,l,v,p,h,r,m,w,F,C,I,x,k,$,G,_,R,D,S,L)=>{function A(){if(n.wallThicknessX>0||n.wallThicknessY>0){e();const b=t.createBindGroup({layout:o.bindGroupLayouts.enforceBoundary,entries:[{binding:0,resource:{buffer:a}},{binding:1,resource:{buffer:i}},{binding:2,resource:{buffer:c}}]}),f=t.createCommandEncoder(),u=f.beginComputePass();u.setPipeline(o.enforceBoundary),u.setBindGroup(0,b),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([f.finish()])}}async function P(){y(),g(),A();{const b=t.createBindGroup({layout:o.bindGroupLayouts.addForce,entries:[{binding:0,resource:{buffer:a}},{binding:1,resource:{buffer:i}},{binding:2,resource:{buffer:B}}]}),f=t.createCommandEncoder(),u=f.beginComputePass();u.setPipeline(o.addForce),u.setBindGroup(0,b),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([f.finish()])}{const b=t.createBindGroup({layout:o.bindGroupLayouts.advect,entries:[{binding:0,resource:{buffer:a}},{binding:1,resource:{buffer:a}},{binding:2,resource:{buffer:d}},{binding:3,resource:{buffer:l}}]}),f=t.createCommandEncoder(),u=f.beginComputePass();u.setPipeline(o.advectVelocity),u.setBindGroup(0,b),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([f.finish()])}{const b=t.createCommandEncoder();b.copyBufferToBuffer(d,0,a,0,v),t.queue.submit([b.finish()])}A();{const b=t.createBindGroup({layout:o.bindGroupLayouts.advectScalar,entries:[{binding:0,resource:{buffer:a}},{binding:1,resource:{buffer:i}},{binding:2,resource:{buffer:p}},{binding:3,resource:{buffer:l}}]}),f=t.createCommandEncoder(),u=f.beginComputePass();u.setPipeline(o.advectScalar),u.setBindGroup(0,b),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([f.finish()])}{const b=t.createCommandEncoder();b.copyBufferToBuffer(p,0,i,0,h),t.queue.submit([b.finish()])}{const b=t.createBindGroup({layout:o.bindGroupLayouts.splitVelocity,entries:[{binding:0,resource:{buffer:a}},{binding:1,resource:{buffer:r}},{binding:2,resource:{buffer:m}},{binding:3,resource:{buffer:w}}]}),f=t.createCommandEncoder(),u=f.beginComputePass();u.setPipeline(o.splitVelocity),u.setBindGroup(0,b),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([f.finish()])}F(r,C,I,!0),F(m,x,I,!0);{const b=t.createBindGroup({layout:o.bindGroupLayouts.projectFFT,entries:[{binding:0,resource:{buffer:C}},{binding:1,resource:{buffer:x}},{binding:2,resource:{buffer:l}}]}),f=t.createCommandEncoder(),u=f.beginComputePass();u.setPipeline(o.projectFFT),u.setBindGroup(0,b),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([f.finish()])}F(C,r,I,!1),F(x,m,I,!1);{const b=t.createBindGroup({layout:o.bindGroupLayouts.mergeVelocity,entries:[{binding:0,resource:{buffer:r}},{binding:1,resource:{buffer:m}},{binding:2,resource:{buffer:a}},{binding:3,resource:{buffer:w}}]}),f=t.createCommandEncoder(),u=f.beginComputePass();u.setPipeline(o.mergeVelocity),u.setBindGroup(0,b),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([f.finish()])}if(A(),n.vorticityConfinement>0){k();{const b=t.createBindGroup({layout:o.bindGroupLayouts.computeVorticity,entries:[{binding:0,resource:{buffer:a}},{binding:1,resource:{buffer:$}},{binding:2,resource:{buffer:G}}]}),f=t.createCommandEncoder(),u=f.beginComputePass();u.setPipeline(o.computeVorticity),u.setBindGroup(0,b),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([f.finish()])}{const b=t.createBindGroup({layout:o.bindGroupLayouts.applyVorticity,entries:[{binding:0,resource:{buffer:a}},{binding:1,resource:{buffer:$}},{binding:2,resource:{buffer:G}}]}),f=t.createCommandEncoder(),u=f.beginComputePass();u.setPipeline(o.applyVorticity),u.setBindGroup(0,b),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([f.finish()])}}if(n.buoyancy!==0){_();const b=t.createBindGroup({layout:o.bindGroupLayouts.applyBuoyancy,entries:[{binding:0,resource:{buffer:a}},{binding:1,resource:{buffer:i}},{binding:2,resource:{buffer:R}}]}),f=t.createCommandEncoder(),u=f.beginComputePass();u.setPipeline(o.applyBuoyancy),u.setBindGroup(0,b),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([f.finish()])}A()}function E(){D();const b=t.createBindGroup({layout:o.bindGroupLayouts.visualize,entries:[{binding:0,resource:{buffer:a}},{binding:1,resource:{buffer:i}},{binding:2,resource:{buffer:S}}]}),f=t.createCommandEncoder(),u=f.beginRenderPass({colorAttachments:[{view:L.getCurrentTexture().createView(),loadOp:"clear",storeOp:"store",clearValue:{r:0,g:0,b:0,a:1}}]});u.setPipeline(o.visualize),u.setBindGroup(0,b),u.draw(6),u.end(),t.queue.submit([f.finish()])}return{enforceBoundaries:A,step:P,render:E}},inputs:["simParams","updateBoundaryUniforms","device","pipelines","velocity","dye","boundaryParamsBuffer","workgroups","updateSimUniforms","updateForceUniforms","forceParamsBuffer","velocityTemp","simParamsBuffer","vec4Size","dyeTemp","vec2Size","uBuffer","vBuffer","projectParamsBuffer","runFFT2D","uHat","fftTemp","vHat","updateVorticityUniforms","vorticityBuffer","vorticityParamsBuffer","updateBuoyancyUniforms","buoyancyParamsBuffer","updateVisUniforms","visParamsBuffer","gpuContext"],outputs:["enforceBoundaries","step","render"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-18"),expanded:[],variables:[]},{id:18,body:(n,e,t,o,a,i,c,s,y,g,B)=>{const d=a`<div id="time-display" style="font-family: monospace; margin-top: 0.5em;">t = 0.000</div>`;i(d);let l=null,v=!1;async function p(){if(!v)try{o&&(c.stopTime<=0||c.time<c.stopTime)&&(await n(),c.time+=c.dt,c.stopTime>0&&c.time>=c.stopTime&&(s.value=!1,s.dispatchEvent(new y("input")))),e(),d.textContent=`t = ${c.time.toFixed(3)}`,g.dx=0,g.dy=0,l=requestAnimationFrame(p)}catch(h){v=!0,console.error("Animation loop error:",h)}}return l=requestAnimationFrame(p),B.then(()=>{v=!0,l!==null&&(cancelAnimationFrame(l),l=null)}),{timeDisplay:d,animFrameId:l,hasError:v,animationLoop:p}},inputs:["step","render","canvas","simulate","html","display","simParams","simulateInput","Event","mouseState","invalidation"],outputs:["timeDisplay","animFrameId","hasError","animationLoop"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-25"),expanded:[],variables:[]},{id:25,body:(n,e,t,o,a,i,c,s,y,g,B,d)=>{const l=s.button("Download PNG");return y(l),l.addEventListener("click",async()=>{const v=e.width,p=e.height,r=v*4,m=Math.ceil(r/256)*256,w=m*p,F=o.createBuffer({size:w,usage:g.COPY_DST|g.MAP_READ});n();const C=o.createCommandEncoder();C.copyTextureToBuffer({texture:t.getCurrentTexture()},{buffer:F,bytesPerRow:m},{width:v,height:p}),o.queue.submit([C.finish()]),await F.mapAsync(B.READ);const I=new Uint8Array(F.getMappedRange()),x=new ImageData(v,p);for(let D=0;D<p;D++){const S=D*m,L=D*v*4;for(let A=0;A<v;A++){const P=S+A*4,E=L+A*4;a==="bgra8unorm"?(x.data[E+0]=I[P+2],x.data[E+1]=I[P+1],x.data[E+2]=I[P+0],x.data[E+3]=255):(x.data[E+0]=I[P+0],x.data[E+1]=I[P+1],x.data[E+2]=I[P+2],x.data[E+3]=255)}}F.unmap(),F.destroy();const k=new d(v,p);k.getContext("2d").putImageData(x,0,0);const G=await k.convertToBlob({type:"image/png"}),_=URL.createObjectURL(G),R=document.createElement("a");R.href=_,R.download=`stable-fluids-${i.toLowerCase().replace(" ","-")}-t${c.time.toFixed(2)}.png`,R.click(),URL.revokeObjectURL(_)}),{downloadButton:l}},inputs:["render","canvas","gpuContext","device","canvasFormat","interpolation","simParams","Inputs","display","GPUBufferUsage","GPUMapMode","OffscreenCanvas"],outputs:["downloadButton"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-19"),expanded:[],variables:[]},{id:19,body:(n,e)=>n`## Algorithm

The Stable Fluids algorithm solves the incompressible Navier-Stokes equations:

${e.block`\frac{\partial \mathbf{u}}{\partial t} = -(\mathbf{u} \cdot \nabla)\mathbf{u} + \nu \nabla^2 \mathbf{u} - \nabla p + \mathbf{f}`}

subject to the incompressibility constraint ${e`\nabla \cdot \mathbf{u} = 0`}.

Each timestep consists of four stages:

1. **Add forces**: Apply external forces (mouse input) to the velocity field
2. **Advect**: Move the velocity field along itself using semi-Lagrangian advection
3. **Diffuse**: Apply viscous diffusion (done in frequency domain as multiplication)
4. **Project**: Make velocity divergence-free by subtracting the gradient of pressure

The key insight is that projection can be done efficiently in frequency domain. The velocity ${e`\hat{\mathbf{u}}(\mathbf{k})`} is decomposed into components parallel and perpendicular to the wavenumber ${e`\mathbf{k}`}. The divergence-free projection removes the parallel component:

${e.block`\hat{\mathbf{u}}_{\perp} = \hat{\mathbf{u}} - \mathbf{k}\frac{\mathbf{k} \cdot \hat{\mathbf{u}}}{|\mathbf{k}|^2}`}

This makes the algorithm unconditionally stable regardless of timestep size.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});T({root:document.getElementById("cell-20"),expanded:[],variables:[]},{id:20,body:(n,e)=>n`## Implementation Details

### Grid Layout

Velocities are **cell-centered** (collocated), not staggered. Cell ${e`(i,j)`} stores both velocity components ${e`(u, v)`} at physical position ${e`(i+0.5, j+0.5)`}. Velocity is stored as \`vec4<f32>\` with layout \`(u_re, u_im, v_re, v_im)\` to accommodate FFT operations. In the spatial domain, the imaginary parts are zero.

### Simulation Loop

Each timestep executes these stages in order:

1. **Add forces** (mouse interaction)
2. **Advect velocity** (semi-Lagrangian)
3. **Advect dye**
4. **Project + diffuse** (FFT-based)
5. **Vorticity confinement**
6. **Buoyancy**
7. **Boundary enforcement**

### FFT-Based Projection and Diffusion

The FFT is used to efficiently solve the pressure projection and diffusion in frequency domain:

1. **Split** the interleaved velocity into separate ${e`u`} and ${e`v`} complex buffers
2. **Forward FFT** on both components
3. **Project and diffuse** in frequency domain:
   - Compute wavenumber ${e`\mathbf{k}`} with frequencies ${e`0, 1, \ldots, N/2-1, -N/2, \ldots, -1`} scaled by ${e`2\pi`}
   - Remove component parallel to ${e`\mathbf{k}`}: ${e.block`\hat{u} \leftarrow \hat{u} - k_x \frac{\mathbf{k} \cdot \hat{\mathbf{u}}}{|\mathbf{k}|^2}, \quad \hat{v} \leftarrow \hat{v} - k_y \frac{\mathbf{k} \cdot \hat{\mathbf{u}}}{|\mathbf{k}|^2}`}
   - Apply implicit diffusion by multiplying by ${e`\frac{1}{1 + \nu |\mathbf{k}|^2 \Delta t}`}
   - Zero the DC component (${e`\mathbf{k} = 0`})
4. **Inverse FFT** to return to spatial domain
5. **Merge** back into interleaved velocity buffer

### Forcing Model

The force uses a **velocity-matching model** rather than direct impulse injection:

${e.block`\mathbf{f} = (\mathbf{v}_{\text{target}} - \mathbf{v}) \cdot \text{damping} \cdot \text{falloff}`}

where ${e`\mathbf{v}_{\text{target}} = \Delta\mathbf{x}_{\text{mouse}} / \Delta t`} is computed from mouse velocity, and the falloff is Gaussian: ${e`\exp(-r^2 / 2\sigma^2)`}.

Dye injection uses a **hard circle** (step function) rather than Gaussian for sharper smoke edges.

### Semi-Lagrangian Advection

For each grid cell, trace backward through the velocity field to find the departure point:

${e.block`\mathbf{x}_{\text{back}} = \mathbf{x} - \mathbf{u}(\mathbf{x}) \cdot N \cdot \Delta t`}

Then sample the source field at ${e`\mathbf{x}_{\text{back}}`} using **monotone cubic interpolation** (Fedkiw et al., "Visual Simulation of Smoke", SIGGRAPH 2001). The factor of ${e`N`} converts velocity from normalized to grid units.

The monotone cubic interpolation uses Hermite interpolation with slope limiting to prevent overshoot:

${e.block`f(t) = a_3 t^3 + a_2 t^2 + a_1 t + a_0`}

where the slopes ${e`d_k = (f_{k+1} - f_{k-1})/2`} are set to zero when they differ in sign from ${e`\Delta_k = f_{k+1} - f_k`}. This preserves monotonicity and eliminates spurious oscillations that can arise with standard cubic interpolation.

### Vorticity Confinement

Two-pass process to counteract numerical dissipation of rotational motion:

**Pass 1**: Compute vorticity (curl) using central differences:
${e.block`\omega = \frac{\partial v}{\partial x} - \frac{\partial u}{\partial y}`}

**Pass 2**: Apply confinement force in the direction perpendicular to the vorticity gradient:
${e.block`\mathbf{N} = \frac{\nabla|\omega|}{|\nabla|\omega||}, \quad \mathbf{f} = \varepsilon (\mathbf{N} \times \omega)`}

In 2D, the cross product gives ${e`\mathbf{f} = \varepsilon (N_y \omega, -N_x \omega)`}. This force points toward vortex centers, amplifying rotational structures.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});
