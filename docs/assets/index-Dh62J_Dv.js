const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/pipeline-uDP97i3_.js","assets/fft-Chkx7JT6.js"])))=>i.map(i=>d[i]);
import{d as c,_ as z}from"./index-ByB2dbry.js";c({root:document.getElementById("cell-1"),expanded:[],variables:[]},{id:1,body:(n,e)=>n`
This is a 2D gravitational N-body simulation using the [Particle-Mesh](https://en.wikipedia.org/wiki/Particle_mesh) (PM) method, implemented entirely in WebGPU compute shaders. The PM method approximates gravitational interactions by depositing particle masses onto a regular grid, solving for the gravitational potential on that grid, then interpolating the resulting forces back to the particles.

The gravitational potential ${e`\phi`} is related to the mass density ${e`\rho`} through the Poisson equation,

${e.block`\nabla^2 \phi = 4\pi G\rho`}

which in Fourier space becomes a simple algebraic relation, ${e.block`\hat\phi(\mathbf{k}) = -4\pi G\, \hat\rho(\mathbf{k}) / |\mathbf{k}|^2.`} This allows the potential to be computed efficiently via FFT. The gravitational acceleration is then ${e`\mathbf{a} = -\nabla\phi`}, which can also be computed in Fourier space by multiplying by ${e`i\mathbf{k}`}.

The PM method is considered somewhat obsolete because it cannot accurately model close interactions between particles. The grid resolution sets a minimum length scale below which gravitational forces are artificially softened. Modern cosmological simulations typically use the Particle-Particle Particle-Mesh (P${e`^3`}M) method, which augments the PM calculation with direct particle-particle summation for nearby pairs, or tree-based methods that adaptively refine force calculations.

Nonetheless, PM lends itself well to GPU architecture and remains a useful pedagogical tool and performs well for problems where small-scale structure is unimportant or where the softening is acceptable.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});c({root:document.getElementById("cell-2"),expanded:[],variables:[]},{id:2,body:async n=>{if(!navigator.gpu)throw new Error("WebGPU is not supported in this browser");const e=await navigator.gpu.requestAdapter();if(!e)throw new Error("Failed to get WebGPU adapter");const t=[],i=e.features.has("shader-f16");i&&t.push("shader-f16");const r=await e.requestDevice({requiredFeatures:t}),a=navigator.gpu.getPreferredCanvasFormat();return n.then(()=>r.destroy()),{adapter:e,requiredFeatures:t,hasF16:i,device:r,canvasFormat:a}},inputs:["invalidation"],outputs:["adapter","requiredFeatures","hasF16","device","canvasFormat"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-3"),expanded:[],variables:[]},{id:3,body:(n,e)=>{const t=n.select([64,128,256,512,1024,2048],{value:1024,label:"Grid resolution",format:r=>`${r}×${r}`}),i=e(t);return{gridResInput:t,N_grid:i}},inputs:["Inputs","view"],outputs:["gridResInput","N_grid"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-4"),expanded:[],variables:[]},{id:4,body:(n,e)=>{const t=n.select([16384,32768,65536,131072,262144,524288,1048576,2097152,4194304],{value:262144,label:"Particles",format:r=>r.toLocaleString()}),i=e(t);return{particleCountInput:t,numParticlesSelected:i}},inputs:["Inputs","view"],outputs:["particleCountInput","numParticlesSelected"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-5"),expanded:[],variables:[]},{id:5,body:(n,e)=>{const t=n.range([1e-4,.01],{step:1e-4,value:.001,transform:Math.log,label:"Timestep (dt)"}),i=e(t);return{dtInput:t,dt:i}},inputs:["Inputs","view"],outputs:["dtInput","dt"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-7"),expanded:[],variables:[]},{id:7,body:(n,e)=>{const t=n.range([1e-5,.1],{step:1e-5,value:.01,label:"Density opacity",transform:Math.log}),i=e(t);return{brightnessInput:t,brightness:i}},inputs:["Inputs","view"],outputs:["brightnessInput","brightness"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-8"),expanded:[],variables:[]},{id:8,body:(n,e)=>{const t=n.range([0,.1],{step:.001,value:.005,label:"Initial velocity (v₀)"}),i=e(t);return{v0Input:t,v0:i}},inputs:["Inputs","view"],outputs:["v0Input","v0"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-9"),expanded:[],variables:[]},{id:9,body:(n,e,t)=>{const i=n?["f32","f16"]:["f32"],r=e.select(i,{value:"f32",label:"Precision"}),a=t(r);return{precisionOptions:i,precisionInput:r,fftPrecision:a}},inputs:["hasF16","Inputs","view"],outputs:["precisionOptions","precisionInput","fftPrecision"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-10"),expanded:[],variables:[]},{id:10,body:(n,e)=>{const t=n.toggle({label:"Simulate",value:!0}),i=e(t);return{simulateInput:t,simulate:i}},inputs:["Inputs","view"],outputs:["simulateInput","simulate"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-11"),expanded:[],variables:[]},{id:11,body:(n,e)=>{const t=n.range([0,1],{step:.01,value:0,label:"Gradient opacity"}),i=e(t);return{gradientIntensityInput:t,gradientIntensity:i}},inputs:["Inputs","view"],outputs:["gradientIntensityInput","gradientIntensity"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-12"),expanded:[],variables:[]},{id:12,body:(n,e)=>{const t=n.button("Reset"),i=e(t);return{resetInput:t,reset:i}},inputs:["Inputs","view"],outputs:["resetInput","reset"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-13"),expanded:[],variables:[]},{id:13,body:(n,e,t,i,r,a,s,u,o,d)=>{n(e`<div id="gravity-controls">
  ${t}
  ${i}
  ${r}
  ${a}
  ${s}
  ${u}
  ${o}
  ${d}
</div>`)},inputs:["display","html","gridResInput","particleCountInput","dtInput","v0Input","brightnessInput","gradientIntensityInput","simulateInput","resetInput"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-14"),expanded:[],variables:[]},{id:14,body:(n,e,t)=>{const i=n,r=e,a=Math.ceil(i/16),s=Math.ceil(r/256),u=t==="f16"?2:4,o=r*4*4,d=i*i*4,f=i*i*2*4,p=i*i*4*u;return{N:i,numParticles:r,workgroupsGrid:a,workgroupsParticles:s,floatSize:u,particleBufferSize:o,atomicBufferSize:d,densityBufferSize:f,gradientBufferSize:p}},inputs:["N_grid","numParticlesSelected","fftPrecision"],outputs:["N","numParticles","workgroupsGrid","workgroupsParticles","floatSize","particleBufferSize","atomicBufferSize","densityBufferSize","gradientBufferSize"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-15"),expanded:[],variables:[]},{id:15,body:async(n,e,t,i)=>{const[{createGravityPipelines:r},{executeFFT2D:a,executeVec4FFT2D:s}]=await Promise.all([z(()=>import("./pipeline-uDP97i3_.js"),__vite__mapDeps([0,1])).then(f=>{if(!("createGravityPipelines"in f))throw new SyntaxError("export 'createGravityPipelines' not found");return f}),z(()=>import("./fft-Chkx7JT6.js"),[]).then(f=>{if(!("executeFFT2D"in f))throw new SyntaxError("export 'executeFFT2D' not found");if(!("executeVec4FFT2D"in f))throw new SyntaxError("export 'executeVec4FFT2D' not found");return f})]),u=await r(n,e,t,i);function o(f,p,h,m){a({device:n,pipelines:u.fft,input:f,output:p,temp:h,N:t,forward:m,splitNormalization:!0})}function d(f,p,h,m){s({device:n,pipelines:u.fftVec4,input:f,output:p,temp:h,N:t,forward:m,splitNormalization:!0})}return{createGravityPipelines:r,executeFFT2D:a,executeVec4FFT2D:s,pipelines:u,runFFT2D:o,runVec4FFT2D:d}},inputs:["device","canvasFormat","N","fftPrecision"],outputs:["createGravityPipelines","executeFFT2D","executeVec4FFT2D","pipelines","runFFT2D","runVec4FFT2D"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-16"),expanded:[],variables:[]},{id:16,body:(n,e,t,i,r,a,s,u,o,d,f)=>{const p=r.STORAGE|r.COPY_SRC|r.COPY_DST,h=a.createBuffer({label:"particles",size:s,usage:p}),m=a.createBuffer({label:"densityAtomic",size:u,usage:p}),g=a.createBuffer({label:"density",size:o,usage:p}),v=a.createBuffer({label:"densityHat",size:o,usage:p}),w=a.createBuffer({label:"gradientHat",size:d,usage:p}),I=a.createBuffer({label:"gradient",size:d,usage:p}),F=a.createBuffer({label:"potentialHat",size:o,usage:p}),P=a.createBuffer({label:"potential",size:o,usage:p}),x=[0,1].map(B=>a.createBuffer({label:`fftTemp[${B}]`,size:d,usage:p}));return f.then(()=>{h.destroy(),m.destroy(),g.destroy(),v.destroy(),w.destroy(),I.destroy(),F.destroy(),P.destroy(),x.forEach(B=>B.destroy())}),{bufferUsage:p,particles:h,densityAtomic:m,density:g,densityHat:v,gradientHat:w,gradient:I,potentialHat:F,potential:P,fftTemp:x}},inputs:["reset","numParticles","N","fftPrecision","GPUBufferUsage","device","particleBufferSize","atomicBufferSize","densityBufferSize","gradientBufferSize","invalidation"],outputs:["bufferUsage","particles","densityAtomic","density","densityHat","gradientHat","gradient","potentialHat","potential","fftTemp"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-17"),expanded:[],variables:[]},{id:17,body:(n,e,t)=>{const i=n.createBuffer({label:"clearParams",size:16,usage:e.UNIFORM|e.COPY_DST}),r=n.createBuffer({label:"accumulateParams",size:16,usage:e.UNIFORM|e.COPY_DST}),a=n.createBuffer({label:"convertParams",size:16,usage:e.UNIFORM|e.COPY_DST}),s=n.createBuffer({label:"poissonParams",size:16,usage:e.UNIFORM|e.COPY_DST}),u=n.createBuffer({label:"integrateParams",size:16,usage:e.UNIFORM|e.COPY_DST});return t.then(()=>{i.destroy(),r.destroy(),a.destroy(),s.destroy(),u.destroy()}),{clearParamsBuffer:i,accumulateParamsBuffer:r,convertParamsBuffer:a,poissonParamsBuffer:s,integrateParamsBuffer:u}},inputs:["device","GPUBufferUsage","invalidation"],outputs:["clearParamsBuffer","accumulateParamsBuffer","convertParamsBuffer","poissonParamsBuffer","integrateParamsBuffer"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-18"),expanded:[],variables:[]},{id:18,body:(n,e,t,i,r)=>{function a(){const u=Math.random(),o=Math.random();return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*o)}const s=new Float32Array(e*4);for(let u=0;u<e;u++){const o=u*4;s[o+0]=Math.random(),s[o+1]=Math.random(),s[o+2]=i*a(),s[o+3]=i*a()}return r.queue.writeBuffer(t,0,s),{randn:a,particleData:s}},inputs:["reset","numParticles","particles","v0","device"],outputs:["randn","particleData"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-19"),expanded:[],variables:[]},{id:19,body:(n,e,t,i,r)=>{const a=Math.min(n,640),s=window.devicePixelRatio||1,u=e`<canvas
  id="gravity-canvas"
  width="${a*s}"
  height="${a*s}"
  style="width: ${a}px; height: ${a}px; background: black;">
</canvas>`,o=u.getContext("webgpu");return o.configure({device:t,format:i,alphaMode:"opaque"}),r(u),{canvasSize:a,pixelRatio:s,canvas:u,gpuContext:o}},inputs:["width","html","device","canvasFormat","display"],outputs:["canvasSize","pixelRatio","canvas","gpuContext"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-20"),expanded:[],variables:[]},{id:20,body:(n,e)=>n`## Initial conditions

The simulation begins with particles distributed uniformly at random, each with a small random velocity drawn from a Gaussian distribution. Two physical scales govern how the system evolves.

The first is the [Jeans length](https://en.wikipedia.org/wiki/Jeans_instability) ${e`\lambda_J`}, which sets the scale above which gravitational collapse overcomes thermal pressure (here represented by the initial velocity dispersion). Density perturbations larger than ${e`\lambda_J`} will grow and collapse, while smaller perturbations oscillate as acoustic waves. With ${e`G = 1`} and mean density ${e`\bar\rho = 1`}, the Jeans length is approximately ${e`\lambda_J \sim v_0 / \sqrt{G\bar\rho} \approx v_0`}.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});c({root:document.getElementById("cell-21"),expanded:[],variables:[]},{id:21,body:(n,e,t)=>{const i=n,r=(i*100).toFixed(1);return e(t.block`\lambda_J \sim \frac{v_0}{\sqrt{G\bar\rho}} \approx ${r}\%\ \text{of domain}`),{jeansLength:i,jeansPercent:r}},inputs:["v0","display","tex"],outputs:["jeansLength","jeansPercent"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-22"),expanded:[],variables:[]},{id:22,body:(n,e)=>n`The second consideration is shot noise from the finite number of particles. The initial density field is not perfectly uniform but has Poisson fluctuations from the random particle positions. With ${e`N`} particles distributed over ${e`M`} grid cells, each cell contains on average ${e`\lambda = N/M`} particles, and the relative density fluctuation is ${e`\sigma_\rho / \bar\rho \sim 1/\sqrt\lambda`}. These fluctuations seed the initial perturbations that gravity amplifies.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});c({root:document.getElementById("cell-23"),expanded:[],variables:[]},{id:23,body:(n,e,t,i,r)=>{const a=n/(e*e);function s(m,g){let v=m*Math.log(g)-g;for(let w=2;w<=m;w++)v-=Math.log(w);return Math.exp(v)}const u=Math.sqrt(a),o=Math.max(0,Math.floor(a-4*u)),d=Math.ceil(a+4*u),f=[];for(let m=o;m<=d;m++){const g=s(m,a);g>1e-6&&f.push({density:m/a,probability:g*a})}const p=t.plot({width:400,height:200,marginLeft:50,x:{label:"Relative density (ρ/ρ̄)",domain:[Math.max(0,1-4/Math.sqrt(a)),1+4/Math.sqrt(a)]},y:{label:"Probability density"},marks:[t.ruleY([0]),t.ruleX([1],{stroke:"#999",strokeDasharray:"4,4"}),t.line(f,{x:"density",y:"probability",stroke:"steelblue",strokeWidth:2}),t.dot(f,{x:"density",y:"probability",fill:"steelblue",r:3})]}),h=(100/Math.sqrt(a)).toFixed(1);return i(r`<figure id="shot-noise-figure">
  ${p}
  <figcaption>With ${a.toFixed(1)} particles per cell, the initial density fluctuations are ±${h}% (1σ).</figcaption>
</figure>`),{lambda:a,poissonPMF:s,std:u,kMin:o,kMax:d,data:f,plot:p,fluctuation:h}},inputs:["numParticles","N","Plot","display","html"],outputs:["lambda","poissonPMF","std","kMin","kMax","data","plot","fluctuation"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-24"),expanded:[],variables:[]},{id:24,body:(n,e,t,i,r)=>{const a=n==="f16"?2:4,s={particles:e*4*4,densityAtomic:t*t*4,density:t*t*2*4,densityHat:t*t*2*4,gradientHat:t*t*4*a,gradient:t*t*4*a,fftTemp:2*t*t*4*a},u=Object.values(s).reduce((d,f)=>d+f,0);function o(d){return d>=1024*1024*1024?(d/(1024*1024*1024)).toFixed(2)+" GB":d>=1024*1024?(d/(1024*1024)).toFixed(1)+" MB":d>=1024?(d/1024).toFixed(1)+" KB":d+" B"}return i(r`<details>
  <summary style="cursor: pointer; font-weight: bold;">Memory usage: ${o(u)}</summary>
  <table style="margin-top: 8px; font-size: 0.9em;">
    <tr><td>Particles</td><td style="text-align: right; padding-left: 16px;">${o(s.particles)}</td></tr>
    <tr><td>Density (atomic)</td><td style="text-align: right; padding-left: 16px;">${o(s.densityAtomic)}</td></tr>
    <tr><td>Density (complex)</td><td style="text-align: right; padding-left: 16px;">${o(s.density)}</td></tr>
    <tr><td>Density (freq domain)</td><td style="text-align: right; padding-left: 16px;">${o(s.densityHat)}</td></tr>
    <tr><td>Gradient (freq domain)</td><td style="text-align: right; padding-left: 16px;">${o(s.gradientHat)}</td></tr>
    <tr><td>Gradient (spatial)</td><td style="text-align: right; padding-left: 16px;">${o(s.gradient)}</td></tr>
    <tr><td>FFT temp (shared)</td><td style="text-align: right; padding-left: 16px;">${o(s.fftTemp)}</td></tr>
    <tr style="font-weight: bold; border-top: 1px solid #ccc;"><td>Total</td><td style="text-align: right; padding-left: 16px;">${o(u)}</td></tr>
  </table>
</details>`),{bytesPerFloat:a,memoryUsage:s,totalBytes:u,formatBytes:o}},inputs:["fftPrecision","numParticles","N","display","html"],outputs:["bytesPerFloat","memoryUsage","totalBytes","formatBytes"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-25"),expanded:[],variables:[]},{id:25,body:(n,e,t,i,r,a,s,u,o)=>{function f(){n.queue.writeBuffer(e,0,new Uint32Array([t]));const p=new ArrayBuffer(16);new Uint32Array(p,0,2).set([t,i]),new Float32Array(p,8,2).set([1073741824,1/i]),n.queue.writeBuffer(r,0,p);const h=new ArrayBuffer(16);new Uint32Array(h,0,1).set([t]),new Float32Array(h,4,1).set([1073741824]),n.queue.writeBuffer(a,0,h),n.queue.writeBuffer(s,0,new Uint32Array([t]));const m=new ArrayBuffer(16);new Uint32Array(m,0,2).set([t,i]),new Float32Array(m,8,2).set([u,0]),n.queue.writeBuffer(o,0,m)}return{FIXED_POINT_SCALE:1073741824,updateUniforms:f}},inputs:["device","clearParamsBuffer","N","numParticles","accumulateParamsBuffer","convertParamsBuffer","poissonParamsBuffer","dt","integrateParamsBuffer"],outputs:["FIXED_POINT_SCALE","updateUniforms"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-26"),expanded:[],variables:[]},{id:26,body:(n,e,t,i,r,a,s,u,o,d,f,p,h,m,g,v,w,I,F,P,x,B,S,T,_,C,k,q)=>{async function O(){n();{const y=e.createBindGroup({layout:t.bindGroupLayouts.clearGrid,entries:[{binding:0,resource:{buffer:i}},{binding:1,resource:{buffer:r}}]}),b=e.createCommandEncoder(),l=b.beginComputePass();l.setPipeline(t.clearGrid),l.setBindGroup(0,y),l.dispatchWorkgroups(a,a),l.end(),e.queue.submit([b.finish()])}{const y=e.createBindGroup({layout:t.bindGroupLayouts.accumulate,entries:[{binding:0,resource:{buffer:s}},{binding:1,resource:{buffer:i}},{binding:2,resource:{buffer:u}}]}),b=e.createCommandEncoder(),l=b.beginComputePass();l.setPipeline(t.accumulate),l.setBindGroup(0,y),l.dispatchWorkgroups(o),l.end(),e.queue.submit([b.finish()])}{const y=e.createBindGroup({layout:t.bindGroupLayouts.convertDensity,entries:[{binding:0,resource:{buffer:i}},{binding:1,resource:{buffer:d}},{binding:2,resource:{buffer:f}}]}),b=e.createCommandEncoder(),l=b.beginComputePass();l.setPipeline(t.convertDensity),l.setBindGroup(0,y),l.dispatchWorkgroups(a,a),l.end(),e.queue.submit([b.finish()])}p(d,h,m,!0);{const y=e.createBindGroup({layout:t.bindGroupLayouts.poissonSolve,entries:[{binding:0,resource:{buffer:h}},{binding:1,resource:{buffer:g}},{binding:2,resource:{buffer:v}},{binding:3,resource:{buffer:w}}]}),b=e.createCommandEncoder(),l=b.beginComputePass();l.setPipeline(t.poissonSolve),l.setBindGroup(0,y),l.dispatchWorkgroups(a,a),l.end(),e.queue.submit([b.finish()])}p(v,I,m,!1),F(g,P,m,!1);{const y=e.createBindGroup({layout:t.bindGroupLayouts.integrate,entries:[{binding:0,resource:{buffer:s}},{binding:1,resource:{buffer:P}},{binding:2,resource:{buffer:x}}]}),b=e.createCommandEncoder(),l=b.beginComputePass();l.setPipeline(t.integrate),l.setBindGroup(0,y),l.dispatchWorkgroups(o),l.end(),e.queue.submit([b.finish()])}}function R(){n();const y=B>0,b=e.createCommandEncoder(),l=S.getCurrentTexture().createView();if(y){const A=e.createBuffer({label:"gradientParams",size:16,usage:T.UNIFORM|T.COPY_DST}),D=new ArrayBuffer(16);new Uint32Array(D,0,1).set([_]),new Float32Array(D,4,3).set([B,C,k]),e.queue.writeBuffer(A,0,D);const N=e.createBindGroup({layout:t.bindGroupLayouts.visualizeGradient,entries:[{binding:0,resource:{buffer:P}},{binding:1,resource:{buffer:I}},{binding:2,resource:{buffer:A}}]}),$=b.beginRenderPass({colorAttachments:[{view:l,loadOp:"clear",storeOp:"store",clearValue:{r:0,g:0,b:0,a:1}}]});$.setPipeline(t.visualizeGradient),$.setBindGroup(0,N),$.draw(3),$.end()}const G=e.createBuffer({label:"densityParams",size:16,usage:T.UNIFORM|T.COPY_DST}),M=new ArrayBuffer(16);new Uint32Array(M,0,1).set([_]),new Float32Array(M,4,1).set([q]),e.queue.writeBuffer(G,0,M);const L=e.createBindGroup({layout:t.bindGroupLayouts.visualizeDensity,entries:[{binding:0,resource:{buffer:d}},{binding:1,resource:{buffer:G}}]}),E=b.beginRenderPass({colorAttachments:[{view:l,loadOp:y?"load":"clear",storeOp:"store",clearValue:{r:0,g:0,b:0,a:1}}]});E.setPipeline(y?t.visualizeDensityAdditive:t.visualizeDensity),E.setBindGroup(0,L),E.draw(3),E.end(),e.queue.submit([b.finish()])}return{step:O,render:R}},inputs:["updateUniforms","device","pipelines","densityAtomic","clearParamsBuffer","workgroupsGrid","particles","accumulateParamsBuffer","workgroupsParticles","density","convertParamsBuffer","runFFT2D","densityHat","fftTemp","gradientHat","potentialHat","poissonParamsBuffer","potential","runVec4FFT2D","gradient","integrateParamsBuffer","gradientIntensity","gpuContext","GPUBufferUsage","N","canvasSize","pixelRatio","brightness"],outputs:["step","render"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-27"),expanded:[],variables:[]},{id:27,body:(n,e,t,i,r)=>{let a=null,s=!1;async function u(){if(!s)try{i&&await n(),e(),a=requestAnimationFrame(u)}catch(o){s=!0,console.error("Animation loop error:",o)}}return e(),a=requestAnimationFrame(u),r.then(()=>{s=!0,a!==null&&(cancelAnimationFrame(a),a=null)}),{animFrameId:a,hasError:s,animationLoop:u}},inputs:["step","render","canvas","simulate","invalidation"],outputs:["animFrameId","hasError","animationLoop"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-28"),expanded:[],variables:[]},{id:28,body:(n,e)=>n`## Implementation Details

The simulation begins each timestep by depositing particle masses onto the grid. Each particle contributes to the four nearest grid cells using bilinear interpolation weights, which ensures smooth density fields and conserves total mass. This "cloud-in-cell" scheme is standard in PM codes.

With the density field ${e`\rho`} assembled, we transform it to Fourier space via a 2D FFT. The Poisson equation ${e`\nabla^2\phi = 4\pi G\rho`} becomes ${e`\hat\phi(\mathbf{k}) = -4\pi G\,\hat\rho(\mathbf{k})/|\mathbf{k}|^2`}, which we solve by simple division (setting the ${e`\mathbf{k}=0`} mode to zero to remove the arbitrary constant in the potential). The gradient ${e`\nabla\phi`} is computed simultaneously in Fourier space by multiplying by ${e`i\mathbf{k}`}, yielding both components of the force field.

After inverse FFTs return the force field to real space, particles sample their accelerations using the same bilinear interpolation used for mass deposition. This symmetry is important for momentum conservation. The particles are then advanced using a second-order midpoint (leapfrog) integrator.

The FFT naturally imposes periodic boundary conditions, so particles that exit one edge of the domain reappear on the opposite side. The overall complexity is ${e`O(N_g^2 \log N_g)`} for the grid operations (where ${e`N_g`} is the grid resolution) plus ${e`O(N_p)`} for the particle operations, making the method efficient even for millions of particles.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});
