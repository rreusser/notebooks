import{vec3 as r,mat4 as M}from"https://cdn.jsdelivr.net/npm/gl-matrix@3.4.3/+esm";class E{constructor(e,t,s,o={}){this.element=e,this.mesh=t,this.controller=s,this.camera=s.camera,this.projectionView=s.projectionView,this.selectedVertexIndex=-1,this.hoverVertexIndex=-1,this.activeVertexIndex=-1,this.selectedEdgeIndex=-1,this.hoverEdgeIndex=-1,this.activeEdgeIndex=-1,this.isDragging=!1,this.dragMode=null,this.initialMousePos=[0,0],this.currentMousePos=[0,0],this.previousMousePos=[0,0],this.deadZoneRadius=5,this.exitedDeadZone=!1,this.touchStartedOnVertex=!1,this.touchVertexIndex=-1,this.backgroundClickStart=null,this.backgroundExitedDeadZone=!1,this.selectionHandledInMouseDown=!1,this.candidateEdge=null,this.dirty=!0,this.onChange=o.onChange||(()=>{}),this._onMouseDown=this._onMouseDown.bind(this),this._onMouseMove=this._onMouseMove.bind(this),this._onMouseUp=this._onMouseUp.bind(this),this._onClick=this._onClick.bind(this),this._onKeyDown=this._onKeyDown.bind(this),this._onKeyUp=this._onKeyUp.bind(this),this._onTouchStart=this._onTouchStart.bind(this),this._onTouchMove=this._onTouchMove.bind(this),this._onTouchEnd=this._onTouchEnd.bind(this),this._setup()}_setup(){const e=this.element;e.tabIndex=1,e.style.outline="none",e.addEventListener("mousedown",this._onMouseDown),e.addEventListener("mousemove",this._onMouseMove),e.addEventListener("click",this._onClick),e.addEventListener("keydown",this._onKeyDown),e.addEventListener("keyup",this._onKeyUp),e.addEventListener("touchstart",this._onTouchStart,{passive:!1}),e.addEventListener("touchmove",this._onTouchMove,{passive:!1}),e.addEventListener("touchend",this._onTouchEnd)}destroy(){const e=this.element;e.removeEventListener("mousedown",this._onMouseDown),e.removeEventListener("mousemove",this._onMouseMove),e.removeEventListener("click",this._onClick),e.removeEventListener("keydown",this._onKeyDown),e.removeEventListener("keyup",this._onKeyUp),e.removeEventListener("touchstart",this._onTouchStart),e.removeEventListener("touchmove",this._onTouchMove),e.removeEventListener("touchend",this._onTouchEnd),window.removeEventListener("mousemove",this._onMouseMove),window.removeEventListener("mouseup",this._onMouseUp)}_getMousePos(e,t=[0,0]){const s=this.element.getBoundingClientRect();return t[0]=e.clientX-s.left,t[1]=e.clientY-s.top,t}_insideDeadZone(){const e=this.currentMousePos[0]-this.initialMousePos[0],t=this.currentMousePos[1]-this.initialMousePos[1];return Math.sqrt(e*e+t*t)<this.deadZoneRadius}_getClosestVertex(e,t){const s=this.mesh,o=this.projectionView,i=this.element.offsetWidth,d=this.element.offsetHeight,n=r.create();let h=-1,a=1/0;for(let c=0;c<s.vertexCount;c++){const u=s.getPosition(c);if(r.transformMat4(n,u,o),n[2]<-1||n[2]>1)continue;const x=(.5+.5*n[0])*i,I=(.5-.5*n[1])*d,f=e-x,l=t-I,g=Math.sqrt(f*f+l*l);g<a&&(a=g,h=c)}return{index:h,distance:a}}_getClosestEdge(e,t){const s=this.mesh,o=this.projectionView,i=this.element.offsetWidth,d=this.element.offsetHeight,n=r.create(),h=r.create();let a=-1,c=1/0;for(let u=0;u<s.edgeCount;u++){const x=s.getEdge(u),I=s.getPosition(x[0]),f=s.getPosition(x[1]);if(r.transformMat4(n,I,o),r.transformMat4(h,f,o),n[2]<-1||n[2]>1||h[2]<-1||h[2]>1)continue;const l=(.5+.5*n[0])*i,g=(.5-.5*n[1])*d,v=(.5+.5*h[0])*i,m=(.5-.5*h[1])*d,p=this._pointToSegmentDistance(e,t,l,g,v,m);p<c&&(c=p,a=u)}return{index:a,distance:c}}_pointToSegmentDistance(e,t,s,o,i,d){const n=i-s,h=d-o,a=n*n+h*h;if(a<1e-4)return Math.sqrt((e-s)*(e-s)+(t-o)*(t-o));let c=((e-s)*n+(t-o)*h)/a;c=Math.max(0,Math.min(1,c));const u=s+c*n,x=o+c*h;return Math.sqrt((e-u)*(e-u)+(t-x)*(t-x))}_getSelectionTarget(e,t,s=18,o=12){const i=this._getClosestVertex(e,t),d=this._getClosestEdge(e,t),n=i.index>=0&&i.distance<s,h=d.index>=0&&d.distance<o;return i.index>=0&&i.distance<10?{type:"vertex",index:i.index,distance:i.distance}:n&&h?d.distance<=i.distance?{type:"edge",index:d.index,distance:d.distance}:{type:"vertex",index:i.index,distance:i.distance}:n?{type:"vertex",index:i.index,distance:i.distance}:h?{type:"edge",index:d.index,distance:d.distance}:{type:"none",index:-1,distance:1/0}}_onMouseDown(e){this._getMousePos(e,this.initialMousePos),this.currentMousePos[0]=this.initialMousePos[0],this.currentMousePos[1]=this.initialMousePos[1],this.previousMousePos[0]=this.initialMousePos[0],this.previousMousePos[1]=this.initialMousePos[1],this.exitedDeadZone=!1;const t=this._getSelectionTarget(this.initialMousePos[0],this.initialMousePos[1]);t.type==="vertex"?(e.preventDefault(),e.stopPropagation(),e.stopImmediatePropagation(),this.element.focus(),this.selectedEdgeIndex=-1,this.selectedVertexIndex>=0&&this.selectedVertexIndex!==t.index&&(this.candidateEdge=[this.selectedVertexIndex,t.index]),this.activeVertexIndex=t.index,this.selectedVertexIndex=t.index,this.dragMode="vertex",this.element.style.cursor="move",this.selectionHandledInMouseDown=!0,this.isDragging=!0,this.dirty=!0,window.addEventListener("mousemove",this._onMouseMove),window.addEventListener("mouseup",this._onMouseUp)):t.type==="edge"?(e.preventDefault(),e.stopPropagation(),e.stopImmediatePropagation(),this.element.focus(),this.selectedVertexIndex=-1,this.activeVertexIndex=-1,this.candidateEdge=null,this.selectedEdgeIndex=t.index,this.activeEdgeIndex=t.index,this.dragMode="edge",this.element.style.cursor="move",this.selectionHandledInMouseDown=!0,this.isDragging=!0,this.dirty=!0,window.addEventListener("mousemove",this._onMouseMove),window.addEventListener("mouseup",this._onMouseUp)):(this.backgroundClickStart=[this.initialMousePos[0],this.initialMousePos[1]],this.backgroundExitedDeadZone=!1,this.selectionHandledInMouseDown=!1,window.addEventListener("mousemove",this._onMouseMove),window.addEventListener("mouseup",this._onMouseUp))}_onMouseMove(e){if(this.previousMousePos[0]=this.currentMousePos[0],this.previousMousePos[1]=this.currentMousePos[1],this._getMousePos(e,this.currentMousePos),this.backgroundClickStart&&!this.backgroundExitedDeadZone){const t=this.currentMousePos[0]-this.backgroundClickStart[0],s=this.currentMousePos[1]-this.backgroundClickStart[1];Math.sqrt(t*t+s*s)>=this.deadZoneRadius&&(this.backgroundExitedDeadZone=!0)}if(!this.isDragging){const t=this._getSelectionTarget(this.currentMousePos[0],this.currentMousePos[1],20,12);let s=-1,o=-1,i="grab";t.type==="vertex"?(s=t.index,i="move"):t.type==="edge"&&(o=t.index,i="pointer"),(s!==this.hoverVertexIndex||o!==this.hoverEdgeIndex)&&(this.hoverVertexIndex=s,this.hoverEdgeIndex=o,this.element.style.cursor=i,this.dirty=!0);return}!this.exitedDeadZone&&!this._insideDeadZone()&&(this.exitedDeadZone=!0),this.dragMode==="vertex"&&this.exitedDeadZone?this._dragVertex():this.dragMode==="edge"&&this.exitedDeadZone&&this._dragEdge()}_onMouseUp(e){if(window.removeEventListener("mousemove",this._onMouseMove),window.removeEventListener("mouseup",this._onMouseUp),!!this.isDragging){if(this._getMousePos(e,this.currentMousePos),!this.exitedDeadZone&&this._insideDeadZone()){const t=this._getSelectionTarget(this.currentMousePos[0],this.currentMousePos[1],20,12);this.dragMode==="vertex"&&(t.type==="vertex"?(this.candidateEdge&&this.mesh.addEdge(this.candidateEdge[0],this.candidateEdge[1]),this.selectedVertexIndex=t.index,this.selectedEdgeIndex=-1):this.selectedVertexIndex>=0&&this._spawnVertex())}this.isDragging=!1,this.dragMode=null,this.activeVertexIndex=-1,this.activeEdgeIndex=-1,this.candidateEdge=null,this.hoverVertexIndex>=0?this.element.style.cursor="move":this.hoverEdgeIndex>=0?this.element.style.cursor="pointer":this.element.style.cursor="grab",this.dirty=!0,this.onChange()}}_onClick(e){const t=this.backgroundExitedDeadZone,s=this.selectionHandledInMouseDown;if(this.backgroundClickStart=null,this.backgroundExitedDeadZone=!1,this.selectionHandledInMouseDown=!1,t||s)return;const o=this._getMousePos(e),i=this._getSelectionTarget(o[0],o[1],20,12);i.type==="vertex"?(this.selectedVertexIndex=i.index,this.selectedEdgeIndex=-1,this.element.focus(),this.dirty=!0):i.type==="edge"?(this.selectedEdgeIndex=i.index,this.selectedVertexIndex=-1,this.element.focus(),this.dirty=!0):this.selectedVertexIndex>=0?this.mesh.degree(this.selectedVertexIndex)<3?(this.currentMousePos[0]=o[0],this.currentMousePos[1]=o[1],this._spawnVertex(),this.element.focus()):(this.selectedVertexIndex=-1,this.selectedEdgeIndex=-1,this.dirty=!0):this.selectedEdgeIndex>=0&&(this.selectedEdgeIndex=-1,this.dirty=!0),this.onChange()}_getTouchPos(e,t=[0,0]){const s=this.element.getBoundingClientRect();return t[0]=e.clientX-s.left,t[1]=e.clientY-s.top,t}_onTouchStart(e){if(e.touches.length!==1){this.touchStartedOnVertex=!1,this.touchVertexIndex=-1;return}const t=this._getTouchPos(e.touches[0]),s=this._getClosestVertex(t[0],t[1]);s.index>=0&&s.distance<35?(e.stopImmediatePropagation(),e.preventDefault(),this.touchStartedOnVertex=!0,this.touchVertexIndex=s.index,this.initialMousePos[0]=t[0],this.initialMousePos[1]=t[1],this.currentMousePos[0]=t[0],this.currentMousePos[1]=t[1],this.exitedDeadZone=!1,this.selectedVertexIndex>=0&&this.selectedVertexIndex!==s.index&&(this.candidateEdge=[this.selectedVertexIndex,s.index]),this.activeVertexIndex=s.index,this.selectedVertexIndex=s.index,this.isDragging=!0,this.dragMode="vertex",this.dirty=!0):(this.touchStartedOnVertex=!1,this.touchVertexIndex=-1,this.backgroundClickStart=[t[0],t[1]],this.backgroundExitedDeadZone=!1)}_onTouchMove(e){if(e.touches.length===1&&this.backgroundClickStart&&!this.backgroundExitedDeadZone){const s=this._getTouchPos(e.touches[0]),o=s[0]-this.backgroundClickStart[0],i=s[1]-this.backgroundClickStart[1];Math.sqrt(o*o+i*i)>=this.deadZoneRadius&&(this.backgroundExitedDeadZone=!0)}if(!this.touchStartedOnVertex||e.touches.length!==1)return;e.preventDefault(),e.stopImmediatePropagation();const t=this._getTouchPos(e.touches[0]);this.previousMousePos[0]=this.currentMousePos[0],this.previousMousePos[1]=this.currentMousePos[1],this.currentMousePos[0]=t[0],this.currentMousePos[1]=t[1],!this.exitedDeadZone&&!this._insideDeadZone()&&(this.exitedDeadZone=!0),this.exitedDeadZone&&this.activeVertexIndex>=0&&this._dragVertex()}_onTouchEnd(e){if(this.touchStartedOnVertex&&e.touches.length===0){if(!this.exitedDeadZone&&this._insideDeadZone()){const t=this._getClosestVertex(this.currentMousePos[0],this.currentMousePos[1]);t.index>=0&&t.distance<35&&(this.candidateEdge&&this.mesh.addEdge(this.candidateEdge[0],this.candidateEdge[1]),this.selectedVertexIndex=t.index)}this.touchStartedOnVertex=!1,this.touchVertexIndex=-1,this.isDragging=!1,this.dragMode=null,this.activeVertexIndex=-1,this.candidateEdge=null,this.dirty=!0,this.onChange()}}_onKeyDown(e){switch(e.code){case"Space":case"Backspace":e.preventDefault(),e.stopPropagation();break}}_onKeyUp(e){switch(e.code){case"Backspace":if(this.selectedVertexIndex>=0){const t=this.mesh.deleteVertex(this.selectedVertexIndex);this.selectedVertexIndex=t,this.hoverVertexIndex=-1,this.hoverEdgeIndex=-1,this.activeVertexIndex=-1,this.dirty=!0,e.preventDefault(),e.stopPropagation()}else this.selectedEdgeIndex>=0&&(this.mesh.deleteEdge(this.selectedEdgeIndex),this.selectedEdgeIndex=-1,this.hoverEdgeIndex=-1,this.hoverVertexIndex=-1,this.dirty=!0,e.preventDefault(),e.stopPropagation());break;case"Space":this.selectedVertexIndex=-1,this.selectedEdgeIndex=-1,this.activeVertexIndex=-1,this.dirty=!0,e.preventDefault(),e.stopPropagation();break;case"KeyC":if(this.selectedVertexIndex>=0){const t=this.mesh.collapseVertex(this.selectedVertexIndex);this.selectedVertexIndex=t,this.hoverVertexIndex=-1,this.activeVertexIndex=-1,this.dirty=!0,e.preventDefault(),e.stopPropagation()}break;case"KeyS":if(this.selectedVertexIndex>=0){const t=this.mesh.splitVertex(this.selectedVertexIndex);this.selectedVertexIndex=t,this.hoverVertexIndex=-1,this.activeVertexIndex=-1,this.dirty=!0,e.preventDefault(),e.stopPropagation()}break;case"KeyE":if(this.selectedVertexIndex>=0){const t=this.mesh.explodeVertex(this.selectedVertexIndex);this.selectedVertexIndex=t,this.hoverVertexIndex=-1,this.activeVertexIndex=-1,this.dirty=!0,e.preventDefault(),e.stopPropagation()}break;case"KeyH":if(this.selectedEdgeIndex>=0){const t=this.mesh.stoneWales(this.selectedEdgeIndex);t>=0&&(this.selectedEdgeIndex=t,this.hoverEdgeIndex=-1,this.hoverVertexIndex=-1),this.dirty=!0,e.preventDefault(),e.stopPropagation()}break;case"KeyA":if(this.selectedVertexIndex>=0){const t=this.mesh.getPosition(this.selectedVertexIndex);r.copy(this.camera.center,t)}else if(this.selectedEdgeIndex>=0){const t=this.mesh.getEdge(this.selectedEdgeIndex),s=this.mesh.getPosition(t[0]),o=this.mesh.getPosition(t[1]);this.camera.center[0]=(s[0]+o[0])/2,this.camera.center[1]=(s[1]+o[1])/2,this.camera.center[2]=(s[2]+o[2])/2}else{const t=this.mesh.computeCentroid();r.copy(this.camera.center,t)}this.dirty=!0,e.preventDefault(),e.stopPropagation();break}this.onChange()}_dragVertex(){const e=this.element.offsetWidth,t=this.element.offsetHeight,s=this.projectionView,o=this.mesh.getPosition(this.activeVertexIndex),i=r.create();r.transformMat4(i,o,s),i[0]=2*this.currentMousePos[0]/e-1,i[1]=1-2*this.currentMousePos[1]/t;const d=M.create();M.invert(d,s);const n=r.create();r.transformMat4(n,i,d),this.mesh.setPosition(this.activeVertexIndex,n[0],n[1],n[2]),this.dirty=!0}_dragEdge(){if(this.selectedEdgeIndex<0)return;const e=this.element.offsetWidth,t=this.element.offsetHeight,s=this.projectionView,o=this.mesh.getEdge(this.selectedEdgeIndex),i=this.mesh.getPosition(o[0]),d=this.mesh.getPosition(o[1]),n=r.fromValues((i[0]+d[0])/2,(i[1]+d[1])/2,(i[2]+d[2])/2),h=r.create();r.transformMat4(h,n,s);const a=2*this.previousMousePos[0]/e-1,c=1-2*this.previousMousePos[1]/t,u=2*this.currentMousePos[0]/e-1,x=1-2*this.currentMousePos[1]/t,I=u-a,f=x-c,l=M.create();M.invert(l,s);for(const g of[o[0],o[1]]){const v=this.mesh.getPosition(g),m=r.create();r.transformMat4(m,v,s),m[0]+=I,m[1]+=f;const p=r.create();r.transformMat4(p,m,l),this.mesh.setPosition(g,p[0],p[1],p[2])}this.dirty=!0}_spawnVertex(){if(this.mesh.degree(this.selectedVertexIndex)>=3)return;const e=this.element.offsetWidth,t=this.element.offsetHeight,s=this.projectionView,o=this.mesh.getPosition(this.selectedVertexIndex),i=r.create();r.transformMat4(i,o,s),i[0]=2*this.currentMousePos[0]/e-1,i[1]=1-2*this.currentMousePos[1]/t;const d=M.create();M.invert(d,s);const n=r.create();r.transformMat4(n,i,d);const h=this.mesh.addVertex(n[0],n[1],n[2]);this.mesh.addEdge(this.selectedVertexIndex,h),this.selectedVertexIndex=h,this.dirty=!0}}export{E as MeshInteractions,E as default};
