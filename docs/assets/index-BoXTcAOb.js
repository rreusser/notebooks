const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/pipeline-CmqcOzJv.js","assets/fft-Chkx7JT6.js"])))=>i.map(i=>d[i]);
import{d as T,_ as M}from"./index-ByB2dbry.js";T({root:document.getElementById("cell-2"),expanded:[],variables:[]},{id:2,body:async n=>{const{createWebGPUContext:e}=await M(()=>import("./webgpu-canvas-C7AS78hn.js"),[]).then(a=>{if(!("createWebGPUContext"in a))throw new SyntaxError("export 'createWebGPUContext' not found");return a}),{device:t,canvasFormat:o}=await e();return n.then(()=>t.destroy()),{createWebGPUContext:e,device:t,canvasFormat:o}},inputs:["invalidation"],outputs:["createWebGPUContext","device","canvasFormat"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-3"),expanded:[],variables:[]},{id:3,body:(n,e)=>{const t=n.select([64,128,256,512,1024,2048],{value:512,label:"Resolution",format:a=>`${a}Ã—${a}`}),o=e(t);return{resolutionInput:t,resolution:o}},inputs:["Inputs","view"],outputs:["resolutionInput","resolution"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-4"),expanded:[],variables:[]},{id:4,body:n=>{const e=n,t=e*e*2*4,o=e*e*4*4,a=Math.ceil(e/16),r=1/e;return{N:e,vec2Size:t,vec4Size:o,workgroups:a,dx:r}},inputs:["resolution"],outputs:["N","vec2Size","vec4Size","workgroups","dx"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-5"),expanded:[],variables:[]},{id:5,body:async(n,e,t)=>{const[{createFluidPipelines:o},{executeFFT2D:a}]=await Promise.all([M(()=>import("./pipeline-CmqcOzJv.js"),__vite__mapDeps([0,1])).then(s=>{if(!("createFluidPipelines"in s))throw new SyntaxError("export 'createFluidPipelines' not found");return s}),M(()=>import("./fft-Chkx7JT6.js"),[]).then(s=>{if(!("executeFFT2D"in s))throw new SyntaxError("export 'executeFFT2D' not found");return s})]),r=await o(n,e,t);function d(s,y,h,B){a({device:n,pipelines:r.fft,input:s,output:y,temp:h,N:t,forward:B,splitNormalization:!0})}return{createFluidPipelines:o,executeFFT2D:a,pipelines:r,runFFT2D:d}},inputs:["device","canvasFormat","N"],outputs:["createFluidPipelines","executeFFT2D","pipelines","runFFT2D"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-6"),expanded:[],variables:[]},{id:6,body:(n,e,t,o,a)=>{const r=n.STORAGE|n.COPY_SRC|n.COPY_DST,d=e.createBuffer({label:"velocity",size:t,usage:r}),s=e.createBuffer({label:"velocityTemp",size:t,usage:r}),y=e.createBuffer({label:"u",size:o,usage:r}),h=e.createBuffer({label:"v",size:o,usage:r}),B=e.createBuffer({label:"uHat",size:o,usage:r}),c=e.createBuffer({label:"vHat",size:o,usage:r}),l=[0,1].map(m=>e.createBuffer({label:`fftTemp[${m}]`,size:o,usage:r})),v=e.createBuffer({label:"dye",size:o,usage:r}),p=e.createBuffer({label:"dyeTemp",size:o,usage:r}),w=a*a*4,i=e.createBuffer({label:"vorticity",size:w,usage:r});return{bufferUsage:r,velocity:d,velocityTemp:s,uBuffer:y,vBuffer:h,uHat:B,vHat:c,fftTemp:l,dye:v,dyeTemp:p,vorticitySize:w,vorticityBuffer:i}},inputs:["GPUBufferUsage","device","vec4Size","vec2Size","N"],outputs:["bufferUsage","velocity","velocityTemp","uBuffer","vBuffer","uHat","vHat","fftTemp","dye","dyeTemp","vorticitySize","vorticityBuffer"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-7"),expanded:[],variables:[]},{id:7,body:(n,e,t)=>{const o=n.createBuffer({label:"simParams",size:32,usage:e.UNIFORM|e.COPY_DST}),a=n.createBuffer({label:"forceParams",size:48,usage:e.UNIFORM|e.COPY_DST}),r=n.createBuffer({label:"projectParams",size:16,usage:e.UNIFORM|e.COPY_DST});n.queue.writeBuffer(r,0,new Uint32Array([t,t]));const d=n.createBuffer({label:"visParams",size:24,usage:e.UNIFORM|e.COPY_DST}),s=n.createBuffer({label:"vorticityParams",size:16,usage:e.UNIFORM|e.COPY_DST}),y=n.createBuffer({label:"boundaryParams",size:24,usage:e.UNIFORM|e.COPY_DST}),h=n.createBuffer({label:"buoyancyParams",size:16,usage:e.UNIFORM|e.COPY_DST});return{simParamsBuffer:o,forceParamsBuffer:a,projectParamsBuffer:r,visParamsBuffer:d,vorticityParamsBuffer:s,boundaryParamsBuffer:y,buoyancyParamsBuffer:h}},inputs:["device","GPUBufferUsage","N"],outputs:["simParamsBuffer","forceParamsBuffer","projectParamsBuffer","visParamsBuffer","vorticityParamsBuffer","boundaryParamsBuffer","buoyancyParamsBuffer"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-8"),expanded:[],variables:[]},{id:8,body:(n,e)=>{const t=n.range([1e-5,.01],{step:1e-5,value:5e-5,transform:Math.log,label:"Viscosity"}),o=e(t),a=n.range([.9,1],{step:.001,value:.99,label:"Dye persistence"}),r=e(a),d=n.range([.01,.15],{step:.005,value:.03,label:"Force radius"}),s=e(d),y=n.range([0,1],{step:.01,value:.5,label:"Force damping"}),h=e(y),B=n.range([0,50],{step:.1,value:5,label:"Vorticity confinement"}),c=e(B),l=n.range([-5,5],{step:.01,value:5,label:"Buoyancy"}),v=e(l),p=n.range([0,10],{step:1,value:5,label:"Wall thickness (cells)"}),w=e(p),i=n.checkbox(["Top/bottom","Left/right"],{label:"Walls"}),m=e(i),g=n.range([.001,.05],{step:.001,value:1/60,label:"Timestep (dt)"}),F=e(g),C=n.select(["Interactive","Rayleigh-Taylor","Kelvin-Helmholtz"],{value:"Rayleigh-Taylor",label:"Initial conditions"}),I=e(C),x=n.range([1,16],{step:1,value:5,label:"Perturbation periods"}),_=e(x),k=n.range([.001,.05],{step:.001,value:.001,label:"Perturbation amplitude"}),G=e(k),$=n.button("Restart"),R=e($),D=n.toggle({label:"Simulate",value:!0}),S=e(D),L=n.range([0,60],{step:.1,value:0,label:"Stop at time (0 = never)"}),E=e(L),P=n.select(["Monotonic cubic","Linear"],{value:"Monotonic cubic",label:"Interpolation"}),A=e(P);return{viscosityInput:t,viscosity:o,dyeDecayInput:a,dyeDecay:r,forceRadiusInput:d,forceRadius:s,forceDampingInput:y,forceDamping:h,vorticityInput:B,vorticityConfinement:c,buoyancyInput:l,buoyancy:v,wallThicknessInput:p,wallThickness:w,wallsEnabledInput:i,wallsEnabled:m,timestepInput:g,timestep:F,initialConditionInput:C,initialCondition:I,perturbationPeriodsInput:x,perturbationPeriods:_,perturbationAmplitudeInput:k,perturbationAmplitude:G,restartInput:$,restart:R,simulateInput:D,simulate:S,stopTimeInput:L,stopTime:E,interpolationInput:P,interpolation:A}},inputs:["Inputs","view"],outputs:["viscosityInput","viscosity","dyeDecayInput","dyeDecay","forceRadiusInput","forceRadius","forceDampingInput","forceDamping","vorticityInput","vorticityConfinement","buoyancyInput","buoyancy","wallThicknessInput","wallThickness","wallsEnabledInput","wallsEnabled","timestepInput","timestep","initialConditionInput","initialCondition","perturbationPeriodsInput","perturbationPeriods","perturbationAmplitudeInput","perturbationAmplitude","restartInput","restart","simulateInput","simulate","stopTimeInput","stopTime","interpolationInput","interpolation"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-9"),expanded:[],variables:[]},{id:9,body:(n,e,t,o,a,r,d,s,y,h,B,c,l,v,p,w,i,m,g)=>{n(e`<div id="fluid-controls">
  ${t}
  ${o}
  ${a}
  ${r}
  ${d}
  ${s}
  ${y}
  ${h}
  ${B}
  ${c}
  ${l}
  ${v}
  ${p}
  ${w}
  ${i}
  ${m}
  ${g}
</div>`)},inputs:["display","html","resolutionInput","initialConditionInput","perturbationPeriodsInput","perturbationAmplitudeInput","stopTimeInput","viscosityInput","dyeDecayInput","timestepInput","forceRadiusInput","forceDampingInput","vorticityInput","buoyancyInput","wallThicknessInput","wallsEnabledInput","interpolationInput","simulateInput","restartInput"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-10"),expanded:[],variables:[]},{id:10,body:(n,e,t,o,a,r)=>{const d=Math.min(n,640),s=e`<canvas
  id="fluid-canvas"
  width="${d*window.devicePixelRatio}"
  height="${d*window.devicePixelRatio}"
  style="width: ${d}px; height: ${d}px; cursor: crosshair;">
</canvas>`,y=s.getContext("webgpu");return y.configure({device:t,format:o,alphaMode:"opaque",usage:a.RENDER_ATTACHMENT|a.COPY_SRC}),r(s),{canvasSize:d,canvas:s,gpuContext:y}},inputs:["width","html","device","canvasFormat","GPUTextureUsage","display"],outputs:["canvasSize","canvas","gpuContext"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-11"),expanded:[],variables:[]},{id:11,body:n=>{const e={down:!1,x:0,y:0,prevX:0,prevY:0,dx:0,dy:0};function t(o){const a=n.getBoundingClientRect();return{x:(o.clientX-a.left)/a.width,y:(o.clientY-a.top)/a.height}}return n.addEventListener("pointerdown",o=>{e.down=!0;const a=t(o);e.x=a.x,e.y=a.y,e.prevX=a.x,e.prevY=a.y,n.setPointerCapture(o.pointerId)}),n.addEventListener("pointermove",o=>{const a=t(o);e.prevX=e.x,e.prevY=e.y,e.x=a.x,e.y=a.y,e.down&&(e.dx=e.x-e.prevX,e.dy=e.y-e.prevY)}),n.addEventListener("pointerup",o=>{e.down=!1,e.dx=0,e.dy=0,n.releasePointerCapture(o.pointerId)}),n.addEventListener("pointerleave",()=>{e.down=!1,e.dx=0,e.dy=0}),n.addEventListener("touchstart",o=>o.preventDefault(),{passive:!1}),n.addEventListener("touchmove",o=>o.preventDefault(),{passive:!1}),{mouseState:e,getMousePos:t}},inputs:["canvas"],outputs:["mouseState","getMousePos"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-12"),expanded:[],variables:[]},{id:12,body:()=>({simParams:{viscosity:5e-5,dyeDecay:.998,forceRadius:.03,forceDamping:.15,vorticityConfinement:2,buoyancy:5,wallThicknessX:0,wallThicknessY:0,dt:.016666666666666666,useLinearInterp:0,time:0,stopTime:0}}),inputs:[],outputs:["simParams"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-13"),expanded:[],variables:[]},{id:13,body:(n,e,t,o,a,r,d,s,y,h,B,c)=>{c.viscosity=n,c.dyeDecay=e,c.dt=y,c.forceRadius=t,c.forceDamping=o,c.vorticityConfinement=a,c.buoyancy=r,c.wallThicknessX=s.includes("Left/right")?d:0,c.wallThicknessY=s.includes("Top/bottom")?d:0,c.useLinearInterp=h==="Linear"?1:0,c.stopTime=B},inputs:["viscosity","dyeDecay","forceRadius","forceDamping","vorticityConfinement","buoyancy","wallThickness","wallsEnabled","timestep","interpolation","stopTime","simParams"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-14"),expanded:[],variables:[]},{id:14,body:(n,e,t,o,a,r)=>{n==="Rayleigh-Taylor"?(e.value=5,e.dispatchEvent(new t("input")),o.value=["Top/bottom"],o.dispatchEvent(new t("input")),a.value=1,a.dispatchEvent(new t("input")),r.value=.5,r.dispatchEvent(new t("input"))):n==="Kelvin-Helmholtz"&&(e.value=5,e.dispatchEvent(new t("input")),o.value=["Top/bottom"],o.dispatchEvent(new t("input")),a.value=1,a.dispatchEvent(new t("input")),r.value=0,r.dispatchEvent(new t("input")))},inputs:["initialCondition","wallThicknessInput","Event","wallsEnabledInput","dyeDecayInput","buoyancyInput"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-15"),expanded:[],variables:[]},{id:15,body:(n,e,t,o,a,r,d,s,y,h,B)=>{a.time=0;const c=new Float32Array(r*r*4),l=new Float32Array(r*r*2);if(e==="Interactive")c.fill(0),l.fill(0);else if(e==="Rayleigh-Taylor")for(let p=0;p<r;p++)for(let w=0;w<r;w++){const i=p*r+w,m=w/r,g=p/r,F=.5+o*Math.sin(2*Math.PI*t*m);if(g<F){const C=(F-g)/.03,I=Math.min(1,C);l[i*2]=I,l[i*2+1]=0}else l[i*2]=0,l[i*2+1]=0;c[i*4]=0,c[i*4+1]=0,c[i*4+2]=0,c[i*4+3]=0}else if(e==="Kelvin-Helmholtz")for(let w=0;w<r;w++)for(let i=0;i<r;i++){const m=w*r+i,g=i/r,F=w/r,C=.5+o*Math.sin(2*Math.PI*t*g),I=(F-C)/.1,x=Math.tanh(I)*.5;if(c[m*4]=x,c[m*4+1]=0,c[m*4+2]=o*Math.sin(2*Math.PI*t*g)*Math.exp(-I*I),c[m*4+3]=0,F<C){const _=(C-F)/.03,k=Math.min(1,_);l[m*2]=k,l[m*2+1]=0}else l[m*2]=0,l[m*2+1]=0}return d.queue.writeBuffer(s,0,c),d.queue.writeBuffer(y,0,c),d.queue.writeBuffer(h,0,l),d.queue.writeBuffer(B,0,l),{velocityData:c,dyeData:l}},inputs:["restart","initialCondition","perturbationPeriods","perturbationAmplitude","simParams","N","device","velocity","velocityTemp","dye","dyeTemp"],outputs:["velocityData","dyeData"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-16"),expanded:[],variables:[]},{id:16,body:(n,e,t,o,a,r,d,s,y,h)=>{function B(){const i=new ArrayBuffer(32);new Uint32Array(i,0,2).set([n,n]),new Float32Array(i,8,1).set([e.dt]),new Float32Array(i,12,1).set([e.viscosity]),new Float32Array(i,16,1).set([e.dyeDecay]),new Float32Array(i,20,1).set([e.wallThicknessX]),new Float32Array(i,24,1).set([e.wallThicknessY]),new Uint32Array(i,28,1).set([e.useLinearInterp]),t.queue.writeBuffer(o,0,i)}function c(){const i=a.dx/e.dt,m=-a.dy/e.dt,g=new ArrayBuffer(48);new Uint32Array(g,0,2).set([n,n]),new Float32Array(g,8,2).set([a.x,1-a.y]),new Float32Array(g,16,2).set([i,m]),new Float32Array(g,24,1).set([e.forceRadius]),new Float32Array(g,28,1).set([a.down?1:0]),new Float32Array(g,32,1).set([e.forceDamping]),t.queue.writeBuffer(r,0,g)}function l(){const i=new ArrayBuffer(24);new Uint32Array(i,0,2).set([n,n]),new Float32Array(i,8,1).set([1]),new Float32Array(i,12,1).set([0]),new Float32Array(i,16,1).set([e.wallThicknessX]),new Float32Array(i,20,1).set([e.wallThicknessY]),t.queue.writeBuffer(d,0,i)}function v(){const i=new ArrayBuffer(16);new Uint32Array(i,0,2).set([n,n]),new Float32Array(i,8,1).set([e.vorticityConfinement]),new Float32Array(i,12,1).set([e.dt]),t.queue.writeBuffer(s,0,i)}function p(){const i=new ArrayBuffer(24);new Uint32Array(i,0,2).set([n,n]),new Float32Array(i,8,1).set([0]),new Float32Array(i,12,1).set([e.wallThicknessX]),new Float32Array(i,16,1).set([e.wallThicknessY]),t.queue.writeBuffer(y,0,i)}function w(){const i=new ArrayBuffer(16);new Uint32Array(i,0,2).set([n,n]),new Float32Array(i,8,1).set([e.buoyancy]),new Float32Array(i,12,1).set([e.dt]),t.queue.writeBuffer(h,0,i)}return{updateSimUniforms:B,updateForceUniforms:c,updateVisUniforms:l,updateVorticityUniforms:v,updateBoundaryUniforms:p,updateBuoyancyUniforms:w}},inputs:["N","simParams","device","simParamsBuffer","mouseState","forceParamsBuffer","visParamsBuffer","vorticityParamsBuffer","boundaryParamsBuffer","buoyancyParamsBuffer"],outputs:["updateSimUniforms","updateForceUniforms","updateVisUniforms","updateVorticityUniforms","updateBoundaryUniforms","updateBuoyancyUniforms"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-17"),expanded:[],variables:[]},{id:17,body:(n,e,t,o,a,r,d,s,y,h,B,c,l,v,p,w,i,m,g,F,C,I,x,_,k,G,$,R,D,S,L)=>{function E(){if(n.wallThicknessX>0||n.wallThicknessY>0){e();const b=t.createBindGroup({layout:o.bindGroupLayouts.enforceBoundary,entries:[{binding:0,resource:{buffer:a}},{binding:1,resource:{buffer:r}},{binding:2,resource:{buffer:d}}]}),f=t.createCommandEncoder(),u=f.beginComputePass();u.setPipeline(o.enforceBoundary),u.setBindGroup(0,b),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([f.finish()])}}async function P(){y(),h(),E();{const b=t.createBindGroup({layout:o.bindGroupLayouts.addForce,entries:[{binding:0,resource:{buffer:a}},{binding:1,resource:{buffer:r}},{binding:2,resource:{buffer:B}}]}),f=t.createCommandEncoder(),u=f.beginComputePass();u.setPipeline(o.addForce),u.setBindGroup(0,b),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([f.finish()])}{const b=t.createBindGroup({layout:o.bindGroupLayouts.advect,entries:[{binding:0,resource:{buffer:a}},{binding:1,resource:{buffer:a}},{binding:2,resource:{buffer:c}},{binding:3,resource:{buffer:l}}]}),f=t.createCommandEncoder(),u=f.beginComputePass();u.setPipeline(o.advectVelocity),u.setBindGroup(0,b),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([f.finish()])}{const b=t.createCommandEncoder();b.copyBufferToBuffer(c,0,a,0,v),t.queue.submit([b.finish()])}E();{const b=t.createBindGroup({layout:o.bindGroupLayouts.advectScalar,entries:[{binding:0,resource:{buffer:a}},{binding:1,resource:{buffer:r}},{binding:2,resource:{buffer:p}},{binding:3,resource:{buffer:l}}]}),f=t.createCommandEncoder(),u=f.beginComputePass();u.setPipeline(o.advectScalar),u.setBindGroup(0,b),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([f.finish()])}{const b=t.createCommandEncoder();b.copyBufferToBuffer(p,0,r,0,w),t.queue.submit([b.finish()])}{const b=t.createBindGroup({layout:o.bindGroupLayouts.splitVelocity,entries:[{binding:0,resource:{buffer:a}},{binding:1,resource:{buffer:i}},{binding:2,resource:{buffer:m}},{binding:3,resource:{buffer:g}}]}),f=t.createCommandEncoder(),u=f.beginComputePass();u.setPipeline(o.splitVelocity),u.setBindGroup(0,b),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([f.finish()])}F(i,C,I,!0),F(m,x,I,!0);{const b=t.createBindGroup({layout:o.bindGroupLayouts.projectFFT,entries:[{binding:0,resource:{buffer:C}},{binding:1,resource:{buffer:x}},{binding:2,resource:{buffer:l}}]}),f=t.createCommandEncoder(),u=f.beginComputePass();u.setPipeline(o.projectFFT),u.setBindGroup(0,b),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([f.finish()])}F(C,i,I,!1),F(x,m,I,!1);{const b=t.createBindGroup({layout:o.bindGroupLayouts.mergeVelocity,entries:[{binding:0,resource:{buffer:i}},{binding:1,resource:{buffer:m}},{binding:2,resource:{buffer:a}},{binding:3,resource:{buffer:g}}]}),f=t.createCommandEncoder(),u=f.beginComputePass();u.setPipeline(o.mergeVelocity),u.setBindGroup(0,b),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([f.finish()])}if(E(),n.vorticityConfinement>0){_();{const b=t.createBindGroup({layout:o.bindGroupLayouts.computeVorticity,entries:[{binding:0,resource:{buffer:a}},{binding:1,resource:{buffer:k}},{binding:2,resource:{buffer:G}}]}),f=t.createCommandEncoder(),u=f.beginComputePass();u.setPipeline(o.computeVorticity),u.setBindGroup(0,b),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([f.finish()])}{const b=t.createBindGroup({layout:o.bindGroupLayouts.applyVorticity,entries:[{binding:0,resource:{buffer:a}},{binding:1,resource:{buffer:k}},{binding:2,resource:{buffer:G}}]}),f=t.createCommandEncoder(),u=f.beginComputePass();u.setPipeline(o.applyVorticity),u.setBindGroup(0,b),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([f.finish()])}}if(n.buoyancy!==0){$();const b=t.createBindGroup({layout:o.bindGroupLayouts.applyBuoyancy,entries:[{binding:0,resource:{buffer:a}},{binding:1,resource:{buffer:r}},{binding:2,resource:{buffer:R}}]}),f=t.createCommandEncoder(),u=f.beginComputePass();u.setPipeline(o.applyBuoyancy),u.setBindGroup(0,b),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([f.finish()])}E()}function A(){D();const b=t.createBindGroup({layout:o.bindGroupLayouts.visualize,entries:[{binding:0,resource:{buffer:a}},{binding:1,resource:{buffer:r}},{binding:2,resource:{buffer:S}}]}),f=t.createCommandEncoder(),u=f.beginRenderPass({colorAttachments:[{view:L.getCurrentTexture().createView(),loadOp:"clear",storeOp:"store",clearValue:{r:0,g:0,b:0,a:1}}]});u.setPipeline(o.visualize),u.setBindGroup(0,b),u.draw(6),u.end(),t.queue.submit([f.finish()])}return{enforceBoundaries:E,step:P,render:A}},inputs:["simParams","updateBoundaryUniforms","device","pipelines","velocity","dye","boundaryParamsBuffer","workgroups","updateSimUniforms","updateForceUniforms","forceParamsBuffer","velocityTemp","simParamsBuffer","vec4Size","dyeTemp","vec2Size","uBuffer","vBuffer","projectParamsBuffer","runFFT2D","uHat","fftTemp","vHat","updateVorticityUniforms","vorticityBuffer","vorticityParamsBuffer","updateBuoyancyUniforms","buoyancyParamsBuffer","updateVisUniforms","visParamsBuffer","gpuContext"],outputs:["enforceBoundaries","step","render"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-18"),expanded:[],variables:[]},{id:18,body:async(n,e,t,o,a,r,d,s,y,h,B)=>{const{createFrameLoop:c}=await M(()=>import("./frame-loop-QkwpdSbZ.js"),[]).then(p=>{if(!("createFrameLoop"in p))throw new SyntaxError("export 'createFrameLoop' not found");return p}),l=a`<div id="time-display" style="font-family: monospace; margin-top: 0.5em;">t = 0.000</div>`;r(l);const v=c(()=>{o&&(d.stopTime<=0||d.time<d.stopTime)&&(n(),d.time+=d.dt,d.stopTime>0&&d.time>=d.stopTime&&(s.value=!1,s.dispatchEvent(new y("input")))),e(),l.textContent=`t = ${d.time.toFixed(3)}`,h.dx=0,h.dy=0});return B.then(()=>v.cancel()),{createFrameLoop:c,timeDisplay:l,loop:v}},inputs:["step","render","canvas","simulate","html","display","simParams","simulateInput","Event","mouseState","invalidation"],outputs:["createFrameLoop","timeDisplay","loop"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-25"),expanded:[],variables:[]},{id:25,body:(n,e,t,o,a,r,d,s,y,h,B,c)=>{const l=s.button("Download PNG");return y(l),l.addEventListener("click",async()=>{const v=e.width,p=e.height,i=v*4,m=Math.ceil(i/256)*256,g=m*p,F=o.createBuffer({size:g,usage:h.COPY_DST|h.MAP_READ});n();const C=o.createCommandEncoder();C.copyTextureToBuffer({texture:t.getCurrentTexture()},{buffer:F,bytesPerRow:m},{width:v,height:p}),o.queue.submit([C.finish()]),await F.mapAsync(B.READ);const I=new Uint8Array(F.getMappedRange()),x=new ImageData(v,p);for(let D=0;D<p;D++){const S=D*m,L=D*v*4;for(let E=0;E<v;E++){const P=S+E*4,A=L+E*4;a==="bgra8unorm"?(x.data[A+0]=I[P+2],x.data[A+1]=I[P+1],x.data[A+2]=I[P+0],x.data[A+3]=255):(x.data[A+0]=I[P+0],x.data[A+1]=I[P+1],x.data[A+2]=I[P+2],x.data[A+3]=255)}}F.unmap(),F.destroy();const _=new c(v,p);_.getContext("2d").putImageData(x,0,0);const G=await _.convertToBlob({type:"image/png"}),$=URL.createObjectURL(G),R=document.createElement("a");R.href=$,R.download=`stable-fluids-${r.toLowerCase().replace(" ","-")}-t${d.time.toFixed(2)}.png`,R.click(),URL.revokeObjectURL($)}),{downloadButton:l}},inputs:["render","canvas","gpuContext","device","canvasFormat","interpolation","simParams","Inputs","display","GPUBufferUsage","GPUMapMode","OffscreenCanvas"],outputs:["downloadButton"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});T({root:document.getElementById("cell-19"),expanded:[],variables:[]},{id:19,body:(n,e)=>n`## Algorithm

The Stable Fluids algorithm solves the incompressible Navier-Stokes equations:

${e.block`\frac{\partial \mathbf{u}}{\partial t} = -(\mathbf{u} \cdot \nabla)\mathbf{u} + \nu \nabla^2 \mathbf{u} - \nabla p + \mathbf{f}`}

subject to the incompressibility constraint ${e`\nabla \cdot \mathbf{u} = 0`}.

Each timestep consists of four stages:

1. **Add forces**: Apply external forces (mouse input) to the velocity field
2. **Advect**: Move the velocity field along itself using semi-Lagrangian advection
3. **Diffuse**: Apply viscous diffusion (done in frequency domain as multiplication)
4. **Project**: Make velocity divergence-free by subtracting the gradient of pressure

The key insight is that projection can be done efficiently in frequency domain. The velocity ${e`\hat{\mathbf{u}}(\mathbf{k})`} is decomposed into components parallel and perpendicular to the wavenumber ${e`\mathbf{k}`}. The divergence-free projection removes the parallel component:

${e.block`\hat{\mathbf{u}}_{\perp} = \hat{\mathbf{u}} - \mathbf{k}\frac{\mathbf{k} \cdot \hat{\mathbf{u}}}{|\mathbf{k}|^2}`}

This makes the algorithm unconditionally stable regardless of timestep size.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});T({root:document.getElementById("cell-20"),expanded:[],variables:[]},{id:20,body:(n,e)=>n`## Implementation Details

### Grid Layout

Velocities are **cell-centered** (collocated), not staggered. Cell ${e`(i,j)`} stores both velocity components ${e`(u, v)`} at physical position ${e`(i+0.5, j+0.5)`}. Velocity is stored as \`vec4<f32>\` with layout \`(u_re, u_im, v_re, v_im)\` to accommodate FFT operations. In the spatial domain, the imaginary parts are zero.

### Simulation Loop

Each timestep executes these stages in order:

1. **Add forces** (mouse interaction)
2. **Advect velocity** (semi-Lagrangian)
3. **Advect dye**
4. **Project + diffuse** (FFT-based)
5. **Vorticity confinement**
6. **Buoyancy**
7. **Boundary enforcement**

### FFT-Based Projection and Diffusion

The FFT is used to efficiently solve the pressure projection and diffusion in frequency domain:

1. **Split** the interleaved velocity into separate ${e`u`} and ${e`v`} complex buffers
2. **Forward FFT** on both components
3. **Project and diffuse** in frequency domain:
   - Compute wavenumber ${e`\mathbf{k}`} with frequencies ${e`0, 1, \ldots, N/2-1, -N/2, \ldots, -1`} scaled by ${e`2\pi`}
   - Remove component parallel to ${e`\mathbf{k}`}: ${e.block`\hat{u} \leftarrow \hat{u} - k_x \frac{\mathbf{k} \cdot \hat{\mathbf{u}}}{|\mathbf{k}|^2}, \quad \hat{v} \leftarrow \hat{v} - k_y \frac{\mathbf{k} \cdot \hat{\mathbf{u}}}{|\mathbf{k}|^2}`}
   - Apply implicit diffusion by multiplying by ${e`\frac{1}{1 + \nu |\mathbf{k}|^2 \Delta t}`}
   - Zero the DC component (${e`\mathbf{k} = 0`})
4. **Inverse FFT** to return to spatial domain
5. **Merge** back into interleaved velocity buffer

### Forcing Model

The force uses a **velocity-matching model** rather than direct impulse injection:

${e.block`\mathbf{f} = (\mathbf{v}_{\text{target}} - \mathbf{v}) \cdot \text{damping} \cdot \text{falloff}`}

where ${e`\mathbf{v}_{\text{target}} = \Delta\mathbf{x}_{\text{mouse}} / \Delta t`} is computed from mouse velocity, and the falloff is Gaussian: ${e`\exp(-r^2 / 2\sigma^2)`}.

Dye injection uses a **hard circle** (step function) rather than Gaussian for sharper smoke edges.

### Semi-Lagrangian Advection

For each grid cell, trace backward through the velocity field to find the departure point:

${e.block`\mathbf{x}_{\text{back}} = \mathbf{x} - \mathbf{u}(\mathbf{x}) \cdot N \cdot \Delta t`}

Then sample the source field at ${e`\mathbf{x}_{\text{back}}`} using **monotone cubic interpolation** (Fedkiw et al., "Visual Simulation of Smoke", SIGGRAPH 2001). The factor of ${e`N`} converts velocity from normalized to grid units.

The monotone cubic interpolation uses Hermite interpolation with slope limiting to prevent overshoot:

${e.block`f(t) = a_3 t^3 + a_2 t^2 + a_1 t + a_0`}

where the slopes ${e`d_k = (f_{k+1} - f_{k-1})/2`} are set to zero when they differ in sign from ${e`\Delta_k = f_{k+1} - f_k`}. This preserves monotonicity and eliminates spurious oscillations that can arise with standard cubic interpolation.

### Vorticity Confinement

Two-pass process to counteract numerical dissipation of rotational motion:

**Pass 1**: Compute vorticity (curl) using central differences:
${e.block`\omega = \frac{\partial v}{\partial x} - \frac{\partial u}{\partial y}`}

**Pass 2**: Apply confinement force in the direction perpendicular to the vorticity gradient:
${e.block`\mathbf{N} = \frac{\nabla|\omega|}{|\nabla|\omega||}, \quad \mathbf{f} = \varepsilon (\mathbf{N} \times \omega)`}

In 2D, the cross product gives ${e`\mathbf{f} = \varepsilon (N_y \omega, -N_x \omega)`}. This force points toward vortex centers, amplifying rotational structures.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});
