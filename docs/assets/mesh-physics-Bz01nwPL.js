class F{constructor(s){this.mesh=s,this.gradient=null,this.k=1,this.l0=1,this.theta0=150,this.kBend=.3,this.kTorsion=.1,this.gamma=.1,this.frozenVertex=-1}_ensureGradient(){const s=this.mesh.vertexCount*3;(!this.gradient||this.gradient.length<s)&&(this.gradient=new Float64Array(Math.max(s,256))),this.gradient.fill(0,0,this.mesh.vertexCount*3)}iterate(){this.mesh.vertexCount!==0&&(this._ensureGradient(),this.k>0&&this._computeAxialGradient(),this.kBend>0&&this._computeDihedralGradient(),this.kTorsion>0&&this._computeTorsionalGradient(),this._applyGradient())}_computeAxialGradient(){const s=this.mesh,i=s.positions,o=this.gradient,a=this.k,r=this.l0;for(let n=0;n<s.edgeCount;n++){const c=n*2,t=s.edges[c],e=s.edges[c+1],d=t*3,h=e*3,l=i[d]-i[h],u=i[d+1]-i[h+1],v=i[d+2]-i[h+2],b=Math.sqrt(l*l+u*u+v*v);if(b<1e-10)continue;const m=a*(1-r/b),G=m*l,k=m*u,q=m*v;o[d]+=G,o[d+1]+=k,o[d+2]+=q,o[h]-=G,o[h+1]-=k,o[h+2]-=q}}_computeDihedralGradient(){const s=this.mesh;s.positions,this.gradient;const i=this.kBend*this.l0*this.l0,o=Math.cos(this.theta0*Math.PI/180);for(let a=0;a<s.vertexCount;a++){const r=a*3,n=s.neighbors[r],c=s.neighbors[r+1],t=s.neighbors[r+2];n!==-1&&c!==-1&&this._accumulateDihedralGradient(a,n,c,i,o),c!==-1&&t!==-1&&this._accumulateDihedralGradient(a,c,t,i,o),t!==-1&&n!==-1&&this._accumulateDihedralGradient(a,t,n,i,o)}}_accumulateDihedralGradient(s,i,o,a,r){const n=this.mesh.positions,c=this.gradient,t=s*3,e=i*3,d=o*3,h=n[e]-n[t],l=n[e+1]-n[t+1],u=n[e+2]-n[t+2],v=n[d]-n[t],b=n[d+1]-n[t+1],m=n[d+2]-n[t+2],G=Math.sqrt(h*h+l*l+u*u),k=Math.sqrt(v*v+b*b+m*m);if(G<1e-10||k<1e-10)return;const y=(h*v+l*b+u*m)/(G*k),T=a*2*(y-r)/(G*k),V=G/k;let f=T*(v-y/V*h),_=T*(b-y/V*l),g=T*(m-y/V*u),B=T*(h-y*V*v),A=T*(l-y*V*b),E=T*(u-y*V*m);c[t]-=f+B,c[t+1]-=_+A,c[t+2]-=g+E,c[e]+=f,c[e+1]+=_,c[e+2]+=g,c[d]+=B,c[d+1]+=A,c[d+2]+=E}_computeTorsionalGradient(){const s=this.mesh;for(let i=0;i<s.edgeCount;i++){const o=s.getTorsionVertices(i);o&&this._accumulateTorsionalGradient(o)}}_accumulateTorsionalGradient(s){const{a:i,b:o,c:a,d:r,e:n,f:c}=s,t=this.mesh.positions,e=this.gradient,d=this.kTorsion*this.l0*this.l0,h=i*3,l=o*3,u=a*3,v=r*3,b=n*3,m=c*3,G=[t[h],t[h+1],t[h+2]],k=[t[l],t[l+1],t[l+2]],q=[t[u],t[u+1],t[u+2]],y=[t[v],t[v+1],t[v+2]],T=[t[b],t[b+1],t[b+2]],V=[t[m],t[m+1],t[m+2]],f=this._unitVector(G,k),_=this._unitVector(q,y),g=this._unitVector(T,V);if(!f||!_||!g)return;const B=f.len,A=_.len,E=g.len,z=this._dot(_.v,g.v),p=this._dot(f.v,g.v),x=this._dot(f.v,_.v),P=(z-x*p)*d,M=[f.v[0]*(-2*x*p)+_.v[0]*p+g.v[0]*x,f.v[1]*(-2*x*p)+_.v[1]*p+g.v[1]*x,f.v[2]*(-2*x*p)+_.v[2]*p+g.v[2]*x];this._scaleVec(M,-2*P/B);const C=[_.v[0]*(z-p*x)-g.v[0]+f.v[0]*p,_.v[1]*(z-p*x)-g.v[1]+f.v[1]*p,_.v[2]*(z-p*x)-g.v[2]+f.v[2]*p];this._scaleVec(C,-2*P/A);const D=[g.v[0]*(z-x*p)-_.v[0]+f.v[0]*x,g.v[1]*(z-x*p)-_.v[1]+f.v[1]*x,g.v[2]*(z-x*p)-_.v[2]+f.v[2]*x];this._scaleVec(D,-2*P/E),e[h]+=M[0],e[h+1]+=M[1],e[h+2]+=M[2],e[l]-=M[0],e[l+1]-=M[1],e[l+2]-=M[2],e[u]+=C[0],e[u+1]+=C[1],e[u+2]+=C[2],e[v]-=C[0],e[v+1]-=C[1],e[v+2]-=C[2],e[b]+=D[0],e[b+1]+=D[1],e[b+2]+=D[2],e[m]-=D[0],e[m+1]-=D[1],e[m+2]-=D[2]}_unitVector(s,i){const o=i[0]-s[0],a=i[1]-s[1],r=i[2]-s[2],n=Math.sqrt(o*o+a*a+r*r);return n<1e-10?null:{v:[o/n,a/n,r/n],len:n}}_dot(s,i){return s[0]*i[0]+s[1]*i[1]+s[2]*i[2]}_scaleVec(s,i){s[0]*=i,s[1]*=i,s[2]*=i}_applyGradient(){const s=this.mesh,i=s.positions,o=this.gradient,a=this.gamma;for(let r=0;r<s.vertexCount;r++){if(r===this.frozenVertex)continue;const n=r*3;i[n]-=o[n]*a,i[n+1]-=o[n+1]*a,i[n+2]-=o[n+2]*a}}computeEdgeStrain(s){const i=this.mesh,o=s*2,a=i.edges[o],r=i.edges[o+1],n=a*3,c=r*3,t=i.positions,e=t[n]-t[c],d=t[n+1]-t[c+1],h=t[n+2]-t[c+2];return Math.sqrt(e*e+d*d+h*h)/this.l0-1}}export{F as MeshPhysics,F as default};
