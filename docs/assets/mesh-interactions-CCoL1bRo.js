import{vec3 as d,mat4 as M}from"https://cdn.jsdelivr.net/npm/gl-matrix@3.4.3/+esm";class E{constructor(e,t,s,i={}){this.element=e,this.mesh=t,this.controller=s,this.camera=s.camera,this.projectionView=s.projectionView,this.selectedVertexIndex=-1,this.hoverVertexIndex=-1,this.activeVertexIndex=-1,this.selectedEdgeIndex=-1,this.hoverEdgeIndex=-1,this.activeEdgeIndex=-1,this.isDragging=!1,this.dragMode=null,this.initialMousePos=[0,0],this.currentMousePos=[0,0],this.previousMousePos=[0,0],this.deadZoneRadius=5,this.exitedDeadZone=!1,this.touchStartedOnVertex=!1,this.touchVertexIndex=-1,this.backgroundClickStart=null,this.backgroundExitedDeadZone=!1,this.selectionHandledInMouseDown=!1,this.candidateEdge=null,this.dirty=!0,this.onChange=i.onChange||(()=>{}),this._onMouseDown=this._onMouseDown.bind(this),this._onMouseMove=this._onMouseMove.bind(this),this._onMouseUp=this._onMouseUp.bind(this),this._onClick=this._onClick.bind(this),this._onKeyDown=this._onKeyDown.bind(this),this._onKeyUp=this._onKeyUp.bind(this),this._onTouchStart=this._onTouchStart.bind(this),this._onTouchMove=this._onTouchMove.bind(this),this._onTouchEnd=this._onTouchEnd.bind(this),this._setup()}_setup(){const e=this.element;e.tabIndex=1,e.style.outline="none",e.addEventListener("mousedown",this._onMouseDown),e.addEventListener("mousemove",this._onMouseMove),e.addEventListener("click",this._onClick),e.addEventListener("keydown",this._onKeyDown),e.addEventListener("keyup",this._onKeyUp),e.addEventListener("touchstart",this._onTouchStart,{passive:!1}),e.addEventListener("touchmove",this._onTouchMove,{passive:!1}),e.addEventListener("touchend",this._onTouchEnd)}destroy(){const e=this.element;e.removeEventListener("mousedown",this._onMouseDown),e.removeEventListener("mousemove",this._onMouseMove),e.removeEventListener("click",this._onClick),e.removeEventListener("keydown",this._onKeyDown),e.removeEventListener("keyup",this._onKeyUp),e.removeEventListener("touchstart",this._onTouchStart),e.removeEventListener("touchmove",this._onTouchMove),e.removeEventListener("touchend",this._onTouchEnd),window.removeEventListener("mousemove",this._onMouseMove),window.removeEventListener("mouseup",this._onMouseUp)}_getMousePos(e,t=[0,0]){const s=this.element.getBoundingClientRect();return t[0]=e.clientX-s.left,t[1]=e.clientY-s.top,t}_insideDeadZone(){const e=this.currentMousePos[0]-this.initialMousePos[0],t=this.currentMousePos[1]-this.initialMousePos[1];return Math.sqrt(e*e+t*t)<this.deadZoneRadius}_getClosestVertex(e,t){const s=this.mesh,i=this.projectionView,o=this.element.offsetWidth,r=this.element.offsetHeight,n=d.create();let h=-1,a=1/0;for(let c=0;c<s.vertexCount;c++){const u=s.getPosition(c);if(d.transformMat4(n,u,i),n[2]<-1||n[2]>1)continue;const l=(.5+.5*n[0])*o,v=(.5-.5*n[1])*r,p=e-l,x=t-v,g=Math.sqrt(p*p+x*x);g<a&&(a=g,h=c)}return{index:h,distance:a}}_getClosestEdge(e,t){const s=this.mesh,i=this.projectionView,o=this.element.offsetWidth,r=this.element.offsetHeight,n=d.create(),h=d.create();let a=-1,c=1/0;for(let u=0;u<s.edgeCount;u++){const l=s.getEdge(u),v=s.getPosition(l[0]),p=s.getPosition(l[1]);if(d.transformMat4(n,v,i),d.transformMat4(h,p,i),n[2]<-1||n[2]>1||h[2]<-1||h[2]>1)continue;const x=(.5+.5*n[0])*o,g=(.5-.5*n[1])*r,I=(.5+.5*h[0])*o,f=(.5-.5*h[1])*r,m=this._pointToSegmentDistance(e,t,x,g,I,f);m<c&&(c=m,a=u)}return{index:a,distance:c}}_pointToSegmentDistance(e,t,s,i,o,r){const n=o-s,h=r-i,a=n*n+h*h;if(a<1e-4)return Math.sqrt((e-s)*(e-s)+(t-i)*(t-i));let c=((e-s)*n+(t-i)*h)/a;c=Math.max(0,Math.min(1,c));const u=s+c*n,l=i+c*h;return Math.sqrt((e-u)*(e-u)+(t-l)*(t-l))}_getSelectionTarget(e,t,s=18,i=12){const o=this._getClosestVertex(e,t),r=this._getClosestEdge(e,t),n=o.index>=0&&o.distance<s,h=r.index>=0&&r.distance<i;return o.index>=0&&o.distance<10?{type:"vertex",index:o.index,distance:o.distance}:n&&h?r.distance<=o.distance?{type:"edge",index:r.index,distance:r.distance}:{type:"vertex",index:o.index,distance:o.distance}:n?{type:"vertex",index:o.index,distance:o.distance}:h?{type:"edge",index:r.index,distance:r.distance}:{type:"none",index:-1,distance:1/0}}_onMouseDown(e){this._getMousePos(e,this.initialMousePos),this.currentMousePos[0]=this.initialMousePos[0],this.currentMousePos[1]=this.initialMousePos[1],this.previousMousePos[0]=this.initialMousePos[0],this.previousMousePos[1]=this.initialMousePos[1],this.exitedDeadZone=!1;const t=this._getSelectionTarget(this.initialMousePos[0],this.initialMousePos[1]);t.type==="vertex"?(e.preventDefault(),e.stopPropagation(),e.stopImmediatePropagation(),this.element.focus(),this.selectedEdgeIndex=-1,this.selectedVertexIndex>=0&&this.selectedVertexIndex!==t.index&&(this.candidateEdge=[this.selectedVertexIndex,t.index]),this.activeVertexIndex=t.index,this.selectedVertexIndex=t.index,this.dragMode="vertex",this.element.classList.remove("cursor-pointer","cursor-grabbing"),this.element.classList.add("cursor-move"),this.selectionHandledInMouseDown=!0,this.isDragging=!0,this.dirty=!0,window.addEventListener("mousemove",this._onMouseMove),window.addEventListener("mouseup",this._onMouseUp)):t.type==="edge"?(e.preventDefault(),e.stopPropagation(),e.stopImmediatePropagation(),this.element.focus(),this.selectedVertexIndex=-1,this.activeVertexIndex=-1,this.candidateEdge=null,this.selectedEdgeIndex=t.index,this.activeEdgeIndex=t.index,this.dragMode="edge",this.element.classList.remove("cursor-pointer","cursor-grabbing"),this.element.classList.add("cursor-move"),this.selectionHandledInMouseDown=!0,this.isDragging=!0,this.dirty=!0,window.addEventListener("mousemove",this._onMouseMove),window.addEventListener("mouseup",this._onMouseUp)):(this.backgroundClickStart=[this.initialMousePos[0],this.initialMousePos[1]],this.backgroundExitedDeadZone=!1,this.selectionHandledInMouseDown=!1,window.addEventListener("mousemove",this._onMouseMove),window.addEventListener("mouseup",this._onMouseUp))}_onMouseMove(e){if(this.previousMousePos[0]=this.currentMousePos[0],this.previousMousePos[1]=this.currentMousePos[1],this._getMousePos(e,this.currentMousePos),this.backgroundClickStart&&!this.backgroundExitedDeadZone){const t=this.currentMousePos[0]-this.backgroundClickStart[0],s=this.currentMousePos[1]-this.backgroundClickStart[1];Math.sqrt(t*t+s*s)>=this.deadZoneRadius&&(this.backgroundExitedDeadZone=!0,this.element.classList.remove("cursor-move","cursor-pointer"),this.element.classList.add("cursor-grabbing"))}if(!this.isDragging){if(this.backgroundClickStart)return;const t=this._getSelectionTarget(this.currentMousePos[0],this.currentMousePos[1],20,12);let s=-1,i=-1;t.type==="vertex"?s=t.index:t.type==="edge"&&(i=t.index),(s!==this.hoverVertexIndex||i!==this.hoverEdgeIndex)&&(this.hoverVertexIndex=s,this.hoverEdgeIndex=i,this.element.classList.remove("cursor-move","cursor-pointer","cursor-grabbing"),s>=0?this.element.classList.add("cursor-move"):i>=0&&this.element.classList.add("cursor-pointer"),this.dirty=!0);return}!this.exitedDeadZone&&!this._insideDeadZone()&&(this.exitedDeadZone=!0),this.dragMode==="vertex"&&this.exitedDeadZone?this._dragVertex():this.dragMode==="edge"&&this.exitedDeadZone&&this._dragEdge()}_onMouseUp(e){if(window.removeEventListener("mousemove",this._onMouseMove),window.removeEventListener("mouseup",this._onMouseUp),!!this.isDragging){if(this._getMousePos(e,this.currentMousePos),!this.exitedDeadZone&&this._insideDeadZone()){const t=this._getSelectionTarget(this.currentMousePos[0],this.currentMousePos[1],20,12);this.dragMode==="vertex"&&(t.type==="vertex"?(this.candidateEdge&&this.mesh.addEdge(this.candidateEdge[0],this.candidateEdge[1]),this.selectedVertexIndex=t.index,this.selectedEdgeIndex=-1):this.selectedVertexIndex>=0&&this._spawnVertex())}this.isDragging=!1,this.dragMode=null,this.activeVertexIndex=-1,this.activeEdgeIndex=-1,this.candidateEdge=null,this.element.classList.remove("cursor-move","cursor-pointer","cursor-grabbing"),this.hoverVertexIndex>=0?this.element.classList.add("cursor-move"):this.hoverEdgeIndex>=0&&this.element.classList.add("cursor-pointer"),this.dirty=!0,this.onChange()}}_onClick(e){const t=this.backgroundExitedDeadZone,s=this.selectionHandledInMouseDown;if(this.backgroundClickStart=null,this.backgroundExitedDeadZone=!1,this.selectionHandledInMouseDown=!1,t||s)return;const i=this._getMousePos(e),o=this._getSelectionTarget(i[0],i[1],20,12);o.type==="vertex"?(this.selectedVertexIndex=o.index,this.selectedEdgeIndex=-1,this.element.focus(),this.dirty=!0):o.type==="edge"?(this.selectedEdgeIndex=o.index,this.selectedVertexIndex=-1,this.element.focus(),this.dirty=!0):this.selectedVertexIndex>=0?this.mesh.degree(this.selectedVertexIndex)<3?(this.currentMousePos[0]=i[0],this.currentMousePos[1]=i[1],this._spawnVertex(),this.element.focus()):(this.selectedVertexIndex=-1,this.selectedEdgeIndex=-1,this.dirty=!0):this.selectedEdgeIndex>=0&&(this.selectedEdgeIndex=-1,this.dirty=!0),this.onChange()}_getTouchPos(e,t=[0,0]){const s=this.element.getBoundingClientRect();return t[0]=e.clientX-s.left,t[1]=e.clientY-s.top,t}_onTouchStart(e){if(e.touches.length!==1){this.touchStartedOnVertex=!1,this.touchVertexIndex=-1;return}const t=this._getTouchPos(e.touches[0]),s=this._getClosestVertex(t[0],t[1]);s.index>=0&&s.distance<35?(e.stopImmediatePropagation(),e.preventDefault(),this.touchStartedOnVertex=!0,this.touchVertexIndex=s.index,this.initialMousePos[0]=t[0],this.initialMousePos[1]=t[1],this.currentMousePos[0]=t[0],this.currentMousePos[1]=t[1],this.exitedDeadZone=!1,this.selectedVertexIndex>=0&&this.selectedVertexIndex!==s.index&&(this.candidateEdge=[this.selectedVertexIndex,s.index]),this.activeVertexIndex=s.index,this.selectedVertexIndex=s.index,this.isDragging=!0,this.dragMode="vertex",this.dirty=!0):(this.touchStartedOnVertex=!1,this.touchVertexIndex=-1,this.backgroundClickStart=[t[0],t[1]],this.backgroundExitedDeadZone=!1)}_onTouchMove(e){if(e.touches.length===1&&this.backgroundClickStart&&!this.backgroundExitedDeadZone){const s=this._getTouchPos(e.touches[0]),i=s[0]-this.backgroundClickStart[0],o=s[1]-this.backgroundClickStart[1];Math.sqrt(i*i+o*o)>=this.deadZoneRadius&&(this.backgroundExitedDeadZone=!0)}if(!this.touchStartedOnVertex||e.touches.length!==1)return;e.preventDefault(),e.stopImmediatePropagation();const t=this._getTouchPos(e.touches[0]);this.previousMousePos[0]=this.currentMousePos[0],this.previousMousePos[1]=this.currentMousePos[1],this.currentMousePos[0]=t[0],this.currentMousePos[1]=t[1],!this.exitedDeadZone&&!this._insideDeadZone()&&(this.exitedDeadZone=!0),this.exitedDeadZone&&this.activeVertexIndex>=0&&this._dragVertex()}_onTouchEnd(e){if(this.touchStartedOnVertex&&e.touches.length===0){if(!this.exitedDeadZone&&this._insideDeadZone()){const t=this._getClosestVertex(this.currentMousePos[0],this.currentMousePos[1]);t.index>=0&&t.distance<35&&(this.candidateEdge&&this.mesh.addEdge(this.candidateEdge[0],this.candidateEdge[1]),this.selectedVertexIndex=t.index)}this.touchStartedOnVertex=!1,this.touchVertexIndex=-1,this.isDragging=!1,this.dragMode=null,this.activeVertexIndex=-1,this.candidateEdge=null,this.dirty=!0,this.onChange()}}_onKeyDown(e){switch(e.code){case"Space":case"Backspace":e.preventDefault(),e.stopPropagation();break}}_onKeyUp(e){switch(e.code){case"Backspace":if(this.selectedVertexIndex>=0){const t=this.mesh.deleteVertex(this.selectedVertexIndex);this.selectedVertexIndex=t,this.hoverVertexIndex=-1,this.hoverEdgeIndex=-1,this.activeVertexIndex=-1,this.dirty=!0,e.preventDefault(),e.stopPropagation()}else this.selectedEdgeIndex>=0&&(this.mesh.deleteEdge(this.selectedEdgeIndex),this.selectedEdgeIndex=-1,this.hoverEdgeIndex=-1,this.hoverVertexIndex=-1,this.dirty=!0,e.preventDefault(),e.stopPropagation());break;case"Space":this.selectedVertexIndex=-1,this.selectedEdgeIndex=-1,this.activeVertexIndex=-1,this.dirty=!0,e.preventDefault(),e.stopPropagation();break;case"KeyC":if(this.selectedVertexIndex>=0){const t=this.mesh.collapseVertex(this.selectedVertexIndex);this.selectedVertexIndex=t,this.hoverVertexIndex=-1,this.activeVertexIndex=-1,this.dirty=!0,e.preventDefault(),e.stopPropagation()}break;case"KeyS":if(this.selectedVertexIndex>=0){const t=this.mesh.splitVertex(this.selectedVertexIndex);this.selectedVertexIndex=t,this.hoverVertexIndex=-1,this.activeVertexIndex=-1,this.dirty=!0,e.preventDefault(),e.stopPropagation()}break;case"KeyE":if(this.selectedVertexIndex>=0){const t=this.mesh.explodeVertex(this.selectedVertexIndex);this.selectedVertexIndex=t,this.hoverVertexIndex=-1,this.activeVertexIndex=-1,this.dirty=!0,e.preventDefault(),e.stopPropagation()}break;case"KeyH":if(this.selectedEdgeIndex>=0){const t=this.mesh.stoneWales(this.selectedEdgeIndex);t>=0&&(this.selectedEdgeIndex=t,this.hoverEdgeIndex=-1,this.hoverVertexIndex=-1),this.dirty=!0,e.preventDefault(),e.stopPropagation()}break;case"KeyA":if(this.selectedVertexIndex>=0){const t=this.mesh.getPosition(this.selectedVertexIndex);d.copy(this.camera.center,t)}else if(this.selectedEdgeIndex>=0){const t=this.mesh.getEdge(this.selectedEdgeIndex),s=this.mesh.getPosition(t[0]),i=this.mesh.getPosition(t[1]);this.camera.center[0]=(s[0]+i[0])/2,this.camera.center[1]=(s[1]+i[1])/2,this.camera.center[2]=(s[2]+i[2])/2}else{const t=this.mesh.computeCentroid();d.copy(this.camera.center,t)}this.dirty=!0,e.preventDefault(),e.stopPropagation();break}this.onChange()}_dragVertex(){const e=this.element.offsetWidth,t=this.element.offsetHeight,s=this.projectionView,i=this.mesh.getPosition(this.activeVertexIndex),o=d.create();d.transformMat4(o,i,s),o[0]=2*this.currentMousePos[0]/e-1,o[1]=1-2*this.currentMousePos[1]/t;const r=M.create();M.invert(r,s);const n=d.create();d.transformMat4(n,o,r),this.mesh.setPosition(this.activeVertexIndex,n[0],n[1],n[2]),this.dirty=!0}_dragEdge(){if(this.selectedEdgeIndex<0)return;const e=this.element.offsetWidth,t=this.element.offsetHeight,s=this.projectionView,i=this.mesh.getEdge(this.selectedEdgeIndex),o=this.mesh.getPosition(i[0]),r=this.mesh.getPosition(i[1]),n=d.fromValues((o[0]+r[0])/2,(o[1]+r[1])/2,(o[2]+r[2])/2),h=d.create();d.transformMat4(h,n,s);const a=2*this.previousMousePos[0]/e-1,c=1-2*this.previousMousePos[1]/t,u=2*this.currentMousePos[0]/e-1,l=1-2*this.currentMousePos[1]/t,v=u-a,p=l-c,x=M.create();M.invert(x,s);for(const g of[i[0],i[1]]){const I=this.mesh.getPosition(g),f=d.create();d.transformMat4(f,I,s),f[0]+=v,f[1]+=p;const m=d.create();d.transformMat4(m,f,x),this.mesh.setPosition(g,m[0],m[1],m[2])}this.dirty=!0}_spawnVertex(){if(this.mesh.degree(this.selectedVertexIndex)>=3)return;const e=this.element.offsetWidth,t=this.element.offsetHeight,s=this.projectionView,i=this.mesh.getPosition(this.selectedVertexIndex),o=d.create();d.transformMat4(o,i,s),o[0]=2*this.currentMousePos[0]/e-1,o[1]=1-2*this.currentMousePos[1]/t;const r=M.create();M.invert(r,s);const n=d.create();d.transformMat4(n,o,r);const h=this.mesh.addVertex(n[0],n[1],n[2]);this.mesh.addEdge(this.selectedVertexIndex,h),this.selectedVertexIndex=h,this.dirty=!0}}export{E as MeshInteractions,E as default};
