function G(n,i){const{x:s,y:r,z:h}=n;if(i>=0)throw new Error("deltaZ must be negative (parent zoom levels)");const o=h+i;if(o<0)throw new Error(`Parent zoom level ${o} is invalid (must be >= 0)`);const c=Math.abs(i),a=Math.pow(2,c),t=Math.floor(s/a),e=Math.floor(r/a),l=Math.floor((s/a-t)*2),p=Math.floor((r/a-e)*2),y=[];y.push({x:t,y:e,z:o,role:"parent-base"});const u=Math.pow(2,o)-1;return l===0&&t>0?y.push({x:t-1,y:e,z:o,role:"parent-west"}):l===1&&t<u&&y.push({x:t+1,y:e,z:o,role:"parent-east"}),p===0&&e>0?y.push({x:t,y:e-1,z:o,role:"parent-north"}):p===1&&e<u&&y.push({x:t,y:e+1,z:o,role:"parent-south"}),l===0&&p===0&&t>0&&e>0?y.push({x:t-1,y:e-1,z:o,role:"parent-nw"}):l===1&&p===0&&t<u&&e>0?y.push({x:t+1,y:e-1,z:o,role:"parent-ne"}):l===0&&p===1&&t>0&&e<u?y.push({x:t-1,y:e+1,z:o,role:"parent-sw"}):l===1&&p===1&&t<u&&e<u&&y.push({x:t+1,y:e+1,z:o,role:"parent-se"}),y}function C({targetTile:n,parentTiles:i,deltaZ:s,tileSize:r=512}){if(s>=0)throw new Error("deltaZ must be negative");const h=Math.abs(s),o=Math.pow(2,h),c=1024,a=new Float32Array(c*c),t=Math.floor(r*(1+Math.pow(2,s))),e=new Map(i.map(x=>[x.role,x])),{x:l,y:p,z:y}=n,u=Math.floor(l/o),I=Math.floor(p/o),X=Math.floor((l/o-u)*2),P=Math.floor((p/o-I)*2),z=[["nw","ne"],["sw","se"]][P][X],Y=O(z);console.log(`
[DEBUG] Copying tiles to assembly:`);for(const[x,f]of Object.entries(Y)){const M=e.get(x);if(!M){console.log(`  ${x}: MISSING (position would be (${f.x}, ${f.y}))`);continue}console.log(`  ${x}: copying to position (${f.x}, ${f.y})`),q(M,a,f,c)}const $=r/o,b=Y["parent-base"],d=A(n,s,r),w={x:b.x+d.x,y:b.y+d.y};console.log("[DEBUG] Assembly details:"),console.log(`  Quadrant: ${z}`),console.log(`  parent-base position in assembly: (${b.x}, ${b.y})`),console.log(`  Target position in parent-base: (${d.x}, ${d.y})`),console.log(`  Target position in assembly: (${w.x}, ${w.y})`),console.log(`  Target size at parent: ${$}`);const g=L(w,$,t);console.log(`  Extraction offset: (${g.x}, ${g.y})`),console.log(`  Target position in output: (${w.x-g.x}, ${w.y-g.y})`);const v=new Float32Array(t*t);for(let x=0;x<t;x++)for(let f=0;f<t;f++){const M=f+g.x,T=(x+g.y)*c+M,E=x*t+f;v[E]=a[T]}const m=[w.x-g.x,w.y-g.y];return console.log(`  Returning targetOffset: [${m[0]}, ${m[1]}]`),{buffer:v,size:t,targetOffset:m,scale:o,targetSizeAtParent:$}}function O(n){switch(n){case"nw":return{"parent-nw":{x:0,y:0},"parent-north":{x:512,y:0},"parent-west":{x:0,y:512},"parent-base":{x:512,y:512}};case"ne":return{"parent-north":{x:0,y:0},"parent-ne":{x:512,y:0},"parent-base":{x:0,y:512},"parent-east":{x:512,y:512}};case"sw":return{"parent-west":{x:0,y:0},"parent-base":{x:512,y:0},"parent-sw":{x:0,y:512},"parent-south":{x:512,y:512}};case"se":return{"parent-base":{x:0,y:0},"parent-east":{x:512,y:0},"parent-south":{x:0,y:512},"parent-se":{x:512,y:512}};default:throw new Error(`Unknown quadrant: ${n}`)}}function q(n,i,s,r){const h=n.tileSize,o=1;for(let c=0;c<h;c++)for(let a=0;a<h;a++){const t=a+o,l=(c+o)*n.width+t,p=s.x+a,u=(s.y+c)*r+p;i[u]=n.data[l]}}function A(n,i,s){const{x:r,y:h}=n,o=Math.pow(2,Math.abs(i)),c=Math.floor(r/o),a=Math.floor(h/o),t=r/o-c,e=h/o-a,l=t*s,p=e*s;return{x:l,y:p}}function L(n,i,s){const r={x:s/2-i/2,y:s/2-i/2};return{x:n.x-r.x,y:n.y-r.y}}export{C as assembleParentTileBufferMultiLevel,G as getParentTilesAtLevel};
