function B(e,n){const t=e.createBuffer({size:n.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!0,label:"Terrain data buffer"});return new Float32Array(t.getMappedRange()).set(n),t.unmap(),t}function U(e,n){const t=new ArrayBuffer(16),u=new DataView(t);u.setUint32(0,n.tileSize,!0),u.setUint32(4,n.tileSize,!0),u.setFloat32(8,n.pixelSize,!0),u.setFloat32(12,0,!0);const r=e.createBuffer({size:t.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,mappedAtCreation:!0,label:"Uniform buffer"});return new Uint8Array(r.getMappedRange()).set(new Uint8Array(t)),r.unmap(),r}function d(e,n){const t=n*n*Float32Array.BYTES_PER_ELEMENT;return e.createBuffer({size:t,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC,label:"Output buffer"})}async function m(e,n,t){const u=t*t*Float32Array.BYTES_PER_ELEMENT,r=e.createBuffer({size:u,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST,label:"Staging buffer"}),a=e.createCommandEncoder({label:"Readback encoder"});a.copyBufferToBuffer(n,0,r,0,u),e.queue.submit([a.finish()]),await e.queue.onSubmittedWorkDone(),await r.mapAsync(GPUMapMode.READ);const f=new Float32Array(r.getMappedRange()).slice();return r.unmap(),r.destroy(),f}async function y({device:e,pipeline:n,bindGroupLayout:t,terrainData:u,tileSize:r,pixelSize:a}){const f=B(e,u),i=U(e,{tileSize:r,pixelSize:a}),s=d(e,r),g=e.createBindGroup({layout:t,entries:[{binding:0,resource:{buffer:i}},{binding:1,resource:{buffer:f}},{binding:2,resource:{buffer:s}}],label:"Lighting bind group"}),c=e.createCommandEncoder({label:"Lighting compute encoder"}),o=c.beginComputePass({label:"Lighting compute pass"});o.setPipeline(n),o.setBindGroup(0,g);const p=Math.ceil(r/16),b=Math.ceil(r/16);o.dispatchWorkgroups(p,b),o.end(),e.queue.submit([c.finish()]);const l=await m(e,s,r);return f.destroy(),i.destroy(),s.destroy(),l}export{y as computeTileLighting};
