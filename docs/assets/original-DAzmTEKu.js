import{d as S,_ as oe}from"./index-ByB2dbry.js";S({root:document.getElementById("cell-8869"),expanded:[],variables:[]},{id:8869,body:function(a){return a`
# Periodic Planar Three-Body Orbits`},inputs:["md"],outputs:void 0,output:"viewof$title",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});S({root:document.getElementById("cell-1410"),expanded:[],variables:[]},{id:1410,body:function(a,e,o){return a`
This notebook collects ${Object.keys(e).map(t=>Object.keys(e[t]).map(r=>Object.keys(e[t][r]).length)).flat().reduce((t,r)=>t+r,0).toLocaleString()} periodic solutions of the planar [three-body problem](https://en.wikipedia.org/wiki/Three-body_problem) in which three bodies experience mutual gravitational attraction according to [Newton's law of universal gravitation](https://en.wikipedia.org/wiki/Newton%27s_law_of_universal_gravitation), ${o.block`F=G{\frac {m_{1}m_{2}}{r^{2}}}.`}

Three-body orbits don't have a closed-form analytical solution and aren't in general periodic, but by reducing the dimensionality of the problem through symmetries and performing a lot of numerical searching, a number of authors have found and published large sets of initial conditions for periodic solutions.

In this notebook we collect and display the orbits, then discuss methods for classification. It's largely a rehashing of an old project, [Periodic three-body orbits](http://rreusser.github.io/periodic-three-body-orbits/), though the format of Observable makes it easy and fun to include discussion instead of limiting ourselves to pretty pictures!`},inputs:["md","threeBodyInitialConditions","tex"],outputs:void 0,output:"viewof$introduction",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});S({root:document.getElementById("cell-8536"),expanded:[],variables:[]},{id:8536,body:function(a,e){return a`
## Governing equations

The vector form of Newton's law of gravitation for the force on body 2 exerted by body 1 is ${e.block`\mathbf{F}_2 = m_2\mathbf{\ddot{x}}_{2} = -\frac{Gm_1m_2(\mathbf{x}_2 - \mathbf{x}_1)}{||\mathbf{x}_2 - \mathbf{x}_1||^3},`} where ${e`\mathbf{x}_1`} and ${e`\mathbf{x}_2`} and ${e`m_1`} and ${e`m_2`} are the vector positions and masses of bodies ${e`1`} and ${e`2`}, respectively, and ${e`\mathbf{\ddot{x}}_{2}`} is the acceleration of body ${e`2`}. To compute a trajectory, we compute all pairwise forces and send the computation to a suitable numerical integration routine.

As a matter of implementation, we flatten the ${e`x`} and ${e`y`} coordinates and time derivatives ${e`\dot{x}`} and ${e`\dot{y}`} into the tuple ${e`\mathbf{y}`} and encode the full state as ${e.block`\mathbf{y} \equiv (x_1, y_1, \dot{x}_1, \dot{y}_1, x_2, y_2, \dot{x}_2, \dot{y}_2, x_3, y_3, \dot{x}_3, \dot{y}_3).`} Given state ${e`\mathbf{y}`}, the function below computes the time derivative ${e`\mathbf{\dot{y}}`}.`},inputs:["md","tex"],outputs:void 0,output:"viewof$governingEquations",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});S({root:document.getElementById("cell-2902"),expanded:[],variables:[]},{id:2902,body:function(a){return function(o,t,r){let n,s,c,b=a.m[0],l=a.m[1],u=a.m[2];o[0]=t[2],o[1]=t[3],o[4]=t[6],o[5]=t[7],o[8]=t[10],o[9]=t[11],n=t[4]-t[0],s=t[5]-t[1],c=Math.pow(n*n+s*s,1.5),n/=c,s/=c,o[2]=n*l,o[3]=s*l,o[6]=-n*b,o[7]=-s*b,n=t[8]-t[0],s=t[9]-t[1],c=Math.pow(n*n+s*s,1.5),n/=c,s/=c,o[2]+=n*u,o[3]+=s*u,o[10]=-n*b,o[11]=-s*b,n=t[8]-t[4],s=t[9]-t[5],c=Math.pow(n*n+s*s,1.5),n/=c,s/=c,o[6]+=n*u,o[7]+=s*u,o[10]-=n*l,o[11]-=s*l}},inputs:["initialConditions"],outputs:void 0,output:"planarThreeBodyDerivative",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-5971"),expanded:[],variables:[]},{id:5971,body:function(a){return a`## Time integration`},inputs:["md"],outputs:void 0,output:"viewof$integration",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});S({root:document.getElementById("cell-1359"),expanded:[],variables:[]},{id:1359,body:function(d){return d`Since we only seek to integrate a single period of the orbit, we don't require excessive accuracy and opt for an adaptive Runge-Kutta scheme which adjusts the time step to maintain a specified accuracy. Since the bodies move very slowly when far apart but very quickly when passing by each other, adaptive methods are dramatically more efficient than fixed step methods.

In particular, we use the [Butcher tableau](https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods#Explicit_Runge.E2.80.93Kutta_methods) of the [Cash-Karp](https://en.wikipedia.org/wiki/Cashâ€“Karp_method) scheme to integrate with fifth order accuracy with a fourth order embedded error estimate. "Embedded" means the same derivative evaluations can be combined differently to produce both fourth and fifth order estimates of the next time step. The difference between the two yields an estimate of the accuracy, which in turn tells how much we should increase or decrease the size of the time step to maintain the same overall accuracy.

This scheme is adequate for integrating the trajectories with reasonable accuracy and efficiency, but a higher order scheme or more advanced techniques might be worthwhile if we actually wanted to *locate* periodic orbits.

Please note that essentially *all* periodic, planar, three-body orbits except for some figure eights are unstable! For the convenience of visualization, this notebook tabulates a single period and repeats it. Therefore the orbits on this page repeat infinitely, while actual ongoing time integration would show relatively fast divergence.`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-8870"),expanded:[],variables:[]},{id:8870,body:async(d,a)=>{const{ode45:e}=await oe(()=>import("https://api.observablehq.com/@rreusser/integration.js?v=4"),[]).then(o=>{const t={},r=d.module(o.default),n=d.module();if(!r.defines("ode45"))throw new SyntaxError("export 'ode45' not found");return n.variable(t.ode45=a()).import("ode45",r),t});return{ode45:e}},inputs:["__ojs_runtime","__ojs_observer"],outputs:["ode45"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});S({root:document.getElementById("cell-8"),expanded:[],variables:[]},{id:8,body:function(a,e,o){let t={tolerance:a.tolerance||1e-9,tLimit:a.period},r={t:0,y:a.y0.slice()},n={position:[],t:[]};function s(b,l){n.t.push(b),n.position.push(l[0],l[1],b,l[4],l[5],b,l[8],l[9],b)}s(r.t,r.y);let c=0;for(;c++<1e6&&!r.limitReached;)e(r,o,t),s(r.t,r.y);return n},inputs:["initialConditions","ode45","planarThreeBodyDerivative"],outputs:void 0,output:"trajectory",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-5963"),expanded:[],variables:[]},{id:5963,body:function(d){return d`## Initial conditions`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-3695"),expanded:[],variables:[]},{id:3695,body:function(d,a,e,o,t,r,n,s,c){const b=Math.min(d,350),l=Math.floor(b*.7),u=a.create("svg").attr("width",b).attr("height",l),p=e.uid("arrowhead");u.append("defs").append("marker").attr("id",p.id).call(o());function v(w){return{xmin:Math.min(w[0],w[4],w[8]),xmax:Math.max(w[0],w[4],w[8]),ymin:Math.min(w[1],w[5],w[9]),ymax:Math.max(w[1],w[5],w[9]),umin:Math.min(w[2],w[6],w[10]),umax:Math.max(w[2],w[6],w[10]),vmin:Math.min(w[3],w[7],w[11]),vmax:Math.max(w[3],w[7],w[11])}}const y=v(t.y0),g=Math.max(y.xmax-y.xmin,y.ymax-y.ymin),C=Math.max(Math.abs(y.umin),Math.abs(y.umax),Math.abs(y.vmin),Math.abs(y.vmax));function I(w){return w/Math.max(g*.2,C*1.2)}const E=a.scaleLinear().domain([-g,g]).range([0,b]),B=a.scaleLinear().domain([-g*l/b,g*l/b]).range([l,0]),O=a.line().x(w=>E(w[0])).y(w=>B(w[1])),k=.9;u.append("g").attr("class","axes").selectAll("path").data([[[-g*k,0],[g*k,0]],[[0,-g*k*l/b],[0,g*k*l/b]]]).join("path").attr("d",O).attr("stroke","black").attr("fill","none").attr("stroke-width",1).attr("marker-start",`url(${p.href.replace(/#.*#/,"#")})`).attr("marker-end",`url(${p.href.replace(/#.*#/,"#")})`);const j=[0,0,0].map((w,$)=>[t.y0[4*$+0],t.y0[4*$+1]]),z=[0,0,0].map((w,$)=>[I(t.y0[4*$+2]),I(t.y0[4*$+3])]),M=t.pointSize.map(w=>Math.max(2.5,w*8));return u.append("g").attr("class","velocities").selectAll("path").data(j.map((w,$)=>[[j[$][0],j[$][1]],[j[$][0]+z[$][0],j[$][1]+z[$][1]]]).filter((w,$)=>z[$][0]*z[$][0]+z[$][1]*z[$][1]>0)).join("path").attr("d",O).attr("stroke","black").attr("fill","none").attr("stroke-width",1.5).attr("marker-end",`url(${p.href.replace(/#.*#/,"#")})`),u.append("g").attr("class","bodies").selectAll("circle").data(j).join("circle").attr("cx",w=>E(w[0])).attr("cy",w=>B(w[1])).attr("r",(w,$)=>M[$]).attr("fill",(w,$)=>r(t.colors[$])).attr("stroke",(w,$)=>r(n.strokeColor[$])).attr("stroke-width",2),u.append("g").attr("class","labels").selectAll("text").data([{xy:[0,g*k*l/b],text:"y"},{xy:[g*k,0],text:"x"}]).join("text").text(w=>w.text).attr("x",w=>E(w.xy[0])).attr("y",w=>B(w.xy[1])).attr("font-size","14px").attr("font-family","serif").attr("font-style","italic").attr("dy",-2).attr("dx",5),u.append("g").attr("class","body-labels").selectAll("text").data(j).join("text").text("m").call(function(w,$){w.append("tspan").attr("dy",5).attr("font-weight",400).attr("font-size","0.75em").text((Q,X)=>X+1)}).attr("x",w=>E(w[0])).attr("y",w=>B(w[1])).attr("font-size","14px").attr("font-family","serif").attr("font-style","italic").attr("dx",(w,$)=>3+M[$]*.707).attr("dy",(w,$)=>11+M[$]*.707).attr("text-anchor","start"),s`
    <figure>
      ${u.node()}
      <figcaption>Initial conditions for the ${c`${t.name}`} planar three-body orbit.</figcaption>
    </figure>
  `},inputs:["width","d3","DOM","arrowhead","initialConditions","floatRgbToHex","drawing","html","tex"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-2534"),expanded:[],variables:[]},{id:2534,body:function(d){return d`The initial conditions in this notebook are obtained from Milovan Å uvakov's [Three-body Gallery](http://three-body.ipb.ac.rs/) as well as from the listing of [Xiaoming Li and Shijun Liao](http://numericaltank.sjtu.edu.cn/three-body/three-body.htm). The initial conditions presented here fall into a few couple categories but all have zero net translational and angular momentum.

For more information as well as an excellent and approachable overview of the techniques used to locate the orbits, see Å uvakov and DmitraÅ¡inoviÄ‡'s [A guide to hunting periodic three-body orbits](https://ui.adsabs.harvard.edu/abs/2014AmJPh..82..609S).
`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-5870"),expanded:[],variables:[]},{id:5870,body:async(d,a)=>{const{threeBodyInitialConditions:e,references:o,sequenceUrls:t}=await oe(()=>import("https://api.observablehq.com/@rreusser/periodic-three-body-initial-conditions.js?v=4"),[]).then(r=>{const n={},s=d.module(r.default),c=d.module();if(!s.defines("threeBodyInitialConditions"))throw new SyntaxError("export 'threeBodyInitialConditions' not found");if(c.variable(n.threeBodyInitialConditions=a()).import("threeBodyInitialConditions",s),!s.defines("references"))throw new SyntaxError("export 'references' not found");if(c.variable(n.references=a()).import("references",s),!s.defines("sequenceUrls"))throw new SyntaxError("export 'sequenceUrls' not found");return c.variable(n.sequenceUrls=a()).import("sequenceUrls",s),n});return{threeBodyInitialConditions:e,references:o,sequenceUrls:t}},inputs:["__ojs_runtime","__ojs_observer"],outputs:["threeBodyInitialConditions","references","sequenceUrls"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});S({root:document.getElementById("cell-8911"),expanded:[],variables:[]},{id:8911,body:function(a,e,o){const t=a[e.group][e.sequence][e.orbit].v,r=a[e.group][e.sequence][e.orbit].x,n=[];for(let[s,c]of Object.entries(a))for(let[b,l]of Object.entries(c))for(let[u,p]of Object.entries(l)){const v=p.v,y=v[0][0]-t[0][0],g=v[0][1]-t[0][1],C=v[1][0]-t[1][0],I=v[1][1]-t[1][1],E=v[2][0]-t[2][0],B=v[2][1]-t[2][1],O=p.x,k=O[0][0]-r[0][0],j=O[0][1]-r[0][1],z=O[1][0]-r[1][0],M=O[1][1]-r[1][1],w=O[2][0]-r[2][0],$=O[2][1]-r[2][1];y*y+g*g+C*C+I*I+E*E+B*B+k*k+j*j+z*z+M*M+w*w+$*$<1e-6*1e-6&&(s!==e.group||b!==e.sequence||u!==e.orbit)&&n.push({groupName:s,sequenceName:b,orbitName:u})}if(n.length){const s=o`Exact duplicates:<br><ul>
${n.map(c=>o`<li><a href="#group=${encodeURIComponent(c.groupName)}&sequence=${encodeURIComponent(c.sequenceName)}&orbit=${encodeURIComponent(c.orbitName)}" target="_blank">${c.groupName} - ${c.sequenceName} - ${c.orbitName}</a></li>`)}
</ul>`;return s.value=n,s}else{const s=o`<span></span>`;return s.value=[],s}},inputs:["threeBodyInitialConditions","selectedConditions","html"],outputs:void 0,output:"viewof$duplicates",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});S({root:document.getElementById("cell-4364"),expanded:[],variables:[]},{id:4364,body:function(a,e,o){const t=this||document.createElement("form");let r=a(window.location.hash),n=unescape(r.group)||"Å uvakov",s=unescape(r.sequence)||"III - Yin Yang",c=unescape(r.orbit)||"III.15.A.Î²",b=Object.keys(e).map(v=>({label:v,options:Object.keys(e[v]).map(y=>({label:y,value:`${v}: ${y}`}))}));function l(v){v.selectAll("select").data([null]).join("select").attr("name","sequence").selectAll("optgroup").data(b).join("optgroup").attr("label",y=>y.label).selectAll("option").data(y=>y.options).join("option").attr("value",y=>y.value).attr("selected",y=>y.value===`${n}: ${s}`?"selected":null).text(y=>y.label),v.selectAll("div").data([null]).join("div").style("font-size","0.85em").style("font-style","italic").text("Sequence")}function u(v){let y;for(;!y;)try{y=Object.keys(e[n][s]).map(g=>({label:g,value:g}))}catch{n=Object.keys(e)[0],s=Object.keys(e[n])[0],c=Object.keys(e[n][s])[0]}v.selectAll("select").data([null]).join("select").attr("name","orbit").selectAll("optgroup").data([y]).join("optgroup").attr("label","- select orbit -").selectAll("option").data(y,g=>`${n}:${s}:${g.value}`).join("option").attr("value",g=>g.value).attr("selected",g=>g.value===c||g.value===c+"."?"selected":null).text(g=>g.label),v.selectAll("div").data([null]).join("div").style("font-size","0.85em").style("font-style","italic").text("Orbit")}function p(v){v.selectAll("div.title").data([null]).join("div").attr("class","title").text("Initial conditions").style("font","700 0.9rem sans-serif"),v.selectAll("div.selectfield").data(["Sequence","Orbit"]).join("div").attr("class","selectfield").style("display","inline-block").style("margin-right","0.5em").each(function(y){(y==="Sequence"?l:u)(o.select(this))})}return p(o.select(t)),t.oninput=()=>{n=t.sequence.value.split(": ")[0],s=t.sequence.value.split(": ")[1],c=t.orbit.value,e[n][s][c]||e[n][s][c+"."]||(c=Object.keys(e[n][s])[0]),p(o.select(t)),t.value={group:n,sequence:s,orbit:c}},t.oninput(),t},inputs:["decodeHash","threeBodyInitialConditions","d3"],outputs:void 0,output:"viewof$selectedConditions",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});S({root:document.getElementById("cell-105"),expanded:[],variables:[]},{id:105,body:function(d,a,e,o,t,r,n,s,c,b,l,u,p,v,y,g,C,I,E,B,O){const{currentXScale:k,currentYScale:j,xScale:z,yScale:M,viewport:w,element:$}=d.orbit,{width:Q,height:X,dpi:ee}=w,F=a.select($).attr("width",Q).attr("height",X),V=e.lineWidth>0&&e.lineOpacity>0,Y=~e.display.indexOf("particles"),f=~e.display.indexOf("orbit"),x=~e.display.indexOf("blur")?Math.min(40,Math.max(3,Math.floor(e.speed))):0,P=81,h=x*2+1,L=o(F,Q,X,ee,{optionalExtensions:["ANGLE_instanced_arrays"],attributes:{antialias:!0}}),m=L.value,i=m.data;i.positionsBuffer=t(i.positionsBuffer,m.buffer,r.position);const W=new Float32Array(P*9);i.pointsBuffer=t(i.pointsBuffer,m.buffer,W),i.pointColorsBuffer=t(i.pointColorsBuffer,m.buffer,new Array(P).fill(0).map((R,N)=>{let G=(1+8*(h/P))/h,A=x?G*Math.exp(-.5*Math.pow((N-h*.5)/h/.4,2)):1;return[0,1,2].map(_=>e.color[_].concat(A))}));const U=R=>1+e.lineOpacity*(R-1),H=[0,1,2].map(R=>({position:i.positionsBuffer,offset:R*3*4,stride:36,color:{constant:e.color[R].map(U).concat(1)},borderColor:{constant:e.strokeColor[R].concat(1)},borderWidth:{constant:e.lineStrokeWidth},width:{constant:e.lineWidth},count:r.t.length})),te=[0,1,2].map(R=>({positions:{buffer:i.pointsBuffer,stride:36,offset:12*R},colors:{buffer:i.pointColorsBuffer,stride:48,offset:16*R},pointSize:n.pointSize[R]*e.pointSize,strokeWidth:e.lineStrokeWidth,strokeColor:e.strokeColor[R],count:h})),T=s();i.drawLines=i.drawLines||c(m),i.drawPoints=i.drawPoints||b(m),i.viewport=i.viewport||l(m),i.scale=i.scale||u(m),s(),i.configureLineDrawing=i.configureLineDrawing||m({uniforms:{uProjectionViewModel:(R,N)=>(p(T,R.view),T[10]=-N.timeScale*2,T[14]=N.timeShift*N.timeScale*2-1,T)},depth:{enable:!0}}),i.configurePointDrawing=i.configurePointDrawing||m({uniforms:{uProjectionView:(R,N)=>(p(T,R.view),T[10]=0,T)},depth:{enable:!1},blend:{enable:!0,func:{srcRGB:"src alpha",srcAlpha:1,dstRGB:"one minus src alpha",dstAlpha:"one minus src alpha"},equation:{rgb:"add",alpha:"add"}}}),i.t0===void 0&&(i.t0=NaN,i.tPrev=NaN,i.tDelta=0);let J=!0,D=!0;i.renderPlot=function(N){if(!J)return;let G=N?N.time:isNaN(i.tPrev)?0:i.tPrev;if(isNaN(i.tPrev)?i.tPrev=i.t0=G:(i.tDelta=Math.min(1/30,G-i.tPrev),i.tPrev=G),!f&&!Y&&!D)return;D=!1;let A=r.t[r.t.length-1],_=i.t0,q=G*e.speed;for(;q>_+A*2;)_+=A*2;for(;q<_;)_-=A*2;let Z=q-_,ae=1/A;m.clear({color:[0,0,0,0],depth:1}),i.viewport(w,()=>{i.scale(k,j,()=>{if(V&&i.configureLineDrawing({timeShift:f?Z:A,timeScale:ae},()=>{i.drawLines(H)}),Y){let le=r.t,ce=r.position;for(var ne=-x,ie=0;ne<=x;ne++,ie+=9){var ue=Z+i.tDelta*(ne/Math.max(1,x+.5))*e.speed;let pe=ue*ae%1/ae,de=v(le,pe),fe=Math.min(le.length-1,de+1),me=(pe-le[de])/(le[fe]-le[de]);for(var se=0;se<9;se++)W[ie+se]=(1-me)*ce[de*9+se]+me*ce[fe*9+se]}i.pointsBuffer.subdata(W),i.configurePointDrawing(()=>{i.drawPoints(te)})}})})},F.selectAll(".axes").remove();const re=F.selectAll(".axes").data(["axes"]).join("g").attr("class","axes");i.updateAxes=function(){re.call(y(w,k,j,{xAxis:g?a.axisTop:a.axisBottom,yAxis:g?a.axisRight:a.axisLeft}))},F.attr("class","draggable").call(C(k,j,z,M).scaleExtent([.01,1e4]).on("zoom.plot",()=>D=!0).on("zoom.axes",()=>i.updateAxes())),i.frame=i.frame||m.frame(R=>i.renderPlot(R)),i.renderPlot(),i.updateAxes();const K=new I(R=>{J=R.pop().intersectionRatio>0});return K.observe(L),E.then(()=>{K.disconnect()}),B`
    <figure style="max-width:100%">
      <div style="height:${X}px">
        ${F.node()}
      </div>
      <figcaption>${O`${n.name}`} orbit in physical space.</figcaption>
    </figure>
  `},inputs:["plotContexts","d3","drawing","getOrAttachReglFO","createOrUpdateBuffer","trajectory","initialConditions","mat4create","createDrawBorderedLineCommand","createStrokedPointsCommand","createReglViewportConfiguration","createReglLinearScaleConfiguration","mat4copy","binarySearch","viewportAxes","isNarrowScreen","persistentZoom","IntersectionObserver","invalidation","html","tex"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-3198"),expanded:[],variables:[]},{id:3198,body:function(a,e,o){const r=a`
  <form class="form-compact">
    <details>
      <summary style="font-size:0.85em;">Display options</summary>

      <div class="field">
        ${[{value:"orbit",label:"animate orbit",checked:!1},{value:"particles",label:"animate particles",checked:!0},{value:"blur",label:"motion blur",checked:!0}].map(n=>`<label style="display: inline-block; margin: 5px 10px 3px 0; font-size: 0.85em;"><input type=checkbox name=display value=${n.value}${n.checked?" checked":""}> ${n.label}</label>`).join("")}
      </div>

      <div class="field"><input type=range name=lineOpacity min=0 max=1 step=0.01 value=0.7> <small><i>line opacity: <output name=lineOpacityOutput></output></i></small></div>

      <div class="field"><input type=range name=lineWidth min=0.5 max=4 step=0.1 value=1.5> <small><i>line width: <output name=lineWidthOutput></i></output></small></div>

      <div class="field"><input type=range name=lineStrokeWidth min=0 max=4 step=0.1 value=0.5> <small><i>stroke width: <output name=lineStrokeWidthOutput></i></output></small></div>

      <div class="field"><input type=range name=pointSize min=4 max=20 step=1 value=10> <small><i>point size: <output name=pointSizeOutput></i></output></small></div>

      <div class="field"><input type=range name=speed min=0.05 max=20 step=0.05 value=5> <small><i>speed: <output name=speedOutput></i></output></small></div>

      <div class="field">
        <input type=color name=lineColor1 value=${e([.63,.83,.18])}>
        <input type=color name=lineColor2 value=${e([.18,.63,.83])}>
        <input type=color name=lineColor3 value=${e([.83,.18,.63])}>
        <small><i>orbit color</i></small>
      </div>

      <div class="field">
        <input type=color name=strokeColor1 value=${e([1,1,1])}>
        <input type=color name=strokeColor2 value=${e([1,1,1])}>
        <input type=color name=strokeColor3 value=${e([1,1,1])}>
        <small><i>stroke color</i></small>
      </div>
    </details>
  </form>`;return r.oninput=()=>{r.lineOpacityOutput.value=r.lineOpacity.valueAsNumber,r.lineWidthOutput.value=r.lineWidth.valueAsNumber,r.lineStrokeWidthOutput.value=r.lineStrokeWidth.valueAsNumber,r.pointSizeOutput.value=r.pointSize.valueAsNumber,r.speedOutput.value=r.speed.valueAsNumber,r.value={lineOpacity:r.lineOpacity.valueAsNumber,lineWidth:r.lineWidth.valueAsNumber,lineStrokeWidth:r.lineStrokeWidth.valueAsNumber,pointSize:r.pointSize.valueAsNumber,speed:r.speed.valueAsNumber,display:[...r.display.values()].filter(n=>n.checked).map(n=>n.value),color:[o(r.lineColor1.value),o(r.lineColor2.value),o(r.lineColor3.value)],strokeColor:[o(r.strokeColor1.value),o(r.strokeColor2.value),o(r.strokeColor3.value)]}},r.oninput(),r},inputs:["html","floatRgbToHex","hexRgbToFloat"],outputs:void 0,output:"viewof$drawing",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});S({root:document.getElementById("cell-8330"),expanded:[],variables:[]},{id:8330,body:function(d,a,e,o,t,r,n){const s=d.group,c=d.sequence,b=d.orbit,l=a[s][c][b],u=l.x,p=l.v,v=l.m?l.m:[1,1,1],y=v[0]!==v[1]||v[0]!==v[2],g=e[l.ref];let C=d.orbit,I=l.url;/i\.c\./.test(C)?C=C.replace(/ i\.c\./,"^{i.c.}").replace(/.([0-9]+)/,"_{$1}"):/^F/.test(C)&&(C=C.replace(/^F([0-9]+)/,"F_{$1}"));let E=`#group=${encodeURIComponent(s)}&sequence=${encodeURIComponent(c)}&orbit=${encodeURIComponent(b)}`,B=`${s} - ${c.replace(/i\.c\./,"isosceles collinear")}`;var O=o`<div style="border: 1px solid #ccc; box-sizing: border-box; padding: 0 10px; max-width:640px;">
  <small><dl class="inline-flex">
    <dt>Sequence</dt><dd><a href="${t[s][c]}">${B}${y?" (unequal mass)":""}</a></dd>
    <dt>Orbit</dt><dd>${I?o`<a href="${I}">${r`${C}`}</a>`:r`${C}`}</dd>
    <dt >Initial positions</dt><dd>${r`((${u[0][0]}, ${u[0][1]}),`} ${r`(${u[1][0]}, ${u[1][1]}),`} ${r`(${u[2][0]}, ${u[2][1]}))`}</dd>
    <dt>Initial velocities</dt><dd>${r`((${p[0][0]}, ${p[0][1]}),`} ${r`(${p[1][0]}, ${p[1][1]}),`} ${r`(${p[2][0]}, ${p[2][1]}))`}</dd>
    <dt>Masses</dt><dd>${r`(${v[0]},`} ${r`${v[1]},`} ${r`${v[2]})`}</dd>
    <dt><a href="http://three-body.ipb.ac.rs/info.php">Free group element</a></dt><dd style="word-break:break-all;">${n}</dd>
    <dt>Period</dt><dd>${l.T}</dd>
    ${l.E!==void 0?`<dt>Energy</dt><dd>${l.E}</dd>`:""}
    <!--dt>Angular momentum</dt><dd>${r`${l.L===void 0?0:l.L}`}</dd-->
    <dt>Discovered</dt><dd>${l.year}</dd>
    <dt>Reference</dt><dd>
       ${g.authors}, <em>${g.title}</em>${g.journal?`, <strong>${g.journal}</strong>,${g.page?` ${g.page}`:""} (${g.year})`:""}.${g.preprint?` <a href="${g.preprint.url}">${g.preprint.label}</a>`:""}
    </dd>
    <dt>Share</dt><dd><a href="${E}">link to this orbit ðŸ”—</a></dt>
  </dl></small>
  </div>`;return O},inputs:["selectedConditions","threeBodyInitialConditions","references","html","sequenceUrls","tex","freeGroupWord"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-2241"),expanded:[],variables:[]},{id:2241,body:function(a,e,o,t){const r=a.group,n=a.sequence,s=a.orbit,c=e[r][n][s],b=c.x,l=c.v,u=c.m?c.m:[1,1,1];u[0]!==u[1]||(u[0],u[2]),o[c.ref];let p=a.orbit;c.url,/i\.c\./.test(p)?p=p.replace(/ i\.c\./,"^{i.c.}").replace(/.([0-9]+)/,"_{$1}"):/^F/.test(p)&&(p=p.replace(/^F([0-9]+)/,"F_{$1}")),n.replace(/i\.c\./,"isosceles collinear");let v={name:p,y0:[b[0][0],b[0][1],l[0][0],l[0][1],b[1][0],b[1][1],l[1][0],l[1][1],b[2][0],b[2][1],l[2][0],l[2][1]],tolerance:c.tolerance||1e-9,period:c.T,m:c.m?c.m:[1,1,1]};v.colors=t.color;var y=v.m.reduce((g,C)=>g+C,0);return v.pointSize=v.m.map(g=>g/y*3).map(g=>Math.pow(g,.5)),v},inputs:["selectedConditions","threeBodyInitialConditions","references","drawing"],outputs:void 0,output:"initialConditions",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-5845"),expanded:[],variables:[]},{id:5845,body:function(d,a){return d`## Orbit classification

It'd be fine to stop right here, but the rest of this notebook will try to communicate how we start to talk about classifying the orbits since without some means of classification, we really just have a large puddle of orbits. We'll use the topogical approach described by Montgomery in [The N-body problem, the braid group, and action-minimizing periodic solutions](https://ui.adsabs.harvard.edu/abs/1998Nonli..11..363M/abstract), though to be honest I didn't get too far in that paper and have found [the works of Å uvakov, DmitraÅ¡inoviÄ‡, et al.](http://three-body.ipb.ac.rs/ref.php) much more helpful and approachable. (This is a reflection of my time and abilities, of course, not of the works of Montgomery.)

Since the interesting aspects of a particular orbit are invariant under translation, rotation, and scaling, we seek a representation which removes the uninteresting aspects. We therefore start with a commonly used coordinate system for n-body problems called [*Jacobi coordinates*](https://en.wikipedia.org/wiki/Jacobi_coordinates). To compute Jacobi coordinates, we start with a single body and aggregate the remaining bodies one at a time, computing as each successive Jacobi coordinate the vector from one additional body to the center of mass of the currently aggregated bodies. The final coordinate is the center of mass of the whole system (which we discard since the overall system, at worst, moves with constant velocity). [See below](#jacobiCoords) for an illustration this procedure.

Jacobi coordinates therefore remove net translation and reduce the degrees of freedom in position from six to four. We can further reduce the dimensionality to two by defining the *shape vector* ${a.block`
\begin{aligned}
\mathbf{n} &= (n_x, n_y, n_z) \\
&= \left( \frac{2 \mathbf{r}_1 \cdot \mathbf{r}_2}{R^2}, \frac{r_1^2 - r_2^2}{R^2}, \frac{2 (\mathbf{r}_1 \times \mathbf{r}_2) \cdot \mathbf{e}_z}{R^2}\right)
\end{aligned}
`} where ${a`\mathbf{r}_1`} and ${a`\mathbf{r}_2`} are the Jacobi coordinates, ${a`\mathbf{e}_z`} is the unit vector along the z-axis, and ${a`R = \sqrt{r_1^2 + r_2^2}`}. The vector ${a`\mathbf{n}`} lives on the unit sphere and describes the configuration of the system in a manner invariant to rotation, translation and overall size.

Move the points below and observe a corresponding behavior on the shape sphere.
- pairwise collisions place the shape at one of three points, marked on the shape sphere in red, green and blue.
- collinear configurations, called *syzygies*, lie on the equator.
`},inputs:["md","tex"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-7196"),expanded:[],variables:[]},{id:7196,body:function(a,e,o,t,r,n,s,c,b){const l=Math.min(a,480),u=Math.floor(l*.7),p=e.create("svg").attr("width",l).attr("height",u),v=o`
    <figure>
      ${p.node()}
      <figcaption>Jacobi coordinates for three bodies. We discard ${t`r_3`}. Move the masses and observe the effect in shape space.</figcaption>
    </figure>`,y=r.uid("arrowhead");p.append("defs").append("marker").attr("id",y.id).call(n());const g=[[4,1],[3,2.7],[1,2.5]];function C(f){let x=s.m[0],P=s.m[1],h=s.m[2],L=f[0][0]-f[1][0],m=f[0][1]-f[1][1],i=(x*f[0][0]+P*f[1][0])/(x+P)-f[2][0],W=(x*f[0][1]+P*f[1][1])/(x+P)-f[2][1],U=(x*f[0][0]+P*f[1][0]+h*f[2][0])/(x+P+h),H=(x*f[0][1]+P*f[1][1]+h*f[2][1])/(x+P+h);return[[L,m],[i,W],[U,H]]}function I(f){let x=C(f);return[[[f[1][0],f[1][1]],[f[1][0]+x[0][0],f[1][1]+x[0][1]]],[[f[2][0],f[2][1]],[f[2][0]+x[1][0],f[2][1]+x[1][1]]],[[0,0],[x[2][0],x[2][1]]]]}const E=5,B=e.scaleLinear().domain([-E*.1,E*1.1]).range([0,l]),O=e.scaleLinear().domain([-E*.1*u/l,E*1.1*u/l]).range([u,0]),k=e.line().x(f=>B(f[0])).y(f=>O(f[1]));function j(f,x,P,h){return function(L){let m=f(L[0][0]),i=x(L[0][1]),W=f(L[1][0]),U=x(L[1][1]),H=W-m,te=U-i,T=Math.hypot(H,te),J=H/T,D=te/T;return[[f.invert(m+J*P),x.invert(i+D*P)],[f.invert(W-J*h),x.invert(U-D*h)]]}}function z(f){return function(x){return[f*x[1][0]+(1-f)*x[0][0],f*x[1][1]+(1-f)*x[0][1]]}}p.append("g").attr("class","axes").selectAll("path").data([[[-E*.05,0],[E,0]],[[0,-E*.05*u/l],[0,E*u/l]]]).join("path").attr("d",k).attr("stroke","black").attr("fill","none").attr("stroke-width",1).attr("marker-start",`url(${y.href.replace(/#.*#/,"#")})`).attr("marker-end",`url(${y.href.replace(/#.*#/,"#")})`),[0,0,0].map((f,x)=>[s.y0[4*x+0],s.y0[4*x+1]]);const M=s.pointSize.map(f=>Math.max(2.5,f*8));let w=p.append("g").attr("class","bodies"),$=p.append("g").attr("class","jacobi"),Q=p.append("g").attr("class","jacobi-labels"),X=p.append("g").attr("class","labels"),ee=p.append("g").attr("class","bodyLabels"),F=p.append("g").attr("class","handles"),V=[[M[1]+1,M[0]-1+6],[M[2]+1,6],[0,6]];function Y(){v.dispatchEvent(new CustomEvent("input")),w.selectAll("circle").data(g).join("circle").attr("cx",f=>B(f[0])).attr("cy",f=>O(f[1])).attr("r",(f,x)=>M[x]).attr("fill",(f,x)=>c(s.colors[x])).attr("stroke",(f,x)=>c(b.strokeColor[x])).attr("stroke-width",2),$.selectAll("path").data(I(g).map((f,x)=>j(B,O,V[x][0],V[x][1])(f))).join("path").attr("d",k),Q.selectAll("text").data(I(g).map(z(.35))).join("text").attr("x",f=>B(f[0])).attr("y",f=>O(f[1])),ee.selectAll("text").data(g).join("text").attr("x",f=>B(f[0])).attr("y",f=>O(f[1])),F.selectAll("circle").data(g).join("circle").attr("cx",f=>B(f[0])).attr("cy",f=>O(f[1]))}return $.selectAll("path").data(I(g)).join("path").attr("d",k).attr("stroke","black").attr("fill","none").attr("stroke-width",1.5).attr("marker-end",`url(${y.href.replace(/#.*#/,"#")})`),Q.selectAll("text").data(I(g)).join("text").text((f,x)=>"r").call(function(f,x){f.append("tspan").attr("dy",5).attr("font-weight",400).attr("font-size","0.75em").text((P,h)=>h+1)}).attr("font-size","16px").attr("font-weight",700).attr("font-family","serif").attr("font-style","italic").attr("dy",9).attr("dx",9),X.selectAll("text").data([{xy:[0,E*u/l],text:"y"},{xy:[E,0],text:"x"}]).join("text").text(f=>f.text).attr("x",f=>B(f.xy[0])).attr("y",f=>O(f.xy[1])).attr("font-size","14px").attr("font-family","serif").attr("font-style","italic").attr("dy",-2).attr("dx",5),ee.selectAll("text").data(g).join("text").text("m").call(function(f,x){f.append("tspan").attr("dy",5).attr("font-weight",400).attr("font-size","0.75em").text((P,h)=>h+1)}).attr("font-size","14px").attr("font-family","serif").attr("font-style","italic").attr("dx",(f,x)=>3+M[x]*.707).attr("dy",(f,x)=>-11+M[x]*.707).attr("text-anchor","top"),F.selectAll("circle").data(g).join("circle").attr("class","draggable").attr("r",25).attr("fill","transparent").call(e.drag().on("drag",f=>{f[0]=B.invert(e.event.x),f[1]=O.invert(e.event.y),Y()})),Y(),v.value=g,v},inputs:["width","d3","html","tex","DOM","arrowhead","initialConditions","floatRgbToHex","drawing"],outputs:void 0,output:"viewof$jacobiCoords",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});S({root:document.getElementById("cell-7445"),expanded:[],variables:[]},{id:7445,body:function(d,a,e,o,t,r,n,s,c,b,l,u,p,v,y,g,C,I,E,B,O,k,j,z){const{currentXScale:M,currentYScale:w,xScale:$,yScale:Q,viewport:X,element:ee}=d.shapeSphereTest,{width:F,height:V,dpi:Y}=X,f=a.select(ee).attr("width",F).attr("height",V);e.lineWidth>0&&e.lineOpacity>0;const x=o(f,F,V,Y,{optionalExtensions:["ANGLE_instanced_arrays","OES_standard_derivatives"],attributes:{antialias:!0}}),P=x.value,h=P.data;h.camera=h.camera||t(P,{phi:.3,center:[0,0,0],theta:.7,distance:3,near:.01,far:5e3,zoomAboutCursor:!1}),h.camera.resize(F/V),h.interactions=h.interactions||r(h.camera,{zoom:!1,touchZoom:!0}),h.icosphere=h.icosphere||n(4),h.icospherePositions=h.icospherePositions||P.buffer(h.icosphere.positions),h.icosphereElements=h.icosphereElements||P.elements(h.icosphere.cells);let L={positions:h.icospherePositions,elements:h.icosphereElements,count:h.icosphere.cells.length*3};h.puncturePointsBuffer=h.puncturePointsBuffer||P.buffer(new Float32Array(15)),h.puncturePointColorsBuffer=h.puncturePointColorsBuffer||P.buffer(new Float32Array(20));function m(A){return[A[1],A[2],A[0]]}let i=s([],c[0][0],c[0][1],c[1][0],c[1][1],c[2][0],c[2][1]);h.l1=b(h.l1,P.buffer,[[0,0,0],i].map(m)),h.l2=b(h.l2,P.buffer,[[0,0,0],l([],[i[0],i[1],0])].map(m));let W=200;h.equator=b(h.equator,P.buffer,new Array(W).fill(0).map((A,_)=>{let q=2*Math.PI*_/(W-1);return[Math.cos(q),0,Math.sin(q)]}));let U=l(u(),[i[0],i[1],0]),H=[0,0,1],te=Math.atan(i[2]/Math.hypot(i[0],i[1]));h.dropLine=b(h.dropLine,P.buffer,new Array(W+1).fill(0).map((A,_)=>{let q=te*_/W,Z=u();return p(Z,[0,0,0],U,Math.cos(q)),p(Z,Z,H,Math.sin(q)),m(Z)}));const T=[{position:h.l2,color:{constant:[.6,.6,.6,1]}},{position:h.equator,color:{constant:[.6,.6,.6,1]},count:W},{position:h.dropLine,color:{constant:[.6,.6,.6,1]},count:W}].map(A=>Object.assign({offset:0,stride:12,width:{constant:1},strokeColor:e.strokeColor,strokeWidth:0,count:2},A)),J=[{positions:h.l1,color:e.color.concat(e.lineOpacity),offset:0,stride:12,strokeWidth:0,arrowheadWidth:9,arrowheadLength:12,arrowTailWidth:2.5,count:2}];let D=s([],0,0,1,1,1,1),re=s([],1,1,0,0,1,1),K=s([],1,1,1,1,0,0);h.puncturePointsBuffer.subdata([D,re,K].map(m)),h.puncturePointColorsBuffer.subdata([[.2,.9,.1,1],[.9,.1,.2,1],[.1,.2,.9,1]]);const R=[{positions:{buffer:h.puncturePointsBuffer,stride:12,offset:0},colors:h.puncturePointColorsBuffer,pointSize:12,strokeWidth:2,strokeColor:[1,1,1],count:3}];v(),h.drawArrows=h.drawArrows||y(P),h.drawLines=h.drawLines||g(P),h.drawPoints=h.drawPoints||C(P),h.drawGlobe=h.drawGlobe||I(P),h.viewport=h.viewport||E(P),h.scale=h.scale||B(P),h.configureDrawing=P({uniforms:{uProjectionViewModel:(A,_)=>O(v(),A.projection,A.view)},depth:{enable:!0}});let N=!0;h.camera.taint(),h.renderPlot=function(_){N&&h.viewport(X,()=>{h.camera(q=>{q.dirty&&(P.clear({color:[0,0,0,0],depth:1}),h.configureDrawing(()=>{h.drawLines(T),h.drawArrows(J),h.drawPoints(R),h.drawGlobe(L)}))})})},h.frame||(h.frame=P.frame(function(A){h.renderPlot(A)})),h.renderPlot({time:0});const G=new k(A=>{N=A.pop().intersectionRatio>0});return G.observe(x),j.then(()=>{G.disconnect()}),f.attr("class","draggable"),z`
    <figure>
      ${f.node()}
      <figcaption>Shape sphere for Jacobi coordinates with the three pairwise collision points marked in red, green, and blue.</figcaption>
    </figure>
  `},inputs:["plotContexts","d3","shapeDrawing","getOrAttachReglFO","createReglCamera","createInteractions","createIcosphere","computeShape","jacobiCoords","createOrUpdateBuffer","vec3normalize","vec3create","vec3scaleAndAdd","mat4create","createDrawArrowsCommand","createDrawLineCommand","createStrokedPointsCommand","createDrawGlobeCommand","createReglViewportConfiguration","createReglLinearScaleConfiguration","mat4multiply","IntersectionObserver","invalidation","html"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-5836"),expanded:[],variables:[]},{id:5836,body:function(a){return function(o,t,r,n,s,c,b){let l=a.m[0],u=a.m[1];a.m[2];let p=(t-n)/Math.sqrt(2),v=(r-s)/Math.sqrt(2),y=((l*t+u*n)/(l+u)-c)*2/Math.sqrt(6),g=((l*r+u*s)/(l+u)-b)*2/Math.sqrt(6),C=p*p+v*v,I=y*y+g*g;return o[2]=2*(p*g-v*y)/(C+I),o[0]=2*(p*y+v*g)/(C+I),o[1]=(I-C)/(C+I),o}},inputs:["initialConditions"],outputs:void 0,output:"computeShape",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-7647"),expanded:[],variables:[]},{id:7647,body:function(d,a,e){return d`We return to the ${a`${e.name}`} orbit and [plot it below](#projectedShapeSphere) on the shape sphere.

Since all orbits here are collision-free, the trajectory meanders about on the surface of the sphere but never passes through any of the three pairwise collision points. In fact we can imagine continuously deforming a trajectory to find similar nearby orbits just as long as we don't ever pass over the collision points and create an invalid orbit. In topology, these forbidden missing points are called *punctures*, and a family of orbits we can obtain through continuous deformation without passing over the punctures corresponds the concept of the [*fundamental group*](https://en.wikipedia.org/wiki/Fundamental_group) from algebraic topology. Algebraic topology is a topic well beyond my expertise, so I'll tread lightly here and not pretend to know more about it.`},inputs:["md","tex","initialConditions"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-5627"),expanded:[],variables:[]},{id:5627,body:function(a,e){let o=[],t=a.position;for(var r=0,n=0;r<a.t.length;r++,n+=9)o.push.apply(o,e([],t[n+0],t[n+1],t[n+3],t[n+4],t[n+6],t[n+7]));return o},inputs:["trajectory","computeShape"],outputs:void 0,output:"shape",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-5856"),expanded:[],variables:[]},{id:5856,body:function(){return function(e,o){return e[0]=o[0]/(1-o[1])*2,e[1]=-1,e[2]=o[2]/(1-o[1])*2,e}},inputs:[],outputs:void 0,output:"computeStereographicProjection",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-5860"),expanded:[],variables:[]},{id:5860,body:function(a,e,o,t,r){let n={xyt:[],xyz:[]},s=a.length;for(let c=0,b=0;b<s;c++,b+=3){let l=e([],[a[b],a[b+1],a[b+2]]);n.xyz.push(l[0],l[1],l[2]);let u=o([],[l[0],l[2]],t.fisheye);n.xyt.push(u[0],u[1],r.t[c])}return n},inputs:["shape","computeStereographicProjection","computeFisheye","shapeDrawing","trajectory"],outputs:void 0,output:"projectedShape",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-6271"),expanded:[],variables:[]},{id:6271,body:function(a,e,o,t,r,n,s,c,b,l,u,p,v,y,g,C,I,E,B,O,k,j,z,M,w,$){const{currentXScale:Q,currentYScale:X,xScale:ee,yScale:F,viewport:V,element:Y}=a.shapeSphere,{width:f,height:x,dpi:P}=V,h=e.select(Y).attr("width",f).attr("height",x);o.lineWidth>0&&o.lineOpacity>0;const L=t(h,f,x,P,{optionalExtensions:["ANGLE_instanced_arrays","OES_standard_derivatives"],attributes:{antialias:!0}}),m=L.value,i=m.data;i.camera=i.camera||r(m,{phi:.1,center:[0,-.2,0],rotationCenter:[0,0,0],theta:.7,distance:5,near:.01,far:5e3}),i.camera.resize(f/x),i.interactions=i.interactions||n(i.camera,{zoomSpeed:.5,zoom:!1,touchZoom:!0}),i.shapeSpaceBuffer=s(i.shapeSpaceBuffer,m.buffer,c),i.projectedShapeBuffer=s(i.projectedShapeBuffer,m.buffer,b.xyz),i.icosphere=i.icosphere||l(4),i.icospherePositions=i.icospherePositions||m.buffer(i.icosphere.positions),i.icosphereElements=i.icosphereElements||m.elements(i.icosphere.cells);let W={positions:i.icospherePositions,elements:i.icosphereElements,count:i.icosphere.cells.length*3,model:u(p(),p(),Math.PI*.5)};i.puncturePointsBuffer=i.puncturePointsBuffer||m.buffer(new Float32Array(15)),i.puncturePointColorsBuffer=i.puncturePointColorsBuffer||m.buffer(new Float32Array(20));let U=v([],0,0,1,1,1,1),H=v([],1,1,0,0,1,1),te=v([],1,1,1,1,0,0),T=y([],U),J=y([],H);i.puncturePointsBuffer.subdata([U,H,te,T,J]),i.puncturePointColorsBuffer.subdata([[.2,.9,.1,1],[.9,.1,.2,1],[.1,.2,.9,1],[.2,.9,.1,1],[.9,.1,.2,1]]);let D=200;i.equator=s(i.equator,m.buffer,new Array(D+1).fill(0).map((A,_)=>{let q=2*Math.PI*_/D;return[Math.cos(q),Math.sin(q),0]})),i.referenceLineBuffer=i.referenceLineBuffer||m.buffer([J,[0,1,0],T]);const re={positions:{buffer:i.puncturePointsBuffer,stride:12,offset:0},colors:i.puncturePointColorsBuffer,pointSize:12,strokeWidth:2,strokeColor:[1,1,1],count:5},K=A=>1+o.lineOpacity*(A-1),R=[{position:i.shapeSpaceBuffer,color:{constant:o.color.map(K).concat(1)},count:g.t.length},{position:i.equator,width:{constant:.5},color:{constant:[.7,.7,.7,1]},count:D+1},{position:i.projectedShapeBuffer,color:{constant:[.7,.7,.7].map(K).concat(1)},count:g.t.length},{position:i.referenceLineBuffer,color:{constant:[.6,.6,.6].map(K).concat(1)},count:3}].map(A=>Object.assign({offset:0,stride:12,width:{constant:1},borderColor:{constant:o.strokeColor},borderWidth:{constant:0}},A));p(),i.drawLines=i.drawLines||C(m),i.drawPoints=i.drawPoints||I(m),i.drawGlobe=i.drawGlobe||E(m),i.viewport=i.viewport||B(m),i.scale=i.scale||O(m),i.configureDrawing=m({uniforms:{uProjectionViewModel:(A,_)=>k(p(),A.projection,A.view)},depth:{enable:!0}});let N=!0;i.camera.taint(),i.renderPlot=function(_){N&&i.viewport(V,()=>{i.camera(q=>{q.dirty&&(m.clear({color:[0,0,0,0],depth:1}),i.configureDrawing(()=>{i.drawLines(R),i.drawPoints(re),i.drawGlobe(W)}))})})},i.frame||(i.frame=m.frame(function(A){i.renderPlot(A)})),i.renderPlot({time:0});const G=new j(A=>{N=A.pop().intersectionRatio>0});return G.observe(L),z.then(()=>{G.disconnect()}),h.attr("class","draggable"),M`
    <figure>
      ${h.node()}
      <figcaption>Shape sphere trajectory of the ${w`${$.name}`} orbit, with the shape sphere turned on its side and projected onto a plane.</figcaption>
    </figure>
  `},inputs:["plotContexts","d3","shapeDrawing","getOrAttachReglFO","createReglCamera","createInteractions","createOrUpdateBuffer","shape","projectedShape","createIcosphere","mat4rotateX","mat4create","computeShape","computeStereographicProjection","trajectory","createDrawBorderedLineCommand","createStrokedPointsCommand","createDrawGlobeCommand","createReglViewportConfiguration","createReglLinearScaleConfiguration","mat4multiply","IntersectionObserver","invalidation","html","tex","initialConditions"],outputs:void 0,output:"viewof$projectedShapeSphere",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});S({root:document.getElementById("cell-7684"),expanded:[],variables:[]},{id:7684,body:function(d){return d`Three dimensional space is still a bit much to work with, so we additionally turn the shape sphere on its side, select one of the punctures, and project the orbit stereographically about that point onto a plane. The figure above illustrates this process.

The figure below shows the orbit projected into the two-dimensional plane. Two punctures are visible while the the puncture about which we projected is removed to infinity. The shape trajectory now lies in a flat two dimensional plane, looping around the two projected punctures but never passing through them.`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-5467"),expanded:[],variables:[]},{id:5467,body:function(d,a,e,o,t,r,n,s,c,b,l,u,p,v,y,g,C,I,E,B,O,k,j,z,M){const{currentXScale:w,currentYScale:$,xScale:Q,yScale:X,viewport:ee,element:F}=d.projectedShapeSphere,{width:V,height:Y,dpi:f}=ee,x=a.select(F).attr("width",V).attr("height",Y);e.lineWidth>0&&e.lineOpacity>0;const P=o,h=t(x,V,Y,f,{optionalExtensions:["ANGLE_instanced_arrays"],attributes:{antialias:!0}}),L=h.value,m=L.data;m.shapeSpaceBuffer=r(m.shapeSpaceBuffer,L.buffer,n.xyt);const i=A=>1+e.lineOpacity*(A-1),W={position:m.shapeSpaceBuffer,offset:0,stride:12,color:{constant:e.color.map(i).concat(1)},borderColor:{constant:e.strokeColor.concat(1)},borderWidth:{constant:e.lineStrokeWidth},width:{constant:e.lineWidth},count:s.t.length};m.puncturePointsBuffer=m.puncturePointsBuffer||L.buffer(new Float32Array(6)),m.puncturePointColorsBuffer=m.puncturePointColorsBuffer||L.buffer(new Float32Array(8));const U=c([],b([],0,0,1,1,1,1)),H=l([],[U[0],U[2]],e.fisheye),te=c([],b([],1,1,0,0,1,1)),T=l([],[te[0],te[2]],e.fisheye);m.puncturePointsBuffer.subdata(new Float32Array([H[0],H[1],0,T[0],T[1],0])),m.puncturePointColorsBuffer.subdata(new Float32Array([.1,.9,.2,1,.9,.2,.1,1]));const J={positions:{buffer:m.puncturePointsBuffer,stride:12,offset:0},colors:m.puncturePointColorsBuffer,pointSize:12,strokeWidth:2,strokeColor:[1,1,1],count:2},D=u();m.drawLines=m.drawLines||p(L),m.drawPoints=m.drawPoints||v(L),m.viewport=m.viewport||y(L),m.scale=m.scale||g(L),m.configureLineDrawing=m.configureLineDrawing||L({uniforms:{uProjectionViewModel:(A,_)=>(C(D,A.view),D[10]=-_.timeScale*2,D[14]=_.timeShift*_.timeScale*2-1,D)},depth:{enable:!0}}),m.configurePointDrawing=m.configurePointDrawing||L({uniforms:{uProjectionView:(A,_)=>(C(D,A.view),D[10]=0,D)},depth:{enable:!1},blend:{enable:!0,func:{srcRGB:"src alpha",srcAlpha:1,dstRGB:"one minus src alpha",dstAlpha:"one minus src alpha"},equation:{rgb:"add",alpha:"add"}}}),m.t0===void 0&&(m.t0=NaN,m.tPrev=NaN,m.tDelta=0);let re=!0,K=!0;m.renderPlot=function(_){if(!re)return;let q=_?_.time:isNaN(m.tPrev)?0:m.tPrev;if(isNaN(m.tPrev)?m.tPrev=m.t0=q:(m.tDelta=Math.min(1/30,q-m.tPrev),m.tPrev=q),!P&&!K)return;K=!1;let Z=s.t[s.t.length-1],ae=m.t0;isNaN(ae)&&(ae=q);let ne=q*e.speed;for(;ne>ae+Z*2;)ae+=Z*2;for(;ne<ae;)ae-=Z*2;let ie=ne-ae,ue=1/Z;L.clear({color:[0,0,0,0],depth:1}),m.viewport(ee,()=>{m.scale(w,$,()=>{m.configureLineDrawing({timeShift:P?ie:Z,timeScale:ue},()=>{m.drawLines(W)}),m.configurePointDrawing({timeShift:P?ie:Z,timeScale:ue},()=>{m.drawPoints(J)})})})},x.selectAll(".axes").remove();const R=x.selectAll(".axes").data(["axes"]).join("g").attr("class","axes");function N(){R.call(I(ee,w,$,{xAxis:E?a.axisTop:a.axisBottom,yAxis:E?a.axisRight:a.axisLeft}))}x.attr("class","draggable").call(B(w,$,Q,X).scaleExtent([1e-4,1e4]).on("zoom.plot",()=>{K=!0}).on("zoom.axes",N)),m.frame||(m.frame=L.frame(function(A){m.renderPlot(A)})),m.renderPlot({time:0}),N();const G=new O(A=>{re=A.pop().intersectionRatio>0});return G.observe(h),k.then(()=>{G.disconnect()}),j`
    <figure>
      ${x.node()}
      <figcaption>${z`${M.name}`} orbit in projected shape space with two of three pairwise collision points (punctures) marked in red and green. The third collision point is at infinity.</figcaption>
    </figure>
  `},inputs:["plotContexts","d3","shapeDrawing","animateShape","getOrAttachReglFO","createOrUpdateBuffer","projectedShape","trajectory","computeStereographicProjection","computeShape","computeFisheye","mat4create","createDrawBorderedLineCommand","createStrokedPointsCommand","createReglViewportConfiguration","createReglLinearScaleConfiguration","mat4copy","viewportAxes","isNarrowScreen","persistentZoom","IntersectionObserver","invalidation","html","tex","initialConditions"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-7797"),expanded:[],variables:[]},{id:7797,body:function(a){return a({options:[{value:"animate",label:"animate shape trajectory"}]})},inputs:["checkbox"],outputs:void 0,output:"viewof$animateShape",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});S({root:document.getElementById("cell-5505"),expanded:[],variables:[]},{id:5505,body:function(a,e,o){const t=a`
  <form class="form-compact">
    <details>
      <summary style="font-size:0.85em;">Display options</summary>
      <div class="field"><input type=range name=lineOpacity min=0 max=1 step=0.01 value=1> <small><i>line opacity: <output name=lineOpacityOutput></output></i></small></div>

      <div class="field"><input type=range name=lineWidth min=0.5 max=4 step=0.1 value=1> <small><i>line width: <output name=lineWidthOutput></i></output></small></div>

      <div class="field"><input type=range name=lineStrokeWidth min=0 max=4 step=0.1 value=0> <small><i>line stroke: <output name=lineStrokeWidthOutput></i></output></small></div>

      <div class="field"><input type=range name=speed min=0.05 max=20 step=0.05 value=3> <small><i>speed: <output name=speedOutput></i></output></small></div>

      <div class="field"><input type=range name=fisheye min=0 max=1 step=0.01 value=0> <small><i>fisheye</small></div>

      <div class="field">
        <input type=color name=lineColor1 value=${e([.18,.63,.83])}>
        <small><i>shape color</i></small>
      </div>

      <div class="field">
        <input type=color name=strokeColor1 value=${e([1,1,1])}>
        <small><i>stroke color</i></small>
      </div>
    </details>
  </form>`;return t.oninput=()=>{t.lineOpacityOutput.value=t.lineOpacity.valueAsNumber,t.lineWidthOutput.value=t.lineWidth.valueAsNumber,t.lineStrokeWidthOutput.value=t.lineStrokeWidth.valueAsNumber,t.speedOutput.value=t.speed.valueAsNumber,t.value={lineOpacity:t.lineOpacity.valueAsNumber,lineWidth:t.lineWidth.valueAsNumber,lineStrokeWidth:t.lineStrokeWidth.valueAsNumber,speed:t.speed.valueAsNumber,fisheye:t.fisheye.valueAsNumber,color:o(t.lineColor1.value),strokeColor:o(t.strokeColor1.value)}},t.oninput(),t},inputs:["html","floatRgbToHex","hexRgbToFloat"],outputs:void 0,output:"viewof$shapeDrawing",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});S({root:document.getElementById("cell-7948"),expanded:[],variables:[]},{id:7948,body:function(d,a){return d`From here, our task is conceptually simple. We walk along the projected shape of the orbit and note every time it completes a loop, either clockwise or counterclockwise, around one of the two punctures. The result is a [_free group word_](https://en.wikipedia.org/wiki/Free_group) and (at last!) identifies our orbit in the topological sense. We record an ${a`a`} for clockwise loops around the righthand puncture and ${a`a^{-1}`} (which we abbreviate as ${a`A`}) for counterclockwise loops. Similarly we record ${a`b`} and ${a`B`}, respectively, for counterclockwise and clockwise loops around the lefthand puncture.`},inputs:["md","tex"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-8418"),expanded:[],variables:[]},{id:8418,body:function(d,a,e,o,t,r,n,s){const c=Math.min(d,350),b=Math.floor(c*.7),l=a.create("svg").attr("width",c).attr("height",b),u=e(o.color),p="#666",v=t.uid("arrowhead"),y=t.uid("axisArrowhead"),g=l.append("defs");g.append("marker").attr("id",v.id).call(r({width:11,length:13})).attr("fill",u),g.append("marker").attr("id",y.id).call(r()).attr("fill",p);let C=3,I=.9;const E=a.scaleLinear().domain([-C,C]).range([0,c]),B=a.scaleLinear().domain([-C*b/c,C*b/c]).range([b,0]),O=a.line().x(k=>E(k[0])).y(k=>B(k[1]));return l.append("g").attr("class","axes").selectAll("path").data([[[-C*I,0],[C*I,0]],[[0,-C*I*b/c],[0,C*I*b/c]]]).join("path").attr("d",O).attr("stroke",p).attr("fill","none").attr("stroke-width",1).attr("marker-start",`url(${y.href.replace(/#.*#/,"#")})`).attr("marker-end",`url(${y.href.replace(/#.*#/,"#")})`),l.append("g").attr("class","vertex-stroke").selectAll("circle").data([[0,0]]).join("circle").attr("cx",k=>E(k[0])).attr("cy",k=>B(k[1])).attr("r",6).attr("fill","white"),l.append("g").attr("class","circle-stroke").selectAll("circle").data([[-1,0],[1,0]]).join("circle").attr("cx",k=>E(k[0])).attr("cy",k=>B(k[1])).attr("r",E(1)-E(0)).attr("stroke","white").attr("stroke-width",5).attr("fill","none"),l.append("g").attr("class","circles").selectAll("circle").data([[-1,0],[1,0]]).join("circle").attr("cx",k=>E(k[0])).attr("cy",k=>B(k[1])).attr("r",E(1)-E(0)).attr("stroke",u).attr("stroke-width",2).attr("fill","none"),l.append("g").attr("class","bodies").selectAll("circle").data([[-1,0],[1,0]]).join("circle").attr("cx",k=>E(k[0])).attr("cy",k=>B(k[1])).attr("r",6).attr("fill",(k,j)=>e(j===0?[.9,.2,.1]:[.1,.9,.2])).attr("stroke","white").attr("stroke-width",2),l.append("g").attr("class","vertex").selectAll("circle").data([[0,0]]).join("circle").attr("cx",k=>E(k[0])).attr("cy",k=>B(k[1])).attr("r",4).attr("fill",u),l.append("g").attr("class","arrowheads").selectAll("path").data([[[1,1],[1.001,1]],[[-1,1],[-1.001,1]],[[-1,-1],[-.999,-1]],[[1,-1],[.999,-1]]]).join("path").attr("d",O).attr("stroke",u).attr("fill","none").attr("stroke-width",1.5).attr("marker-end",`url(${v.href.replace(/#.*#/,"#")})`),l.append("g").attr("class","body-labels").selectAll("text").data([{x:[-1,1],text:"b"},{x:[1,1],text:"a"}]).join("text").text(k=>k.text).attr("x",k=>E(k.x[0])).attr("y",k=>B(k.x[1])).attr("font-size","17px").attr("font-family","serif").attr("font-style","italic").attr("dx",-3).attr("dy",-10).attr("text-anchor","top"),n`
    <figure>
      ${l.node()}
      <figcaption>Our free group elements, ${s`a`} and ${s`b`}.</figcaption>
    </figure>
  `},inputs:["width","d3","floatRgbToHex","shapeDrawing","DOM","arrowhead","html","tex"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-8714"),expanded:[],variables:[]},{id:8714,body:function(d){return d`Though conceptually simple, reading these elements is somewhat tedious. In their paper [A guide to hunting periodic three-body orbits](https://ui.adsabs.harvard.edu/abs/2014AmJPh..82..609S), Å uvakov and DmitraÅ¡inoviÄ‡ present a "free group word reading algorithm". Following the algorithm, we track every crossing of the shape sphere equator, which corresponds to collinear configurations (*syzygies*). We track the direction of each crossing and which body is in the middle, then convert the information via a lookup table into the free group word.`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-8207"),expanded:[],variables:[]},{id:8207,body:function(a){function e(u,p,v){let y=Math.atan2(u,p);return Math.floor((y/(2*Math.PI)+1)%1*3)}const o=[1];let t=0;for(let u=0;u<a.length;u+=3){let p=a[u+2];if(t*p<0){let v=e(a[u],a[u+1]);o.push(v)}t=p}o[o.length-1]!==2&&o.push(2);let r=[[null,"F","FA"],["B",null,"A"],["EB","E",null]],n=[[null,"D","DG"],["H",null,"G"],["CH","C",null]],s=[];for(let u=0;u<o.length-1;u++)s.push((u%2===0?n:r)[o[u]][o[u+1]]);let c=s.join(""),b=[],l={AC:"b",GE:"B",BD:"a",HF:"A"};for(let u=0;u<c.length;u+=2){let p=c.substr(u,2);b.push(l[p])}return b.join("")},inputs:["shape"],outputs:void 0,output:"freeGroupWord",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-8728"),expanded:[],variables:[]},{id:8728,body:function(d,a,e,o){return d`In this case, for the ${a`${e.name}`} orbit, we compute the free group word *<span style="word-break:break-all">${o}</span>*.

Many patterns lie within. Figure-eight orbits, for example, follow a repeating *BabA* pattern. Other classes of orbits follow more complicated patterns. To preempt an issue you may have noticed, *yes*, there is indeed ambiguity in this classification. We could have chosen one of the other puncture points about which to project. For some families of orbits this makes a difference; for others it does not. Orbits are similarly equivalent under time reversal so that the free group word *Ab* is equivalent to *Ba*. Å uvakov and DmitraÅ¡inoviÄ‡ have a much more detailed discussion of these considerations in their paper [Linear stability of periodic three-body orbits with zero angular momentum and topological dependence of Kepler's third law: a numerical test](https://arxiv.org/abs/1705.03728). It's worth a read!`},inputs:["md","tex","initialConditions","freeGroupWord"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-8522"),expanded:[],variables:[]},{id:8522,body:function(d){return d`## Future work
In a future notebook, I'd love to implement a search algorithm to actually locate periodic orbits. From the abstract of the paper mentioned above, [A guide to hunting periodic three-body orbits](https://ui.adsabs.harvard.edu/abs/2014AmJPh..82..609S),

> The recent discovery of thirteen new and distinct three-body periodic planar orbits suggests that many more such orbits remain undiscovered. Searches in two-dimensional subspaces of the full four-dimensional space of initial conditions require computing resources that are available to many students, and the required level of computational and numerical expertise is also at the advanced undergraduate level. We discuss the methods for solving the planar three-body equations of motion, as well as some basic strategies and tactics for searches of periodic orbits. Our discussion should allow interested undergraduates to start their own searches. Users can submit new three-body orbits to a wiki-based website.

The [wiki appears either defunct or in progress](http://www.orbitopedia.org/), but the exploration sounds fun!

Comments? Question? [Let me know](https://twitter.com/rickyreusser/status/1185354588280348672).
`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-8848"),expanded:[],variables:[]},{id:8848,body:function(d){return d`## License

With the exception of code imported from other sources as stated above, the code in this notebook is MIT Licensed.`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-8838"),expanded:[],variables:[]},{id:8838,body:function(){return"mit"},inputs:[],outputs:void 0,output:"LICENSE",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-8861"),expanded:[],variables:[]},{id:8861,body:function(d,a){return d`The written content of this notebook is licensed under a ${a`<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a><br><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a>.`}`},inputs:["md","html"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-1474"),expanded:[],variables:[]},{id:1474,body:function(d){return d`## Imports and definitions`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-7530"),expanded:[],variables:[]},{id:7530,body:function(a,e,o){function t(r,n){const s=n.xrange||[-1,1],c=n.yrange||[-1,1],b=n.width||640,l=n.margin||(a<640?{t:3,r:0,b:1,l:1}:{t:5,r:5,b:20,l:40}),u=n.height||Math.max(300,Math.min(900,b*.7)),p={width:b,height:u,dpi:devicePixelRatio,margin:l},v=e.scaleLinear().domain(s).range([p.height-p.margin.b,p.margin.t]),y=o(e.scaleLinear().domain(c).range([p.margin.l,p.width-p.margin.r]),v,1);return Object.assign(r||{element:e.create("svg").node()},{viewport:p,xScale:y,yScale:v,currentXScale:y.copy(),currentYScale:v.copy()})}return{orbit:t((this||{}).orbit,{width:a,height:Math.max(340,Math.floor(a*.7))}),shapeSphereTest:t((this||{}).shapeSphereTest,{width:Math.min(a,480),height:Math.min(a,480)*.7,margin:{t:0,r:0,b:0,l:0}}),projectedShapeSphere:t((this||{}).projectedShapeSphere,{width:Math.min(a,640),height:Math.max(Math.min(a,640)*.7,300),xrange:[-1.5,1.5],yrange:[-1.5,1.5]}),shapeSphere:t((this||{}).shapeSphere,{width:Math.min(a,640),height:Math.max(Math.min(a,640)*.7,300),margin:{t:0,r:0,b:0,l:0}})}},inputs:["width","d3","constrainLinearScaleAspectRatio"],outputs:void 0,output:"plotContexts",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-244"),expanded:[],variables:[]},{id:244,body:function(a){return a("d3@5")},inputs:["require"],outputs:void 0,output:"d3",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-1248"),expanded:[],variables:[]},{id:1248,body:function(a){return a("regl")},inputs:["require"],outputs:void 0,output:"createREGL",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-6489"),expanded:[],variables:[]},{id:6489,body:async(d,a)=>{const{createIcosphere:e}=await oe(()=>import("https://api.observablehq.com/@rreusser/icosphere.js?v=4"),[]).then(o=>{const t={},r=d.module(o.default),n=d.module();if(!r.defines("createIcosphere"))throw new SyntaxError("export 'createIcosphere' not found");return n.variable(t.createIcosphere=a()).import("createIcosphere",r),t});return{createIcosphere:e}},inputs:["__ojs_runtime","__ojs_observer"],outputs:["createIcosphere"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});S({root:document.getElementById("cell-241"),expanded:[],variables:[]},{id:241,body:async(d,a)=>{const{getOrAttachReglFO:e,constrainLinearScaleAspectRatio:o,createReglViewportConfiguration:t,createReglLinearScaleConfiguration:r,persistentZoom:n,viewportAxes:s,createReglCamera:c,createInteractions:b}=await oe(()=>import("https://api.observablehq.com/@rreusser/regl-tools.js?v=4"),[]).then(l=>{const u={},p=d.module(l.default),v=d.module();if(!p.defines("getOrAttachReglFO"))throw new SyntaxError("export 'getOrAttachReglFO' not found");if(v.variable(u.getOrAttachReglFO=a()).import("getOrAttachReglFO",p),!p.defines("constrainLinearScaleAspectRatio"))throw new SyntaxError("export 'constrainLinearScaleAspectRatio' not found");if(v.variable(u.constrainLinearScaleAspectRatio=a()).import("constrainLinearScaleAspectRatio",p),!p.defines("createReglViewportConfiguration"))throw new SyntaxError("export 'createReglViewportConfiguration' not found");if(v.variable(u.createReglViewportConfiguration=a()).import("createReglViewportConfiguration",p),!p.defines("createReglLinearScaleConfiguration"))throw new SyntaxError("export 'createReglLinearScaleConfiguration' not found");if(v.variable(u.createReglLinearScaleConfiguration=a()).import("createReglLinearScaleConfiguration",p),!p.defines("persistentZoom"))throw new SyntaxError("export 'persistentZoom' not found");if(v.variable(u.persistentZoom=a()).import("persistentZoom",p),!p.defines("viewportAxes"))throw new SyntaxError("export 'viewportAxes' not found");if(v.variable(u.viewportAxes=a()).import("viewportAxes",p),!p.defines("createReglCamera"))throw new SyntaxError("export 'createReglCamera' not found");if(v.variable(u.createReglCamera=a()).import("createReglCamera",p),!p.defines("createInteractions"))throw new SyntaxError("export 'createInteractions' not found");return v.variable(u.createInteractions=a()).import("createInteractions",p),u});return{getOrAttachReglFO:e,constrainLinearScaleAspectRatio:o,createReglViewportConfiguration:t,createReglLinearScaleConfiguration:r,persistentZoom:n,viewportAxes:s,createReglCamera:c,createInteractions:b}},inputs:["__ojs_runtime","__ojs_observer"],outputs:["getOrAttachReglFO","constrainLinearScaleAspectRatio","createReglViewportConfiguration","createReglLinearScaleConfiguration","persistentZoom","viewportAxes","createReglCamera","createInteractions"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});S({root:document.getElementById("cell-7785"),expanded:[],variables:[]},{id:7785,body:async(d,a)=>{const{vec3normalize:e,vec3scaleAndAdd:o,vec3create:t}=await oe(()=>import("https://api.observablehq.com/@rreusser/gl-vec3.js?v=4"),[]).then(r=>{const n={},s=d.module(r.default),c=d.module();if(!s.defines("vec3normalize"))throw new SyntaxError("export 'vec3normalize' not found");if(c.variable(n.vec3normalize=a()).import("vec3normalize",s),!s.defines("vec3scaleAndAdd"))throw new SyntaxError("export 'vec3scaleAndAdd' not found");if(c.variable(n.vec3scaleAndAdd=a()).import("vec3scaleAndAdd",s),!s.defines("vec3create"))throw new SyntaxError("export 'vec3create' not found");return c.variable(n.vec3create=a()).import("vec3create",s),n});return{vec3normalize:e,vec3scaleAndAdd:o,vec3create:t}},inputs:["__ojs_runtime","__ojs_observer"],outputs:["vec3normalize","vec3scaleAndAdd","vec3create"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});S({root:document.getElementById("cell-5074"),expanded:[],variables:[]},{id:5074,body:async(d,a)=>{const{mat4copy:e,mat4create:o,mat4rotateX:t,mat4rotateY:r,mat4rotateZ:n,mat4translate:s,mat4multiply:c}=await oe(()=>import("https://api.observablehq.com/@rreusser/gl-mat4.js?v=4"),[]).then(b=>{const l={},u=d.module(b.default),p=d.module();if(!u.defines("mat4copy"))throw new SyntaxError("export 'mat4copy' not found");if(p.variable(l.mat4copy=a()).import("mat4copy",u),!u.defines("mat4create"))throw new SyntaxError("export 'mat4create' not found");if(p.variable(l.mat4create=a()).import("mat4create",u),!u.defines("mat4rotateX"))throw new SyntaxError("export 'mat4rotateX' not found");if(p.variable(l.mat4rotateX=a()).import("mat4rotateX",u),!u.defines("mat4rotateY"))throw new SyntaxError("export 'mat4rotateY' not found");if(p.variable(l.mat4rotateY=a()).import("mat4rotateY",u),!u.defines("mat4rotateZ"))throw new SyntaxError("export 'mat4rotateZ' not found");if(p.variable(l.mat4rotateZ=a()).import("mat4rotateZ",u),!u.defines("mat4translate"))throw new SyntaxError("export 'mat4translate' not found");if(p.variable(l.mat4translate=a()).import("mat4translate",u),!u.defines("mat4multiply"))throw new SyntaxError("export 'mat4multiply' not found");return p.variable(l.mat4multiply=a()).import("mat4multiply",u),l});return{mat4copy:e,mat4create:o,mat4rotateX:t,mat4rotateY:r,mat4rotateZ:n,mat4translate:s,mat4multiply:c}},inputs:["__ojs_runtime","__ojs_observer"],outputs:["mat4copy","mat4create","mat4rotateX","mat4rotateY","mat4rotateZ","mat4translate","mat4multiply"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});S({root:document.getElementById("cell-7138"),expanded:[],variables:[]},{id:7138,body:function(){return function(e,o,t){let r,n=t.length;if(Array.isArray(t)){let s=t;for(n=1;Array.isArray(s);)n*=s.length,s=s[0]}return!e||n>e.capacity?(r=o(t),r.capacity=n):(r=e.subdata(t),r.capacity=n),r.count=n,r}},inputs:[],outputs:void 0,output:"createOrUpdateBuffer",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-7735"),expanded:[],variables:[]},{id:7735,body:function(a){return function(o){var t=a();return o({vert:`
      precision highp float;
      uniform mat4 uProjectionView, uModel;
      attribute vec3 aPosition;
      varying vec3 p;
      void main () {
        p = aPosition;
        gl_Position = uProjectionView * uModel * vec4(aPosition, 1);
      }
      `,frag:`
      #extension GL_OES_standard_derivatives : enable
      precision highp float;
      varying vec3 p;
      uniform float dist;

      float gridFactor (vec2 parameter, float width, float feather) {
        float w1 = width - feather * 0.5;
        vec2 d = fwidth(parameter);
        vec2 looped = 0.5 - abs(mod(parameter, 1.0) - 0.5);
        vec2 a2 = smoothstep(d * w1, d * (w1 + feather), looped);
        return min(a2.x, a2.y);
      }

      #define LAT_GRID (180.0 / 3.1415926 / 30.0)
      #define LON_GRID (180.0 / 3.1415926 / 60.0)

      void main () {
        float theta = atan(p.z, p.x);
        float f = gridFactor(vec2(atan(p.y, length(p.xz)) * LAT_GRID, theta * LON_GRID), 1.0, 0.5);
        gl_FragColor = vec4(vec3(0), mix(0.16, 0.10, f));
      }
    `,attributes:{aPosition:o.prop("positions")},uniforms:{uModel:(r,n)=>n.model||t},elements:o.prop("elements"),primitive:"triangles",depth:{enable:!0,mask:!1},cull:{enable:!0,face:"back"},blend:{enable:!0,func:{srcRGB:"src alpha",srcAlpha:1,dstRGB:"one minus src alpha",dstAlpha:1},equation:{rgb:"reverse subtract",alpha:"add"}},polygonOffset:{enable:!0,offset:{factor:2,units:0}},count:o.prop("count")})}},inputs:["mat4create"],outputs:void 0,output:"createDrawGlobeCommand",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-8318"),expanded:[],variables:[]},{id:8318,body:function(){return function(e){return e({vert:`
      precision highp float;

      uniform mat4 uProjectionView;
      uniform float uPixelRatio, uStrokeWidth;
      uniform float uPointSize;
      attribute vec3 aPosition;
      attribute vec4 aColor;
      varying vec4 vColor;

      void main () {
        vColor = aColor;
        gl_Position = uProjectionView * vec4(aPosition, 1);
        gl_PointSize = (uPointSize + uStrokeWidth) * uPixelRatio;
      }`,frag:`
      precision highp float;
      varying vec4 vColor;
      uniform vec3 uStrokeColor, uPointColor;
      uniform vec2 uStrokeEdges;
      void main () {
        float r = length(gl_PointCoord.xy * 2.0 - 1.0);
        if (r > 1.0) discard;
        vec3 color = mix(
          uStrokeColor,
          vColor.rgb,
          smoothstep(uStrokeEdges.y, uStrokeEdges.x, r) *
          smoothstep(-uStrokeEdges.y, -uStrokeEdges.x, r)
        );
        gl_FragColor = vec4(color, vColor.a);
      }`,attributes:{aPosition:e.prop("positions"),aColor:e.prop("colors")},uniforms:{uPointSize:e.prop("pointSize"),uPixelRatio:e.context("pixelRatio"),uStrokeWidth:e.prop("strokeWidth"),uStrokeColor:e.prop("strokeColor"),uStrokeEdges:(o,t)=>{if(!t.strokeWidth)return[1,2];let r=t.strokeWidth*2;return[1-(r+.5)/(t.pointSize+r),1-(r-.5)/(t.pointSize+r)]}},primitive:"points",count:e.prop("count")})}},inputs:[],outputs:void 0,output:"createStrokedPointsCommand",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-5937"),expanded:[],variables:[]},{id:5937,body:function(){return function(e){return e({vert:`
      precision highp float;
      uniform mat4 uProjectionView;
      uniform float uTailWidth, uAspect, uScale;
      uniform vec2 uArrowheadShape;
      attribute vec3 aPoint, aNextPoint;
      attribute vec4 aArrow;

      void main () {
        vec4 p = uProjectionView * vec4(aPoint, 1);
        vec4 pn = uProjectionView * vec4(aNextPoint, 1);
        gl_Position = mix(p, pn, aArrow.y);
        vec2 unitVector = normalize((pn.xy / pn.w - p.xy / p.w) * vec2(uAspect, 1));
        vec2 perpUnitVector = vec2(-unitVector.y, unitVector.x);
        gl_Position.xy += (
            perpUnitVector * (aArrow.x * uTailWidth + aArrow.w * uArrowheadShape.y) +
            + unitVector * aArrow.z * uArrowheadShape.x
          ) / vec2(uAspect, 1) * gl_Position.w;
      }
    `,frag:`
      precision highp float;
      uniform vec4 uColor;
      void main () {
        gl_FragColor = uColor;
      }
    `,attributes:{aPoint:{buffer:e.prop("positions"),stride:(o,t)=>t.stride===void 0?12:t.stride,offset:function(o,t){return t.offset===void 0?0:t.offset},divisor:1},aNextPoint:{buffer:e.prop("positions"),stride:(o,t)=>t.stride===void 0?12:t.stride,offset:function(o,t){let r=t.stride===void 0?12:t.stride,n=t.offset===void 0?0:t.offset;return r+n},divisor:1},aArrow:new Float32Array([-1,0,0,0,1,0,0,0,1,1,-1,0,-1,0,0,0,1,1,-1,0,-1,1,-1,0,0,1,-1,-1,0,1,-1,1,0,1,0,0])},uniforms:{uTailWidth:(o,t)=>t.arrowTailWidth/o.viewportHeight*o.pixelRatio,uArrowheadShape:(o,t)=>[t.arrowheadLength/o.viewportHeight*o.pixelRatio*2,t.arrowheadWidth/o.viewportHeight*o.pixelRatio],uAspect:o=>o.viewportWidth/o.viewportHeight,uColor:e.prop("color")},primitive:"triangles",instances:(o,t)=>t.count-1,count:9})}},inputs:[],outputs:void 0,output:"createDrawArrowsCommand",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-7657"),expanded:[],variables:[]},{id:7657,body:function(){return function(e,o,t){let r=Math.pow(o[0]*o[0]+o[1]*o[1],.5*t);return e[0]=o[0]/(1+r),e[1]=o[1]/(1+r),e[2]=o[2],e}},inputs:[],outputs:void 0,output:"computeFisheye",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-8105"),expanded:[],variables:[]},{id:8105,body:async(d,a)=>{const{createDrawBorderedLineCommand:e,createDrawLineCommand:o}=await oe(()=>import("https://api.observablehq.com/@rreusser/quick-miterless-lines-in-webgl.js?v=4"),[]).then(t=>{const r={},n=d.module(t.default),s=d.module();if(!n.defines("createDrawBorderedLineCommand"))throw new SyntaxError("export 'createDrawBorderedLineCommand' not found");if(s.variable(r.createDrawBorderedLineCommand=a()).import("createDrawBorderedLineCommand",n),!n.defines("createDrawLineCommand"))throw new SyntaxError("export 'createDrawLineCommand' not found");return s.variable(r.createDrawLineCommand=a()).import("createDrawLineCommand",n),r});return{createDrawBorderedLineCommand:e,createDrawLineCommand:o}},inputs:["__ojs_runtime","__ojs_observer"],outputs:["createDrawBorderedLineCommand","createDrawLineCommand"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});S({root:document.getElementById("cell-1735"),expanded:[],variables:[]},{id:1735,body:async(d,a)=>{const{binarySearch:e,decodeHash:o,isThumbnailDaemon:t,floatRgbToHex:r,arrowhead:n,hexRgbToFloat:s}=await oe(()=>import("https://api.observablehq.com/@rreusser/utils.js?v=4"),[]).then(c=>{const b={},l=d.module(c.default),u=d.module();if(!l.defines("binarySearch"))throw new SyntaxError("export 'binarySearch' not found");if(u.variable(b.binarySearch=a()).import("binarySearch",l),!l.defines("decodeHash"))throw new SyntaxError("export 'decodeHash' not found");if(u.variable(b.decodeHash=a()).import("decodeHash",l),!l.defines("isThumbnailDaemon"))throw new SyntaxError("export 'isThumbnailDaemon' not found");if(u.variable(b.isThumbnailDaemon=a()).import("isThumbnailDaemon",l),!l.defines("floatRgbToHex"))throw new SyntaxError("export 'floatRgbToHex' not found");if(u.variable(b.floatRgbToHex=a()).import("floatRgbToHex",l),!l.defines("arrowhead"))throw new SyntaxError("export 'arrowhead' not found");if(u.variable(b.arrowhead=a()).import("arrowhead",l),!l.defines("hexRgbToFloat"))throw new SyntaxError("export 'hexRgbToFloat' not found");return u.variable(b.hexRgbToFloat=a()).import("hexRgbToFloat",l),b});return{binarySearch:e,decodeHash:o,isThumbnailDaemon:t,floatRgbToHex:r,arrowhead:n,hexRgbToFloat:s}},inputs:["__ojs_runtime","__ojs_observer"],outputs:["binarySearch","decodeHash","isThumbnailDaemon","floatRgbToHex","arrowhead","hexRgbToFloat"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});S({root:document.getElementById("cell-1928"),expanded:[],variables:[]},{id:1928,body:function(a){return a<=640},inputs:["width"],outputs:void 0,output:"isNarrowScreen",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});S({root:document.getElementById("cell-7794"),expanded:[],variables:[]},{id:7794,body:async(d,a)=>{const{checkbox:e}=await oe(()=>import("https://api.observablehq.com/@jashkenas/inputs.js?v=4"),[]).then(o=>{const t={},r=d.module(o.default),n=d.module();if(!r.defines("checkbox"))throw new SyntaxError("export 'checkbox' not found");return n.variable(t.checkbox=a()).import("checkbox",r),t});return{checkbox:e}},inputs:["__ojs_runtime","__ojs_observer"],outputs:["checkbox"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});S({root:document.getElementById("cell-2282"),expanded:[],variables:[]},{id:2282,body:function(d){return d`<style>
.observablehq .katex,
.observablehq .katex-display>.katex {
  font-size: 1.08em;
}

.observablehq svg.draggable,
.observablehq svg .draggable {
  cursor: grab;
}
.observablehq .katex-display {
  overflow: visible;
}
.observablehq svg.draggable:active,
.observablehq svg .draggable:active {
  cursor: grabbing;
}
.observablehq p > img {
  margin-left: auto;
  margin-right: auto;
  display: block;
}
.observablehq blockquote {
  border-left: 5px solid #ddd;
  padding-left: 15px;
}
.observablehq dl.inline-flex {
  max-width: 640px;
  display: flex;
  flex-flow: row;
  flex-wrap: wrap;
  overflow: visible;
}
.observablehq dl.inline-flex dt {
  flex: 0 0 25%;
  min-width: 130px;
  text-overflow: ellipsis;
  overflow: hidden;
  font-weight: 600;
  margin: 0;
}
.observablehq dl.inline-flex dd {
  flex: 0 0 75%;
  text-align: left;
  text-overflow: ellipsis;
  overflow: hidden;
  margin: 0 0 0 auto;
}
.observablehq .form-compact input {
  max-width: 60%;
}
.observablehq figcaption {
  max-width: 400px;
  margin-left: auto;
  margin-top: 1em;
  margin-right: auto;
  color: black;
  font-size: 0.9em;
  font-family: serif;
}
.observablehq figcaption:before {
  color: black;
  font-family: serif;
  font-weight: 600;
  content: "Figure: ";
}
.observablehq figure {
  box-sizing: border-box;
}
.observablehq figure {
  padding: 15px 0;
  box-sizing: border-box;
  max-width: 640px;
  text-align: center;
}
.observablehq .field {
  margin: 0.5em 0;
}
.observablehq summary {
  cursor: pointer;
}
.observablehq h2 {
  padding-top: 1em;
}

.observablehq figure {
  padding-top: 1em;
  padding-bottom: 1em;
}

@media (max-width: 590px) {
  .observablehq dl.inline-flex dd {
    flex: 0 0 95%;
  }
  .observablehq dl.inline-flex dt {
    flex: 0 0 100%;
  }
}
</style>`},inputs:["html"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});
