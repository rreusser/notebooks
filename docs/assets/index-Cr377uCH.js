const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/pipeline-DxRJQbw7.js","assets/fft-Chkx7JT6.js","assets/turing-simulation-DIW3QSOj.js","assets/turing-2d-D4E14fju.js","assets/turing-2scale-DnJKUYHC.js"])))=>i.map(i=>d[i]);
import{d as g,_ as Y}from"./index-ByB2dbry.js";g({root:document.getElementById("cell-2"),expanded:[],variables:[]},{id:2,body:(t,e)=>{navigator.gpu||t(e`<div style="color: red; padding: 20px; border: 1px solid red; background: #fff0f0; border-radius: 4px;">
    <strong>WebGPU is not available</strong><br>
    Please use a browser that supports WebGPU (Chrome 113+, Edge 113+, or Firefox with flags enabled).
  </div>`)},inputs:["display","html"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-3"),expanded:[],variables:[]},{id:3,body:async()=>{const[{createWebGPUContext:t,isWebGPUAvailable:e},{createTuringPipelines:i},{createVec4FFTPipelines:f},{createElementStack:a},{createZoomableAxes:l},{expandable:s},{createScaleParamsInput:u,createTuringSimulation:o}]=await Promise.all([Y(()=>import("./webgpu-canvas-C7AS78hn.js"),[]).then(p=>{if(!("createWebGPUContext"in p))throw new SyntaxError("export 'createWebGPUContext' not found");if(!("isWebGPUAvailable"in p))throw new SyntaxError("export 'isWebGPUAvailable' not found");return p}),Y(()=>import("./pipeline-DxRJQbw7.js"),__vite__mapDeps([0,1])).then(p=>{if(!("createTuringPipelines"in p))throw new SyntaxError("export 'createTuringPipelines' not found");return p}),Y(()=>import("./fft-Chkx7JT6.js"),[]).then(p=>{if(!("createVec4FFTPipelines"in p))throw new SyntaxError("export 'createVec4FFTPipelines' not found");return p}),Y(()=>import("./element-stack-BU40TvN2.js"),[]).then(p=>{if(!("createElementStack"in p))throw new SyntaxError("export 'createElementStack' not found");return p}),Y(()=>import("./zoomable-axes-BfGyq1bg.js"),[]).then(p=>{if(!("createZoomableAxes"in p))throw new SyntaxError("export 'createZoomableAxes' not found");return p}),Y(()=>import("./expandable-dZkDG0zz.js"),[]).then(p=>{if(!("expandable"in p))throw new SyntaxError("export 'expandable' not found");return p}),Y(()=>import("./turing-simulation-DIW3QSOj.js"),__vite__mapDeps([2,1])).then(p=>{if(!("createScaleParamsInput"in p))throw new SyntaxError("export 'createScaleParamsInput' not found");if(!("createTuringSimulation"in p))throw new SyntaxError("export 'createTuringSimulation' not found");return p})]);return{createWebGPUContext:t,isWebGPUAvailable:e,createTuringPipelines:i,createVec4FFTPipelines:f,createElementStack:a,createZoomableAxes:l,expandable:s,createScaleParamsInput:u,createTuringSimulation:o}},inputs:[],outputs:["createWebGPUContext","isWebGPUAvailable","createTuringPipelines","createVec4FFTPipelines","createElementStack","createZoomableAxes","expandable","createScaleParamsInput","createTuringSimulation"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-4"),expanded:[],variables:[]},{id:4,body:async(t,e)=>{const{device:i,canvasFormat:f,features:a}=await t({optionalFeatures:["shader-f16","timestamp-query"],maxBufferSizes:!0}),l=a.has("shader-f16")?"f16":"f32";return e.then(()=>i.destroy()),{device:i,canvasFormat:f,features:a,detectedPrecision:l}},inputs:["createWebGPUContext","invalidation"],outputs:["device","canvasFormat","features","detectedPrecision"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-5"),expanded:[],variables:[]},{id:5,body:(t,e,i)=>{const f=t==="f16"?["f16","f32"]:["f32"],a=e.radio(f,{label:"Precision",value:t}),l=i(a);return{precisionOptions:f,precisionInput:a,precisionValue:l}},inputs:["detectedPrecision","Inputs","view"],outputs:["precisionOptions","precisionInput","precisionValue"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-6"),expanded:[],variables:[]},{id:6,body:(t,e)=>{const i=t??e;return{precision:i,bytesPerFloat:i==="f16"?2:4}},inputs:["precisionValue","detectedPrecision"],outputs:["precision","bytesPerFloat"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-7"),expanded:[],variables:[]},{id:7,body:t=>({N:parseInt(t.split("×")[0])}),inputs:["NString"],outputs:["N"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-8"),expanded:[],variables:[]},{id:8,body:()=>({gridSizeState:{N:512},referenceN:512}),inputs:[],outputs:["gridSizeState","referenceN"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-9"),expanded:[],variables:[]},{id:9,body:()=>({expandableState:{expanded:!1}}),inputs:[],outputs:["expandableState"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-10"),expanded:[],variables:[]},{id:10,body:(t,e)=>{e.N=t},inputs:["N","gridSizeState"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-11"),expanded:[],variables:[]},{id:11,body:(t,e,i,f)=>{const a=t.range([1,8],{value:4,step:1,label:"Number of scales"}),l=e(a);return i(f`<div id="turing-num-scales">${a}</div>`),{numScalesInput:a,numScalesValue:l}},inputs:["Inputs","view","display","html"],outputs:["numScalesInput","numScalesValue"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-12"),expanded:[],variables:[]},{id:12,body:t=>({numScales:Math.round(t??1)}),inputs:["numScalesValue"],outputs:["numScales"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-13"),expanded:[],variables:[]},{id:13,body:(t,e,i,f,a,l)=>{const s=[],u=e(t,i,s),o=f(u);return a(l`<div id="turing-scale-params">${u}</div>`),{existingScaleParams:s,scaleParamsInput:u,scaleParamsValue:o}},inputs:["numScales","createScaleParamsInput","gridSizeState","view","display","html"],outputs:["existingScaleParams","scaleParamsInput","scaleParamsValue"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-14"),expanded:[],variables:[]},{id:14,body:t=>({scaleParams:t??[{activatorRadius:2,inhibitorRatio:2,kernelType:0,amount:.05,weight:1,symmetry:1,color:[.33,.53,.8]}]}),inputs:["scaleParamsValue"],outputs:["scaleParams"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-15"),expanded:[],variables:[]},{id:15,body:(t,e,i,f,a)=>{const l=document.createElement("button");l.textContent="Randomize",l.style.cssText="padding: 4px 8px; cursor: pointer; font-size: 12px;",l.onclick=()=>{const o=document.querySelector("#turing-scale-params .scale-params-container");o?.randomize&&o.randomize()};const s=document.createElement("button");return s.id="turing-download-btn",s.textContent="Download PNG",s.style.cssText="padding: 4px 8px; cursor: pointer; font-size: 12px;",s.onclick=()=>{s._download&&s._download()},t.style.cssText="padding: 4px 8px; cursor: pointer; font-size: 12px;",e(i`<div id="turing-button-row" style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
  ${l}
  ${t}
  ${s}
  ${f}
  ${a}
</div>`),{randomizeBtn:l,downloadBtn:s,downloadButton:s}},inputs:["restartButton","display","html","simulateInput","symmetryInput"],outputs:["randomizeBtn","downloadBtn","downloadButton"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-16"),expanded:[],variables:[]},{id:16,body:t=>{const e=document.querySelector("#turing-scale-params .scale-params-container");return e&&e.classList.toggle("symmetry-hidden",!t),{container:e}},inputs:["symmetryEnabled"],outputs:["container"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-17"),expanded:[],variables:[]},{id:17,body:(t,e,i,f,a,l,s,u,o,p)=>{const d=i`<figure style="margin: 0;">${t.element}</figure>`;return f(a(d,{width:Math.min(l,640),height:Math.min(l,640),toggleOffset:[-15,-16],controls:["#turing-num-scales","#turing-scale-params","#turing-button-row","#turing-sim-controls","#turing-display-controls"],state:s,onResize(r,n,c){t.resize(n,c),e.updateScales(u.scaleLinear().domain([0,o]).range([0,n]),u.scaleLinear().domain([0,o]).range([c,0])),p.dirty=!0}})),{figure:d}},inputs:["stack","axes","html","display","expandable","width","expandableState","d3","referenceN","simState"],outputs:["figure"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-18"),expanded:[],variables:[]},{id:18,body:(t,e)=>{const i=t`<div id="turing-status" style="font-family: monospace; font-size: 12px; color: #666;">Initializing...</div>`;return e(i),{statusEl:i}},inputs:["html","display"],outputs:["statusEl"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-19"),expanded:[],variables:[]},{id:19,body:(t,e,i)=>{const f=t.limits.maxComputeWorkgroupSizeX,a=[256,512,1024,2048,4096],l=a.filter(d=>{if(d<=f)return!0;const n=d/f;return Number.isInteger(n)&&(n&n-1)===0}),s=l.map(d=>`${d}×${d}`),u=512,o=e.select(s,{value:`${u}×${u}`,label:"Grid size"}),p=i(o);return{maxWorkgroupSize:f,allSizes:a,validSizes:l,gridSizeOptions:s,defaultN:u,NInput:o,NString:p}},inputs:["device","Inputs","view"],outputs:["maxWorkgroupSize","allSizes","validSizes","gridSizeOptions","defaultN","NInput","NString"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-20"),expanded:[],variables:[]},{id:20,body:t=>{const e=document.createElement("label");e.style.cssText="display: flex; align-items: center; gap: 4px; cursor: pointer; font-size: 12px;";const i=document.createElement("input");i.type="checkbox",i.checked=!0,e.appendChild(i),e.appendChild(document.createTextNode("Simulate")),e.value=!0,i.onchange=()=>{e.value=i.checked,e.dispatchEvent(new CustomEvent("input"))};const f=t(e),a=document.createElement("label");a.style.cssText="display: flex; align-items: center; gap: 4px; cursor: pointer; font-size: 12px;";const l=document.createElement("input");l.type="checkbox",l.checked=!1,a.appendChild(l),a.appendChild(document.createTextNode("Symmetry")),a.value=!1,l.onchange=()=>{a.value=l.checked,a.dispatchEvent(new CustomEvent("input"))};const s=t(a);return{simulateContainer:e,simulateCheckbox:i,simulateValue:f,symmetryContainer:a,symmetryCheckbox:l,symmetryEnabledValue:s,simulateInput:e,symmetryInput:a}},inputs:["view"],outputs:["simulateContainer","simulateCheckbox","simulateValue","symmetryContainer","symmetryCheckbox","symmetryEnabledValue","simulateInput","symmetryInput"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-21"),expanded:[],variables:[]},{id:21,body:()=>({symmetryState:{enabled:!1}}),inputs:[],outputs:["symmetryState"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-22"),expanded:[],variables:[]},{id:22,body:(t,e,i)=>{const f=t??!0,a=e??!1;return i.enabled=a,{simulate:f,symmetryEnabled:a}},inputs:["simulateValue","symmetryEnabledValue","symmetryState"],outputs:["simulate","symmetryEnabled"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-23"),expanded:[],variables:[]},{id:23,body:(t,e)=>{e.dirty=!0},inputs:["symmetryEnabled","simState"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-24"),expanded:[],variables:[]},{id:24,body:(t,e,i,f,a,l)=>{const s=document.createElement("button");s.textContent="Restart",s.style.cssText="padding: 4px 12px; cursor: pointer; font-size: 12px;";let u=0;s.value=u,s.onclick=()=>{s.value=++u,s.dispatchEvent(new CustomEvent("input"))};const o=t(s),p=e.range([.01,1],{value:.2,step:.01,label:"Step size"}),d=t(p),r=e.range([.001,.1],{value:.02,step:.001,label:"Color rate"}),n=t(r),c=e.range([1,20],{value:1,step:1,label:"Steps per frame"}),P=t(c);return i(f`<div id="turing-sim-controls">
  <details class="sim-config-details" open>
    <summary style="cursor: pointer; font-size: 12px;">Simulation config</summary>
    <div style="padding-left: 8px;">
      <div id="turing-grid-size">${a}</div>
      <div id="turing-precision">${l}</div>
      ${p}
      ${r}
      ${c}
    </div>
  </details>
</div>`),{restartBtn:s,restartCount:u,restart:o,stepSizeInput:p,stepSizeValue:d,colorRateInput:r,colorRateValue:n,stepsPerFrameInput:c,stepsPerFrameValue:P,restartButton:s}},inputs:["view","Inputs","display","html","NInput","precisionInput"],outputs:["restartBtn","restartCount","restart","stepSizeInput","stepSizeValue","colorRateInput","colorRateValue","stepsPerFrameInput","stepsPerFrameValue","restartButton"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-25"),expanded:[],variables:[]},{id:25,body:(t,e,i)=>{const f=t??.02,a=e??.01,l=Math.round(i??5);return{stepSize:f,colorRate:a,stepsPerFrame:l}},inputs:["stepSizeValue","colorRateValue","stepsPerFrameValue"],outputs:["stepSize","colorRate","stepsPerFrame"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-26"),expanded:[],variables:[]},{id:26,body:(t,e,i,f)=>{const a=t.range([0,.99],{value:.5,step:.01,label:"Contrast"}),l=e(a),s=t.range([-2,2],{value:-1,step:.1,label:"Brightness"}),u=e(s),o=t.range([.2,3],{value:1,step:.1,label:"Gamma"}),p=e(o),d=t.range([0,4],{value:1,step:.1,label:"Color strength"}),r=e(d),n=t.toggle({label:"Invert",value:!1}),c=e(n);return i(f`<div id="turing-display-controls">
  <details class="display-config-details">
    <summary style="cursor: pointer; font-size: 12px; margin-bottom: 8px;">Display config</summary>
    <div style="padding-left: 8px;">
      ${a}
      ${s}
      ${o}
      ${d}
      ${n}
    </div>
  </details>
</div>`),{contrastInput:a,contrastValue:l,brightnessInput:s,brightnessValue:u,gammaInput:o,gammaValue:p,colorStrengthInput:d,colorStrengthValue:r,invertInput:n,invertValue:c}},inputs:["Inputs","view","display","html"],outputs:["contrastInput","contrastValue","brightnessInput","brightnessValue","gammaInput","gammaValue","colorStrengthInput","colorStrengthValue","invertInput","invertValue"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-27"),expanded:[],variables:[]},{id:27,body:(t,e,i,f,a)=>({contrast:t??.5,brightness:e??0,gamma:i??1,colorStrength:f??.5,invert:a??!1}),inputs:["contrastValue","brightnessValue","gammaValue","colorStrengthValue","invertValue"],outputs:["contrast","brightness","gamma","colorStrength","invert"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-28"),expanded:[],variables:[]},{id:28,body:(t,e,i,f,a,l,s,u,o)=>{const p=t*t*4*a,d=t*t*2*a,r=s.STORAGE|s.COPY_SRC|s.COPY_DST;let n=0;const c=[u.createBuffer({label:"Solution 0",size:p,usage:r}),u.createBuffer({label:"Solution 1",size:p,usage:r})];n+=p*2;const P=u.createBuffer({label:"fhat",size:d,usage:r}),F=u.createBuffer({label:"fhat_freq",size:d,usage:r});n+=d*2;const m=[u.createBuffer({label:"FFT temp 0",size:d,usage:r}),u.createBuffer({label:"FFT temp 1",size:d,usage:r})];n+=d*2;const v=t*t*4*a,B=u.createBuffer({label:"Vec4 FFT work",size:v,usage:r|s.COPY_DST|s.COPY_SRC}),h=[u.createBuffer({label:"Vec4 FFT temp 0",size:v,usage:r}),u.createBuffer({label:"Vec4 FFT temp 1",size:v,usage:r})];n+=v*3;const L=o(u,t,u.limits.maxComputeWorkgroupSizeX,l),S=Math.ceil(e/2),z=S*t*t*4*a,I=u.createBuffer({label:"Activator/Inhibitor",size:z,usage:r});n+=z;const V=u.createBuffer({label:"Init params",size:16,usage:s.UNIFORM|s.COPY_DST}),w=u.createBuffer({label:"Extract params",size:16,usage:s.UNIFORM|s.COPY_DST}),R=u.createBuffer({label:"Convolve params",size:48,usage:s.UNIFORM|s.COPY_DST}),G=u.createBuffer({label:"Update params",size:32,usage:s.UNIFORM|s.COPY_DST}),W=e*32,A=u.createBuffer({label:"Scale params",size:W,usage:s.STORAGE|s.COPY_DST});n+=W;const b=u.createBuffer({label:"Visualize params",size:40,usage:s.UNIFORM|s.COPY_DST});n+=40;const E=u.createBuffer({label:"View inverse",size:64,usage:s.UNIFORM|s.COPY_DST});n+=64,n+=112;const k=C=>C>=1024*1024*1024?(C/(1024*1024*1024)).toFixed(2)+" GB":C>=1024*1024?(C/(1024*1024)).toFixed(2)+" MB":C>=1024?(C/1024).toFixed(2)+" KB":C+" B",M={total:n,formatted:k(n),precision:l};return{solutionSize:p,complexSize:d,bufferUsage:r,totalGPUMemory:n,solution:c,fhat:P,fhatFreq:F,fftTemp:m,vec4Size:v,vec4FftWork:B,vec4FftTemp:h,vec4FftPipelines:L,numScalePairs:S,aiSize:z,activatorInhibitor:I,initParamsBuffer:V,extractParamsBuffer:w,convolveParamsBuffer:R,updateParamsBuffer:G,scaleParamsSize:W,scaleParamsBuffer:A,visualizeParamsBuffer:b,viewInverseBuffer:E,formatBytes:k,memoryInfo:M}},inputs:["N","numScales","restart","scaleParams","bytesPerFloat","precision","GPUBufferUsage","device","createVec4FFTPipelines"],outputs:["solutionSize","complexSize","bufferUsage","totalGPUMemory","solution","fhat","fhatFreq","fftTemp","vec4Size","vec4FftWork","vec4FftTemp","vec4FftPipelines","numScalePairs","aiSize","activatorInhibitor","initParamsBuffer","extractParamsBuffer","convolveParamsBuffer","updateParamsBuffer","scaleParamsSize","scaleParamsBuffer","visualizeParamsBuffer","viewInverseBuffer","formatBytes","memoryInfo"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-29"),expanded:[],variables:[]},{id:29,body:async(t,e,i,f,a)=>({pipelines:await i(f,a,t,e)}),inputs:["N","precision","createTuringPipelines","device","canvasFormat"],outputs:["pipelines"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-30"),expanded:[],variables:[]},{id:30,body:(t,e,i,f,a,l)=>{const s=window.devicePixelRatio||1;function u(d,r){const n=Math.round(d*s),c=Math.round(r*s);(t.width!==n||t.height!==c)&&(t.width=n,t.height=c,e.configure({device:i,format:f,alphaMode:"opaque"})),t.style.width=`${d}px`,t.style.height=`${r}px`}const o=Math.min(a,640);u(o,o);const p=l({width:o,height:o,layers:[{id:"canvas",element:({current:d,width:r,height:n})=>(u(r,n),t)}]});return{dpr:s,resizeCanvas:u,initialSize:o,stack:p}},inputs:["canvas","ctx","device","canvasFormat","width","createElementStack"],outputs:["dpr","resizeCanvas","initialSize","stack"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-31"),expanded:[],variables:[]},{id:31,body:(t,e)=>{const i=document.createElement("canvas");i.id="turing-canvas";const f=i.getContext("webgpu");return i.width=1,i.height=1,f.configure({device:t,format:e,alphaMode:"opaque"}),{canvas:i,ctx:f}},inputs:["device","canvasFormat"],outputs:["canvas","ctx"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-32"),expanded:[],variables:[]},{id:32,body:(t,e,i,f,a,l)=>{const s=Math.floor(Math.random()*4294967295),u=new Uint32Array([t,t,s,0]);l.queue.writeBuffer(f,0,u);const o=l.createBindGroup({label:"Initialize bind group",layout:a.bindGroupLayouts.initialize,entries:[{binding:0,resource:{buffer:i[0]}},{binding:1,resource:{buffer:f}}]}),p=l.createCommandEncoder({label:"Initialize encoder"}),d=p.beginComputePass({label:"Initialize pass"});d.setPipeline(a.initialize),d.setBindGroup(0,o),d.dispatchWorkgroups(Math.ceil(t/16),Math.ceil(t/16),1),d.end(),l.queue.submit([p.finish()]);const r=l.createBindGroup({label:"Initialize bind group 2",layout:a.bindGroupLayouts.initialize,entries:[{binding:0,resource:{buffer:i[1]}},{binding:1,resource:{buffer:f}}]}),n=l.createCommandEncoder({label:"Initialize encoder 2"}),c=n.beginComputePass({label:"Initialize pass 2"});return c.setPipeline(a.initialize),c.setBindGroup(0,r),c.dispatchWorkgroups(Math.ceil(t/16),Math.ceil(t/16),1),c.end(),l.queue.submit([n.finish()]),{randomSeed:s,initParams:u,initBindGroup:o,initEncoder:p,initPass:d,init2BindGroup:r,init2Encoder:n,init2Pass:c}},inputs:["N","restart","solution","initParamsBuffer","pipelines","device"],outputs:["randomSeed","initParams","initBindGroup","initEncoder","initPass","init2BindGroup","init2Encoder","init2Pass"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-33"),expanded:[],variables:[]},{id:33,body:()=>({simState:{dirty:!0,solutionIndex:0,iteration:0}}),inputs:[],outputs:["simState"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-34"),expanded:[],variables:[]},{id:34,body:(t,e,i)=>{i.dirty=!0,i.solutionIndex=0,i.iteration=0},inputs:["restart","scaleParams","simState"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-35"),expanded:[],variables:[]},{id:35,body:(t,e,i,f,a)=>{const l=e({d3:i,element:t.element,xScale:i.scaleLinear().domain([0,f]).range([0,t.width]),yScale:i.scaleLinear().domain([0,f]).range([t.height,0]),aspectRatio:1,scaleExtent:[.02,20],onChange:()=>{a.dirty=!0}});return t.addEventListener("update",()=>{a.dirty=!0}),{axes:l}},inputs:["stack","createZoomableAxes","d3","referenceN","simState"],outputs:["axes"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-36"),expanded:[],variables:[]},{id:36,body:(t,e,i,f,a,l,s,u,o,p,d,r,n,c,P,F,m,v,B,h,L,S,z,I,V,w,R,G,W,A,b,E,k,M,C,y,_,q,x,T)=>{const $=_({device:t,canvasFormat:q,ctx:e,canvas:i,pipelines:l,N:f,numScales:a,bytesPerFloat:s,referenceN:x,solution:u,fhat:o,fhatFreq:p,fftTemp:d,vec4FftWork:n,vec4FftTemp:c,vec4FftPipelines:P,activatorInhibitor:r,extractParamsBuffer:F,convolveParamsBuffer:m,updateParamsBuffer:v,scaleParamsBuffer:B,visualizeParamsBuffer:h,viewInverseBuffer:L,simState:I,symmetryState:w,statusEl:V,memoryInfo:y,axes:z,scaleParams:S,stepSize:R,colorRate:G,stepsPerFrame:W,simulate:A,contrast:b,brightness:E,gamma:k,colorStrength:M,invert:C}),O=document.querySelector("#turing-download-btn");return O&&(O._download=()=>$.downloadPNG()),T.then(()=>$.dispose()),{simulation:$,downloadBtnEl:O}},inputs:["device","ctx","canvas","N","numScales","pipelines","bytesPerFloat","solution","fhat","fhatFreq","fftTemp","activatorInhibitor","vec4FftWork","vec4FftTemp","vec4FftPipelines","extractParamsBuffer","convolveParamsBuffer","updateParamsBuffer","scaleParamsBuffer","visualizeParamsBuffer","viewInverseBuffer","scaleParams","axes","simState","statusEl","symmetryState","stepSize","colorRate","stepsPerFrame","simulate","contrast","brightness","gamma","colorStrength","invert","memoryInfo","createTuringSimulation","canvasFormat","referenceN","invalidation"],outputs:["simulation","downloadBtnEl"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-38"),expanded:[],variables:[]},{id:38,body:(t,e)=>t`### The Gray-Scott Model

Reaction-diffusion can mean a lot of things. The first model I learned about--or really learned *of*, to be more precise--is the Gray-Scott model. The Gray-Scott model describes a chemical reaction between substances ${e`u`} and ${e`v`} which diffuse in space at different rates and react, producing an interesting landscape of complicated behaviors.

${e.block`\frac{\partial u}{\partial t} = D_u \nabla^2 u - uv^2 + f(1-u)`}
${e.block`\frac{\partial v}{\partial t} = D_v \nabla^2 v + uv^2 - (f+k)v`}

In these equations, ${e`D_u`} and ${e`D_v`} are diffusion coefficients, ${e`f`} is the feed rate, and ${e`k`} is the kill rate. 

I've been a long-term fan, in particular because the Gray-Scott model is unusually forgiving to simulate. Second order finite differences for diffusion and explicit Euler time-stepping are perfectly adequate.

John Pearson's 1993 paper ["Complex Patterns in a Simple System"](https://arxiv.org/abs/patt-sol/9304003) maps out the parameter space and documents a remarkable variety of behaviors including self-replicating spots, traveling waves, and labyrinthine patterns. [Karl Sims has a nice tutorial](https://www.karlsims.com/rd.html) which discusses the dynamics. Below, in that style, I've implemented a simple two-dimensional version of the above PDE.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});g({root:document.getElementById("cell-39"),expanded:[],variables:[]},{id:39,body:async(t,e,i)=>{const[{default:f},{reglCanvas:a},{createGrayScott2D:l}]=await Promise.all([Y(()=>import("https://cdn.jsdelivr.net/npm/regl@2.1.1/+esm"),[]).then(m=>{if(!("default"in m))throw new SyntaxError("export 'default' not found");return m}),Y(()=>import("./regl-canvas-4j8SAjSv.js"),[]).then(m=>{if(!("reglCanvas"in m))throw new SyntaxError("export 'reglCanvas' not found");return m}),Y(()=>import("./gray-scott-2d-BcbhI6kV.js"),[]).then(m=>{if(!("createGrayScott2D"in m))throw new SyntaxError("export 'createGrayScott2D' not found");return m})]),s=256,u=s/2,o=a(f,{extensions:["OES_texture_float"],attributes:{preserveDrawingBuffer:!0},pixelRatio:1}),p=o.value;o.width=s,o.height=u,o.style.border="1px solid #ccc",o.style.width="512px",o.style.maxWidth="100%",o.style.height="auto",o.style.aspectRatio="2 / 1",o.style.cursor="pointer",o.style.boxSizing="border-box";const d=l(p,{width:s,height:u});d.restart();function r(m){const v=o.getBoundingClientRect();return[(m.clientX-v.left)/v.width,1-(m.clientY-v.top)/v.height]}function n(m){const v=o.getBoundingClientRect(),B=m.touches[0];return[(B.clientX-v.left)/v.width,1-(B.clientY-v.top)/v.height]}o.addEventListener("mousedown",m=>d.setMouse(r(m))),o.addEventListener("mousemove",m=>{m.buttons&1&&d.setMouse(r(m))}),o.addEventListener("mouseup",()=>d.setMouse(null)),o.addEventListener("mouseleave",()=>d.setMouse(null)),o.addEventListener("touchstart",m=>{m.preventDefault(),d.setMouse(n(m))},{passive:!1}),o.addEventListener("touchmove",m=>{m.preventDefault(),d.setMouse(n(m))},{passive:!1}),o.addEventListener("touchend",()=>d.setMouse(null)),o.addEventListener("touchcancel",()=>d.setMouse(null));const c=p.frame(()=>{for(let m=0;m<10;m++)d.step();d.render()});t.then(()=>c.cancel());const P=e`<button>Restart</button>`;P.onclick=()=>d.restart(),P.style.position="absolute",P.style.right="10px",P.style.bottom="10px";const F=e`<figure id="gray-scott-2d-figure" style="overflow: hidden;">
  <div style="position:relative">
    ${o}
    ${P}
  </div>
  <figcaption>2D Gray-Scott reaction-diffusion. Click and drag to paint.</figcaption>
</figure>`;return i(F),{createREGL:f,reglCanvas:a,createGrayScott2D:l,w:s,h:u,canvas2d:o,regl:p,gsSim:d,getMouseUV:r,getTouchUV:n,loop:c,gsRestartBtn:P,gsFigure:F}},inputs:["invalidation","html","display"],outputs:["createREGL","reglCanvas","createGrayScott2D","w","h","canvas2d","regl","gsSim","getMouseUV","getTouchUV","loop","gsRestartBtn","gsFigure"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-40"),expanded:[],variables:[]},{id:40,body:()=>({gsParams:{k:.062,f:.055}}),inputs:[],outputs:["gsParams"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-41"),expanded:[],variables:[]},{id:41,body:(t,e,i,f,a,l)=>{const u=[0,.08],o=[0,.14],p=340,d=280,r=50,n=40,c=25,P=10,F=[];for(let b=0;b<=100;b++){const E=b/100*.0625,k=1-16*E;if(k>=0){const M=Math.pow(1+Math.sqrt(k),2)/16;F.push({k:E,f:M})}}for(let b=100;b>=0;b--){const E=b/100*.0625,k=1-16*E;if(k>=0){const M=Math.pow(1-Math.sqrt(k),2)/16;F.push({k:E,f:M})}}const m=[],v=.015;for(let b=0;b<=100;b++){const E=v+b/100*(.0625-v),k=1-4*Math.sqrt(E);if(k>=0){const M=(1-Math.sqrt(k))/2,C=M*E/(1-M),y=1-16*E;if(y>=0&&C>0){const _=Math.pow(1+Math.sqrt(y),2)/16,q=Math.pow(1-Math.sqrt(y),2)/16;C>q&&C<_&&m.push({k:E,f:C})}}}const B=e.scaleLinear().domain(u).range([r,p-P]),h=e.scaleLinear().domain(o).range([d-n,c]),L=i.plot({width:p,height:d,marginLeft:r,marginBottom:n,marginTop:c,marginRight:P,x:{label:"k (kill rate)",domain:u},y:{label:"f (feed rate)",domain:o},marks:[i.line(F,{x:"k",y:"f",stroke:"#333",strokeWidth:2}),i.line(m,{x:"k",y:"f",stroke:"#333",strokeWidth:1.5,strokeDasharray:"4,3"}),i.text([{k:.035,f:.023,text:`Pattern
formation`}],{x:"k",y:"f",text:"text",fontSize:10,fill:"#666",lineAnchor:"middle",textAnchor:"middle"})]}),S=f`<div id="phase-diagram-container" style="position: relative; width: ${p}px; height: ${d}px;">`;S.appendChild(L);const z=document.createElementNS("http://www.w3.org/2000/svg","svg");z.setAttribute("width",p),z.setAttribute("height",d),z.style.position="absolute",z.style.top="0",z.style.left="0",z.style.pointerEvents="none";const I=document.createElementNS("http://www.w3.org/2000/svg","circle");I.setAttribute("r","7"),I.setAttribute("fill","#e63946"),I.setAttribute("stroke","rgba(255,0,0,0.2)"),I.setAttribute("stroke-width","20"),I.style.cursor="grab",I.style.pointerEvents="auto",z.appendChild(I),S.appendChild(z);function V(){I.setAttribute("cx",B(a.k)),I.setAttribute("cy",h(a.f))}V();let w=!1;function R(b,E,k){return Math.max(E,Math.min(k,b))}function G(b,E){const k=S.getBoundingClientRect(),M=b-k.left,C=E-k.top;a.k=R(B.invert(M),.001,.079),a.f=R(h.invert(C),.001,.139),V(),t.setParams(a.f,a.k)}I.addEventListener("mousedown",b=>{w=!0,I.style.cursor="grabbing",b.preventDefault()}),document.addEventListener("mousemove",b=>{w&&G(b.clientX,b.clientY)}),document.addEventListener("mouseup",()=>{w&&(w=!1,I.style.cursor="grab")}),I.addEventListener("touchstart",b=>{w=!0,b.preventDefault()},{passive:!1}),document.addEventListener("touchmove",b=>{w&&b.touches.length>0&&G(b.touches[0].clientX,b.touches[0].clientY)},{passive:!1}),document.addEventListener("touchend",()=>{w=!1});const W=f`<div id="gs-param-display" style="font-family: monospace; font-size: 11px; color: #666; margin-top: 4px;">
  k = ${a.k.toFixed(4)}, f = ${a.f.toFixed(4)}
</div>`;function A(){W.textContent=`k = ${a.k.toFixed(4)}, f = ${a.f.toFixed(4)}`,requestAnimationFrame(A)}return A(),l(f`<figure id="gray-scott-phase-figure" style="max-width: ${p}px;">
  ${S}
  ${W}
  <figcaption style="font-size: 11px;">Phase diagram. Drag the red dot to change parameters. Inside the curve: patterns form.</figcaption>
</figure>`),{nPoints:100,kDomain:u,fDomain:o,plotWidth:p,plotHeight:d,marginLeft:r,marginBottom:n,marginTop:c,marginRight:P,saddleNodeCurve:F,hopfCurve:m,kMin:v,xScale:B,yScale:h,basePlot:L,container:S,dotSvg:z,dot:I,updateDotPosition:V,isDragging:w,clamp:R,updateFromPosition:G,paramDisplay:W,updateDisplay:A}},inputs:["gsSim","d3","Plot","html","gsParams","display"],outputs:["nPoints","kDomain","fDomain","plotWidth","plotHeight","marginLeft","marginBottom","marginTop","marginRight","saddleNodeCurve","hopfCurve","kMin","xScale","yScale","basePlot","container","dotSvg","dot","updateDotPosition","isDragging","clamp","updateFromPosition","paramDisplay","updateDisplay"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-42"),expanded:[],variables:[]},{id:42,body:(t,e)=>t`<details>
  <summary>Derivation of the Hopf bifurcation curve</summary>

The Gray-Scott model consists of two coupled reaction-diffusion equations:

${e.block`\frac{\partial u}{\partial t} = D_u \nabla^2 u - uv^2 + f(1-u)`}
${e.block`\frac{\partial v}{\partial t} = D_v \nabla^2 v + uv^2 - (f+k)v`}

where ${e`u`} and ${e`v`} are the concentrations of two chemical species, ${e`f`} is the feed rate, and ${e`k`} is the kill rate.

**Steady states.** Setting the time derivatives to zero (ignoring diffusion for spatially uniform states):

${e.block`uv^2 = f(1-u), \quad uv = f + k`}

From the second equation, ${e`v = (f+k)/u`}. Substituting into the first:

${e.block`u \cdot \frac{(f+k)^2}{u^2} = f(1-u) \implies (f+k)^2 = fu(1-u)`}

**Jacobian matrix.** To determine stability, we examine how small deviations ${e`\tilde{u} = u - u^*`} and ${e`\tilde{v} = v - v^*`} from the steady state evolve. The Jacobian matrix, formed from partial derivatives of the reaction terms evaluated at the steady state, governs this evolution:

${e.block`J = \begin{pmatrix} \partial_u(-uv^2 + f(1-u)) & \partial_v(-uv^2 + f(1-u)) \\ \partial_u(uv^2 - (f+k)v) & \partial_v(uv^2 - (f+k)v) \end{pmatrix}`}

${e.block`\phantom{J} = \begin{pmatrix} -v^2 - f & -2uv \\ v^2 & 2uv - (f+k) \end{pmatrix}`}

Using ${e`uv = f+k`} at steady state, the element ${e`J_{22} = 2(f+k) - (f+k) = f+k`}.

**Hopf bifurcation condition.** The eigenvalues of ${e`J`} determine stability. For a 2×2 matrix, ${e`\lambda = \tfrac{1}{2}(\text{Tr} \pm \sqrt{\text{Tr}^2 - 4\det})`}. When ${e`\det > 0`} and ${e`\text{Tr} < 0`}, both eigenvalues have negative real parts. These eigenvalues dictate growth and decay of perturbations, so negative real parts means perturbations decay and the steady state is stable. When ${e`\text{Tr} > 0`}, perturbations grow exponentially.

The boundary ${e`\text{Tr} = 0`} (with ${e`\det > 0`}) marks a *Hopf bifurcation*: the eigenvalues become purely imaginary, and the system transitions from stable equilibrium to sustained oscillations. Setting ${e`\text{Tr}(J) = J_{11} + J_{22} = 0`}:

${e.block`(-v^2 - f) + (f + k) = 0 \implies v^2 = k`}

So at the Hopf bifurcation, ${e`v = \sqrt{k}`}.

**Solving for the curve.** Combining ${e`v = \sqrt{k}`} with the steady-state condition ${e`uv = f+k`}:

${e.block`u\sqrt{k} = f + k`}

From ${e`f(1-u) = uv^2 = uk`}, we get ${e`f = uk/(1-u)`}. Substituting:

${e.block`u\sqrt{k} = \frac{uk}{1-u} + k = \frac{uk + k(1-u)}{1-u} = \frac{k}{1-u}`}

Therefore ${e`u(1-u) = \sqrt{k}`}, giving the quadratic:

${e.block`u^2 - u + \sqrt{k} = 0`}

Solving: ${e`u = \frac{1 - \sqrt{1 - 4\sqrt{k}}}{2}`} (taking the smaller root for stability).

Finally, ${e`f = uk/(1-u)`} gives the Hopf curve parametrized by ${e`k`}.

**Saddle-node bifurcation.** The solid curve marks where non-trivial steady states exist. Recall the steady-state condition ${e`(f+k)^2 = fu(1-u)`}. Viewing this as a quadratic in ${e`u`}, solutions exist only when the discriminant is non-negative: ${e`f^2 - 4f(f+k)^2 \geq 0`}. The boundary where this discriminant equals zero gives the saddle-node curve ${e`f = \tfrac{1}{16}(1 \pm \sqrt{1-16k})^2`}. Outside this curve, only the trivial state ${e`(u,v) = (1,0)`} exists. Inside, a second steady state with ${e`v > 0`} appears.

**Interpreting the phase diagram.** Outside the dashed Hopf curve, the system settles to a spatially uniform state (no patterns). Inside the dashed curve, the uniform state becomes unstable, and small perturbations grow into the spots and stripes we observe.

</details>`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});g({root:document.getElementById("cell-44"),expanded:[],variables:[]},{id:44,body:(t,e,i,f)=>{const s=t.range(-6,6.01,.05),u=(n,c)=>Math.exp(-n*n/(2*c*c)),o=s.map(n=>({x:n,y:.6*u(n,1),type:"activator"})),p=s.map(n=>({x:n,y:-.4*u(n,2),type:"inhibitor"})),d=s.map(n=>({x:n,y:.6*u(n,1)-.4*u(n,2),type:"difference"})),r=e.plot({width:500,height:280,marginLeft:50,marginBottom:35,x:{label:"Position",domain:[-5,5]},y:{label:null,domain:[-.5,.8]},color:{domain:["activator","inhibitor","difference"],range:["#2563eb","#dc2626","#16a34a"]},marks:[e.ruleY([0],{stroke:"#999",strokeWidth:1}),e.line(o,{x:"x",y:"y",stroke:"type",strokeWidth:2,curve:"natural"}),e.line(p,{x:"x",y:"y",stroke:"type",strokeWidth:2,curve:"natural"}),e.line(d,{x:"x",y:"y",stroke:"type",strokeWidth:2.5,strokeDasharray:"6,3",curve:"natural"}),e.text([{x:2.8,y:.52,text:"Activator (narrow)"}],{x:"x",y:"y",text:"text",fill:"#2563eb",fontSize:12,fontWeight:500}),e.text([{x:3.2,y:-.32,text:"Inhibitor (wide)"}],{x:"x",y:"y",text:"text",fill:"#dc2626",fontSize:12,fontWeight:500}),e.text([{x:-3.2,y:.35,text:"Difference (update)"}],{x:"x",y:"y",text:"text",fill:"#16a34a",fontSize:12,fontWeight:500})]});return i(f`<figure id="gaussian-mechanism-figure" style="max-width: 500px;">
  ${r}
  <figcaption>The narrow activator (blue) responds strongly to the peak while the wide inhibitor (red) averages over a broader region. Their difference (green dashed) drives the update: positive at the center, negative at the flanks.</figcaption>
</figure>`),{sigma_a:1,sigma_i:2,xs:s,gaussianKernel:u,activatorData:o,inhibitorData:p,differenceData:d,gaussianPlot:r}},inputs:["d3","Plot","display","html"],outputs:["sigma_a","sigma_i","xs","gaussianKernel","activatorData","inhibitorData","differenceData","gaussianPlot"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-46"),expanded:[],variables:[]},{id:46,body:(t,e)=>t`### 1D Turing pattern model

The simulation below implements the activator-inhibitor model in one dimension. We maintain a scalar field and use the [Fast Fourier Transform](https://en.wikipedia.org/wiki/Fast_Fourier_transform) (FFT) to repeatedly convolve it with two Gaussian kernels: a narrow activator and a wider inhibitor. At each step, we add the difference to the field, then apply an ${e`\arctan`} function to keep values bounded.

The ratio of inhibitor to activator width determines the characteristic spacing of the pattern. A 2:1 ratio creates tight spacing; larger ratios spread the features further apart. Try adjusting the activator radius to see how it affects the emerging pattern. The colored bars below the simulation show the relative widths of the activator (blue) and inhibitor (red) kernels.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});g({root:document.getElementById("cell-47"),expanded:[],variables:[]},{id:47,body:t=>({activatorInput:t.range([2,25],{value:15,step:.1,label:"Activator radius"})}),inputs:["Inputs"],outputs:["activatorInput"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-48"),expanded:[],variables:[]},{id:48,body:async(t,e,i,f,a,l,s)=>{const{createTuring1D:u}=await Y(()=>import("./turing-1d-MU1RQjB9.js"),[]).then(y=>{if(!("createTuring1D"in y))throw new SyntaxError("export 'createTuring1D' not found");return y}),o=256,p=.5,d=1,r=2,n=u(o);n.initialize(),n.setKernels(15,r),t.addEventListener("input",()=>{n.setKernels(t.value,r)});const c=document.createElement("canvas");c.id="turing-1d-canvas",c.width=o,c.height=75,c.style.width="512px",c.style.maxWidth="100%",c.style.height="auto",c.style.aspectRatio="512 / 150",c.style.border="1px solid #ccc",c.style.cursor="crosshair";const P=c.getContext("2d");function F(y){const _=c.getBoundingClientRect();return(y.clientX-_.left)/_.width}function m(y){const _=c.getBoundingClientRect();return(y.touches[0].clientX-_.left)/_.width}c.addEventListener("mousedown",y=>n.setMouse(F(y))),c.addEventListener("mousemove",y=>{y.buttons&1&&n.setMouse(F(y))}),c.addEventListener("mouseup",()=>n.setMouse(null)),c.addEventListener("mouseleave",()=>n.setMouse(null)),c.addEventListener("touchstart",y=>{y.preventDefault(),n.setMouse(m(y))},{passive:!1}),c.addEventListener("touchmove",y=>{y.preventDefault(),n.setMouse(m(y))},{passive:!1}),c.addEventListener("touchend",()=>n.setMouse(null)),c.addEventListener("touchcancel",()=>n.setMouse(null));const v=e`<button style="position: absolute; right: 10px; bottom: 10px;">Restart</button>`;v.onclick=()=>{n.initialize(),n.setKernels(t.value,r)};const B=e`<div id="kernel-indicator-1d" style="display: flex; flex-direction: column; gap: 4px; margin-top: 8px; font-size: 11px; font-family: sans-serif;">
  <div style="display: flex; align-items: center; gap: 8px;">
    <span style="width: 80px; text-align: right; color: #2563eb;">Activator</span>
    <div id="activator-bar-1d" style="height: 8px; background: #2563eb; border-radius: 2px;"></div>
  </div>
  <div style="display: flex; align-items: center; gap: 8px; position: relative;">
    <span style="width: 80px; text-align: right; color: #dc2626;">Inhibitor (2×)</span>
    <div id="inhibitor-bar-1d" style="height: 8px; background: #dc2626; border-radius: 2px;"></div>
    <svg id="drag-handle-1d" style="position: absolute; left: 88px; top: 50%; transform: translateY(-50%); overflow: visible; pointer-events: none;" width="10" height="10">
      <circle id="drag-dot-1d" cx="0" cy="5" r="8" fill="#e63946" stroke="transparent" stroke-width="44" style="cursor: grab; pointer-events: stroke;" />
    </svg>
  </div>
</div>`,h=document.createElement("canvas");h.id="turing-1d-plot";const L=window.devicePixelRatio||1;h.width=512*L,h.height=120*L,h.style.width="512px",h.style.maxWidth="100%",h.style.height="auto",h.style.aspectRatio="512 / 120",h.style.display="block";const S=h.getContext("2d");S.scale(L,L),i(e`<figure>
  <div style="position: relative;">
    ${c}
    ${v}
  </div>
  ${h}
  ${B}
  <figcaption style="font-size: 12px; color: #666; margin-top: 8px;">Single-scale Turing pattern. Drag the red dot to adjust kernel size. The plot shows the activator (blue) and negated inhibitor (red) convolutions, with their difference (green dashed).</figcaption>
</figure>`);const z=c.getBoundingClientRect();let I=z.top<window.innerHeight&&z.bottom>0;const V=new f(y=>{I=y[0].isIntersecting},{threshold:.01});V.observe(c);const w=document.getElementById("activator-bar-1d"),R=document.getElementById("inhibitor-bar-1d"),G=document.getElementById("drag-handle-1d"),W=document.getElementById("drag-dot-1d");function A(){const _=c.getBoundingClientRect().width/o,q=t.value,x=q*r*2*_;w.style.width=q*2*_+"px",R.style.width=x+"px",G.style.left=88+x+"px"}A(),t.addEventListener("input",A);const b=new a(()=>A());b.observe(c);let E=!1;W.addEventListener("mousedown",y=>{E=!0,W.style.cursor="grabbing",y.preventDefault()}),document.addEventListener("mousemove",y=>{if(!E)return;const _=B.getBoundingClientRect(),q=c.getBoundingClientRect().width,x=q/o,T=y.clientX-_.left-88,O=Math.max(20,Math.min(q,T))/(r*2*x),D=Math.max(2,Math.min(25,O));t.value=D,t.dispatchEvent(new l("input")),n.setKernels(D,r)}),document.addEventListener("mouseup",()=>{E&&(E=!1,W.style.cursor="grab")}),W.addEventListener("touchstart",y=>{E=!0,y.preventDefault()},{passive:!1}),document.addEventListener("touchmove",y=>{if(!E||!y.touches.length)return;const _=B.getBoundingClientRect(),q=c.getBoundingClientRect().width,x=q/o,T=y.touches[0].clientX-_.left-88,O=Math.max(20,Math.min(q,T))/(r*2*x),D=Math.max(2,Math.min(25,O));t.value=D,t.dispatchEvent(new l("input")),n.setKernels(D,r)},{passive:!1}),document.addEventListener("touchend",()=>{E=!1});function k(){const q=512/o,x=120/2;S.fillStyle="#fff",S.fillRect(0,0,512,120),S.strokeStyle="#ccc",S.lineWidth=1,S.beginPath(),S.moveTo(0,120/2),S.lineTo(512,120/2),S.stroke();function T(D,K,X=!1){S.strokeStyle=K,S.lineWidth=1.5,S.setLineDash(X?[6,4]:[]),S.beginPath();for(let N=0;N<o;N++){const H=N*q,J=120/2-D[N]*x;N===0?S.moveTo(H,J):S.lineTo(H,J)}S.stroke(),S.setLineDash([])}T(n.activator,"#2563eb");const $=new Float64Array(o);for(let D=0;D<o;D++)$[D]=-n.inhibitor[D];T($,"#dc2626");const O=new Float64Array(o);for(let D=0;D<o;D++)O[D]=n.activator[D]-n.inhibitor[D];T(O,"#16a34a",!0)}let M;function C(){I&&(n.step(p,d),n.render(P,c.width,c.height),k()),M=requestAnimationFrame(C)}return C(),s.then(()=>{cancelAnimationFrame(M),V.disconnect(),b.disconnect()}),{createTuring1D:u,turing1dN:o,turing1dStepSize:p,turing1dToneMapRange:d,turing1dInhibitorRatio:r,turingSim:n,turingCanvas:c,turingCtx:P,getMouseX:F,getTouchX:m,turing1dRestartBtn:v,kernelIndicator:B,plotCanvas:h,plotDpr:L,plotCtx:S,rect:z,isVisible:I,visibilityObserver:V,activatorBar1D:w,inhibitorBar1D:R,dragHandle1D:G,dragDot1D:W,updateKernelIndicator:A,resizeObserver:b,isDragging1D:E,updatePlot:k,turing1dAnimationId:M,animate:C}},inputs:["activatorInput","html","display","IntersectionObserver","ResizeObserver","Event","invalidation"],outputs:["createTuring1D","turing1dN","turing1dStepSize","turing1dToneMapRange","turing1dInhibitorRatio","turingSim","turingCanvas","turingCtx","getMouseX","getTouchX","turing1dRestartBtn","kernelIndicator","plotCanvas","plotDpr","plotCtx","rect","isVisible","visibilityObserver","activatorBar1D","inhibitorBar1D","dragHandle1D","dragDot1D","updateKernelIndicator","resizeObserver","isDragging1D","updatePlot","turing1dAnimationId","animate"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-50"),expanded:[],variables:[]},{id:50,body:async(t,e,i,f,a,l,s,u,o,p)=>{const{createTuring2D:d}=await Y(()=>import("./turing-2d-D4E14fju.js"),__vite__mapDeps([3,1])).then(r=>{if(!("createTuring2D"in r))throw new SyntaxError("export 'createTuring2D' not found");return r});if(!t())e(i`<div style="color: #666; padding: 12px; border: 1px solid #ccc; background: #f9f9f9; border-radius: 4px; font-size: 13px;">WebGPU is not available.</div>`);else{let z=function(x){const T=h.getBoundingClientRect();return[(x.clientX-T.left)/T.width,(x.clientY-T.top)/T.height]},I=function(x){const T=h.getBoundingClientRect(),$=x.touches[0];return[($.clientX-T.left)/T.width,($.clientY-T.top)/T.height]},b=function(){const T=h.getBoundingClientRect().width/c,$=B.value,O=$*m*2*T;R.style.width=$*2*T+"px",G.style.width=O+"px",W.style.left=88+O+"px"},q=function(){C&&(v.step(),S.render(L.getCurrentTexture().createView())),_=requestAnimationFrame(q)};const{device:r,canvasFormat:n}=await f(),c=256,P=.5,F=1,m=2,v=d(r,{width:c,height:c,activatorRadius:15,inhibitorRatio:m,stepSize:P,toneMapRange:F});v.initialize();const B=a.range([2,25],{value:l.value,step:.1,label:"Activator radius"});a.bind(B,l,s);const h=document.createElement("canvas");h.id="turing-2d-canvas",h.width=c,h.height=c,h.style.width="512px",h.style.maxWidth="100%",h.style.height="auto",h.style.aspectRatio="1 / 1",h.style.border="1px solid #ccc",h.style.cursor="crosshair";const L=h.getContext("webgpu");L.configure({device:r,format:n,alphaMode:"opaque"});const S=v.createRenderer(n);h.addEventListener("mousedown",x=>v.setMouse(z(x))),h.addEventListener("mousemove",x=>{x.buttons&1&&v.setMouse(z(x))}),h.addEventListener("mouseup",()=>v.setMouse(null)),h.addEventListener("mouseleave",()=>v.setMouse(null)),h.addEventListener("touchstart",x=>{x.preventDefault(),v.setMouse(I(x))},{passive:!1}),h.addEventListener("touchmove",x=>{x.preventDefault(),v.setMouse(I(x))},{passive:!1}),h.addEventListener("touchend",()=>v.setMouse(null)),h.addEventListener("touchcancel",()=>v.setMouse(null));const V=i`<button style="position: absolute; right: 10px; bottom: 10px;">Restart</button>`;V.onclick=()=>{v.setKernels(B.value,m),v.initialize()};const w=i`<div id="kernel-indicator-2d" style="display: flex; flex-direction: column; gap: 4px; margin-top: 8px; font-size: 11px; font-family: sans-serif;">
      <div style="display: flex; align-items: center; gap: 8px;">
        <span style="width: 80px; text-align: right; color: #2563eb;">Activator</span>
        <div id="activator-bar-2d" style="height: 8px; background: #2563eb; border-radius: 2px;"></div>
      </div>
      <div style="display: flex; align-items: center; gap: 8px; position: relative;">
        <span style="width: 80px; text-align: right; color: #dc2626;">Inhibitor (2×)</span>
        <div id="inhibitor-bar-2d" style="height: 8px; background: #dc2626; border-radius: 2px;"></div>
        <svg id="drag-handle-2d" style="position: absolute; left: 88px; top: 50%; transform: translateY(-50%); overflow: visible; pointer-events: none;" width="10" height="10">
          <circle id="drag-dot-2d" cx="0" cy="5" r="8" fill="#e63946" stroke="transparent" stroke-width="44" style="cursor: grab; pointer-events: stroke;" />
        </svg>
      </div>
    </div>`;e(i`<figure id="turing-2d-figure">
      <div style="position: relative; display: inline-block;">
        ${h}
        ${V}
      </div>
      ${w}
      <figcaption style="font-size: 12px; color: #666; margin-top: 8px;">2D single-scale Turing pattern. Drag the red dot to adjust kernel size.</figcaption>
    </figure>`);const R=document.getElementById("activator-bar-2d"),G=document.getElementById("inhibitor-bar-2d"),W=document.getElementById("drag-handle-2d"),A=document.getElementById("drag-dot-2d");b(),B.addEventListener("input",()=>{v.setKernels(B.value,m),b()}),l.addEventListener("input",()=>{v.setKernels(l.value,m),b()});const E=new u(()=>b());E.observe(h);let k=!1;A.addEventListener("mousedown",x=>{k=!0,A.style.cursor="grabbing",x.preventDefault()}),document.addEventListener("mousemove",x=>{if(!k)return;const T=w.getBoundingClientRect(),$=h.getBoundingClientRect().width,O=$/c,D=x.clientX-T.left-88,X=Math.max(20,Math.min($,D))/(m*2*O),N=Math.max(2,Math.min(25,X));B.value=N,l.value=N,l.dispatchEvent(new o("input")),v.setKernels(N,m),b()}),document.addEventListener("mouseup",()=>{k&&(k=!1,A.style.cursor="grab")}),A.addEventListener("touchstart",x=>{k=!0,x.preventDefault()},{passive:!1}),document.addEventListener("touchmove",x=>{if(!k||!x.touches.length)return;const T=w.getBoundingClientRect(),$=h.getBoundingClientRect().width,O=$/c,D=x.touches[0].clientX-T.left-88,X=Math.max(20,Math.min($,D))/(m*2*O),N=Math.max(2,Math.min(25,X));B.value=N,l.value=N,l.dispatchEvent(new o("input")),v.setKernels(N,m),b()},{passive:!1}),document.addEventListener("touchend",()=>{k=!1});const M=h.getBoundingClientRect();let C=M.top<window.innerHeight&&M.bottom>0;const y=new p(x=>{C=x[0].isIntersecting},{threshold:.01});y.observe(h);let _;q(),s.then(()=>{cancelAnimationFrame(_),y.disconnect(),E.disconnect(),v.destroy(),r.destroy()})}return{createTuring2D:d}},inputs:["isWebGPUAvailable","display","html","createWebGPUContext","Inputs","activatorInput","invalidation","ResizeObserver","Event","IntersectionObserver"],outputs:["createTuring2D"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-51"),expanded:[],variables:[]},{id:51,body:(t,e)=>t`## Extension to Multiple Scales

The single-scale algorithm produces patterns with a characteristic wavelength determined by the kernel ratio. To create the rich, nested structures of true multiscale Turing patterns, we run multiple scales simultaneously and let them compete.

At each point in the field, we compute activator and inhibitor values for several scales. Each scale proposes an update direction based on the sign of its ${e`(a - b)`} difference. The question is which scale should "win" at each location.

The answer comes from looking at the magnitude ${e`|a - b|`} at each scale. Where this variation is small, the field is already near equilibrium for that scale—further updates would create excessive local contrast. Where variation is large, the scale has strong opinions about which direction to push.

The algorithm selects the scale with minimum variation at each point and steps in the direction that scale indicates. The effect is that coarse scales dominate in regions where fine scales would fight against each other, while fine scales fill in details where coarse scales have nothing to say. The result is a hierarchy of nested patterns spanning the full range of scales.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});g({root:document.getElementById("cell-52"),expanded:[],variables:[]},{id:52,body:(t,e)=>t`## Two-Scale Demo

The simulation below demonstrates this scale-selection logic with just two scales: a fine scale and a coarse scale. Each scale computes its own activator-inhibitor difference, and at each pixel the scale with minimum ${e`|a - b|`} controls the update direction.

Check "Show scale selection" to visualize which scale wins at each location. Blue regions are controlled by the fine scale, orange by the coarse scale. `,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});g({root:document.getElementById("cell-53"),expanded:[],variables:[]},{id:53,body:async(t,e,i,f,a,l)=>{const{createTuring2Scale:s}=await Y(()=>import("./turing-2scale-DnJKUYHC.js"),__vite__mapDeps([4,1])).then(u=>{if(!("createTuring2Scale"in u))throw new SyntaxError("export 'createTuring2Scale' not found");return u});if(!t())e(i`<div style="color: #666; padding: 12px; border: 1px solid #ccc; background: #f9f9f9; border-radius: 4px; font-size: 13px;">WebGPU is not available.</div>`);else{let P=function(w){const R=r.getBoundingClientRect();return[(w.clientX-R.left)/R.width,(w.clientY-R.top)/R.height]},F=function(w){const R=r.getBoundingClientRect(),G=w.touches[0];return[(G.clientX-R.left)/R.width,(G.clientY-R.top)/R.height]},V=function(){S&&(d.step(),c.render(n.getCurrentTexture().createView())),I=requestAnimationFrame(V)};const{device:u,canvasFormat:o}=await f(),p=256,d=s(u,{width:p,height:p,activatorRadius1:2,inhibitorRatio1:2,activatorRadius2:25,inhibitorRatio2:2,stepSize:.005,toneMapRange:1});d.initialize();const r=document.createElement("canvas");r.id="turing-2scale-canvas",r.width=p,r.height=p,r.style.width="512px",r.style.maxWidth="100%",r.style.height="auto",r.style.aspectRatio="1 / 1",r.style.border="1px solid #ccc",r.style.cursor="crosshair";const n=r.getContext("webgpu");n.configure({device:u,format:o,alphaMode:"opaque"});const c=d.createRenderer(o);r.addEventListener("mousedown",w=>d.setMouse(P(w))),r.addEventListener("mousemove",w=>{w.buttons&1&&d.setMouse(P(w))}),r.addEventListener("mouseup",()=>d.setMouse(null)),r.addEventListener("mouseleave",()=>d.setMouse(null)),r.addEventListener("touchstart",w=>{w.preventDefault(),d.setMouse(F(w))},{passive:!1}),r.addEventListener("touchmove",w=>{w.preventDefault(),d.setMouse(F(w))},{passive:!1}),r.addEventListener("touchend",()=>d.setMouse(null)),r.addEventListener("touchcancel",()=>d.setMouse(null));const m=i`<button style="position: absolute; right: 10px; bottom: 10px;">Restart</button>`;m.onclick=()=>d.initialize();const v=i`<label style="display: flex; align-items: center; gap: 6px; font-size: 12px; cursor: pointer;">
      <input type="checkbox" id="scale-tint-checkbox" checked>
      Show scale selection
    </label>`,B=v.querySelector("input");B.onchange=()=>d.setShowScaleTint(B.checked);const h=i`<div id="kernel-indicator-2scale" style="display: flex; flex-direction: column; gap: 4px; margin-top: 8px; font-size: 11px; font-family: sans-serif;">
      <div style="display: flex; align-items: center; gap: 8px;">
        <span style="width: 100px; text-align: right; color: #3b82f6;">Fine scale (A≈3)</span>
        <div style="height: 8px; background: #3b82f6; border-radius: 2px; width: 12px;"></div>
        <div style="height: 8px; background: #93c5fd; border-radius: 2px; width: 24px;"></div>
        <span style="color: #666; font-size: 10px;">activator / inhibitor</span>
      </div>
      <div style="display: flex; align-items: center; gap: 8px;">
        <span style="width: 100px; text-align: right; color: #f97316;">Coarse scale (A≈20)</span>
        <div style="height: 8px; background: #f97316; border-radius: 2px; width: 80px;"></div>
        <div style="height: 8px; background: #fdba74; border-radius: 2px; width: 160px;"></div>
      </div>
    </div>`;e(i`<figure id="turing-2scale-figure">
      <div style="position: relative; display: inline-block;">
        ${r}
        ${m}
      </div>
      ${h}
      <div style="margin-top: 8px;">${v}</div>
      <figcaption style="font-size: 12px; color: #666; margin-top: 8px;">Two-scale Turing pattern. Blue tint = fine scale selected, orange tint = coarse scale selected.</figcaption>
    </figure>`);const L=r.getBoundingClientRect();let S=L.top<window.innerHeight&&L.bottom>0;const z=new a(w=>{S=w[0].isIntersecting},{threshold:.01});z.observe(r);let I;V(),l.then(()=>{cancelAnimationFrame(I),z.disconnect(),d.destroy(),u.destroy()})}return{createTuring2Scale:s}},inputs:["isWebGPUAvailable","display","html","createWebGPUContext","IntersectionObserver","invalidation"],outputs:["createTuring2Scale"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});g({root:document.getElementById("cell-54"),expanded:[],variables:[]},{id:54,body:(t,e)=>t`## Multi-scale Turing pattern Implementation notes

The visualization at the top of the page puts all the pieces together and performs a multi-scale simulation. Getting it to work efficiently is a moderate undertaking with a few tricks and caveats documented below. The rough algorithm, from Jonathan McCabe's [Cyclic Symmetric Multi-Scale Turing Patterns](http://www.archive.bridgesmathart.org/2010/bridges2010-387.pdf) is:

1. Convolve the field with Gaussian or circular kernels at different radii to compute activator and inhibitor values
2. Find the scale with minimum variation (smallest |activator - inhibitor|)
3. Step the field in the direction indicated by that scale (positive if activator > inhibitor)
4. Mix the color toward the dominant scale's color

This implementation uses several techniques to maximize throughput on the GPU:

**Packed FFTs**: We compute four real-valued FFTs in a single pass by packing data into complex pairs. The real solution field ${e`u`} is stored as a vec4 treating it as two identical complex numbers:

${e.block`(u + 0i,\; u + 0i)`}

Similarly, four convolution kernels (two activator-inhibitor pairs for scales ${e`n`} and ${e`n+1`}) are packed into two complex numbers:

${e.block`(\hat{A}_n + i\hat{I}_n,\; \hat{A}_{n+1} + i\hat{I}_{n+1})`}

where ${e`\hat{A}`} and ${e`\hat{I}`} are the frequency-domain activator and inhibitor kernels. After a single forward FFT, we multiply by two sets of frequency-domain kernels and perform one inverse FFT to recover all four convolved outputs. It's interesting to note that even thought the real and complex components of the two kernels end up intermingled in frequency space, the final inverse FFT separates them nicely into the real-valued convolutions we seek.

**Analytical frequency-domain kernels**: Rather than storing precomputed kernel textures, we evaluate kernels analytically in the shader. The Fourier transform of a Gaussian with standard deviation ${e`\sigma`} is another Gaussian:

${e.block`\mathcal{F}\left[e^{-x^2/2\sigma^2}\right] = e^{-2\pi^2\sigma^2 f^2}`}

The Fourier transform of a circular disc of radius ${e`R`} is a Bessel function of the first kind:

${e.block`\mathcal{F}\left[\Pi(r/R)\right] = \frac{J_1(2\pi R f)}{\pi R f}`}

This eliminates kernel memory bandwidth entirely and allows arbitrary kernel parameters without regenerating textures.

**Float16 precision**: All computation uses 16-bit floating point for storage buffers, halving memory bandwidth compared to float32. The reduced precision is sufficient for the visual nature of the simulation while enabling larger grid sizes and faster execution.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});
