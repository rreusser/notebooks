const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/pipeline-DLROI3QM.js","assets/fft-Chkx7JT6.js"])))=>i.map(i=>d[i]);
import{d as v,_ as q}from"./index-ByB2dbry.js";v({root:document.getElementById("cell-2"),expanded:[],variables:[]},{id:2,body:async n=>{const{createWebGPUContext:e}=await q(()=>import("./webgpu-context-CA7EEXHP.js"),[]).then(i=>{if(!("createWebGPUContext"in i))throw new SyntaxError("export 'createWebGPUContext' not found");return i}),t=await e(),a=t.device,o=navigator.gpu.getPreferredCanvasFormat();return n.then(()=>a.destroy()),{createWebGPUContext:e,context:t,device:a,canvasFormat:o}},inputs:["invalidation"],outputs:["createWebGPUContext","context","device","canvasFormat"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-3"),expanded:[],variables:[]},{id:3,body:(n,e)=>{const t=n.select([64,128,256,512,1024,2048],{value:512,label:"Resolution",format:o=>`${o}Ã—${o}`}),a=e(t);return{resolutionInput:t,resolution:a}},inputs:["Inputs","view"],outputs:["resolutionInput","resolution"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-4"),expanded:[],variables:[]},{id:4,body:n=>{const e=n,t=e*e*2*4,a=e*e*4*4,o=Math.ceil(e/16),i=1/e;return{N:e,vec2Size:t,vec4Size:a,workgroups:o,dx:i}},inputs:["resolution"],outputs:["N","vec2Size","vec4Size","workgroups","dx"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-5"),expanded:[],variables:[]},{id:5,body:async(n,e,t)=>{const[{createFluidPipelines:a},{executeFFT2D:o}]=await Promise.all([q(()=>import("./pipeline-DLROI3QM.js"),__vite__mapDeps([0,1])).then(s=>{if(!("createFluidPipelines"in s))throw new SyntaxError("export 'createFluidPipelines' not found");return s}),q(()=>import("./fft-Chkx7JT6.js"),[]).then(s=>{if(!("executeFFT2D"in s))throw new SyntaxError("export 'executeFFT2D' not found");return s})]),i=await a(n,e,t);function c(s,m,l,p){o({device:n,pipelines:i.fft,input:s,output:m,temp:l,N:t,forward:p,splitNormalization:!0})}return{createFluidPipelines:a,executeFFT2D:o,pipelines:i,runFFT2D:c}},inputs:["device","canvasFormat","N"],outputs:["createFluidPipelines","executeFFT2D","pipelines","runFFT2D"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-6"),expanded:[],variables:[]},{id:6,body:(n,e,t,a,o)=>{const i=n.STORAGE|n.COPY_SRC|n.COPY_DST,c=e.createBuffer({label:"velocity",size:t,usage:i}),s=e.createBuffer({label:"velocityTemp",size:t,usage:i}),m=e.createBuffer({label:"u",size:a,usage:i}),l=e.createBuffer({label:"v",size:a,usage:i}),p=e.createBuffer({label:"uHat",size:a,usage:i}),b=e.createBuffer({label:"vHat",size:a,usage:i}),F=[0,1].map(w=>e.createBuffer({label:`fftTemp[${w}]`,size:a,usage:i})),B=e.createBuffer({label:"dye",size:a,usage:i}),h=e.createBuffer({label:"dyeTemp",size:a,usage:i}),y=o*o*4,r=e.createBuffer({label:"vorticity",size:y,usage:i});return{bufferUsage:i,velocity:c,velocityTemp:s,uBuffer:m,vBuffer:l,uHat:p,vHat:b,fftTemp:F,dye:B,dyeTemp:h,vorticitySize:y,vorticityBuffer:r}},inputs:["GPUBufferUsage","device","vec4Size","vec2Size","N"],outputs:["bufferUsage","velocity","velocityTemp","uBuffer","vBuffer","uHat","vHat","fftTemp","dye","dyeTemp","vorticitySize","vorticityBuffer"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-7"),expanded:[],variables:[]},{id:7,body:(n,e,t)=>{const a=n.createBuffer({label:"simParams",size:32,usage:e.UNIFORM|e.COPY_DST}),o=n.createBuffer({label:"forceParams",size:48,usage:e.UNIFORM|e.COPY_DST}),i=n.createBuffer({label:"projectParams",size:16,usage:e.UNIFORM|e.COPY_DST});n.queue.writeBuffer(i,0,new Uint32Array([t,t]));const c=n.createBuffer({label:"visParams",size:24,usage:e.UNIFORM|e.COPY_DST}),s=n.createBuffer({label:"vorticityParams",size:16,usage:e.UNIFORM|e.COPY_DST}),m=n.createBuffer({label:"boundaryParams",size:24,usage:e.UNIFORM|e.COPY_DST}),l=n.createBuffer({label:"buoyancyParams",size:16,usage:e.UNIFORM|e.COPY_DST});return{simParamsBuffer:a,forceParamsBuffer:o,projectParamsBuffer:i,visParamsBuffer:c,vorticityParamsBuffer:s,boundaryParamsBuffer:m,buoyancyParamsBuffer:l}},inputs:["device","GPUBufferUsage","N"],outputs:["simParamsBuffer","forceParamsBuffer","projectParamsBuffer","visParamsBuffer","vorticityParamsBuffer","boundaryParamsBuffer","buoyancyParamsBuffer"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-8"),expanded:[],variables:[]},{id:8,body:(n,e)=>{const t=n.range([1e-5,.01],{step:1e-5,value:15e-5,transform:Math.log,label:"Viscosity"}),a=e(t),o=n.range([.9,1],{step:.001,value:.99,label:"Dye persistence"}),i=e(o),c=n.range([.01,.15],{step:.005,value:.03,label:"Force radius"}),s=e(c),m=n.range([0,1],{step:.01,value:.5,label:"Force damping"}),l=e(m),p=n.range([0,50],{step:.1,value:20,label:"Vorticity confinement"}),b=e(p),F=n.range([-5,5],{step:.01,value:5,label:"Buoyancy"}),B=e(F),h=n.range([0,10],{step:1,value:5,label:"Wall thickness (cells)"}),y=e(h),r=n.checkbox(["Top/bottom","Left/right"],{label:"Walls"}),w=e(r),g=n.range([.001,.05],{step:.001,value:1/60,label:"Timestep (dt)"}),T=e(g),I=n.select(["Interactive","Rayleigh-Taylor","Kelvin-Helmholtz"],{value:"Rayleigh-Taylor",label:"Initial conditions"}),x=e(I),P=n.range([1,16],{step:1,value:8,label:"Perturbation periods"}),A=e(P),C=n.range([.001,.05],{step:.001,value:.005,label:"Perturbation amplitude"}),k=e(C),_=n.button("Restart"),D=e(_),$=n.toggle({label:"Simulate",value:!0}),G=e($);return{viscosityInput:t,viscosity:a,dyeDecayInput:o,dyeDecay:i,forceRadiusInput:c,forceRadius:s,forceDampingInput:m,forceDamping:l,vorticityInput:p,vorticityConfinement:b,buoyancyInput:F,buoyancy:B,wallThicknessInput:h,wallThickness:y,wallsEnabledInput:r,wallsEnabled:w,timestepInput:g,timestep:T,initialConditionInput:I,initialCondition:x,perturbationPeriodsInput:P,perturbationPeriods:A,perturbationAmplitudeInput:C,perturbationAmplitude:k,restartInput:_,restart:D,simulateInput:$,simulate:G}},inputs:["Inputs","view"],outputs:["viscosityInput","viscosity","dyeDecayInput","dyeDecay","forceRadiusInput","forceRadius","forceDampingInput","forceDamping","vorticityInput","vorticityConfinement","buoyancyInput","buoyancy","wallThicknessInput","wallThickness","wallsEnabledInput","wallsEnabled","timestepInput","timestep","initialConditionInput","initialCondition","perturbationPeriodsInput","perturbationPeriods","perturbationAmplitudeInput","perturbationAmplitude","restartInput","restart","simulateInput","simulate"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-9"),expanded:[],variables:[]},{id:9,body:(n,e,t,a,o,i,c,s,m,l,p,b,F,B,h,y,r)=>{n(e`<div id="fluid-controls">
  ${t}
  ${a}
  ${o}
  ${i}
  ${c}
  ${s}
  ${m}
  ${l}
  ${p}
  ${b}
  ${F}
  ${B}
  ${h}
  ${y}
  ${r}
</div>`)},inputs:["display","html","resolutionInput","initialConditionInput","perturbationPeriodsInput","perturbationAmplitudeInput","restartInput","simulateInput","viscosityInput","dyeDecayInput","timestepInput","forceRadiusInput","forceDampingInput","vorticityInput","buoyancyInput","wallThicknessInput","wallsEnabledInput"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-10"),expanded:[],variables:[]},{id:10,body:(n,e,t,a,o)=>{const i=Math.min(n,640),c=e`<canvas
  id="fluid-canvas"
  width="${i*window.devicePixelRatio}"
  height="${i*window.devicePixelRatio}"
  style="width: ${i}px; height: ${i}px; cursor: crosshair;">
</canvas>`,s=c.getContext("webgpu");return s.configure({device:t,format:a,alphaMode:"opaque"}),o(c),{canvasSize:i,canvas:c,gpuContext:s}},inputs:["width","html","device","canvasFormat","display"],outputs:["canvasSize","canvas","gpuContext"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-11"),expanded:[],variables:[]},{id:11,body:n=>{const e={down:!1,x:0,y:0,prevX:0,prevY:0,dx:0,dy:0};function t(a){const o=n.getBoundingClientRect();return{x:(a.clientX-o.left)/o.width,y:(a.clientY-o.top)/o.height}}return n.addEventListener("pointerdown",a=>{e.down=!0;const o=t(a);e.x=o.x,e.y=o.y,e.prevX=o.x,e.prevY=o.y,n.setPointerCapture(a.pointerId)}),n.addEventListener("pointermove",a=>{const o=t(a);e.prevX=e.x,e.prevY=e.y,e.x=o.x,e.y=o.y,e.down&&(e.dx=e.x-e.prevX,e.dy=e.y-e.prevY)}),n.addEventListener("pointerup",a=>{e.down=!1,e.dx=0,e.dy=0,n.releasePointerCapture(a.pointerId)}),n.addEventListener("pointerleave",()=>{e.down=!1,e.dx=0,e.dy=0}),n.addEventListener("touchstart",a=>{a.preventDefault(),e.down=!0;const o=a.touches[0],i=t(o);e.x=i.x,e.y=i.y,e.prevX=i.x,e.prevY=i.y}),n.addEventListener("touchmove",a=>{a.preventDefault();const o=a.touches[0],i=t(o);e.prevX=e.x,e.prevY=e.y,e.x=i.x,e.y=i.y,e.down&&(e.dx=e.x-e.prevX,e.dy=e.y-e.prevY)}),n.addEventListener("touchend",()=>{e.down=!1,e.dx=0,e.dy=0}),{mouseState:e,getMousePos:t}},inputs:["canvas"],outputs:["mouseState","getMousePos"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-12"),expanded:[],variables:[]},{id:12,body:()=>({simParams:{viscosity:5e-5,dyeDecay:.998,forceRadius:.03,forceDamping:.15,vorticityConfinement:2,buoyancy:5,wallThicknessX:0,wallThicknessY:0,dt:.016666666666666666}}),inputs:[],outputs:["simParams"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-13"),expanded:[],variables:[]},{id:13,body:(n,e,t,a,o,i,c,s,m,l)=>{l.viscosity=n,l.dyeDecay=e,l.dt=m,l.forceRadius=t,l.forceDamping=a,l.vorticityConfinement=o,l.buoyancy=i,l.wallThicknessX=s.includes("Left/right")?c:0,l.wallThicknessY=s.includes("Top/bottom")?c:0},inputs:["viscosity","dyeDecay","forceRadius","forceDamping","vorticityConfinement","buoyancy","wallThickness","wallsEnabled","timestep","simParams"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-14"),expanded:[],variables:[]},{id:14,body:(n,e,t,a,o,i)=>{n==="Rayleigh-Taylor"?(e.value=5,e.dispatchEvent(new t("input")),a.value=["Top/bottom"],a.dispatchEvent(new t("input")),o.value=1,o.dispatchEvent(new t("input")),i.value=.5,i.dispatchEvent(new t("input"))):n==="Kelvin-Helmholtz"&&(e.value=5,e.dispatchEvent(new t("input")),a.value=["Top/bottom"],a.dispatchEvent(new t("input")),o.value=1,o.dispatchEvent(new t("input")))},inputs:["initialCondition","wallThicknessInput","Event","wallsEnabledInput","dyeDecayInput","buoyancyInput"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-15"),expanded:[],variables:[]},{id:15,body:(n,e,t,a,o,i,c,s,m,l)=>{const p=new Float32Array(o*o*4),b=new Float32Array(o*o*2);if(e==="Interactive")p.fill(0),b.fill(0);else if(e==="Rayleigh-Taylor")for(let B=0;B<o;B++)for(let h=0;h<o;h++){const y=B*o+h,r=h/o,w=B/o,g=.5+a*Math.sin(2*Math.PI*t*r);if(w<g){const T=(g-w)/.03,I=Math.min(1,T);b[y*2]=I,b[y*2+1]=0}else b[y*2]=0,b[y*2+1]=0;p[y*4]=0,p[y*4+1]=0,p[y*4+2]=0,p[y*4+3]=0}else if(e==="Kelvin-Helmholtz")for(let h=0;h<o;h++)for(let y=0;y<o;y++){const r=h*o+y,w=y/o,g=h/o,T=.5+a*Math.sin(2*Math.PI*t*w),I=(g-T)/.1,x=Math.tanh(I)*.5;if(p[r*4]=x,p[r*4+1]=0,p[r*4+2]=a*Math.sin(2*Math.PI*t*w)*Math.exp(-I*I),p[r*4+3]=0,g<T){const P=(T-g)/.03,A=Math.min(1,P);b[r*2]=A,b[r*2+1]=0}else b[r*2]=0,b[r*2+1]=0}return i.queue.writeBuffer(c,0,p),i.queue.writeBuffer(s,0,p),i.queue.writeBuffer(m,0,b),i.queue.writeBuffer(l,0,b),{velocityData:p,dyeData:b}},inputs:["restart","initialCondition","perturbationPeriods","perturbationAmplitude","N","device","velocity","velocityTemp","dye","dyeTemp"],outputs:["velocityData","dyeData"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-16"),expanded:[],variables:[]},{id:16,body:(n,e,t,a,o,i,c,s,m,l)=>{function p(){const r=new ArrayBuffer(32);new Uint32Array(r,0,2).set([n,n]),new Float32Array(r,8,1).set([e.dt]),new Float32Array(r,12,1).set([e.viscosity]),new Float32Array(r,16,1).set([e.dyeDecay]),new Float32Array(r,20,1).set([e.wallThicknessX]),new Float32Array(r,24,1).set([e.wallThicknessY]),t.queue.writeBuffer(a,0,r)}function b(){const r=o.dx/e.dt,w=-o.dy/e.dt,g=new ArrayBuffer(48);new Uint32Array(g,0,2).set([n,n]),new Float32Array(g,8,2).set([o.x,1-o.y]),new Float32Array(g,16,2).set([r,w]),new Float32Array(g,24,1).set([e.forceRadius]),new Float32Array(g,28,1).set([o.down?1:0]),new Float32Array(g,32,1).set([e.forceDamping]),t.queue.writeBuffer(i,0,g)}function F(){const r=new ArrayBuffer(24);new Uint32Array(r,0,2).set([n,n]),new Float32Array(r,8,1).set([1]),new Float32Array(r,12,1).set([0]),new Float32Array(r,16,1).set([e.wallThicknessX]),new Float32Array(r,20,1).set([e.wallThicknessY]),t.queue.writeBuffer(c,0,r)}function B(){const r=new ArrayBuffer(16);new Uint32Array(r,0,2).set([n,n]),new Float32Array(r,8,1).set([e.vorticityConfinement]),new Float32Array(r,12,1).set([e.dt]),t.queue.writeBuffer(s,0,r)}function h(){const r=new ArrayBuffer(24);new Uint32Array(r,0,2).set([n,n]),new Float32Array(r,8,1).set([0]),new Float32Array(r,12,1).set([e.wallThicknessX]),new Float32Array(r,16,1).set([e.wallThicknessY]),t.queue.writeBuffer(m,0,r)}function y(){const r=new ArrayBuffer(16);new Uint32Array(r,0,2).set([n,n]),new Float32Array(r,8,1).set([e.buoyancy]),new Float32Array(r,12,1).set([e.dt]),t.queue.writeBuffer(l,0,r)}return{updateSimUniforms:p,updateForceUniforms:b,updateVisUniforms:F,updateVorticityUniforms:B,updateBoundaryUniforms:h,updateBuoyancyUniforms:y}},inputs:["N","simParams","device","simParamsBuffer","mouseState","forceParamsBuffer","visParamsBuffer","vorticityParamsBuffer","boundaryParamsBuffer","buoyancyParamsBuffer"],outputs:["updateSimUniforms","updateForceUniforms","updateVisUniforms","updateVorticityUniforms","updateBoundaryUniforms","updateBuoyancyUniforms"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-17"),expanded:[],variables:[]},{id:17,body:(n,e,t,a,o,i,c,s,m,l,p,b,F,B,h,y,r,w,g,T,I,x,P,A,C,k,_,D,$,G,R)=>{function E(){if(n.wallThicknessX>0||n.wallThicknessY>0){e();const f=t.createBindGroup({layout:a.bindGroupLayouts.enforceBoundary,entries:[{binding:0,resource:{buffer:o}},{binding:1,resource:{buffer:i}},{binding:2,resource:{buffer:c}}]}),d=t.createCommandEncoder(),u=d.beginComputePass();u.setPipeline(a.enforceBoundary),u.setBindGroup(0,f),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([d.finish()])}}async function z(){m(),l(),E();{const f=t.createBindGroup({layout:a.bindGroupLayouts.addForce,entries:[{binding:0,resource:{buffer:o}},{binding:1,resource:{buffer:i}},{binding:2,resource:{buffer:p}}]}),d=t.createCommandEncoder(),u=d.beginComputePass();u.setPipeline(a.addForce),u.setBindGroup(0,f),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([d.finish()])}{const f=t.createBindGroup({layout:a.bindGroupLayouts.advect,entries:[{binding:0,resource:{buffer:o}},{binding:1,resource:{buffer:o}},{binding:2,resource:{buffer:b}},{binding:3,resource:{buffer:F}}]}),d=t.createCommandEncoder(),u=d.beginComputePass();u.setPipeline(a.advectVelocity),u.setBindGroup(0,f),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([d.finish()])}{const f=t.createCommandEncoder();f.copyBufferToBuffer(b,0,o,0,B),t.queue.submit([f.finish()])}E();{const f=t.createBindGroup({layout:a.bindGroupLayouts.advectScalar,entries:[{binding:0,resource:{buffer:o}},{binding:1,resource:{buffer:i}},{binding:2,resource:{buffer:h}},{binding:3,resource:{buffer:F}}]}),d=t.createCommandEncoder(),u=d.beginComputePass();u.setPipeline(a.advectScalar),u.setBindGroup(0,f),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([d.finish()])}{const f=t.createCommandEncoder();f.copyBufferToBuffer(h,0,i,0,y),t.queue.submit([f.finish()])}{const f=t.createBindGroup({layout:a.bindGroupLayouts.splitVelocity,entries:[{binding:0,resource:{buffer:o}},{binding:1,resource:{buffer:r}},{binding:2,resource:{buffer:w}},{binding:3,resource:{buffer:g}}]}),d=t.createCommandEncoder(),u=d.beginComputePass();u.setPipeline(a.splitVelocity),u.setBindGroup(0,f),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([d.finish()])}T(r,I,x,!0),T(w,P,x,!0);{const f=t.createBindGroup({layout:a.bindGroupLayouts.projectFFT,entries:[{binding:0,resource:{buffer:I}},{binding:1,resource:{buffer:P}},{binding:2,resource:{buffer:F}}]}),d=t.createCommandEncoder(),u=d.beginComputePass();u.setPipeline(a.projectFFT),u.setBindGroup(0,f),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([d.finish()])}T(I,r,x,!1),T(P,w,x,!1);{const f=t.createBindGroup({layout:a.bindGroupLayouts.mergeVelocity,entries:[{binding:0,resource:{buffer:r}},{binding:1,resource:{buffer:w}},{binding:2,resource:{buffer:o}},{binding:3,resource:{buffer:g}}]}),d=t.createCommandEncoder(),u=d.beginComputePass();u.setPipeline(a.mergeVelocity),u.setBindGroup(0,f),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([d.finish()])}if(E(),n.vorticityConfinement>0){A();{const f=t.createBindGroup({layout:a.bindGroupLayouts.computeVorticity,entries:[{binding:0,resource:{buffer:o}},{binding:1,resource:{buffer:C}},{binding:2,resource:{buffer:k}}]}),d=t.createCommandEncoder(),u=d.beginComputePass();u.setPipeline(a.computeVorticity),u.setBindGroup(0,f),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([d.finish()])}{const f=t.createBindGroup({layout:a.bindGroupLayouts.applyVorticity,entries:[{binding:0,resource:{buffer:o}},{binding:1,resource:{buffer:C}},{binding:2,resource:{buffer:k}}]}),d=t.createCommandEncoder(),u=d.beginComputePass();u.setPipeline(a.applyVorticity),u.setBindGroup(0,f),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([d.finish()])}}if(n.buoyancy!==0){_();const f=t.createBindGroup({layout:a.bindGroupLayouts.applyBuoyancy,entries:[{binding:0,resource:{buffer:o}},{binding:1,resource:{buffer:i}},{binding:2,resource:{buffer:D}}]}),d=t.createCommandEncoder(),u=d.beginComputePass();u.setPipeline(a.applyBuoyancy),u.setBindGroup(0,f),u.dispatchWorkgroups(s,s),u.end(),t.queue.submit([d.finish()])}E()}function S(){$();const f=t.createBindGroup({layout:a.bindGroupLayouts.visualize,entries:[{binding:0,resource:{buffer:o}},{binding:1,resource:{buffer:i}},{binding:2,resource:{buffer:G}}]}),d=t.createCommandEncoder(),u=d.beginRenderPass({colorAttachments:[{view:R.getCurrentTexture().createView(),loadOp:"clear",storeOp:"store",clearValue:{r:0,g:0,b:0,a:1}}]});u.setPipeline(a.visualize),u.setBindGroup(0,f),u.draw(6),u.end(),t.queue.submit([d.finish()])}return{enforceBoundaries:E,step:z,render:S}},inputs:["simParams","updateBoundaryUniforms","device","pipelines","velocity","dye","boundaryParamsBuffer","workgroups","updateSimUniforms","updateForceUniforms","forceParamsBuffer","velocityTemp","simParamsBuffer","vec4Size","dyeTemp","vec2Size","uBuffer","vBuffer","projectParamsBuffer","runFFT2D","uHat","fftTemp","vHat","updateVorticityUniforms","vorticityBuffer","vorticityParamsBuffer","updateBuoyancyUniforms","buoyancyParamsBuffer","updateVisUniforms","visParamsBuffer","gpuContext"],outputs:["enforceBoundaries","step","render"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-18"),expanded:[],variables:[]},{id:18,body:(n,e,t,a,o,i)=>{let c=null,s=!1;async function m(){if(!s)try{a&&await n(),e(),o.dx=0,o.dy=0,c=requestAnimationFrame(m)}catch(l){s=!0,console.error("Animation loop error:",l)}}return c=requestAnimationFrame(m),i.then(()=>{s=!0,c!==null&&(cancelAnimationFrame(c),c=null)}),{animFrameId:c,hasError:s,animationLoop:m}},inputs:["step","render","canvas","simulate","mouseState","invalidation"],outputs:["animFrameId","hasError","animationLoop"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});v({root:document.getElementById("cell-19"),expanded:[],variables:[]},{id:19,body:(n,e)=>n`## Algorithm

The Stable Fluids algorithm solves the incompressible Navier-Stokes equations:

${e.block`\frac{\partial \mathbf{u}}{\partial t} = -(\mathbf{u} \cdot \nabla)\mathbf{u} + \nu \nabla^2 \mathbf{u} - \nabla p + \mathbf{f}`}

subject to the incompressibility constraint ${e`\nabla \cdot \mathbf{u} = 0`}.

Each timestep consists of four stages:

1. **Add forces**: Apply external forces (mouse input) to the velocity field
2. **Advect**: Move the velocity field along itself using semi-Lagrangian advection
3. **Diffuse**: Apply viscous diffusion (done in frequency domain as multiplication)
4. **Project**: Make velocity divergence-free by subtracting the gradient of pressure

The key insight is that projection can be done efficiently in frequency domain. The velocity ${e`\hat{\mathbf{u}}(\mathbf{k})`} is decomposed into components parallel and perpendicular to the wavenumber ${e`\mathbf{k}`}. The divergence-free projection removes the parallel component:

${e.block`\hat{\mathbf{u}}_{\perp} = \hat{\mathbf{u}} - \mathbf{k}\frac{\mathbf{k} \cdot \hat{\mathbf{u}}}{|\mathbf{k}|^2}`}

This makes the algorithm unconditionally stable regardless of timestep size.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});v({root:document.getElementById("cell-20"),expanded:[],variables:[]},{id:20,body:(n,e)=>n`## Implementation Details

### Grid Layout

Velocities are **cell-centered** (collocated), not staggered. Cell ${e`(i,j)`} stores both velocity components ${e`(u, v)`} at physical position ${e`(i+0.5, j+0.5)`}. Velocity is stored as \`vec4<f32>\` with layout \`(u_re, u_im, v_re, v_im)\` to accommodate FFT operations. In the spatial domain, the imaginary parts are zero.

### Simulation Loop

Each timestep executes these stages in order:

1. **Add forces** (mouse interaction)
2. **Advect velocity** (semi-Lagrangian)
3. **Advect dye**
4. **Project + diffuse** (FFT-based)
5. **Vorticity confinement**
6. **Buoyancy**
7. **Boundary enforcement**

### FFT-Based Projection and Diffusion

The FFT is used to efficiently solve the pressure projection and diffusion in frequency domain:

1. **Split** the interleaved velocity into separate ${e`u`} and ${e`v`} complex buffers
2. **Forward FFT** on both components
3. **Project and diffuse** in frequency domain:
   - Compute wavenumber ${e`\mathbf{k}`} with frequencies ${e`0, 1, \ldots, N/2-1, -N/2, \ldots, -1`} scaled by ${e`2\pi`}
   - Remove component parallel to ${e`\mathbf{k}`}: ${e.block`\hat{u} \leftarrow \hat{u} - k_x \frac{\mathbf{k} \cdot \hat{\mathbf{u}}}{|\mathbf{k}|^2}, \quad \hat{v} \leftarrow \hat{v} - k_y \frac{\mathbf{k} \cdot \hat{\mathbf{u}}}{|\mathbf{k}|^2}`}
   - Apply implicit diffusion by multiplying by ${e`\frac{1}{1 + \nu |\mathbf{k}|^2 \Delta t}`}
   - Zero the DC component (${e`\mathbf{k} = 0`})
4. **Inverse FFT** to return to spatial domain
5. **Merge** back into interleaved velocity buffer

### Forcing Model

The force uses a **velocity-matching model** rather than direct impulse injection:

${e.block`\mathbf{f} = (\mathbf{v}_{\text{target}} - \mathbf{v}) \cdot \text{damping} \cdot \text{falloff}`}

where ${e`\mathbf{v}_{\text{target}} = \Delta\mathbf{x}_{\text{mouse}} / \Delta t`} is computed from mouse velocity, and the falloff is Gaussian: ${e`\exp(-r^2 / 2\sigma^2)`}.

Dye injection uses a **hard circle** (step function) rather than Gaussian for sharper smoke edges.

### Semi-Lagrangian Advection

For each grid cell, trace backward through the velocity field to find the departure point:

${e.block`\mathbf{x}_{\text{back}} = \mathbf{x} - \mathbf{u}(\mathbf{x}) \cdot N \cdot \Delta t`}

Then sample the source field at ${e`\mathbf{x}_{\text{back}}`} using **monotone cubic interpolation** (Fedkiw et al., "Visual Simulation of Smoke", SIGGRAPH 2001). The factor of ${e`N`} converts velocity from normalized to grid units.

The monotone cubic interpolation uses Hermite interpolation with slope limiting to prevent overshoot:

${e.block`f(t) = a_3 t^3 + a_2 t^2 + a_1 t + a_0`}

where the slopes ${e`d_k = (f_{k+1} - f_{k-1})/2`} are set to zero when they differ in sign from ${e`\Delta_k = f_{k+1} - f_k`}. This preserves monotonicity and eliminates spurious oscillations that can arise with standard cubic interpolation.

### Vorticity Confinement

Two-pass process to counteract numerical dissipation of rotational motion:

**Pass 1**: Compute vorticity (curl) using central differences:
${e.block`\omega = \frac{\partial v}{\partial x} - \frac{\partial u}{\partial y}`}

**Pass 2**: Apply confinement force in the direction perpendicular to the vorticity gradient:
${e.block`\mathbf{N} = \frac{\nabla|\omega|}{|\nabla|\omega||}, \quad \mathbf{f} = \varepsilon (\mathbf{N} \times \omega)`}

In 2D, the cross product gives ${e`\mathbf{f} = \varepsilon (N_y \omega, -N_x \omega)`}. This force points toward vortex centers, amplifying rotational structures.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});
