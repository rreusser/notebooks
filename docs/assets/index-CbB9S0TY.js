const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/jacobi-coords-figure-2Sej2Y98.js","assets/initial-conditions-figure-CPctfvuv.js","assets/shape-sphere-s9Pu1v4H.js","assets/shape-projection-BjqwNMLv.js"])))=>i.map(i=>d[i]);
import{d as f,_ as I}from"./index-ByB2dbry.js";f({root:document.getElementById("cell-2"),expanded:[],variables:[]},{id:2,body:async()=>{const[{default:t},{default:e},{createElementStack:n},{reglElement:i,reglAxesViewport:d},{createZoomableAxes:o},{expandable:a},{planarThreeBodyDerivative:l,computeShape:r,computeFreeGroupWord:p,integrateTrajectory:c,parseInitialConditions:b,decodeHash:y},{createInitialConditionsFigure:h},{createJacobiCoordsFigure:m,computeShapeFromPositions:v},{createShapeSphere:w,createOrbitShapeSphere:g,createIcosphere:u,getCollisionPoints:S},{createShapeProjection2D:E,computeProjectedBounds:x}]=await Promise.all([I(()=>import("https://cdn.jsdelivr.net/npm/regl@2.1.1/+esm"),[]).then(s=>{if(!("default"in s))throw new SyntaxError("export 'default' not found");return s}),I(()=>import("https://cdn.jsdelivr.net/npm/regl-gpu-lines@2.4.1/+esm"),[]).then(s=>{if(!("default"in s))throw new SyntaxError("export 'default' not found");return s}),I(()=>import("./element-stack-BU40TvN2.js"),[]).then(s=>{if(!("createElementStack"in s))throw new SyntaxError("export 'createElementStack' not found");return s}),I(()=>import("./regl-canvas-4j8SAjSv.js"),[]).then(s=>{if(!("reglElement"in s))throw new SyntaxError("export 'reglElement' not found");if(!("reglAxesViewport"in s))throw new SyntaxError("export 'reglAxesViewport' not found");return s}),I(()=>import("./zoomable-axes-BfGyq1bg.js"),[]).then(s=>{if(!("createZoomableAxes"in s))throw new SyntaxError("export 'createZoomableAxes' not found");return s}),I(()=>import("./expandable-BCrxs32f.js"),[]).then(s=>{if(!("expandable"in s))throw new SyntaxError("export 'expandable' not found");return s}),I(()=>import("./three-body-physics-DLuPQzXb.js"),[]).then(s=>{if(!("planarThreeBodyDerivative"in s))throw new SyntaxError("export 'planarThreeBodyDerivative' not found");if(!("computeShape"in s))throw new SyntaxError("export 'computeShape' not found");if(!("computeFreeGroupWord"in s))throw new SyntaxError("export 'computeFreeGroupWord' not found");if(!("integrateTrajectory"in s))throw new SyntaxError("export 'integrateTrajectory' not found");if(!("parseInitialConditions"in s))throw new SyntaxError("export 'parseInitialConditions' not found");if(!("decodeHash"in s))throw new SyntaxError("export 'decodeHash' not found");return s}),I(()=>import("./initial-conditions-figure-CPctfvuv.js"),[]).then(s=>{if(!("createInitialConditionsFigure"in s))throw new SyntaxError("export 'createInitialConditionsFigure' not found");return s}),I(()=>import("./jacobi-coords-figure-2Sej2Y98.js"),__vite__mapDeps([0,1])).then(s=>{if(!("createJacobiCoordsFigure"in s))throw new SyntaxError("export 'createJacobiCoordsFigure' not found");if(!("computeShapeFromPositions"in s))throw new SyntaxError("export 'computeShapeFromPositions' not found");return s}),I(()=>import("./shape-sphere-s9Pu1v4H.js"),__vite__mapDeps([2,0,1])).then(s=>{if(!("createShapeSphere"in s))throw new SyntaxError("export 'createShapeSphere' not found");if(!("createOrbitShapeSphere"in s))throw new SyntaxError("export 'createOrbitShapeSphere' not found");if(!("createIcosphere"in s))throw new SyntaxError("export 'createIcosphere' not found");if(!("getCollisionPoints"in s))throw new SyntaxError("export 'getCollisionPoints' not found");return s}),I(()=>import("./shape-projection-BjqwNMLv.js"),__vite__mapDeps([3,0,1])).then(s=>{if(!("createShapeProjection2D"in s))throw new SyntaxError("export 'createShapeProjection2D' not found");if(!("computeProjectedBounds"in s))throw new SyntaxError("export 'computeProjectedBounds' not found");return s})]);return{createREGL:t,createDrawLines:e,createElementStack:n,reglElement:i,reglAxesViewport:d,createZoomableAxes:o,expandable:a,planarThreeBodyDerivative:l,computeShape:r,computeFreeGroupWord:p,integrateTrajectory:c,parseInitialConditions:b,decodeHash:y,createInitialConditionsFigure:h,createJacobiCoordsFigure:m,computeShapeFromPositions:v,createShapeSphere:w,createOrbitShapeSphere:g,createIcosphere:u,getCollisionPoints:S,createShapeProjection2D:E,computeProjectedBounds:x}},inputs:[],outputs:["createREGL","createDrawLines","createElementStack","reglElement","reglAxesViewport","createZoomableAxes","expandable","planarThreeBodyDerivative","computeShape","computeFreeGroupWord","integrateTrajectory","parseInitialConditions","decodeHash","createInitialConditionsFigure","createJacobiCoordsFigure","computeShapeFromPositions","createShapeSphere","createOrbitShapeSphere","createIcosphere","getCollisionPoints","createShapeProjection2D","computeProjectedBounds"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-3"),expanded:[],variables:[]},{id:3,body:async(t,e)=>{const[{ode45:n},{threeBodyInitialConditions:i,references:d,sequenceUrls:o}]=await Promise.all([I(()=>import("https://api.observablehq.com/@rreusser/integration.js?v=4"),[]).then(a=>{const l={},r=t.module(a.default),p=t.module();if(!r.defines("ode45"))throw new SyntaxError("export 'ode45' not found");return p.variable(l.ode45=e()).import("ode45",r),l}),I(()=>import("https://api.observablehq.com/@rreusser/periodic-three-body-initial-conditions.js?v=4"),[]).then(a=>{const l={},r=t.module(a.default),p=t.module();if(!r.defines("threeBodyInitialConditions"))throw new SyntaxError("export 'threeBodyInitialConditions' not found");if(p.variable(l.threeBodyInitialConditions=e()).import("threeBodyInitialConditions",r),!r.defines("references"))throw new SyntaxError("export 'references' not found");if(p.variable(l.references=e()).import("references",r),!r.defines("sequenceUrls"))throw new SyntaxError("export 'sequenceUrls' not found");return p.variable(l.sequenceUrls=e()).import("sequenceUrls",r),l})]);return{ode45:n,threeBodyInitialConditions:i,references:d,sequenceUrls:o}},inputs:["__ojs_runtime","__ojs_observer"],outputs:["ode45","threeBodyInitialConditions","references","sequenceUrls"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-4"),expanded:[],variables:[]},{id:4,body:(t,e,n,i)=>{const d=Object.keys(t).flatMap(o=>Object.keys(t[o]).flatMap(a=>Object.keys(t[o][a]).length)).reduce((o,a)=>o+a,0);return e(n`This notebook collects ${d.toLocaleString()} periodic solutions of the planar [three-body problem](https://en.wikipedia.org/wiki/Three-body_problem) in which three bodies experience mutual gravitational attraction according to [Newton's law of universal gravitation](https://en.wikipedia.org/wiki/Newton%27s_law_of_universal_gravitation), ${i.block`F=G{\frac {m_{1}m_{2}}{r^{2}}}.`}

Three-body orbits don't have a closed-form analytical solution and aren't in general periodic, but by reducing the dimensionality of the problem through symmetries and performing a lot of numerical searching, a number of authors have found and published large sets of initial conditions for periodic solutions.`),{orbitCount:d}},inputs:["threeBodyInitialConditions","display","md","tex"],outputs:["orbitCount"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-5"),expanded:[],variables:[]},{id:5,body:(t,e)=>t`## Governing equations

The vector form of Newton's law of gravitation for the force on body 2 exerted by body 1 is ${e.block`\mathbf{F}_2 = m_2\mathbf{\ddot{x}}_{2} = -\frac{Gm_1m_2(\mathbf{x}_2 - \mathbf{x}_1)}{||\mathbf{x}_2 - \mathbf{x}_1||^3},`} where ${e`\mathbf{x}_1`} and ${e`\mathbf{x}_2`} and ${e`m_1`} and ${e`m_2`} are the vector positions and masses of bodies ${e`1`} and ${e`2`}, respectively, and ${e`\mathbf{\ddot{x}}_{2}`} is the acceleration of body ${e`2`}. Given state ${e`\mathbf{y}`}, we compute the time derivative ${e`\mathbf{\dot{y}}`}.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});f({root:document.getElementById("cell-9"),expanded:[],variables:[]},{id:9,body:(t,e,n,i,d,o)=>{(()=>{if(!t)return;const a=document.createElement("figure");a.style.maxWidth="350px",a.style.margin="0 auto";const l=e(n,t,i,{width:Math.min(d,350)});a.appendChild(l);const r=document.createElement("figcaption");r.innerHTML=`Initial conditions for the ${t.name} planar three-body orbit.`,a.appendChild(r),o(a)})()},inputs:["initialConditions","createInitialConditionsFigure","d3","drawingParams","width","display"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-11"),expanded:[],variables:[]},{id:11,body:(t,e,n)=>{const i=(()=>{const o=document.createElement("form");o.className="orbit-selector";const a=t(window.location.hash);let l=a.group||"Šuvakov",r=a.sequence||"III - Yin Yang",p=a.orbit||"III.15.A.β";const c=Object.keys(e).map(u=>({label:u,options:Object.keys(e[u]).map(S=>({label:S,value:`${u}: ${S}`}))})),b=document.createElement("label");b.innerHTML="<small><em>Sequence</em></small><br>";const y=document.createElement("select");y.name="sequence",c.forEach(u=>{const S=document.createElement("optgroup");S.label=u.label,u.options.forEach(E=>{const x=document.createElement("option");x.value=E.value,x.textContent=E.label,E.value===`${l}: ${r}`&&(x.selected=!0),S.appendChild(x)}),y.appendChild(S)}),b.appendChild(y);const h=document.createElement("label");h.innerHTML="<small><em>Orbit</em></small><br>";const m=document.createElement("select");m.name="orbit",h.appendChild(m);function v(){m.innerHTML="";const u=Object.keys(e[l]?.[r]||{});u.forEach(S=>{const E=document.createElement("option");E.value=S,E.textContent=S,S===p&&(E.selected=!0),m.appendChild(E)}),!u.includes(p)&&u.length>0&&(p=u[0],m.value=p)}v();const w=document.createElement("div");w.innerHTML='<strong style="font-size:0.9rem">Initial conditions</strong>',o.appendChild(w);const g=document.createElement("div");return g.style.cssText="display:flex;gap:1em;flex-wrap:wrap;",g.appendChild(b),g.appendChild(h),o.appendChild(g),y.onchange=()=>{const[u,S]=y.value.split(": ");l=u,r=S,v(),p=m.value,o.value={group:l,sequence:r,orbit:p},o.dispatchEvent(new CustomEvent("input",{bubbles:!0}))},m.onchange=()=>{p=m.value,o.value={group:l,sequence:r,orbit:p},o.dispatchEvent(new CustomEvent("input",{bubbles:!0}))},o.value={group:l,sequence:r,orbit:p},o})(),d=n.input(i);return{selectedConditionsInput:i,selectedConditions:d}},inputs:["decodeHash","threeBodyInitialConditions","Generators"],outputs:["selectedConditionsInput","selectedConditions"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-102"),expanded:[],variables:[]},{id:102,body:()=>({drawingParams:{animate:!0,lineOpacity:1,lineWidth:2.5,lineBorderWidth:1,pointSize:10,speed:5,color:[[.63,.83,.18],[.18,.63,.83],[.83,.18,.63]],borderColor:[[1,1,1],[1,1,1],[1,1,1]],strokeColor:[[1,1,1],[1,1,1],[1,1,1]]}}),inputs:[],outputs:["drawingParams"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-12"),expanded:[],variables:[]},{id:12,body:(t,e,n,i)=>({initialConditions:(()=>{const{group:o,sequence:a,orbit:l}=t,r=e[o]?.[a]?.[l];return n(r,l,i.color)})()}),inputs:["selectedConditions","threeBodyInitialConditions","parseInitialConditions","drawingParams"],outputs:["initialConditions"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-7"),expanded:[],variables:[]},{id:7,body:(t,e,n)=>({trajectory:t(e,n)}),inputs:["integrateTrajectory","ode45","initialConditions"],outputs:["trajectory"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-202"),expanded:[],variables:[]},{id:202,body:(t,e,n)=>({shapeTrajectory:(()=>{const d=[],o=t?.m||[1,1,1];for(let a=0;a<e.t.length;a++)d.push(...n(e.position,o,a));return d})()}),inputs:["initialConditions","trajectory","computeShape"],outputs:["shapeTrajectory"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-204"),expanded:[],variables:[]},{id:204,body:(t,e)=>({freeGroupWord:t(e)}),inputs:["computeFreeGroupWord","shapeTrajectory"],outputs:["freeGroupWord"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-101"),expanded:[],variables:[]},{id:101,body:(t,e,n)=>{const i=t`<div class="plot-controls">
  <details>
    <summary style="cursor:pointer;font-size:0.85em;color:#666;">Display options</summary>
    <div class="controls-inner" style="padding-top:0.5em;"></div>
  </details>
</div>`,d=i.querySelector(".controls-inner");function o(b){return d.appendChild(b),e.input(b)}const a=o(n.toggle({label:"Animate lines",value:!0})),l=o(n.range([0,1],{label:"Line opacity",value:.7,step:.01})),r=o(n.range([.5,6],{label:"Line width",value:2.5,step:.1})),p=o(n.range([4,20],{label:"Point size",value:10,step:1})),c=o(n.range([.05,20],{label:"Speed",value:5,step:.05}));return{controlsContainer:i,controlsInner:d,ctrl:o,animate:a,lineOpacity:l,lineWidth:r,pointSize:p,animSpeed:c}},inputs:["html","Generators","Inputs"],outputs:["controlsContainer","controlsInner","ctrl","animate","lineOpacity","lineWidth","pointSize","animSpeed"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-103"),expanded:[],variables:[]},{id:103,body:(t,e,n,i,d,o,a)=>{t.animate=e,t.lineOpacity=n,t.lineWidth=i,t.pointSize=d,t.speed=o,a?.elements?.regl?.value&&(a.elements.regl.value.dirty=!0)},inputs:["drawingParams","animate","lineOpacity","lineWidth","pointSize","animSpeed","stack"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-104"),expanded:[],variables:[]},{id:104,body:t=>{function e(n,i,d=[-2,2],o=[-2,2]){return t.plot({width:n,height:i,marginTop:20,marginRight:20,marginLeft:40,marginBottom:30,style:{backgroundColor:"transparent",maxWidth:"none",position:"absolute",top:"0",left:"0"},x:{domain:d,tickSpacing:100},y:{domain:o,tickSpacing:100},marks:[t.ruleX([0],{stroke:"#0002"}),t.ruleY([0],{stroke:"#0002"})]})}return{createPlot:e}},inputs:["Plot"],outputs:["createPlot"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-105"),expanded:[],variables:[]},{id:105,body:(t,e,n,i,d)=>({stack:t({layers:[{id:"regl",element:e(n,{optionalExtensions:["ANGLE_instanced_arrays"],attributes:{antialias:!0,preserveDrawingBuffer:!0}})},{id:"plot",element:({width:a,height:l})=>i(a,l)},{id:"svg",element:({current:a,width:l,height:r})=>(a?d.select(a):d.create("svg")).attr("width",l).attr("height",r).style("position","absolute").style("top","0").style("left","0").node()}]})}),inputs:["createElementStack","reglElement","createREGL","createPlot","d3"],outputs:["stack"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-106"),expanded:[],variables:[]},{id:106,body:(t,e,n,i)=>({axes:t({d3:e,element:n.elements.svg,xScale:n.elements.plot.scale("x"),yScale:n.elements.plot.scale("y"),aspectRatio:1,scaleExtent:[.01,1e4],onChange:({xDomain:o,yDomain:a})=>{const l=i(n.width,n.height,o,a);n.elements.plot.replaceWith(l),n.elements.plot=l,n.dispatchEvent(new CustomEvent("update")),n.elements.regl?.value&&(n.elements.regl.value.dirty=!0)}})}),inputs:["createZoomableAxes","d3","stack","createPlot"],outputs:["axes"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-205"),expanded:[],variables:[]},{id:205,body:(t,e)=>{t(e)},inputs:["display","selectedConditionsInput"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-107"),expanded:[],variables:[]},{id:107,body:(t,e,n,i,d)=>{t(e(n.element,{width:Math.min(i,640),height:Math.min(480,i*.7),controls:[".orbit-selector",".orbit-metadata",".plot-controls"],onResize(o,a,l){n.resize(a,l),d.updateScales(n.elements.plot.scale("x"),n.elements.plot.scale("y")),n.elements.regl?.value&&(n.elements.regl.value.dirty=!0)}}))},inputs:["display","expandable","stack","width","axes"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-904"),expanded:[],variables:[]},{id:904,body:(t,e)=>{t(e)},inputs:["display","metadataContainer"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-903"),expanded:[],variables:[]},{id:903,body:(t,e)=>{t(e)},inputs:["display","controlsContainer"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-108"),expanded:[],variables:[]},{id:108,body:(t,e,n,i,d,o,a,l)=>{(()=>{const r=t.elements.regl.value;if(!r)return;const p=1e10;e.t.length;const c=new Float32Array(9+e.position.length+9);c.fill(p,0,9),c.set(e.position,9),c.fill(p,9+e.position.length);const b=r.buffer(c),y=16,h=2,m=new Float32Array(9*y),v=r.buffer(m),w=n(r,{vert:`
      precision highp float;

      #pragma lines: attribute vec3 position;
      #pragma lines: position = getPosition(position);
      #pragma lines: width = getWidth();

      uniform mat4 view;
      uniform float timeScale, timeShift;
      uniform float width;

      vec4 getPosition(vec3 p) {
        // Detect sentinel value and return vec4(0) to trigger line cap
        if (p.x > 1e9) return vec4(0);
        return view * vec4(p.xy, (p.z * timeScale - timeShift) * 2.0 - 1.0, 1.0);
      }

      float getWidth() {
        return width;
      }
    `,frag:`
      precision highp float;
      varying vec3 lineCoord;
      uniform vec3 color, borderColor;
      uniform float opacity, width, borderWidth;
      void main() {
        float sdf = length(lineCoord.xy) * width;
        vec3 c = mix(color, borderColor, smoothstep(width - borderWidth - 1.0, width - borderWidth + 1.0, sdf));
        gl_FragColor = vec4(c * opacity, opacity);
      }
    `,uniforms:{view:()=>i.view,timeScale:r.prop("timeScale"),timeShift:r.prop("timeShift"),color:r.prop("color"),borderColor:r.prop("borderColor"),opacity:()=>d.lineOpacity,width:E=>E.pixelRatio*d.lineWidth,borderWidth:E=>E.pixelRatio*d.lineBorderWidth},depth:{enable:!0},blend:{enable:!0,func:{src:"one",dst:"zero"}},viewport:o(i),scissor:{enable:!0,box:o(i)}}),g=r({vert:`
      precision highp float;
      attribute vec3 position;
      uniform mat4 view;
      uniform float pointSize, pixelRatio;
      void main() {
        gl_Position = view * vec4(position.xy, 0, 1);
        gl_PointSize = pointSize * pixelRatio;
      }
    `,frag:`
      precision highp float;
      uniform vec3 color, strokeColor;
      uniform float opacity;
      void main() {
        float r = length(gl_PointCoord * 2.0 - 1.0);
        if (r > 1.0) discard;
        vec3 c = r > 0.7 ? strokeColor : color;
        gl_FragColor = vec4(c * opacity, opacity);
      }
    `,attributes:{position:{buffer:v,stride:12,offset:r.prop("offset")}},uniforms:{view:()=>i.view,pointSize:r.prop("pointSize"),pixelRatio:r.context("pixelRatio"),color:r.prop("color"),strokeColor:r.prop("strokeColor"),opacity:r.prop("opacity")},count:1,primitive:"points",depth:{enable:!1},blend:{enable:!0,func:{srcRGB:"one",srcAlpha:"one",dstRGB:"one minus src alpha",dstAlpha:"one minus src alpha"}},viewport:o(i),scissor:{enable:!0,box:o(i)}});function u(E,x){let s=0,$=E.length-1;for(;s<$;){const B=s+$>>1;E[B]<x?s=B+1:$=B}return Math.max(0,s-1)}r.dirty=!0;const S=r.frame(E=>{if(!r.dirty)return;r.dirty=!1;const x=e.t[e.t.length-1],s=5e-4;let $,B;d.animate?($=E.time*d.speed%(x*2)/x-1,B=1/x):($=-s,B=(1-2*s)/x),r.clear({color:[0,0,0,0],depth:1});for(let C=0;C<3;C++)w({join:"bevel",insertCaps:!0,vertexCount:e.t.length+2,vertexAttributes:{position:{buffer:b,stride:36,offset:C*12}},timeScale:B,timeShift:$,color:d.color[C],borderColor:d.borderColor[C]});const _=e.t,P=e.position,T=E.time*d.speed%x,D=h*(1/60)*d.speed;for(let C=0;C<y;C++){const L=(T-D*(y-1-C)/y+x)%x,k=u(_,L),R=Math.min(_.length-1,k+1),A=(L-_[k])/(_[R]-_[k]||1),W=C*9;for(let j=0;j<9;j++)m[W+j]=(1-A)*P[k*9+j]+A*P[R*9+j]}v.subdata(m);const O=1.5/y;for(let C=0;C<y;C++){const L=C*9*4;for(let k=0;k<3;k++)g({offset:L+k*12,pointSize:(a?.pointSize?.[k]||1)*d.pointSize,color:d.color[k],strokeColor:d.color[k],opacity:O})}r.dirty=!0});l.then(()=>S.cancel())})()},inputs:["stack","trajectory","createDrawLines","axes","drawingParams","reglAxesViewport","initialConditions","invalidation"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-1090"),expanded:[],variables:[]},{id:1090,body:()=>({metadataState:{detailsOpen:!0}}),inputs:[],outputs:["metadataState"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-109"),expanded:[],variables:[]},{id:109,body:(t,e,n,i,d,o,a,l,r)=>({metadataContainer:(()=>{const{group:c,sequence:b,orbit:y}=t,h=e[c]?.[b]?.[y];if(!h)return n`<div class="orbit-metadata"></div>`;const m=h.x,v=h.v,w=h.m||[1,1,1],g=i[h.ref],u=w[0]!==w[1]||w[0]!==w[2],S=`#group=${encodeURIComponent(c)}&sequence=${encodeURIComponent(b)}&orbit=${encodeURIComponent(y)}`,E=`${c} - ${b.replace(/i\.c\./,"isosceles collinear")}`,x=n`<div class="orbit-metadata">
    <details>
      <summary style="cursor:pointer;font-size:0.85em;color:#666;">Orbit details</summary>
      <div style="border:1px solid #ccc;padding:0 10px;margin-top:0.5em;box-sizing:border-box;max-width:100%;">
        <small><dl class="inline-flex">
          <dt>Sequence</dt><dd><a href="${d[c]?.[b]||"#"}">${E}${u?" (unequal mass)":""}</a></dd>
          <dt>Orbit</dt><dd>${h.url?n`<a href="${h.url}">${o`${a.name}`}</a>`:o`${a.name}`}</dd>
          <dt>Initial positions</dt><dd>${o`(${m[0][0]}, ${m[0][1]}),`} ${o`(${m[1][0]}, ${m[1][1]}),`} ${o`(${m[2][0]}, ${m[2][1]})`}</dd>
          <dt>Initial velocities</dt><dd>${o`(${v[0][0]}, ${v[0][1]}),`} ${o`(${v[1][0]}, ${v[1][1]}),`} ${o`(${v[2][0]}, ${v[2][1]})`}</dd>
          <dt>Masses</dt><dd>${o`(${w[0]}, ${w[1]}, ${w[2]})`}</dd>
          <dt>Free group element</dt><dd style="word-break:break-all;">${l}</dd>
          <dt>Period</dt><dd>${h.T}</dd>
          <dt>Discovered</dt><dd>${h.year}</dd>
          <dt>Reference</dt><dd>${g.authors}, <em>${g.title}</em></dd>
          <dt>Share</dt><dd><a href="${S}">link to this orbit</a></dd>
        </dl></small>
      </div>
    </details>
  </div>`,s=x.querySelector("details");return s.open=r.detailsOpen,s.addEventListener("toggle",()=>{r.detailsOpen=s.open}),x})()}),inputs:["selectedConditions","threeBodyInitialConditions","html","references","sequenceUrls","tex","initialConditions","freeGroupWord","metadataState"],outputs:["metadataContainer"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-201"),expanded:[],variables:[]},{id:201,body:(t,e)=>t`### Shape space

Jacobi coordinates remove net translation and reduce the degrees of freedom in position from six to four. We can further reduce the dimensionality to two by defining the *shape vector* ${e.block`
\begin{aligned}
\mathbf{n} &= (n_x, n_y, n_z) \\
&= \left( \frac{2 \mathbf{r}_1 \cdot \mathbf{r}_2}{R^2}, \frac{r_1^2 - r_2^2}{R^2}, \frac{2 (\mathbf{r}_1 \times \mathbf{r}_2) \cdot \mathbf{e}_z}{R^2}\right)
\end{aligned}
`} where ${e`\mathbf{r}_1`} and ${e`\mathbf{r}_2`} are the Jacobi coordinates, ${e`\mathbf{e}_z`} is the unit vector along the z-axis, and ${e`R = \sqrt{r_1^2 + r_2^2}`}. The vector ${e`\mathbf{n}`} lives on the unit sphere and describes the configuration of the system in a manner invariant to rotation, translation and overall size.

Move the points below and observe a corresponding behavior on the shape sphere:
- Pairwise collisions place the shape at one of three points, marked on the shape sphere in red, green, and blue
- Collinear configurations, called *syzygies*, lie on the equator`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});f({root:document.getElementById("cell-210"),expanded:[],variables:[]},{id:210,body:(t,e,n,i,d,o,a,l,r)=>{(()=>{if(!t)return;const p=Math.min(e,480),c=document.createElement("div");c.style.display="flex",c.style.flexDirection="column",c.style.gap="20px";const b=p,y=n(i,t,d,{width:b,height:b*.7}),h=document.createElement("figure");h.appendChild(y.node);const m=document.createElement("figcaption");m.textContent="Jacobi coordinates. Drag the masses to see the effect in shape space.",h.appendChild(m),c.appendChild(h);const v=p,w=v*.7,g=document.createElement("canvas");g.id="interactive-shape-sphere",g.width=v*devicePixelRatio,g.height=w*devicePixelRatio,g.style.width=`${v}px`,g.style.height=`${w}px`,g.style.cursor="grab";const u=document.createElement("figure");u.appendChild(g);const S=document.createElement("figcaption");S.textContent="Shape sphere with collision points. Drag to rotate.",u.appendChild(S),c.appendChild(u);const E=o({canvas:g,extensions:["ANGLE_instanced_arrays","OES_standard_derivatives"],attributes:{antialias:!0}}),x=a(E,{theta:.7,phi:.3});x.setPunctures(t.m),x.setShape(y.getShape()),x.render(v,w),y.addEventListener("input",()=>{x.setShape(y.getShape()),x.render(v,w)});let s=!1,$=0,B=0;g.addEventListener("mousedown",_=>{s=!0,$=_.clientX,B=_.clientY,g.style.cursor="grabbing"}),window.addEventListener("mousemove",_=>{s&&(x.rotate((_.clientX-$)*.01,(_.clientY-B)*.01),x.render(v,w),$=_.clientX,B=_.clientY)}),window.addEventListener("mouseup",()=>{s=!1,g.style.cursor="grab"}),l(c),r.then(()=>{x.destroy(),E.destroy()})})()},inputs:["initialConditions","width","createJacobiCoordsFigure","d3","drawingParams","createREGL","createShapeSphere","display","invalidation"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-211"),expanded:[],variables:[]},{id:211,body:(t,e,n)=>t`We return to the ${e`${n?.name||""}`} orbit and plot it on the shape sphere below.

Since all orbits here are collision-free, the trajectory meanders about on the surface of the sphere but never passes through any of the three pairwise collision points. In fact we can imagine continuously deforming a trajectory to find similar nearby orbits just as long as we don't ever pass over the collision points and create an invalid orbit. In topology, these forbidden missing points are called *punctures*, and a family of orbits we can obtain through continuous deformation without passing over the punctures corresponds the concept of the [*fundamental group*](https://en.wikipedia.org/wiki/Fundamental_group) from algebraic topology. Algebraic topology is a topic well beyond my expertise, so I'll tread lightly here and not pretend to know more about it.`,inputs:["md","tex","initialConditions"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});f({root:document.getElementById("cell-212"),expanded:[],variables:[]},{id:212,body:(t,e,n,i,d,o,a,l)=>{(()=>{if(!t||!e)return;const r=Math.min(n,480),p=r*.8,c=document.createElement("canvas");c.id="orbit-shape-sphere",c.width=r*devicePixelRatio,c.height=p*devicePixelRatio,c.style.width=`${r}px`,c.style.height=`${p}px`,c.style.cursor="grab";const b=document.createElement("figure");b.appendChild(c);const y=document.createElement("figcaption");y.innerHTML=`Shape sphere trajectory of the <em>${e.name}</em> orbit, with the shape sphere turned on its side and projected onto a plane.`,b.appendChild(y);const h=i({canvas:c,attributes:{antialias:!0,preserveDrawingBuffer:!0},extensions:["ANGLE_instanced_arrays","OES_standard_derivatives"]}),m=d(h,t,e.m,{theta:.7,phi:.1},o);m.render(r,p);let v=!1,w=0,g=0;c.addEventListener("mousedown",u=>{v=!0,w=u.clientX,g=u.clientY,c.style.cursor="grabbing"}),window.addEventListener("mousemove",u=>{v&&(m.rotate((u.clientX-w)*.01,(u.clientY-g)*.01),m.render(r,p),w=u.clientX,g=u.clientY)}),window.addEventListener("mouseup",()=>{v=!1,c.style.cursor="grab"}),a(b),l.then(()=>{m.destroy(),h.destroy()})})()},inputs:["shapeTrajectory","initialConditions","width","createREGL","createOrbitShapeSphere","createDrawLines","display","invalidation"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-213"),expanded:[],variables:[]},{id:213,body:(t,e,n)=>{const i=t&&e?n(t,e.m):{minX:-2,maxX:2,minY:-2,maxY:2},d=i.maxX-i.minX,o=i.maxY-i.minY,a=Math.max(d,o),l=(i.minX+i.maxX)/2,r=(i.minY+i.maxY)/2,p=[l-a/2,l+a/2],c=[r-a/2,r+a/2];return{projBounds:i,projRangeX:d,projRangeY:o,projRange:a,projCenterX:l,projCenterY:r,projXDomain:p,projYDomain:c}},inputs:["trajectory","initialConditions","computeProjectedBounds"],outputs:["projBounds","projRangeX","projRangeY","projRange","projCenterX","projCenterY","projXDomain","projYDomain"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-214"),expanded:[],variables:[]},{id:214,body:(t,e,n)=>{function i(d,o,a=t,l=e){return n.plot({width:d,height:o,marginTop:20,marginRight:20,marginLeft:50,marginBottom:40,style:{backgroundColor:"transparent",maxWidth:"none",position:"absolute",top:"0",left:"0"},x:{domain:a,tickSpacing:80,label:"n₁ / (1 - n₂)"},y:{domain:l,tickSpacing:80,label:"n₃ / (1 - n₂)"},marks:[n.ruleX([0],{stroke:"#0002"}),n.ruleY([0],{stroke:"#0002"})]})}return{createProjPlot:i}},inputs:["projXDomain","projYDomain","Plot"],outputs:["createProjPlot"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-215"),expanded:[],variables:[]},{id:215,body:(t,e,n,i)=>({projStack:t({layers:[{id:"regl",element:e(n,{optionalExtensions:["ANGLE_instanced_arrays"],attributes:{antialias:!0,preserveDrawingBuffer:!0}})},{id:"plot",element:({width:o,height:a})=>i(o,a)}]})}),inputs:["createElementStack","reglElement","createREGL","createProjPlot"],outputs:["projStack"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-216"),expanded:[],variables:[]},{id:216,body:(t,e,n,i)=>({projAxes:t({d3:e,element:n.element,xScale:n.elements.plot.scale("x"),yScale:n.elements.plot.scale("y"),aspectRatio:1,scaleExtent:[.1,100],onChange:({xDomain:o,yDomain:a})=>{const l=i(n.width,n.height,o,a);n.elements.plot.replaceWith(l),n.elements.plot=l,n.dispatchEvent(new CustomEvent("update")),n.elements.regl?.value&&(n.elements.regl.value.dirty=!0)}})}),inputs:["createZoomableAxes","d3","projStack","createProjPlot"],outputs:["projAxes"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-217"),expanded:[],variables:[]},{id:217,body:(t,e,n,i,d)=>{const o=document.createElement("figure");o.appendChild(t.element);const a=document.createElement("figcaption");return a.innerHTML="Stereographic projection of the shape sphere trajectory. The two visible collision points are marked. The third (blue) is at the pole of projection (infinity).",o.appendChild(a),e(n(o,{width:Math.min(i,640),height:Math.min(400,Math.floor(i*.625)),onResize(l,r,p){t.resize(r,p),d.updateScales(t.elements.plot.scale("x"),t.elements.plot.scale("y")),t.elements.regl?.value&&(t.elements.regl.value.dirty=!0)}})),{projFigure:o,projCaption:a}},inputs:["projStack","display","expandable","width","projAxes"],outputs:["projFigure","projCaption"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-218"),expanded:[],variables:[]},{id:218,body:(t,e,n,i,d,o,a,l,r)=>{(()=>{const p=t.elements.regl.value;if(!p||!e||!n)return;const c=i(p,e,n.m,d,o,{speed:a.speed},l);p.dirty=!0;const b=p.frame(y=>{p.dirty&&(p.dirty=!1,c.render(y.time),p.dirty=!0)});r.then(()=>{b.cancel(),c.destroy()})})()},inputs:["projStack","trajectory","initialConditions","createShapeProjection2D","projAxes","reglAxesViewport","drawingParams","createDrawLines","invalidation"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-219"),expanded:[],variables:[]},{id:219,body:(t,e)=>t`### Free group word

From here, our task is conceptually simple. We walk along the projected shape of the orbit and note every time it completes a loop, either clockwise or counterclockwise, around one of the two punctures. The result is a [*free group word*](https://en.wikipedia.org/wiki/Free_group) and (at last!) identifies our orbit in the topological sense. We record an ${e`a`} for clockwise loops around the righthand puncture and ${e`a^{-1}`} (which we abbreviate as ${e`A`}) for counterclockwise loops. Similarly we record ${e`b`} and ${e`B`}, respectively, for counterclockwise and clockwise loops around the lefthand puncture.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});f({root:document.getElementById("cell-220"),expanded:[],variables:[]},{id:220,body:(t,e,n)=>{(()=>{const i=Math.min(t,350),d=Math.floor(i*.7),o=e.create("svg").attr("id","free-group-elements").attr("width",i).attr("height",d).style("max-width","100%").style("height","auto"),a="#49a1c9",l="#666",r=`arrow-fg-${Math.random().toString(36).slice(2)}`,p=`arrow-ax-${Math.random().toString(36).slice(2)}`,c=o.append("defs");c.append("marker").attr("id",r).attr("viewBox","0 -5.5 13 11").attr("refX",12).attr("refY",0).attr("markerWidth",13).attr("markerHeight",11).attr("orient","auto").append("path").attr("d","M0,-5.5L13,0L0,5.5").attr("fill",a),c.append("marker").attr("id",p).attr("viewBox","0 -4 10 8").attr("refX",9).attr("refY",0).attr("markerWidth",10).attr("markerHeight",8).attr("orient","auto").append("path").attr("d","M0,-4L10,0L0,4").attr("fill",l);const b=3,y=.9,h=e.scaleLinear().domain([-b,b]).range([0,i]),m=e.scaleLinear().domain([-b*d/i,b*d/i]).range([d,0]),v=e.line().x(u=>h(u[0])).y(u=>m(u[1]));o.append("g").selectAll("path").data([[[-b*y,0],[b*y,0]],[[0,-b*y*d/i],[0,b*y*d/i]]]).join("path").attr("d",v).attr("stroke",l).attr("fill","none").attr("stroke-width",1).attr("marker-start",`url(#${p})`).attr("marker-end",`url(#${p})`),o.append("g").selectAll("circle").data([[-1,0],[1,0]]).join("circle").attr("cx",u=>h(u[0])).attr("cy",u=>m(u[1])).attr("r",h(1)-h(0)).attr("stroke","white").attr("stroke-width",5).attr("fill","none"),o.append("g").selectAll("circle").data([[-1,0],[1,0]]).join("circle").attr("cx",u=>h(u[0])).attr("cy",u=>m(u[1])).attr("r",h(1)-h(0)).attr("stroke",a).attr("stroke-width",2).attr("fill","none"),o.append("g").selectAll("circle").data([[-1,0],[1,0]]).join("circle").attr("cx",u=>h(u[0])).attr("cy",u=>m(u[1])).attr("r",6).attr("fill",(u,S)=>S===0?"#e6332a":"#33cc55").attr("stroke","white").attr("stroke-width",2),o.append("circle").attr("cx",h(0)).attr("cy",m(0)).attr("r",4).attr("fill",a),o.append("g").selectAll("path").data([[[1,1],[1.001,1]],[[-1,1],[-1.001,1]],[[-1,-1],[-.999,-1]],[[1,-1],[.999,-1]]]).join("path").attr("d",v).attr("stroke",a).attr("fill","none").attr("stroke-width",1.5).attr("marker-end",`url(#${r})`),o.append("g").selectAll("text").data([{xy:[-1,1],text:"b"},{xy:[1,1],text:"a"}]).join("text").text(u=>u.text).attr("x",u=>h(u.xy[0])).attr("y",u=>m(u.xy[1])).attr("font-size","17px").attr("font-family","serif").attr("font-style","italic").attr("dx",-3).attr("dy",-10);const w=document.createElement("figure");w.appendChild(o.node());const g=document.createElement("figcaption");g.innerHTML="Our free group elements, <em>a</em> and <em>b</em>.",w.appendChild(g),n(w)})()},inputs:["width","d3","display"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-207"),expanded:[],variables:[]},{id:207,body:(t,e,n,i,d)=>{t(e`For the ${n`${i?.name||""}`} orbit, we compute the free group word: *<span style="word-break:break-all">${d}</span>*.

Many patterns lie within. Figure-eight orbits, for example, follow a repeating *BabA* pattern. Other classes of orbits follow more complicated patterns. To preempt an issue you may have noticed, *yes*, there is indeed ambiguity in this classification. We could have chosen one of the other puncture points about which to project. For some families of orbits this makes a difference; for others it does not. Orbits are similarly equivalent under time reversal so that the free group word *Ab* is equivalent to *Ba*. Šuvakov and Dmitrašinović have a much more detailed discussion of these considerations in their paper [Linear stability of periodic three-body orbits with zero angular momentum and topological dependence of Kepler's third law: a numerical test](https://arxiv.org/abs/1705.03728). It's worth a read!`)},inputs:["display","md","tex","initialConditions","freeGroupWord"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});f({root:document.getElementById("cell-900"),expanded:[],variables:[]},{id:900,body:(t,e)=>{t(e`<style>
  dl.inline-flex {
    display: flex;
    flex-flow: row wrap;
    max-width: 640px;
  }
  dl.inline-flex dt {
    flex: 0 0 25%;
    min-width: 130px;
    font-weight: 600;
    margin: 0;
  }
  dl.inline-flex dd {
    flex: 0 0 75%;
    margin: 0 0 0 auto;
  }
  .orbit-selector select {
    margin-top: 0.25em;
  }
  @media (max-width: 590px) {
    dl.inline-flex dt { flex: 0 0 100%; }
    dl.inline-flex dd { flex: 0 0 95%; }
  }
</style>`)},inputs:["display","html"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});
