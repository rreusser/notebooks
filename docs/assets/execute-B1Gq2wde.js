import{cycleBuffers as U}from"./buffers-GrqrZRML.js";import{e as h}from"./fft-BKdtHrAL.js";function N(u,f){const t=f[0]*f[1]*4*Float32Array.BYTES_PER_ELEMENT;return u.createBuffer({label:"Temporary vec4 buffer",size:t,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC})}async function C(u,f){const{device:t,pipelines:n,buffers:e,config:i}=u,[o,s]=i.N;console.log(`[Init] Starting initialization with n=${f}, resolution=${o}x${s}`),console.log("[Init] Pipeline exists:",!!n.initialize),console.log("[Init] Buffer V[0] exists:",!!e.V[0]),console.log("[Init] Buffer V[0] size:",e.V[0].size);const a=t.createBuffer({label:"Initialize params",size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),r=new ArrayBuffer(16),c=new Uint32Array(r),b=new Float32Array(r);c[0]=o,c[1]=s,b[2]=f,console.log("[Init] Uniform buffer data:",{resolution_x:c[0],resolution_y:c[1],n:b[2]}),t.queue.writeBuffer(a,0,r);const l=t.createBindGroup({label:"Initialize bind group",layout:n.bindGroupLayouts.initialize,entries:[{binding:0,resource:{buffer:e.V[0]}},{binding:1,resource:{buffer:a}}]});console.log("[Init] Bind group created");const p=Math.ceil(o/16),d=Math.ceil(s/16);console.log(`[Init] Dispatching ${p}x${d}x1 workgroups (${p*d*256} threads total)`);const g=t.createCommandEncoder({label:"Initialize encoder"}),m=g.beginComputePass({label:"Initialize pass"});m.setPipeline(n.initialize),m.setBindGroup(0,l),m.dispatchWorkgroups(p,d,1),m.end();const B=g.finish();console.log("[Init] Command buffer created"),t.queue.submit([B]),console.log("[Init] Commands submitted to GPU"),await t.queue.onSubmittedWorkDone(),console.log("[Init] GPU work completed"),console.log("[Init] Performing forward FFT: V[0] -> Vhat[0]"),h({device:t,pipelines:n.fft,input:e.V[0],output:e.Vhat[0],temp:e.fftTemp,N:o,forward:!0,splitNormalization:!0}),console.log("[Init] Computing ABhat[0] from Vhat[0]"),A(u,e.Vhat[0],e.V[0],e.ABhat[0]),console.log("[Init] Copying state to previous timestep buffers"),w(t,e.Vhat[0],e.Vhat[1]),w(t,e.ABhat[0],e.ABhat[1]),await t.queue.onSubmittedWorkDone(),console.log("[Init] All initialization FFTs complete"),a.destroy(),console.log("[Init] Initialization complete")}function A(u,f,t,n){const{device:e,pipelines:i,buffers:o,config:s}=u,[a,r]=s.N,c=N(e,s.N),b=e.createBuffer({label:"Differentiate params",size:32,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),l=new Uint32Array(8);l[0]=a,l[1]=r,new Float32Array(l.buffer)[2]=s.dx[0],new Float32Array(l.buffer)[3]=s.dx[1],e.queue.writeBuffer(b,0,l);const p=e.createBindGroup({layout:i.bindGroupLayouts.differentiate,entries:[{binding:0,resource:{buffer:f}},{binding:1,resource:{buffer:c}},{binding:2,resource:{buffer:b}}]}),d=e.createCommandEncoder(),g=d.beginComputePass();g.setPipeline(i.differentiate),g.setBindGroup(0,p),g.dispatchWorkgroups(Math.ceil(a/16),Math.ceil(r/16),1),g.end(),e.queue.submit([d.finish()]),h({device:e,pipelines:i.fft,input:c,output:t,temp:o.fftTemp,N:a,forward:!1,splitNormalization:!0});const m=e.createBuffer({label:"Nonlinear params",size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),B=new Uint32Array([a,r]);e.queue.writeBuffer(m,0,B);const P=e.createBindGroup({layout:i.bindGroupLayouts.computeNonlinear,entries:[{binding:0,resource:{buffer:t}},{binding:1,resource:{buffer:c}},{binding:2,resource:{buffer:m}}]}),G=e.createCommandEncoder(),y=G.beginComputePass();y.setPipeline(i.computeNonlinear),y.setBindGroup(0,P),y.dispatchWorkgroups(Math.ceil(a/16),Math.ceil(r/16),1),y.end(),e.queue.submit([G.finish()]),h({device:e,pipelines:i.fft,input:c,output:n,temp:o.fftTemp,N:a,forward:!0,splitNormalization:!0}),c.destroy(),b.destroy(),m.destroy()}function F(u,f=!0){const{device:t,pipelines:n,buffers:e,config:i}=u,[o,s]=i.N;A(u,e.Vhat[1],e.V[1],e.ABhat[1]);const a=t.createBuffer({label:"BDF params",size:32,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),r=new Uint32Array(8);r[0]=o,r[1]=s,new Float32Array(r.buffer)[2]=i.dx[0],new Float32Array(r.buffer)[3]=i.dx[1],new Float32Array(r.buffer)[4]=i.dt,new Float32Array(r.buffer)[5]=0,new Float32Array(r.buffer)[6]=i.nu[0],new Float32Array(r.buffer)[7]=i.nu[1],t.queue.writeBuffer(a,0,r);const c=t.createBindGroup({layout:n.bindGroupLayouts.bdfUpdate,entries:[{binding:0,resource:{buffer:e.Vhat[0]}},{binding:1,resource:{buffer:e.Vhat[1]}},{binding:2,resource:{buffer:e.ABhat[0]}},{binding:3,resource:{buffer:e.ABhat[1]}},{binding:4,resource:{buffer:e.Vhat[2]}},{binding:5,resource:{buffer:a}}]}),b=t.createCommandEncoder(),l=b.beginComputePass();if(l.setPipeline(n.bdfUpdate),l.setBindGroup(0,c),l.dispatchWorkgroups(Math.ceil(o/16),Math.ceil(s/16),1),l.end(),t.queue.submit([b.finish()]),U(e.Vhat),U(e.V),U(e.ABhat),f){const p=N(t,i.N);h({device:t,pipelines:n.fft,input:e.Vhat[1],output:p,temp:e.fftTemp,N:o,forward:!1,splitNormalization:!0});const d=t.createBuffer({label:"Extract real params",size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),g=new Uint32Array([o,s]);t.queue.writeBuffer(d,0,g);const m=t.createBindGroup({layout:n.bindGroupLayouts.extractReal,entries:[{binding:0,resource:{buffer:p}},{binding:1,resource:{buffer:e.fftTemp[0]}},{binding:2,resource:{buffer:d}}]}),B=t.createCommandEncoder(),P=B.beginComputePass();P.setPipeline(n.extractReal),P.setBindGroup(0,m),P.dispatchWorkgroups(Math.ceil(o/16),Math.ceil(s/16),1),P.end(),t.queue.submit([B.finish()]),h({device:t,pipelines:n.fft,input:e.fftTemp[0],output:e.Vhat[1],temp:[e.fftTemp[1],p],N:o,forward:!0,splitNormalization:!0}),p.destroy(),d.destroy()}a.destroy()}function w(u,f,t){const n=u.createCommandEncoder({label:"Copy buffer encoder"});n.copyBufferToBuffer(f,0,t,0,f.size),u.queue.submit([n.finish()])}export{C as performInitialization,F as performIteration};
