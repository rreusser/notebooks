import{d as s,_ as G}from"./index-ByB2dbry.js";s({root:document.getElementById("cell-2779"),expanded:[],variables:[]},{id:2779,body:function(i){return i`# Toiletpaperfullerenes and Charmin Nanotubes

Toilet paper tubes have the curious property that you can flatten them, cut out loops, and link the loops together without fasteners.

For a couple years now, I've hoarded every used cardboard toilet paper tube that's passed through our home. Feeling inspired after seeing a tweet (with apologies, author long since forgotten), I stockedpiled tubes and built a [Buckyball](https://en.wikipedia.org/wiki/Buckminsterfullerene). Vines in the bedroom now climb a six foot [carbon nanotube](https://en.wikipedia.org/wiki/Carbon_nanotube) trellis (*Charmin nanotube*, if you will, and not exactly *nano* either, for that matter). And [Alison Martin's work](https://mastodon.social/@alisonmartin57) continuously inspires me.

*Update: I've tracked down some precedent, though perhaps not the actual tweet that inspired me as this seems to be a popular project! See tweets by [@Ian_Willey](https://twitter.com/Ian_Willey/status/1119257024649474049) andâ€”with excellent instructionsâ€”[@mrallanmaths](https://twitter.com/mrallanmaths/status/1125438241774166017).*

This notebook represents my attempt to step things up. It provides some basic instructions and suggestions, as well as a simulator to help the toilet-paper-tube-constrained make the best use of what they have. In hindsight, the simulation certainly wasn't necessary. And at any rate, there's really no upper limit to tackling this with trial and error; the recyclability means there's no need to open a family dialogue about where to store the large geometric constructions that result.
`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-2750"),expanded:[],variables:[]},{id:2750,body:async function(i,e,a){return i`
<figure>
  <img src="${await e(new URL("spikyball.jpg",import.meta.url).href).url()}" width="${Math.min(a,600)}">
  <figcaption>The finished product, composed of 49 recycled toilet paper tubes (and which I realize after building sorta brings things full circle and looks a bit like a coronavirus).</figcaption>
</figure>
`},inputs:["html","FileAttachment","width"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3337"),expanded:[],variables:[]},{id:3337,body:function(i,e){return i`## Fabrication

My brand is regular Trader Joe's toilet paper, though I have no reason to believe anything about the brand is particularly important, beyond consistency of diameterâ€”with the exception of those cowards who make tube-free toilet paper rolls. Those won't work. I've considered side-stepping material collection and waiting to buy tag board when shelter-in-place eases, though to be honest, the recycled nature of the raw materials is a primary factor which draws me to this project.

Accumulating raw materials is simple. Flatten the tubes andâ€”if you live with familyâ€”stash them somewhere a family member is unlikely to find them, lest you be required to explain yourself. Conversely, you may wish to avoid much wailing and gnashing of teeth and discuss your hoarding early on to prevent your stash from getting casually recycled.

The pattern below illustrates the required cuts. The angle required for three edges to join gracefully is ${e`30^\circ`}, which makes the measurements easy. I've found a far easier method than measuring every tube though is to add opposing marks to one tube and use it as a template. I get about eight strips per tube. 

<em>Update: I've trended toward thicker strips, as it makes the final constructions a bit more robust. The only limit on thickness is they can't be so thick that the joints on opposite ends interfere and prevent linking. Further simplifying, even cutting strips at flat 0Ëš angles produces a visually appealing look and may save a bit of trouble.</em>`},inputs:["md","tex"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3328"),expanded:[],variables:[]},{id:3328,body:async function(i,e,a){return i`
<figure>
  <img src="${await e(new URL("measurements.jpg",import.meta.url).href).url()}" width="${Math.min(a,400)}">
  <figcaption>The pattern of cuts illustrated on a flattened toilet paper tube.</figcaption>
</figure>
`},inputs:["html","FileAttachment","width"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3354"),expanded:[],variables:[]},{id:3354,body:function(i,e){return i`Assembling the joints is straightforward. The pieces lock together in pleasing ${e`120^\circ`} angles, requiring no additional fasteners up until the very last piece of the model, which requires a cut and some tape.

The illustration below shows how the joints interlock. I'd give more instruction, but if you actually want to do this, there's no better way to learn than through experimentation. After some fumbling around, I learned to always attach new pieces by branching off in the same direction, after which it becomes quite repetitive.`},inputs:["md","tex"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3332"),expanded:[],variables:[]},{id:3332,body:async function(i,e,a){return i`
<figure>
  <img src="${await e(new URL("interlock@1.jpg",import.meta.url).href).url()}" width="${Math.min(a,400)}">
  <figcaption>Three loops link together to form an interlocked joint.</figcaption>
</figure>
`},inputs:["html","FileAttachment","width"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3379"),expanded:[],variables:[]},{id:3379,body:function(i){return i`Assembling larger patterns is where things start to get frustrating and difficult. I have little advice here except to rely heavily on patterns, examples, and patience. And perhaps the simulator below. For inspiration, the best paper I found is ["The Topology of Fullerenes"](https://onlinelibrary.wiley.com/doi/full/10.1002/wcms.1207) by Schwerdtfeger, Wirz, and Avery.

In my initial attempt, I started making a torus and failed to appreciate just how much of a material shortage I'd encounter. After some iteration though, I tried out different constructions. My favorite so far is our rabbit tunnel.`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-4115"),expanded:[],variables:[]},{id:4115,body:async(i,e)=>i`<figure>
  <img src="${await e(new URL("IMG_3353.jpg",import.meta.url).href).url()}">
  <figcaption>A semi-completed Y-joint tunnel with rabbit (barely visible, hiding from curious dog) inside.</figcaption>
</figure>`,inputs:["md","FileAttachment"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});s({root:document.getElementById("cell-3431"),expanded:[],variables:[]},{id:3431,body:function(i){return i`With quiet sheltered-in-place weekends and little access to toilet paper (at which point these constructions quickly became the least of my worries), I dismantled my initial constructions, explored construction via simulation, and eventually settled on the model pictured at the top of the notebook. The rest of this notebook steps through simulation of these models.

I now return to the material collection phase. ðŸ§»ðŸ§»ðŸ§»ðŸ§»ðŸ§»ðŸ§»ðŸ§»`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-2675"),expanded:[],variables:[]},{id:2675,body:function(i){return i`## Simulation`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3466"),expanded:[],variables:[]},{id:3466,body:function(i){return i`We'll get right to the point and present the finished simulator, followed by an explanation of how it works. It's really non-scientific in the sense that I've pulled forces and energies out of the sky to get it to look nice. It's not without some physical justification, but there's little motivation by legit physical chemistry, and the optimization method is staggeringly inefficient.

We represent the model as a graph consisting of vertices and edges. The topology follows one rule:

- Every vertex has no more than three outgoing edges.

This rule is enough to constrain the topology, though it says nothing about the particular geometry of the result in three-dimensional space.

**Notes**:
- You'll need a desktop computer to use the simulator.
- The genus 3 torus comes from the lovely [construction of Alison Martin](https://twitter.com/alisonmartin57/status/1254050723077279745), whose work has certainly inspired a lot of this exploration to begin with!
- Most of the other constructions come from the paper listed above, ["The Topology of Fullerenes"](https://onlinelibrary.wiley.com/doi/full/10.1002/wcms.1207) by Schwerdtfeger, Wirz, and Avery.
- I chose a regrettable data structure (a simple list of edges and vertices) which makes faces, as much as I'd love to display them, difficult to work out. My apologies. ðŸ¤·â€`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-2607"),expanded:[],variables:[]},{id:2607,body:async function(e,a,o,t){function n(r){return e(r,a([],o(r),-1))}return{Starter:{vertices:[[-1,-1,0],[-1,1,0],[-.5,0,0],[.5,0,0],[1,-1,0],[1,1,0]],edges:[[0,2],[1,2],[2,3],[3,4],[3,5]]},"C60 Fullerene":n(await t(new URL("fullerene.json",import.meta.url).href).json()),"C180 Fullerene":n(await t(new URL("c180-fullerene.json",import.meta.url).href).json()),"C320 Fullerene":n(await t(new URL("c320-fullerene.json",import.meta.url).href).json()),"C500 Fullerene":n(await t(new URL("c500-fullerene.json",import.meta.url).href).json()),Capsule:n(await t(new URL("capsule.json",import.meta.url).href).json()),"C240 torus":n(await t(new URL("c240-torus.json",import.meta.url).href).json()),"C360 torus":n(await t(new URL("c360-torus.json",import.meta.url).href).json()),Dodecahedron:n(await t(new URL("dodecahedron.json",import.meta.url).href).json()),"C28[5,7]-D7d":n(await t(new URL("c28-57-d7d.json",import.meta.url).href).json()),"C28-Td[5,6]":n(await t(new URL("c28-td-56.json",import.meta.url).href).json()),"C260-I[5,7]":n(await t(new URL("spiky@1.json",import.meta.url).href).json()),"C360-D5h[5,6,7]":n(await t(new URL("C310-D5h-567.json",import.meta.url).href).json()),"C120-5d[5,6,7] peanut fulleroid":n(await t(new URL("c120-peanut-fulleroid.json",import.meta.url).href).json()),"C168-D3d[5,6,7] peanut fulleroid":n(await t(new URL("double-fullerene.json",import.meta.url).href).json()),"Double torus":n(await t(new URL("double-torus.json",import.meta.url).href).json()),"Genus-3 Torus":n(await t(new URL("mess-of-vertices.json",import.meta.url).href).json()),"Genus-3 Torus (extended)":n(await t(new URL("genus-3-extended-torus@1.json",import.meta.url).href).json()),"Not quite Klein Quartic":n(await t(new URL("klein-quartic@1.json",import.meta.url).href).json()),"Metadodecahedron (reduce the iterations per frame!)":n(await t(new URL("metafullerene-2.json",import.meta.url).href).json()),"Bent tube":n(await t(new URL("model (1).json",import.meta.url).href).json())}},inputs:["translateGraph","vec3scale","computeCentroid","FileAttachment"],outputs:void 0,output:"presetGraphs",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-2606"),expanded:[],variables:[]},{id:2606,body:function(e,a){return e({options:Object.keys(a),value:"C260-I[5,7]",title:"Preset"})},inputs:["select","presetGraphs"],outputs:void 0,output:"viewof$presetGraph",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});s({root:document.getElementById("cell-2648"),expanded:[],variables:[]},{id:2648,body:function(i,e){return i.download(()=>new Blob([JSON.stringify({vertices:e.state.graph.vertices,edges:e.state.graph.edges})],{type:"application/json"}),"model.json","Download current graph as JSON")},inputs:["DOM","ctx"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3814"),expanded:[],variables:[]},{id:3814,body:function(e){return e({value:"Reset"})},inputs:["button"],outputs:void 0,output:"viewof$reset",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});s({root:document.getElementById("cell-232"),expanded:[],variables:[]},{id:232,body:function(e){return e({value:"simulate",options:["simulate"]})},inputs:["checkbox"],outputs:void 0,output:"viewof$simulate",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});s({root:document.getElementById("cell-4061"),expanded:[],variables:[]},{id:4061,body:function(e){return e({description:"Axial strain coloring",min:0,max:5,step:.1,value:1.5})},inputs:["slider"],outputs:void 0,output:"viewof$strainColoring",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});s({root:document.getElementById("cell-4023"),expanded:[],variables:[]},{id:4023,body:function(e){return e({min:0,max:5,step:.5,value:3,description:"Border width"})},inputs:["slider"],outputs:void 0,output:"viewof$borderWidth",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});s({root:document.getElementById("cell-4018"),expanded:[],variables:[]},{id:4018,body:function(e){return e({min:.5,max:5,step:.5,value:3,description:"Vertex size"})},inputs:["slider"],outputs:void 0,output:"viewof$pointSize",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});s({root:document.getElementById("cell-1010"),expanded:[],variables:[]},{id:1010,body:function(i,e,a,o,t,n){const r=e(a,o);return t`
    <figure style="max-width:900px">
      ${r}
      <figcaption>${n`Select the [starter preset above](#presetGraph) to experiement. Click a vertex to select, then either click to add a new vertex or click an existing vertex to create a new connection. <kbd>Spacebar</kbd> to deselect. <kbd>Backspace</kbd> deletes vertices, <kbd>s</kbd>/<kbd>c</kbd> splits/collapses vertices of degree 2. <kbd>e</kbd> to explode a vertex. Drag to rotate, <kbd>shift</kbd> + drag to pan, and <kbd>a</kbd> to aim the camera at the selected vertex.`}</figcaption>
    </figure>
  `},inputs:["updateParameters","drawGraph","ctx","invalidation","html","md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-2635"),expanded:[],variables:[]},{id:2635,body:function(e){return e({description:"Iterations per frame",min:0,max:200,step:1,value:30})},inputs:["slider"],outputs:void 0,output:"viewof$iterations",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});s({root:document.getElementById("cell-218"),expanded:[],variables:[]},{id:218,body:function(e){return e({min:0,max:2,step:.01,value:1,description:"Axial spring constant"})},inputs:["slider"],outputs:void 0,output:"viewof$k",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});s({root:document.getElementById("cell-276"),expanded:[],variables:[]},{id:276,body:function(e){return e({min:.1,max:2,step:.01,value:1,description:"Equilibrium length, l0"})},inputs:["slider"],outputs:void 0,output:"viewof$l0",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});s({root:document.getElementById("cell-393"),expanded:[],variables:[]},{id:393,body:function(e){return e({min:1,max:180,step:1,value:150,description:"Equilibrium bending angle, Î¸â‚€"})},inputs:["slider"],outputs:void 0,output:"viewof$theta0",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});s({root:document.getElementById("cell-411"),expanded:[],variables:[]},{id:411,body:function(e){return e({min:0,max:2,step:.01,value:.3,description:"Bending spring constant"})},inputs:["slider"],outputs:void 0,output:"viewof$kBend",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});s({root:document.getElementById("cell-1270"),expanded:[],variables:[]},{id:1270,body:function(e){return e({min:0,max:.2,step:.01,value:.1,description:"Torsional spring constant"})},inputs:["slider"],outputs:void 0,output:"viewof$kTorsion",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});s({root:document.getElementById("cell-3863"),expanded:[],variables:[]},{id:3863,body:function(e,a,o,t){return a(o[t])},inputs:["reset","cloneGraph","presetGraphs","presetGraph"],outputs:void 0,output:"graphCopy",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3011"),expanded:[],variables:[]},{id:3011,body:function(e,a,o,t,n){e.state=a(o),t(e.state,e.camera,n)},inputs:["ctx","createState","graphCopy","createInteractions","invalidation"],outputs:void 0,output:"updateGraph",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3050"),expanded:[],variables:[]},{id:3050,body:function(e,a,o,t,n,r,l,u,d){a.state.k=o,a.state.l0=t,a.state.theta0=n,a.state.kBend=r*t*t,a.state.kTorsion=l*t*t,a.state.iterations=u,a.state.simulate=d},inputs:["updateGraph","ctx","k","l0","theta0","kBend","kTorsion","iterations","simulate"],outputs:void 0,output:"updateParameters",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-2512"),expanded:[],variables:[]},{id:2512,body:function(i){return i`## Physical model`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3094"),expanded:[],variables:[]},{id:3094,body:function(i){return i`

The sections below outline how the simulation works. We take a simple approach to computing physical configuration in three dimensions. We write down an energy function that's minimized by nice, physically pleasant configurations, then directly minimize the energy via [gradient descent](https://en.wikipedia.org/wiki/Gradient_descent) on the vertex positions.

The concept of gradient descent is simple. We compute the change in energy with respect to independent changes in each vertex position, then move each vertex slightly downhill, opposite the direction of the gradient. There are more efficient ways to minimize energy, but we simply take a simultaneous small step for all vertices.
`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3096"),expanded:[],variables:[]},{id:3096,body:async function(i,e,a){return i`
<figure>
  <img src="${await e(new URL("descent.png",import.meta.url).href).url()}" width="${Math.min(a,500)}">
  <figcaption><p>Gradient descent minimizes energy by taking incremental steps downhill.</p></figcaption>
</figure>
`},inputs:["html","FileAttachment","width"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-2718"),expanded:[],variables:[]},{id:2718,body:function(i,e){return i`### Mathematical Statement

We write an arbitrary energy function for our graph that maps the configuration to a single real number, ${e.block`E = E(v_i, e_j) \in \mathbb{R}`} where ${e`v_i`} and ${e`e_j`} are the ${e`i^{th}`} vertex and ${e`j^{th}`} edge of the graph, respectively. ${e`E`} here is any useful function, picked out of the sky, such that it's minimized when the graph reaches a desirable configuration. We compute the gradient with respect to the *x-y-z* coordinates of all ${e`N`} vertex positions, ${e.block`\nabla E = \left(\frac{\partial E}{\partial v_{0,x}}, \frac{\partial E}{\partial v_{0,y}}, \frac{\partial E}{\partial v_{0,z}}, \frac{\partial E}{\partial v_{1,x}}, \ldots, \frac{\partial E}{\partial v_{N - 1,z}}\right).`} In the sense of rolling down a hill, this gradient points uphill so that we update the solution in the direction of a small downhill step. We compute the ${e`n + 1^{th}`} step of vertex ${e`v_i`} as ${e.block`v_i^{n + 1} = v_i^n - \gamma \frac{\partial E}{\partial v_i}`} where ${e`\gamma`} is some small number.

It's no more complicated than that, but we must now select a function ${e`E`}.`},inputs:["md","tex"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3166"),expanded:[],variables:[]},{id:3166,body:function(i,e){return i`## Axial stiffness

We start simple and add lengthwise (axial) stiffness to enforce uniform length. Given an edge connecting vertices ${e`a`} and ${e`b`}, we denote the length of the edge ${e`r_{ab}`} and the equilibrium length ${e`r_0`}.`},inputs:["md","tex"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3583"),expanded:[],variables:[]},{id:3583,body:async function(i,e,a,o){return i`
<figure>
  <img src="${await e(new URL("axial.png",import.meta.url).href).url()}" width="${Math.min(a,300)}">
  <figcaption><p>Points ${o`a`} and ${o`b`} are separated by radius ${o`r_{ab}`}.</p></figcaption>
</figure>
`},inputs:["html","FileAttachment","width","tex"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3646"),expanded:[],variables:[]},{id:3646,body:function(i,e){return i`The minimum-energy configuration occurs when ${e`r_{ab} = r_0`}, so we construct an energy function ${e.block`E_{axial} = k_{axial} (r_{ab} - r_0)^2`} where ${e`k_{axial}`} is the axial stiffness. Note that ${e`E_{axial} = 0`} when ${e`r_{ab} = r_0`}. Since ${e`E_{axial}`} is strictly non-negative, this is just fancy way of saying that the energy can't get any lower than when the length is equal to the desired length; it's the bottom of the hill.

If we differentiate this function with respect to the position of the two endpoints, then we obtain the gradient. For example, the energy gradient with respect to the coordinates of vertex ${e`a`} is ${e.block`
\begin{aligned}\frac{\partial E}{\partial v_{a, x}} &= k_{axial}  \left(1 - \frac{r_0}{r_{ab}}\right) \left(v_{a,x} - v_{b, x}\right)\end{aligned} \\
\begin{aligned}\frac{\partial E}{\partial v_{a, y}} &= k_{axial}  \left(1 - \frac{r_0}{r_{ab}}\right) \left(v_{a,y} - v_{b, y}\right)\end{aligned} \\
\begin{aligned}\frac{\partial E}{\partial v_{a, z}} &= k_{axial}  \left(1 - \frac{r_0}{r_{ab}}\right) \left(v_{a,z} - v_{b, z}\right)\end{aligned}
`} The gradient with respect to the coordinates of vertex ${e`b`} are equal and opposite.

The function below iterates over all edges and accumulates the energy gradient into a single array.`},inputs:["md","tex"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-158"),expanded:[],variables:[]},{id:158,body:function(e){return function(o,t,n,r){for(var l=0;l<t.edges.length;l++){var u=t.edges[l],d=3*u[0],p=3*u[1],c=t.vertices[u[0]],y=t.vertices[u[1]],f=e(c,y),b=r*(1-n/f),E=b*(c[0]-y[0]),B=b*(c[1]-y[1]),j=b*(c[2]-y[2]);o[d+0]+=E,o[p+0]-=E,o[d+1]+=B,o[p+1]-=B,o[d+2]+=j,o[p+2]-=j}return o}},inputs:["vec3distance"],outputs:void 0,output:"computeSpringEnergyGradient",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3158"),expanded:[],variables:[]},{id:3158,body:function(){return{vertices:[[-1,0,0],[-.5,-.866,0],[.5,-.866,0],[1,0,0],[.5,.866,0],[-.5,.866,0]],edges:[[0,1],[1,2],[2,3],[3,4],[4,5],[5,0]]}},inputs:[],outputs:void 0,output:"graph2",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3128"),expanded:[],variables:[]},{id:3128,body:function(i,e,a,o,t){const n=e(a,o);return t`
    <figure>
      ${n}
      <figcaption><p>Axial stiffness enforces edge length but doesn't adequately constrain the structure. Move the points in three dimensions and observe that the structure is not maintained.</p></figcaption>
    </figure>
  `},inputs:["updateParameters2","drawGraph","ctx2","invalidation","html"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3174"),expanded:[],variables:[]},{id:3174,body:function(e){return e({min:.1,max:2,step:.01,value:1,description:"Equilibrium length"})},inputs:["slider"],outputs:void 0,output:"viewof$l0_2",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});s({root:document.getElementById("cell-3190"),expanded:[],variables:[]},{id:3190,body:function(e){return e({min:0,max:2,step:.01,value:1,description:"Axial spring constant"})},inputs:["slider"],outputs:void 0,output:"viewof$k_2",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});s({root:document.getElementById("cell-3119"),expanded:[],variables:[]},{id:3119,body:function(e,a,o,t,n){e.state=a(o),t(e.state,e.camera,n)},inputs:["ctx2","createState","graph2","createInteractions","invalidation"],outputs:void 0,output:"updateGraph2",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3125"),expanded:[],variables:[]},{id:3125,body:function(e,a,o,t,n){a.state.k=o,a.state.l0=t,a.state.theta0=n,a.state.kBend=0,a.state.kTorsion=0,a.state.iterations=1,a.state.simulate=!0},inputs:["updateGraph2","ctx2","k_2","l0_2","theta0"],outputs:void 0,output:"updateParameters2",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3687"),expanded:[],variables:[]},{id:3687,body:function(i){return i`## Dihedral stiffness`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3689"),expanded:[],variables:[]},{id:3689,body:async function(i,e,a,o){return i`
<figure>
  <img src="${await e(new URL("angular.png",import.meta.url).href).url()}" width="${Math.min(a,400)}">
  <figcaption><p>The segment connecting ${o`a`}, ${o`b`}, and ${o`c`} form angle ${o`\theta`}.</p></figcaption>
</figure>
`},inputs:["html","FileAttachment","width","tex"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3169"),expanded:[],variables:[]},{id:3169,body:function(i,e){return i`Axial stiffness alone clearly does not accomplish our goal of maintaining pleasant configurations. We now add an additional type of stiffness: *dihedral stiffness*. The rationale is that edges meet at a preferred angle, ${e`\theta_0`}. We therefore define the energy function ${e.block`E_{dihedral} = k_{dihedral}(\theta - \theta_0)^2.`} I'm sure chemistry has a lot to say about this topic, but it seems to be the case based on the structures produced that ${e`180^\circ`} is the desired pairwise dihedral angle, and that angles of ${e`120^\circ`} are simply the resulting compromise wherever three edges meet a vertex and result in three pairwise dihedral angles.`},inputs:["md","tex"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-333"),expanded:[],variables:[]},{id:333,body:function(e){return function(o,t,n,r){e(t);var l=Math.cos(n*Math.PI/180);function u(h,g,w,k,A,T){var M,S,_=g[0]-h[0],$=g[1]-h[1],V=g[2]-h[2],q=w[0]-h[0],R=w[1]-h[1],z=w[2]-h[2],D=Math.sqrt(_*_+$*$+V*V),U=Math.sqrt(q*q+R*R+z*z),O=_*q+$*R+V*z,L=O/(D*U),P=r*2*(L-l)/(D*U),W=D/U;M=P*(q-L/W*_),S=P*(_-L*W*q),o[3*k+0]-=M+S,o[3*A+0]+=M,o[3*T+0]+=S,M=P*(R-L/W*$),S=P*($-L*W*R),o[3*k+1]-=M+S,o[3*A+1]+=M,o[3*T+1]+=S,M=P*(z-L/W*V),S=P*(V-L*W*z),o[3*k+2]-=M+S,o[3*A+2]+=M,o[3*T+2]+=S}for(var d=0;d<t.edges.length;d++){var p=t.vertices[d],c=t.edgeAdjacency[3*d+0],y=t.edgeAdjacency[3*d+1],f=t.edgeAdjacency[3*d+2],b=c>=0?t.edges[c]:null,E=y>=0?t.edges[y]:null,B=f>=0?t.edges[f]:null,j=c>=0?b[0]===d?b[1]:b[0]:-1,I=y>=0?E[0]===d?E[1]:E[0]:-1,m=f>=0?B[0]===d?B[1]:B[0]:-1,x=t.vertices[j],C=t.vertices[I],v=t.vertices[m];x&&C&&u(p,x,C,d,j,I),C&&v&&u(p,C,v,d,I,m),v&&x&&u(p,v,x,d,m,j)}return o}},inputs:["computeAdjacency"],outputs:void 0,output:"computeJoinAngleEnergyGradient",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3171"),expanded:[],variables:[]},{id:3171,body:function(){return{vertices:[[-1,0,0],[-.5,-.866,0],[.5,-.866,0],[1,0,0],[.5,.866,0],[-.5,.866,0]],edges:[[0,1],[1,2],[2,3],[3,4],[4,5],[5,0]]}},inputs:[],outputs:void 0,output:"graph3",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3207"),expanded:[],variables:[]},{id:3207,body:function(i,e,a,o,t){const n=e(a,o);return t`
    <figure>
      ${n}
      <figcaption><p>The combination of dihedral and axial stiffness is enough to maintain sructure. Move the points in three dimensions and observe that the ring maintains its structure.</p></figcaption>
    </figure>
  `},inputs:["updateParameters3","drawGraph","ctx3","invalidation","html"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3203"),expanded:[],variables:[]},{id:3203,body:function(e){return e({min:0,max:2,step:.01,value:.3,description:"Bending spring constant"})},inputs:["slider"],outputs:void 0,output:"viewof$kBend_3",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});s({root:document.getElementById("cell-3205"),expanded:[],variables:[]},{id:3205,body:function(e){return e({min:1,max:180,step:1,value:120,description:"Equilibrium bending angle, Î¸â‚€"})},inputs:["slider"],outputs:void 0,output:"viewof$theta0_3",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});s({root:document.getElementById("cell-3198"),expanded:[],variables:[]},{id:3198,body:function(e,a,o,t,n){e.state=a(o),t(e.state,e.camera,n)},inputs:["ctx3","createState","graph3","createInteractions","invalidation"],outputs:void 0,output:"updateGraph3",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3200"),expanded:[],variables:[]},{id:3200,body:function(e,a,o,t){a.state.k=1,a.state.l0=1,a.state.theta0=o,a.state.kBend=t,a.state.kTorsion=0,a.state.iterations=1,a.state.simulate=!0},inputs:["updateGraph3","ctx3","theta0_3","kBend_3"],outputs:void 0,output:"updateParameters3",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3218"),expanded:[],variables:[]},{id:3218,body:function(i){return i`## Torsional stiffness`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3869"),expanded:[],variables:[]},{id:3869,body:function(i){return i`Finally we tackle torsion about an edge.`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-2866"),expanded:[],variables:[]},{id:2866,body:async function(i,e,a){return i`
<figure>
  <img src="${await e(new URL("torsion@1.png",import.meta.url).href).url()}" width="${Math.min(a,400)}">
  <figcaption><p>Stiffness of the cardboard from which we construct the model generates a moment which pushes the six vertices toward a flat configuration.</p></figcaption>
</figure>
`},inputs:["html","FileAttachment","width"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3704"),expanded:[],variables:[]},{id:3704,body:function(i,e){return i`The figure above shows six adjacent vertices connected by an edge. Torsional stiffness of the cardboard produces a rotational force which causes vertices ${e`c`}, ${e`d`}, ${e`e`}, and ${e`f`} to rotate toward flat.`},inputs:["md","tex"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-2876"),expanded:[],variables:[]},{id:2876,body:async function(i,e,a,o){return i`
<figure>
  <img src="${await e(new URL("torsion-setup.png",import.meta.url).href).url()}" width="${Math.min(a,600)}">
  <figcaption><p>We define unit vectors ${o`\alpha`},  ${o`\beta`}, and  ${o`\gamma`} based on the six adjacent vertices.</p></figcaption>
</figure>
`},inputs:["html","FileAttachment","width","tex"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-2898"),expanded:[],variables:[]},{id:2898,body:function(i,e){return i`Without the sort of physical justification required for a scientifically valid molecular dynamics simulation, we simply pick an energy function that's minimized when the outer vertices are not twisted. We therefore define the unit vectors ${e`\vec{\alpha}`}, ${e`\vec{\beta}`}, and ${e`\vec{\gamma}`} ${e.block`\vec{\alpha} \equiv \frac{\vec{b} - \vec{a}}{|\vec{b} - \vec{a}|},\;\;\;\vec{\beta} \equiv \frac{\vec{d} - \vec{c}}{|\vec{d} - \vec{c}|},\;\;\;\vec{\gamma} \equiv \frac{\vec{f} - \vec{e}}{|\vec{f} - \vec{e}|}`} and define the energy function ${e.block`E_{torsion} = -((\vec{\alpha} \times \vec{\beta}) \cdot (\vec{\alpha} \times \vec{\gamma}))^2.`} Due to the square, this function takes the value ${e`-1`} when ${e`\vec{\alpha} \times \vec{\beta}`} is either parallel *or* antiparallel to ${e`\vec{\alpha} \times \vec{\gamma}`}. In words, this means that the value is minimized when vertices ${e`c`}, ${e`d`}, ${e`e`}, and ${e`f`} exhibit no rotation relative to the central edge, ${e`e_{ab}`}.`},inputs:["md","tex"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3694"),expanded:[],variables:[]},{id:3694,body:function(i,e){return i`Note importantly that if we did not normalize vectors ${e`\vec{\alpha}`}, ${e`\vec{\beta}`}, and ${e`\vec{\gamma}`}, then ${e`E_{torsion}`} would depend upon the distance between the vertices, and the simulation would either blow up or collapse to a point, depending on the sign of ${e`E_{torsion}`}. As it stands though, the constraint that ${e`\vec{\alpha}`}, ${e`\vec{\beta}`}, and ${e`\vec{\gamma}`} are unit vectors produces a strictly torsional force.

Computing the gradient of the above function without an explosion of terms is a bit challenging. I spent a couple sheets of paper giving it a try before recalling why [Einstein summation notation](https://en.wikipedia.org/wiki/Einstein_notation) is so useful in vector calculus.

The page below illustrates the full derivation of all eighteen components of the gradient.`},inputs:["md","tex"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3435"),expanded:[],variables:[]},{id:3435,body:async function(i,e,a){return i`
<figure>
  <a href="${await e(new URL("derivation.jpg",import.meta.url).href).url()}" target="_blank"><img src="${await e(new URL("derivation.jpg",import.meta.url).href).url()}" width="${Math.min(a,600)}"></a>
  <figcaption></figcaption>
</figure>
`},inputs:["html","FileAttachment","width"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-500"),expanded:[],variables:[]},{id:500,body:function(e,a,o,t,n,r){return function(u,d,p){const c=e(),y=e(),f=e();var b=e(),E=e(),B=e();const j=[0,0],I=[0,0];function m(v,h,g){var w=d.vertexAdjacency[h],k=d.vertexAdjacency[h+1],A=d.vertexAdjacency[h+2];w===g?(v[0]=k,v[1]=A):k===g?(v[0]=w,v[1]=A):(v[0]=w,v[1]=k)}function x(v,h,g,w,k,A,T,M,S){const _=a(k,A),$=a(w,A),V=a(w,k);var q=(_-V*$)*p;o(v,w,-2*V*$),t(v,v,k,$),t(v,v,A,V),o(v,v,-2*q/T),o(h,k,_-$*V),n(h,h,A),t(h,h,w,$),o(h,h,-2*q/M),o(g,A,_-V*$),n(g,g,k),t(g,g,w,V),o(g,g,-2*q/S)}for(var C=0;C<d.edges.length;C++){const v=d.edges[C],h=v[0],g=v[1],w=h*3,k=g*3;if(h===-1||g===-1)throw new Error("Invalid edge");if(d.vertexAdjacency[w+2]===-1||d.vertexAdjacency[k+2]===-1)continue;m(j,w,g),m(I,k,h);const A=j[0],T=j[1],M=I[0],S=I[1],_=3*A,$=3*T,V=3*M,q=3*S,R=d.vertices[h],z=d.vertices[g],D=d.vertices[A],U=d.vertices[T],O=d.vertices[M],L=d.vertices[S];n(b,z,R);const P=r(b);o(b,b,1/P),n(E,U,D);const W=r(E);o(E,E,1/W),n(B,L,O);const F=r(B);o(B,B,1/F),x(c,y,f,b,E,B,P,W,F),u[w]+=c[0],u[w+1]+=c[1],u[w+2]+=c[2],u[k]-=c[0],u[k+1]-=c[1],u[k+2]-=c[2],u[_]+=y[0],u[_+1]+=y[1],u[_+2]+=y[2],u[$]-=y[0],u[$+1]-=y[1],u[$+2]-=y[2],u[V]+=f[0],u[V+1]+=f[1],u[V+2]+=f[2],u[q]-=f[0],u[q+1]-=f[1],u[q+2]-=f[2]}return u}},inputs:["vec3create","vec3dot","vec3scale","vec3scaleAndAdd","vec3sub","vec3length"],outputs:void 0,output:"computeTorsionalEnergyGradient",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3261"),expanded:[],variables:[]},{id:3261,body:function(){return{vertices:[[-1,0,.86],[-1,0,-.86],[-.5,0,0],[.5,0,0],[1,0,-.86],[1,0,.86]],edges:[[0,2],[1,2],[2,3],[3,4],[3,5]]}},inputs:[],outputs:void 0,output:"graph4",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3276"),expanded:[],variables:[]},{id:3276,body:function(i,e,a,o,t){const n=e(a,o);return t`
    <figure>
      ${n}
      <figcaption><p>Move the vertices above and observe that the addition of torsional stiffness keeps the above structure planar.</p></figcaption>
    </figure>
  `},inputs:["updateParameters4","drawGraph","ctx4","invalidation","html"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3295"),expanded:[],variables:[]},{id:3295,body:function(e){return e({min:0,max:.05,step:.001,value:.025,precision:3,description:"Torsional spring constant"})},inputs:["slider"],outputs:void 0,output:"viewof$kTorsion_4",assets:void 0,autodisplay:!0,autoview:!0,automutable:!1});s({root:document.getElementById("cell-3267"),expanded:[],variables:[]},{id:3267,body:function(e,a,o,t,n){e.state=a(o),t(e.state,e.camera,n)},inputs:["ctx4","createState","graph4","createInteractions","invalidation"],outputs:void 0,output:"updateGraph4",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3269"),expanded:[],variables:[]},{id:3269,body:function(e,a,o){a.state.k=1,a.state.l0=1,a.state.theta0=180,a.state.kBend=.5,a.state.kTorsion=o,a.state.iterations=1,a.state.simulate=!0},inputs:["updateGraph4","ctx4","kTorsion_4"],outputs:void 0,output:"updateParameters4",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-2552"),expanded:[],variables:[]},{id:2552,body:function(i){return i`## Graph operations`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-2692"),expanded:[],variables:[]},{id:2692,body:function(i){return i`The graph is modeled as a simple set of vertices and edges.

In hindsight, I regret such a simple choice because it makes faces quite difficult to work out after the fact. Mikola Lysenko recommended his [planar-dual](https://github.com/mikolalysenko/planar-dual) module which extracts faces using a 2D projection of the graph. It worked, but I found it very sensitive to the particular parojection so that any faces which were inverted in the particular projection were omitted. There are workarounds, but something like a [half edge mesh](https://github.com/nmwsharp/DDGSpring2016/wiki/Halfedge-Mesh-Data-Structure) from the start would prevent needing such convoluted patches at the end.`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-2704"),expanded:[],variables:[]},{id:2704,body:function(i){return i`The operations below build a very simple adjacency graph. We cache it right on the \`graph\` object and simply delete the cached adjacency when connectivity changes, thus forcing recomputation the next time it's queried.`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-1284"),expanded:[],variables:[]},{id:1284,body:function(e,a){return function(t){return t.vertexAdjacency||(t.vertexAdjacency=e(t)),t.edgeAdjacency||(t.edgeAdjacency=a(t)),t}},inputs:["buildVertexAdjacency","buildEdgeAdjacency"],outputs:void 0,output:"computeAdjacency",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-1158"),expanded:[],variables:[]},{id:1158,body:function(){return function(a){var o=new Int32Array(a.vertices.length*3);o.fill(-1);function t(d,p){var c=3*d;if(o[c]>=0&&c++,o[c]>=0&&c++,o[c]>=0)throw new Error("Too many connections for vertex "+d+"-"+p+"!");o[c]=p}for(var n=0;n<a.edges.length;n++){var r=a.edges[n],l=r[0],u=r[1];t(l,u),t(u,l)}return o}},inputs:[],outputs:void 0,output:"buildVertexAdjacency",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-306"),expanded:[],variables:[]},{id:306,body:function(){return function(a){var o=new Int32Array(a.vertices.length*3);o.fill(-1);function t(l,u){var d=3*l;if(o[d]>=0&&d++,o[d]>=0&&d++,o[d]>=0)throw new Error("Too many connections for edge "+d+"!");o[d]=u}for(var n=0;n<a.edges.length;n++){var r=a.edges[n];t(r[0],n),t(r[1],n)}return o}},inputs:[],outputs:void 0,output:"buildEdgeAdjacency",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-2012"),expanded:[],variables:[]},{id:2012,body:function(){return function(a){delete a.vertexAdjacency,delete a.edgeAdjacency}},inputs:[],outputs:void 0,output:"clearCachedAdjacency",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-2709"),expanded:[],variables:[]},{id:2709,body:function(i){return i`The operations below implement a few simple graph modification functions.`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-1999"),expanded:[],variables:[]},{id:1999,body:function(){return function(a){const o=a.vertices.length;for(let t=0;t<a.edges.length;t++){const n=a.edges[t],r=n[0],l=n[1];if(r>=o||l>=o)return!1}return!0}},inputs:[],outputs:void 0,output:"isValid",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-1892"),expanded:[],variables:[]},{id:1892,body:function(e,a){return function(t,n){e(t);var r=t.edgeAdjacency[n[0]*3],l=t.edgeAdjacency[n[0]*3+1],u=t.edgeAdjacency[n[0]*3+2];if(u>=0||t.edgeAdjacency[n[1]*3+2]>=0)return;function d(p,c){return p[0]===c[0]&&p[1]===c[1]||p[0]===c[1]&&p[1]===c[0]}if(r>=0&&d(t.edges[r],n)||l>=0&&d(t.edges[l],n)||u>=0&&d(t.edges[u],n))return!1;t.edges.push(n),a(t)}},inputs:["computeAdjacency","clearCachedAdjacency"],outputs:void 0,output:"addEdge",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-1764"),expanded:[],variables:[]},{id:1764,body:function(e,a){return function(t,n){if(n===void 0)throw new Error("Invalid vertex index, "+n);if(n<0)return n;e(t);const r=[t.edgeAdjacency[n*3],t.edgeAdjacency[n*3+1],t.edgeAdjacency[n*3+2]];var l=-1;if(r[0]>=0){var u=t.edges[r[0]];l=u[n===u[0]?1:0]}a(t),r.sort((p,c)=>c-p);for(var d=0;d<r.length;d++)r[d]<0||t.edges.splice(r[d],1);t.vertices.splice(n,1);for(var d=0;d<t.edges.length;d++){const c=t.edges[d];c[0]>n&&c[0]--,c[1]>n&&c[1]--}return l>n&&l--,l}},inputs:["computeAdjacency","clearCachedAdjacency"],outputs:void 0,output:"deleteVertex",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-1990"),expanded:[],variables:[]},{id:1990,body:function(e,a,o,t){return function(n,r){if(r<0||(e(n),a(n.edgeAdjacency,r)!==2))return r;var l=n.edges[n.edgeAdjacency[3*r]],u=l[0]===r?l[1]:l[0];let d=n.vertexAdjacency[r*3],p=n.vertexAdjacency[r*3+1];return o(n,r),d>r&&d--,p>r&&p--,n.edges.push([d,p]),u>r&&u--,t(n),u}},inputs:["computeAdjacency","degree","deleteVertex","clearCachedAdjacency"],outputs:void 0,output:"collapseVertex",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3933"),expanded:[],variables:[]},{id:3933,body:function(e,a,o){return function(n,r){if(r<0||(e(n),a(n.edgeAdjacency,r)!==2))return r;var l=n.vertices[r],u=n.edges[n.edgeAdjacency[3*r]],d=u[0]===r?u[1]:u[0],p=n.vertices[d],c=[.5*(l[0]+p[0]),.5*(l[1]+p[1]),.5*(l[2]+p[2])],y=n.vertices.length;return n.vertices[y]=c,n.edges.push([d,y]),u[u[0]===r?1:0]=y,o(n),y}},inputs:["computeAdjacency","degree","clearCachedAdjacency"],outputs:void 0,output:"splitVertex",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3977"),expanded:[],variables:[]},{id:3977,body:function(e,a){return function(t,n){if(n<0)return n;e(t);var r=t.edgeAdjacency[3*n+1],l=t.edgeAdjacency[3*n+2],u=t.vertices[n];if(r>=0){var d=t.edges[r];d[n===d[0]?0:1]=t.vertices.length,t.vertices.push(u.slice())}if(l>=0){var d=t.edges[l];d[n===d[0]?0:1]=t.vertices.length,t.vertices.push(u.slice())}return a(t),n}},inputs:["computeAdjacency","clearCachedAdjacency"],outputs:void 0,output:"explodeVertex",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-526"),expanded:[],variables:[]},{id:526,body:function(){return function(a,o){return a[3*o]===-1?0:a[3*o+1]===-1?1:a[3*o+2]===-1?2:3}},inputs:[],outputs:void 0,output:"degree",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-2563"),expanded:[],variables:[]},{id:2563,body:function(){return function(a){const o=a.vertices;let t=0,n=0,r=0;for(var l=0;l<o.length;l++){const u=o[l];t+=u[0],n+=u[1],r+=u[2]}return t/=o.length,n/=o.length,r/=o.length,[t,n,r]}},inputs:[],outputs:void 0,output:"computeCentroid",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-2565"),expanded:[],variables:[]},{id:2565,body:function(){return function(a,o){const t=a.vertices;for(var n=0;n<t.length;n++){const r=t[n];r[0]+=o[0],r[1]+=o[1],r[2]+=o[2]}return a}},inputs:[],outputs:void 0,output:"translateGraph",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-2684"),expanded:[],variables:[]},{id:2684,body:function(){return function(a){for(var o={vertices:[],edges:[]},t=0;t<a.vertices.length;t++)o.vertices.push(a.vertices[t].slice());for(var t=0;t<a.edges.length;t++)o.edges.push(a.edges[t].slice());return o}},inputs:[],outputs:void 0,output:"cloneGraph",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-239"),expanded:[],variables:[]},{id:239,body:function(e,a,o){return function(n,r,l){var u=new Float64Array(n.vertices.length*3);l.k>0&&e(u,n,l.l0,l.k),l.kBend>0&&a(u,n,l.theta0,l.kBend),l.kTorsion>0&&o(u,n,l.kTorsion);for(var d=0;d<n.vertices.length;d++)d!==l.activeVertexIndex&&(n.vertices[d][0]-=u[d*3+0]*r,n.vertices[d][1]-=u[d*3+1]*r,n.vertices[d][2]-=u[d*3+2]*r)}},inputs:["computeSpringEnergyGradient","computeJoinAngleEnergyGradient","computeTorsionalEnergyGradient"],outputs:void 0,output:"iterate",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-2502"),expanded:[],variables:[]},{id:2502,body:function(i){return i`## Drawing commands`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-1329"),expanded:[],variables:[]},{id:1329,body:function(){return function(a){for(var o=new Float32Array(a.edges.length*6),t=0,n=0;t<a.edges.length;t++,n+=6){var r=a.edges[t],l=r[0],u=r[1];o[n+0]=a.vertices[l][0],o[n+1]=a.vertices[l][1],o[n+2]=a.vertices[l][2],o[n+3]=a.vertices[u][0],o[n+4]=a.vertices[u][1],o[n+5]=a.vertices[u][2]}return o}},inputs:[],outputs:void 0,output:"flattenEdges",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-2525"),expanded:[],variables:[]},{id:2525,body:function(){return function(a){for(var o=new Float32Array(a.vertices.length*3),t=0,n=0;t<a.vertices.length;t++,n+=3)o[n+0]=a.vertices[t][0],o[n+1]=a.vertices[t][1],o[n+2]=a.vertices[t][2];return o}},inputs:[],outputs:void 0,output:"flattenVertices",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-45"),expanded:[],variables:[]},{id:45,body:function(e){return function(o){const t=e(1),n=o.buffer(t.positions),r=o.elements(t.cells),l=new Uint16Array(65536);o.buffer(new Float32Array(65536));for(var u=0;u<l.length;u++)l[u]=u;const d=o.buffer(l);return o({vert:`
    precision highp float;
    attribute vec3 icoPosition;
    attribute vec3 vertex;
    attribute float index;
    uniform mat4 projectionView;
    uniform float pointSize;
    uniform float selectedIndex, hoverIndex;
    varying float isSelected, isActive, isHover;
    void main () {
      isSelected = index == selectedIndex ? 1.0 : 0.0;
      isHover = index == hoverIndex ? 1.0 : 0.0;
      vec4 p0 = projectionView * vec4(vertex, 1);
      float size = p0.z * pointSize;
      gl_Position = projectionView * vec4(vertex + icoPosition * size, 1);
    }`,frag:`
    precision highp float;
    varying float isSelected, isHover;
    void main () {
      gl_FragColor = vec4(
        vec3(0.14, 0.37, 0.69) + isHover * vec3(0, 0.5, 0) + isSelected * vec3(1, 0, 0)
        , 1);
    }`,attributes:{icoPosition:n,vertex:(p,c)=>({buffer:c.vertexBuffer,divisor:1}),index:{buffer:d,divisor:1}},elements:r,cull:{enable:!0,face:"back"},uniforms:{pointSize:(p,c)=>p.pixelRatio*c.pointSize/p.viewportHeight,selectedIndex:(p,c)=>c.selectedVertexIndex,hoverIndex:(p,c)=>c.hoverVertexIndex},primitive:"triangles",count:t.cells.length*3,instances:(p,c)=>c.count})}},inputs:["createIcosphere"],outputs:void 0,output:"createDrawVertices",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-1295"),expanded:[],variables:[]},{id:1295,body:function(){return function(a){return a({vert:`
      precision highp float;

      uniform mat4 projectionView;
      uniform float uAspect, uTurningAngleSafetyExtension, uScaleFactor, uPixelRatio, uL0, uStrainColoring;
      attribute vec3 aPosition, aNextPosition;
      attribute vec2 aLinePosition;
      varying float vOffset;
      varying vec2 vStrokeEdges;
      uniform float uBorderWidth;
      uniform float uLineWidth;
      varying vec3 vColor;

      vec2 lineNormal (vec4 p, vec4 n, float aspect) { 
        return normalize((p.yx / p.w  - n.yx / n.w) * vec2(1, aspect));
      }

      const float pi = 3.14159;

      vec3 colormap (float x) {
        float cx = clamp(x, 0.0, 1.0);
        return vec3(
          cos(pi * cx),
          cos(pi * (cx - 0.5)),
          cos(pi * (cx - 1.0))
        );
      }

      void main () {
        // Compute the position of two adjacent points
        vec4 currentPoint = projectionView * vec4(aPosition, 1);
        vec4 nextPoint = projectionView * vec4(aNextPosition, 1);
        float strain = (length(aNextPosition - aPosition) / uL0 - 1.0);
        vColor = colormap(0.5 + strain * uStrainColoring * 2.0) * 0.8 * (uStrainColoring > 0.0 ? 1.0 : 0.0);

        float totalWidth = uLineWidth + uBorderWidth * 2.0;

        // Use the aLinePosition attribute to select either the current or next point
        gl_Position = mix(currentPoint, nextPoint, aLinePosition.y);

        // Apply the screen-space offset to make a line of the correct width
        vec2 vn = lineNormal(currentPoint, nextPoint, uAspect);
          gl_Position.xy += (
          vn / vec2(-uAspect, 1) * aLinePosition.x * totalWidth +
          -vn.yx * vec2(1, uAspect) * aLinePosition.y * totalWidth * uTurningAngleSafetyExtension
        ) * gl_Position.w * uScaleFactor;

        // Pass the horizontal line offset to the fragment shader so we can
        // add a stroke to the line
        vOffset = aLinePosition.x * totalWidth;

        vStrokeEdges = uBorderWidth < 1e-3 ? vec2(-100, -101) : (uLineWidth + vec2(-1, 1) / uPixelRatio);
      }`,frag:`
      precision highp float;

      uniform vec4 uColor, uBorderColor;
      varying float vOffset;
      varying vec3 vColor;
      varying vec2 vStrokeEdges;

      void main () {
        gl_FragColor = mix(
          uBorderColor,
          vec4(vColor, 1),
          smoothstep( vStrokeEdges.y,  vStrokeEdges.x, vOffset) *
          smoothstep(-vStrokeEdges.y, -vStrokeEdges.x, vOffset)
        );
      }`,polygonOffset:{enable:!0,offset:{factor:2,units:2}},attributes:{aLinePosition:[[-1,0],[1,0],[-1,1],[1,1]],aPosition:(o,t)=>({buffer:t.vertexBuffer,offset:0,stride:24,divisor:1}),aNextPosition:(o,t)=>({buffer:t.vertexBuffer,offset:12,stride:24,divisor:1})},elements:a.prop("edgeBuffer"),uniforms:{uL0:(o,t)=>t.l0===void 0?1:t.l0,uStrainColoring:(o,t)=>t.strainColoring===void 0?0:t.strainColoring,uBorderColor:a.prop("borderColor"),uLineWidth:a.prop("lineWidth"),uBorderWidth:a.prop("borderWidth"),uColor:a.prop("color"),uAspect:o=>o.viewportWidth/o.viewportHeight,uScaleFactor:(o,t)=>o.pixelRatio/o.viewportHeight,uPixelRatio:a.context("pixelRatio"),uTurningAngleSafetyExtension:(o,t)=>{var n=Math.PI/180*(t.maxExpectedTurningAngle===void 0?5:t.maxExpectedTurningAngle);return n<1e-4?n*.5:(1-Math.cos(n))/Math.sin(n)}},primitive:"triangle strip",instances:a.prop("count"),count:4})}},inputs:[],outputs:void 0,output:"createDrawEdges",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-6"),expanded:[],variables:[]},{id:6,body:function(e,a,o,t,n,r,l,u,d,p,c){return function(f,b){f.cache({drawVertices:()=>e(f.regl),drawEdges:()=>a(f.regl)},!0);let E=!1;const B=f.regl.buffer(new Float32Array(65536)),j=f.regl.buffer(new Float32Array(65536));f.camera.taint();const I=f.regl.frame(()=>{if(!E)return;const x=f.state,C=x&&x.graph;try{f.camera.tick(({dirty:v})=>{if(!(!x.simulate&&!v)){if(C){if(x.simulate)for(var h=0;h<o;h++)t(C,.1,f.state);B.subdata(n(C)),j.subdata(r(C))}f.regl.clear({color:[1,1,1,1],depth:1}),C&&(f.data.drawVertices(Object.assign({},x,{vertexBuffer:B,count:C.vertices.length,pointSize:l})),f.data.drawEdges({vertexBuffer:j,strainColoring:u,l0:d,color:[0,0,0,1],lineWidth:2,borderWidth:p,borderColor:[1,1,1,1],count:C.edges.length}))}})}catch(v){console.error(v),I.cancel()}}),m=new c(x=>{E=x.pop().intersectionRatio>0});return m.observe(f.container),b&&b.then(()=>{I.cancel(),m.disconnect()}),f.container}},inputs:["createDrawVertices","createDrawEdges","iterations","iterate","flattenVertices","flattenEdges","pointSize","strainColoring","l0","borderWidth","IntersectionObserver"],outputs:void 0,output:"drawGraph",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-2493"),expanded:[],variables:[]},{id:2493,body:function(i){return i`## WebGL context and camera`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-24"),expanded:[],variables:[]},{id:24,body:function(e,a,o){return function(n){n=Object.assign({width:Math.min(window.outerWidth-80,e),height:Math.min(window.outerHeight-80,Math.floor(e*.9)),eye:[0,1,-20]},n);const r=devicePixelRatio,l=document.createElement("div");l.style.width=`${n.width}px`,l.style.height=`${n.height}px`;const u=a({container:l,pixelRatio:r,extensions:["ANGLE_instanced_arrays"]}),d=o(u,{eye:n.eye}),p={};function c(y,f){return Object.keys(y).forEach(b=>{f?p[b]=y[b]():p[b]=p[b]||y[b]()}),p}return{regl:u,container:l,camera:d,data:p,cache:c}}},inputs:["width","createREGL","reglCamera"],outputs:void 0,output:"createContext",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-661"),expanded:[],variables:[]},{id:661,body:function(e,a,o,t,n,r,l,u,d,p,c,y,f,b,E,B,j,I){var m=new Float32Array(16),x=new Float32Array(16);function C(g,w,k){this.rotation=g,this.center=w,this.distance=k}var v=C.prototype;v.view=function(g){return g||(g=e()),x[0]=x[1]=0,x[2]=-this.distance,a(g,o(m,this.rotation),x),t(g,g,n(m,this.center)),g},v.lookAt=function(g,w,k){r(m,g,w,k),l(m,m),u(this.rotation,m),d(this.center,w),this.distance=p(g,w)},v.pan=function(g){var w=this.distance;m[0]=-w*(g[0]||0),m[1]=w*(g[1]||0),m[2]=w*(g[2]||0),c(m,m,this.rotation),y(this.center,this.center,m)},v.zoom=function(g){this.distance*=Math.exp(g/10),this.distance<0&&(this.distance=0)};function h(g,w){var k=w[0],A=w[1];w[2];var T=k*k+A*A;T>1&&(T=1),g[0]=-w[0],g[1]=w[1],g[2]=w[2]||Math.sqrt(1-T),g[3]=0}return v.rotate=function(g,w){h(m,g),h(x,w),f(x,x),b(m,m,x),!(E(m)<1e-6)&&(b(this.rotation,this.rotation,m),B(this.rotation,this.rotation))},function(w,k,A){w=w||[0,0,-1],k=k||[0,0,0],A=A||[0,1,0];var T=new C(j(),I(),1);return T.lookAt(w,k,A),T}},inputs:["mat4create","mat4fromRotationTranslation","quatConjugate","mat4translate","vec3negate","mat4lookAt","mat3fromMat4","quatFromMat3","vec3copy","vec3distance","vec3transformQuat","vec3add","quatInvert","quatMultiply","quatLength","quatNormalize","quatCreate","vec3create"],outputs:void 0,output:"createOrbitCamera",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-699"),expanded:[],variables:[]},{id:699,body:function(e,a,o,t){return function(r,l){l=Object.assign({eye:l.eye||[0,1,-20],center:[0,0,0],up:[0,1,0],fovy:Math.PI/4,near:.1,far:200},l);const u=e(l.eye,l.center,l.up),d=a(),p=a(),c=a();let y=r._gl.canvas.width/r._gl.canvas.height,f=!0;const b=r({uniforms:{eye:()=>u.eye,center:()=>u.center,view:()=>d,projection:()=>p,projectionView:()=>c,aspectRatio:()=>y},context:{eye:()=>u.eye,center:()=>u.center,view:()=>d,projection:()=>p,projectionView:()=>c,aspectRatio:()=>y,dirty:()=>f}});return u.tick=function(E){y=r._gl.canvas.width/r._gl.canvas.height,u.view(d),o(p,l.fovy,y,l.near,l.far),t(c,p,d),b(E),f=!1},u.taint=function(){f=!0},u.element=r._gl.canvas,u.projectionView=c,u}},inputs:["createOrbitCamera","mat4create","mat4perspective","mat4multiply"],outputs:void 0,output:"reglCamera",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-2980"),expanded:[],variables:[]},{id:2980,body:function(e){return e({eye:[0,1,-20]})},inputs:["createContext"],outputs:void 0,output:"ctx",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3116"),expanded:[],variables:[]},{id:3116,body:function(e){return e({width:Math.min(700),height:Math.max(400,Math.floor(Math.min(700)*.7)),eye:[0,0,-4]})},inputs:["createContext"],outputs:void 0,output:"ctx2",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3195"),expanded:[],variables:[]},{id:3195,body:function(e){return e({width:Math.min(700),height:Math.max(400,Math.floor(Math.min(700)*.7)),eye:[0,0,-4]})},inputs:["createContext"],outputs:void 0,output:"ctx3",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3263"),expanded:[],variables:[]},{id:3263,body:function(e){return e({width:Math.min(700),height:Math.max(400,Math.floor(Math.min(700)*.7)),eye:[0,2,-3]})},inputs:["createContext"],outputs:void 0,output:"ctx4",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-2521"),expanded:[],variables:[]},{id:2521,body:function(i){return i`## Interactions`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-2712"),expanded:[],variables:[]},{id:2712,body:function(i){return i`The class below tries to implement a simple interaction controller which I don't very much like. It allows plugging in tools which are called in sequence on event input until one of them elects to capture the event. This allows layering a vertex editing tool on top of a camera controller without a particularly special case for camera control. The downside is that it's not done well and cleanly enough to be quite the right abstraction.`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-761"),expanded:[],variables:[]},{id:761,body:function(e){function a(t,n){this.state="INITIAL",this.initialX=null,this.initialY=null,this.previousX=null,this.previousY=null,this.captured=!1,this.wheelCaptured=!1,this.element=t,this.xy=[null,null],this.initialXY=[null,null],this.toolStack=[n],this.capturedTool=null,t.tabIndex="1",t.style.outline="none",this.element.style.cursor="grab",this.handleMouseWheel=this._onMouseWheel.bind(this),this.handleMousedown=this._onMousedown.bind(this),this.handleMousemove=this._onMousemove.bind(this),this.handleWindowMousemove=this._onWindowMousemove.bind(this),this.handleWindowMouseup=this._onWindowMouseup.bind(this),this.handleKeyUp=this._onKeyUp.bind(this),this.capture=()=>this.captured=!0,this.captureWheel=()=>this.captureWheel=!0,t.addEventListener("mousedown",this.handleMousedown),t.addEventListener("mousemove",this.handleMousemove),t.addEventListener("wheel",this.handleMouseWheel),t.addEventListener("keyup",this.handleKeyUp),this.destroy=()=>{t.removeEventListener("mousedown",this.handleMousedown),t.removeEventListener("mousemove",this.handleMousemove),t.removeEventListener("wheel",this.handleMouseWheel),t.removeEventListener("keyup",this.handleKeyUp),this._stopObservingWindow()}}a.prototype.pushToolStack=function(t){this.toolStack.unshift(t)},a.prototype.popToolStack=function(t){this.toolStack.length<2||this.toolStack.shift()},a.prototype.setCursor=function(t){this.element.style.cursor=t};function o(t){Object.assign(this,t),this.reset()}return o.prototype.capture=function(){this.captured=!0},o.prototype.stopPropagation=function(){this.propagationStopped=!0},o.prototype.reset=function(){this.captured=!1,this.propagationStopped=!1},o.prototype.insideDeadZone=function(t){if(this.initialX===void 0||this.initialY===void 0||this.x===void 0||this.x===void 0)return!1;const n=this.x-this.initialX,r=this.y-this.initialY;return n*n+r*r<t*t},a.prototype._consumeEvent=function(t,n){const r=this.xy[0],l=this.xy[1];return n&&(this.initialXY[0]=this.xy[0],this.initialXY[1]=this.xy[1]),e(t,this.element,this.xy),{x:this.xy[0],y:this.xy[1],deltaX:this.xy[0]-r,deltaY:this.xy[1]-l,previousX:r,previousY:l,initialX:this.initialXY[0],initialY:this.initialXY[1],originalEvent:t}},a.prototype._delegate=function(t,n,r){const l=new o(n),u=r?[r]:this.toolStack[0];for(var d=0;d<u.length;d++){const p=u[d];if(p[t]){if(p[t].bind(this)(l),l.captured)return this.capturedTool=p,l;if(l.propagationStopped)break}}},a.prototype._startObservingWindow=function(){this.setCursor("grabbing"),window.addEventListener("mousemove",this.handleWindowMousemove),window.addEventListener("mouseup",this.handleWindowMouseup)},a.prototype._stopObservingWindow=function(){this.setCursor(null),window.removeEventListener("mousemove",this.handleWindowMousemove),window.removeEventListener("mousemove",this.handleWindowMouseup)},a.prototype._onMouseWheel=function(t){this._delegate("wheel",Object.assign(this._consumeEvent(t),{deltaX:t.deltaX,deltaY:t.deltaY}))},a.prototype._onMousedown=function(t){this._startObservingWindow();const n=this._consumeEvent(t,!0);this._delegate("beginPress",n)},a.prototype._onKeyUp=function(t){this._delegate("keyUp",{originalEvent:t})},a.prototype._onMousemove=function(t){this.capturedTool||this._delegate("passiveMove",this._consumeEvent(t))},a.prototype._onWindowMousemove=function(t){this.capturedTool&&this._delegate("capturedMove",this._consumeEvent(t),this.capturedTool)},a.prototype._onWindowMouseup=function(t){if(this._stopObservingWindow(),this.capturedTool){const n=this._consumeEvent(t);this._delegate("endPress",n),this._delegate("endCapture",n,this.capturedTool),this.capturedTool=null}},a},inputs:["mouseEventOffset"],outputs:void 0,output:"InteractionController",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-784"),expanded:[],variables:[]},{id:784,body:function(e,a,o){return function(n,r,l){const u=new e(r.element,[a(n,r),o(n,r)]);return l.then(u.destroy),u}},inputs:["InteractionController","createVertexTool","createCameraTool"],outputs:void 0,output:"createInteractions",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-1031"),expanded:[],variables:[]},{id:1031,body:function(e,a,o){return function(n,r,l,u){const d=n.vertices,p=e(),c=a();let y=-1,f=1/0;for(var b=0;b<d.length;b++)if(o(p,d[b],r),!(p[2]<-1||p[2]>1)){c[0]=(.5+.5*p[0])*u[0],c[1]=(.5-.5*p[1])*u[1];var E=l[0]-c[0],B=l[1]-c[1],j=E*E+B*B;j<f*f&&(f=Math.sqrt(j),y=b)}return{index:y,distance:f}}},inputs:["vec3create","vec2create","vec3transformMat4"],outputs:void 0,output:"getClosestPointIndex",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-1038"),expanded:[],variables:[]},{id:1038,body:function(){return function(a){return{graph:a,state:"MOVE_VERTICES",selectedVertexIndex:-1,hoverVertexIndex:-1,activeVertexIndex:-1,deadZoneRadius:4}}},inputs:[],outputs:void 0,output:"createState",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-1547"),expanded:[],variables:[]},{id:1547,body:function(e,a,o,t,n,r,l,u,d,p,c){return function(f,b){const E=f.graph,B=b.element;let j=!1,I;const m=[B.offsetWidth,B.offsetHeight];function x(){m[0]=B.offsetWidth,m[1]=B.offsetHeight}function C(v,h){return x(),e(E,b.projectionView,[v,h],m)}return{keyUp:function(v){switch(v.originalEvent.keyCode){case 8:if(f.selectedVertexIndex>=0){var h=a(E,f.selectedVertexIndex);f.selectedVertexIndex=h,f.hoverVertexIndex=-1,f.activeVertexIndex=-1,f.spawnVertexIndex=h,I=null,b.taint(),v.originalEvent.preventDefault()}break;case 32:f.selectedVertexIndex=-1,f.activeVertexIndex=-1,b.taint(),v.originalEvent.preventDefault();break;case 67:var h=o(E,f.selectedVertexIndex);f.selectedVertexIndex=h,f.hoverVertexIndex=-1,f.activeVertexIndex=-1,f.spawnVertexIndex=h,I=null,b.taint(),v.originalEvent.preventDefault();break;case 83:var h=t(E,f.selectedVertexIndex);f.selectedVertexIndex=h,f.hoverVertexIndex=-1,f.activeVertexIndex=-1,f.spawnVertexIndex=h,I=null,b.taint(),v.originalEvent.preventDefault();break;case 69:var h=n(E,f.selectedVertexIndex);f.selectedVertexIndex=h,f.hoverVertexIndex=-1,f.activeVertexIndex=-1,f.spawnVertexIndex=h,I=null,b.taint(),v.originalEvent.preventDefault();break}},beginPress:function(v){j=!1;const h=C(v.x,v.y);h.index>=0&&h.distance<25&&(f.selectedVertexIndex>=0&&f.selectedVertexIndex!==h.index&&(I=[f.selectedVertexIndex,h.index]),f.activeVertexIndex=h.index,f.selectedVertexIndex=h.index,f.spawnVertexIndex=h.index,b.taint(),this.setCursor("move"),v.capture())},endPress:function(v){if(!j&&v.insideDeadZone(5)){const k=C(v.x,v.y);if(k.index>=0&&k.distance<25)I&&r(E,I),v.stopPropagation(),f.selectedVertexIndex=k.index,b.taint();else if(f.spawnVertexIndex>=0){x();var h=l(),g=u(d(),b.projectionView),w=E.vertices[f.spawnVertexIndex];p(h,w,b.projectionView),h[0]=2*v.x/m[0]-1,h[1]=1-2*v.y/m[1];const A=p(l(),h,g);c(E),E.edgeAdjacency[f.spawnVertexIndex*3+2]===-1&&(E.vertices.push(A),E.edges.push([f.spawnVertexIndex,E.vertices.length-1]),delete E.vertexAdjacency,delete E.edgeAdjacency,b.taint(),f.spawnVertexIndex=f.selectedVertexIndex=E.vertices.length-1,v.stopPropagation())}}f.activeVertexIndex=-1,f.candidateEdge=null},passiveMove:function(v){const h=C(v.x,v.y);h.index>=0&&h.distance<25?(f.hoverVertexIndex=h.index,b.taint(),this.setCursor("move")):(f.hoverVertexIndex=-1,this.setCursor(null),b.taint())},capturedMove:function(v){if(!v.insideDeadZone(5)){j=!0,x();var h=l(),g=u(d(),b.projectionView);b.taint(),f.selectedVertexIndex=f.activeVertexIndex;var w=E.vertices[f.selectedVertexIndex];p(h,w,b.projectionView),h[0]=2*v.x/m[0]-1,h[1]=1-2*v.y/m[1],p(w,h,g)}},endCapture:function(v){}}}},inputs:["getClosestPointIndex","deleteVertex","collapseVertex","splitVertex","explodeVertex","addEdge","vec3create","mat4invert","mat4create","vec3transformMat4","computeAdjacency"],outputs:void 0,output:"createVertexTool",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-1541"),expanded:[],variables:[]},{id:1541,body:function(e,a){return function(t,n){const r=t.graph,l=n.element;return{keyUp:function(u){switch(u.originalEvent.keyCode){case 65:if(t.selectedVertexIndex>=0){const d=r.vertices[t.selectedVertexIndex];e(n.center,d),n.taint()}else e(n.center,a(r)),n.taint();break}},beginPress:function(u){u.capture(),this.setCursor("grabbing")},endPress:function(u){u.insideDeadZone(5)&&(t.selectedVertexIndex=-1,n.taint())},capturedMove:function(u){u.originalEvent.shiftKey?n.pan([u.deltaX/l.offsetWidth,u.deltaY/l.offsetHeight]):n.rotate([-(u.previousX/l.offsetWidth-.5),-(u.previousY/l.offsetHeight-.5)],[-(u.x/l.offsetWidth-.5),-(u.y/l.offsetHeight-.5)]),n.taint()},wheel:function(u){u.originalEvent.preventDefault(),n.zoom(u.deltaY*.03),n.taint()},endCapture:function(){this.setCursor(null)}}}},inputs:["vec3copy","computeCentroid"],outputs:void 0,output:"createCameraTool",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-2486"),expanded:[],variables:[]},{id:2486,body:function(i){return i`## Imports`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-13"),expanded:[],variables:[]},{id:13,body:async(i,e)=>{const{button:a,checkbox:o,slider:t,select:n}=await G(()=>import("https://api.observablehq.com/@jashkenas/inputs.js?v=4"),[]).then(r=>{const l={},u=i.module(r.default),d=i.module();if(!u.defines("button"))throw new SyntaxError("export 'button' not found");if(d.variable(l.button=e()).import("button",u),!u.defines("checkbox"))throw new SyntaxError("export 'checkbox' not found");if(d.variable(l.checkbox=e()).import("checkbox",u),!u.defines("slider"))throw new SyntaxError("export 'slider' not found");if(d.variable(l.slider=e()).import("slider",u),!u.defines("select"))throw new SyntaxError("export 'select' not found");return d.variable(l.select=e()).import("select",u),l});return{button:a,checkbox:o,slider:t,select:n}},inputs:["__ojs_runtime","__ojs_observer"],outputs:["button","checkbox","slider","select"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});s({root:document.getElementById("cell-677"),expanded:[],variables:[]},{id:677,body:async(i,e)=>{const{mat3fromMat4:a}=await G(()=>import("https://api.observablehq.com/@rreusser/gl-mat3.js?v=4"),[]).then(o=>{const t={},n=i.module(o.default),r=i.module();if(!n.defines("mat3fromMat4"))throw new SyntaxError("export 'mat3fromMat4' not found");return r.variable(t.mat3fromMat4=e()).import("mat3fromMat4",n),t});return{mat3fromMat4:a}},inputs:["__ojs_runtime","__ojs_observer"],outputs:["mat3fromMat4"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});s({root:document.getElementById("cell-21"),expanded:[],variables:[]},{id:21,body:async(i,e)=>{const{vec3fromValues:a,vec3dot:o,vec3cross:t,vec3normalize:n,vec3length:r,vec3distance:l,vec3set:u,vec3copy:d,vec3sub:p,vec3scaleAndAdd:c,vec3scale:y,vec3add:f,vec3transformQuat:b,vec3negate:E,vec3transformMat4:B}=await G(()=>import("https://api.observablehq.com/@rreusser/gl-vec3.js?v=4"),[]).then(j=>{const I={},m=i.module(j.default),x=i.module();if(!m.defines("vec3fromValues"))throw new SyntaxError("export 'vec3fromValues' not found");if(x.variable(I.vec3fromValues=e()).import("vec3fromValues",m),!m.defines("vec3dot"))throw new SyntaxError("export 'vec3dot' not found");if(x.variable(I.vec3dot=e()).import("vec3dot",m),!m.defines("vec3cross"))throw new SyntaxError("export 'vec3cross' not found");if(x.variable(I.vec3cross=e()).import("vec3cross",m),!m.defines("vec3normalize"))throw new SyntaxError("export 'vec3normalize' not found");if(x.variable(I.vec3normalize=e()).import("vec3normalize",m),!m.defines("vec3length"))throw new SyntaxError("export 'vec3length' not found");if(x.variable(I.vec3length=e()).import("vec3length",m),!m.defines("vec3distance"))throw new SyntaxError("export 'vec3distance' not found");if(x.variable(I.vec3distance=e()).import("vec3distance",m),!m.defines("vec3set"))throw new SyntaxError("export 'vec3set' not found");if(x.variable(I.vec3set=e()).import("vec3set",m),!m.defines("vec3copy"))throw new SyntaxError("export 'vec3copy' not found");if(x.variable(I.vec3copy=e()).import("vec3copy",m),!m.defines("vec3sub"))throw new SyntaxError("export 'vec3sub' not found");if(x.variable(I.vec3sub=e()).import("vec3sub",m),!m.defines("vec3scaleAndAdd"))throw new SyntaxError("export 'vec3scaleAndAdd' not found");if(x.variable(I.vec3scaleAndAdd=e()).import("vec3scaleAndAdd",m),!m.defines("vec3scale"))throw new SyntaxError("export 'vec3scale' not found");if(x.variable(I.vec3scale=e()).import("vec3scale",m),!m.defines("vec3add"))throw new SyntaxError("export 'vec3add' not found");if(x.variable(I.vec3add=e()).import("vec3add",m),!m.defines("vec3transformQuat"))throw new SyntaxError("export 'vec3transformQuat' not found");if(x.variable(I.vec3transformQuat=e()).import("vec3transformQuat",m),!m.defines("vec3negate"))throw new SyntaxError("export 'vec3negate' not found");if(x.variable(I.vec3negate=e()).import("vec3negate",m),!m.defines("vec3transformMat4"))throw new SyntaxError("export 'vec3transformMat4' not found");return x.variable(I.vec3transformMat4=e()).import("vec3transformMat4",m),I});return{vec3fromValues:a,vec3dot:o,vec3cross:t,vec3normalize:n,vec3length:r,vec3distance:l,vec3set:u,vec3copy:d,vec3sub:p,vec3scaleAndAdd:c,vec3scale:y,vec3add:f,vec3transformQuat:b,vec3negate:E,vec3transformMat4:B}},inputs:["__ojs_runtime","__ojs_observer"],outputs:["vec3fromValues","vec3dot","vec3cross","vec3normalize","vec3length","vec3distance","vec3set","vec3copy","vec3sub","vec3scaleAndAdd","vec3scale","vec3add","vec3transformQuat","vec3negate","vec3transformMat4"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});s({root:document.getElementById("cell-662"),expanded:[],variables:[]},{id:662,body:async(i,e)=>{const{quatMultiply:a,quatNormalize:o,quatInvert:t,quatLength:n,quatCreate:r,quatFromMat3:l,quatConjugate:u}=await G(()=>import("https://api.observablehq.com/@rreusser/gl-quat.js?v=4"),[]).then(d=>{const p={},c=i.module(d.default),y=i.module();if(!c.defines("quatMultiply"))throw new SyntaxError("export 'quatMultiply' not found");if(y.variable(p.quatMultiply=e()).import("quatMultiply",c),!c.defines("quatNormalize"))throw new SyntaxError("export 'quatNormalize' not found");if(y.variable(p.quatNormalize=e()).import("quatNormalize",c),!c.defines("quatInvert"))throw new SyntaxError("export 'quatInvert' not found");if(y.variable(p.quatInvert=e()).import("quatInvert",c),!c.defines("quatLength"))throw new SyntaxError("export 'quatLength' not found");if(y.variable(p.quatLength=e()).import("quatLength",c),!c.defines("quatCreate"))throw new SyntaxError("export 'quatCreate' not found");if(y.variable(p.quatCreate=e()).import("quatCreate",c),!c.defines("quatFromMat3"))throw new SyntaxError("export 'quatFromMat3' not found");if(y.variable(p.quatFromMat3=e()).import("quatFromMat3",c),!c.defines("quatConjugate"))throw new SyntaxError("export 'quatConjugate' not found");return y.variable(p.quatConjugate=e()).import("quatConjugate",c),p});return{quatMultiply:a,quatNormalize:o,quatInvert:t,quatLength:n,quatCreate:r,quatFromMat3:l,quatConjugate:u}},inputs:["__ojs_runtime","__ojs_observer"],outputs:["quatMultiply","quatNormalize","quatInvert","quatLength","quatCreate","quatFromMat3","quatConjugate"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});s({root:document.getElementById("cell-682"),expanded:[],variables:[]},{id:682,body:async(i,e)=>{const{mat4lookAt:a,mat4fromRotationTranslation:o,mat4create:t,mat4translate:n,mat4perspective:r,mat4multiply:l,mat4invert:u}=await G(()=>import("https://api.observablehq.com/@rreusser/gl-mat4.js?v=4"),[]).then(d=>{const p={},c=i.module(d.default),y=i.module();if(!c.defines("mat4lookAt"))throw new SyntaxError("export 'mat4lookAt' not found");if(y.variable(p.mat4lookAt=e()).import("mat4lookAt",c),!c.defines("mat4fromRotationTranslation"))throw new SyntaxError("export 'mat4fromRotationTranslation' not found");if(y.variable(p.mat4fromRotationTranslation=e()).import("mat4fromRotationTranslation",c),!c.defines("mat4create"))throw new SyntaxError("export 'mat4create' not found");if(y.variable(p.mat4create=e()).import("mat4create",c),!c.defines("mat4translate"))throw new SyntaxError("export 'mat4translate' not found");if(y.variable(p.mat4translate=e()).import("mat4translate",c),!c.defines("mat4perspective"))throw new SyntaxError("export 'mat4perspective' not found");if(y.variable(p.mat4perspective=e()).import("mat4perspective",c),!c.defines("mat4multiply"))throw new SyntaxError("export 'mat4multiply' not found");if(y.variable(p.mat4multiply=e()).import("mat4multiply",c),!c.defines("mat4invert"))throw new SyntaxError("export 'mat4invert' not found");return y.variable(p.mat4invert=e()).import("mat4invert",c),p});return{mat4lookAt:a,mat4fromRotationTranslation:o,mat4create:t,mat4translate:n,mat4perspective:r,mat4multiply:l,mat4invert:u}},inputs:["__ojs_runtime","__ojs_observer"],outputs:["mat4lookAt","mat4fromRotationTranslation","mat4create","mat4translate","mat4perspective","mat4multiply","mat4invert"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});s({root:document.getElementById("cell-1034"),expanded:[],variables:[]},{id:1034,body:async(i,e)=>{const{vec2length:a,vec2create:o}=await G(()=>import("https://api.observablehq.com/@rreusser/gl-vec2.js?v=4"),[]).then(t=>{const n={},r=i.module(t.default),l=i.module();if(!r.defines("vec2length"))throw new SyntaxError("export 'vec2length' not found");if(l.variable(n.vec2length=e()).import("vec2length",r),!r.defines("vec2create"))throw new SyntaxError("export 'vec2create' not found");return l.variable(n.vec2create=e()).import("vec2create",r),n});return{vec2length:a,vec2create:o}},inputs:["__ojs_runtime","__ojs_observer"],outputs:["vec2length","vec2create"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});s({root:document.getElementById("cell-1369"),expanded:[],variables:[]},{id:1369,body:async(i,e)=>{const{createIcosphere:a}=await G(()=>import("https://api.observablehq.com/@rreusser/icosphere.js?v=4"),[]).then(o=>{const t={},n=i.module(o.default),r=i.module();if(!n.defines("createIcosphere"))throw new SyntaxError("export 'createIcosphere' not found");return r.variable(t.createIcosphere=e()).import("createIcosphere",n),t});return{createIcosphere:a}},inputs:["__ojs_runtime","__ojs_observer"],outputs:["createIcosphere"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});s({root:document.getElementById("cell-3409"),expanded:[],variables:[]},{id:3409,body:async(i,e)=>{const{tweet:a}=await G(()=>import("https://api.observablehq.com/@mbostock/tweet.js?v=4"),[]).then(o=>{const t={},n=i.module(o.default),r=i.module();if(!n.defines("tweet"))throw new SyntaxError("export 'tweet' not found");return r.variable(t.tweet=e()).import("tweet",n),t});return{tweet:a}},inputs:["__ojs_runtime","__ojs_observer"],outputs:["tweet"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});s({root:document.getElementById("cell-1256"),expanded:[],variables:[]},{id:1256,body:function(){return function(){return[0,0,0]}},inputs:[],outputs:void 0,output:"vec3create",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-7"),expanded:[],variables:[]},{id:7,body:function(e){return e("regl")},inputs:["require"],outputs:void 0,output:"createREGL",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-978"),expanded:[],variables:[]},{id:978,body:function(){var e={left:0,top:0};function a(t,n,r){n=n||t.currentTarget||t.srcElement,Array.isArray(r)||(r=[0,0]);var l=t.clientX||0,u=t.clientY||0,d=o(n);return r[0]=l-d.left,r[1]=u-d.top,r}function o(t){return t===window||t===document||t===document.body?e:t.getBoundingClientRect()}return a},inputs:[],outputs:void 0,output:"mouseEventOffset",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-1372"),expanded:[],variables:[]},{id:1372,body:function(e){return e(0)},inputs:["createIcosphere"],outputs:void 0,output:"icosphere",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-2469"),expanded:[],variables:[]},{id:2469,body:function(i){return i`
<style>
kbd {
  background-color: #eee;
  border-radius: 3px;
  border: 1px solid #b4b4b4;
  box-shadow: 0 1px 1px rgba(0, 0, 0, .2), 0 2px 0 0 rgba(255, 255, 255, .7) inset;
  color: #333;
  display: inline-block;
  font-size: .85em;
  font-weight: 700;
  line-height: 1;
  padding: 2px 4px;
  white-space: nowrap;
}
figcaption {
  color: black;
  font-size: 1em;
  font-family: serif;
  font-style: italic;
  margin-top: 1em;
  max-width: 600px;
  text-align: left;
  margin-left: auto;
  margin-right: auto;
  text-align: center;
}
figcaption > p {
display: inline-block;
  max-width: 600px;
  margin: auto;
  text-align: left;
}
h2 {
  padding-top: 1em;
}
figure {
  padding: 2em 0;
}
figure canvas {
  border: 1px solid #eee !important;
}
figure img {
  margin-left: auto;
  margin-right: auto;
  display: block;
}
</style>
`},inputs:["html"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3878"),expanded:[],variables:[]},{id:3878,body:function(i){return i`## License`},inputs:["md"],outputs:void 0,output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});s({root:document.getElementById("cell-3873"),expanded:[],variables:[]},{id:3873,body:function(){return"mit"},inputs:[],outputs:void 0,output:"LICENSE",assets:void 0,autodisplay:!0,autoview:!1,automutable:!1});
