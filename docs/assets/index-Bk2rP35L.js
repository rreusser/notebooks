import{d,_ as f}from"./index-ByB2dbry.js";d({root:document.getElementById("cell-4"),expanded:[],variables:[]},{id:4,body:(e,t,o,a,r,i,n)=>{const s=e`<figure>
  ${t.element}
  <figcaption>Drag points to adjust values. Use mouse wheel to zoom, drag to pan.</figcaption>
</figure>`;return o(a(s,{width:Math.min(r,640),height:Math.min(480,r),toggleOffset:[-6,-33],onResize(u,m,v){t.resize(m,v),i.updateScales(t.elements.plot.scale("x"),t.elements.plot.scale("y")),n.dirty=!0}})),{figure:s}},inputs:["html","stack","display","expandable","width","axes","regl"],outputs:["figure"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});d({root:document.getElementById("cell-39"),expanded:[],variables:[]},{id:39,body:async()=>{const[{default:e},{createElementStack:t},{reglElement:o,reglAxesViewport:a},{createZoomableAxes:r},{expandable:i}]=await Promise.all([f(()=>import("https://cdn.jsdelivr.net/npm/regl@2.1.1/+esm"),[]).then(n=>{if(!("default"in n))throw new SyntaxError("export 'default' not found");return n}),f(()=>import("./element-stack-U6qmxFVc.js"),[]).then(n=>{if(!("createElementStack"in n))throw new SyntaxError("export 'createElementStack' not found");return n}),f(()=>import("./regl-canvas-Cs3pLjCJ.js"),[]).then(n=>{if(!("reglElement"in n))throw new SyntaxError("export 'reglElement' not found");if(!("reglAxesViewport"in n))throw new SyntaxError("export 'reglAxesViewport' not found");return n}),f(()=>import("./zoomable-axes-xikZlprl.js"),[]).then(n=>{if(!("createZoomableAxes"in n))throw new SyntaxError("export 'createZoomableAxes' not found");return n}),f(()=>import("./expandable-BgcqCFlA.js"),[]).then(n=>{if(!("expandable"in n))throw new SyntaxError("export 'expandable' not found");return n})]);return{createREGL:e,createElementStack:t,reglElement:o,reglAxesViewport:a,createZoomableAxes:r,expandable:i}},inputs:[],outputs:["createREGL","createElementStack","reglElement","reglAxesViewport","createZoomableAxes","expandable"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});d({root:document.getElementById("cell-7"),expanded:[],variables:[]},{id:7,body:(e,t,o,a,r)=>({stack:e({layers:[{id:"regl",element:t(o,{extensions:["OES_standard_derivatives"],attributes:{depthStencil:!1,preserveDrawingBuffer:!0}})},{id:"plot",element:({width:n,height:s})=>a(n,s)},{id:"svg",element:({current:n,width:s,height:u})=>(n?r.select(n):r.create("svg")).attr("width",s).attr("height",u).node()}]})}),inputs:["createElementStack","reglElement","createREGL","createPlot","d3"],outputs:["stack"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});d({root:document.getElementById("cell-21"),expanded:[],variables:[]},{id:21,body:e=>{function t(o,a,r=[-2,2],i=[-2,2]){return e.plot({width:o,height:a,marginTop:20,marginRight:10,marginLeft:40,marginBottom:20,style:{backgroundColor:"transparent",maxWidth:"none",position:"absolute"},x:{domain:r,tickSpacing:100},y:{domain:i,tickSpacing:100},marks:[e.ruleX([0],{stroke:"#0002"}),e.ruleY([0],{stroke:"#0002"})]})}return{createPlot:t}},inputs:["Plot"],outputs:["createPlot"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});d({root:document.getElementById("cell-8"),expanded:[],variables:[]},{id:8,body:(e,t,o,a,r)=>({axes:e({d3:t,element:o.elements.svg,xScale:o.elements.plot.scale("x"),yScale:o.elements.plot.scale("y"),aspectRatio:1,onChange:({xDomain:n,yDomain:s})=>{a.dirty=!0;const u=r(o.width,o.height,n,s);o.elements.plot.replaceWith(u),o.elements.plot=u,o.dispatchEvent(new CustomEvent("update"))}})}),inputs:["createZoomableAxes","d3","stack","regl","createPlot"],outputs:["axes"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});d({root:document.getElementById("cell-9"),expanded:[],variables:[]},{id:9,body:(e,t)=>e`Next, we wire up some actual math. As a test case, we render a [domain coloring](https://en.wikipedia.org/wiki/Domain_coloring) of a Möbius transformation. The function maps complex numbers according to

${t.block`f(z) = \frac{(z - a)(b - m)}{(z - b)(a - m)}`}

where ${t`a`}, ${t`m`}, and ${t`b`} are control points you can drag to explore the transformation. By construction, ${t`f(a) = 0`}, ${t`f(b) = \infty`}, and ${t`f(m) = 1`}. Möbius transformations are conformal (angle-preserving) and map circles to circles. Neat!`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});d({root:document.getElementById("cell-10"),expanded:[],variables:[]},{id:10,body:()=>({controlPoints:{a:{x:-1,y:.5},m:{x:0,y:0},b:{x:1,y:-.5}}}),inputs:[],outputs:["controlPoints"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});d({root:document.getElementById("cell-25"),expanded:[],variables:[]},{id:25,body:(e,t,o,a,r)=>{const i=e.select(t.elements.svg),n=i.selectAll("defs").data([0]).join("defs"),s=n.selectAll("clipPath#viewport-clip").data([0]).join("clipPath").attr("id","viewport-clip").selectAll("rect").data([0]).join("rect"),u=i.selectAll("g.clipped").data([0]).join("g").attr("class","clipped").attr("clip-path","url(#viewport-clip)"),m=[{id:"a",point:o.a,color:"rgb(51, 85, 238)",label:"a"},{id:"m",point:o.m,color:"rgb(51, 85, 238)",label:"m"},{id:"b",point:o.b,color:"rgb(51, 85, 238)",label:"b"}],v=u.selectAll("circle.control").data(m,l=>l.id).join("circle").attr("class","control").attr("r",6).attr("fill",l=>l.color).attr("stroke","#fff").attr("stroke-width",2).attr("cursor","move").call(e.drag().on("start",function(){e.select(this).attr("cursor","grabbing")}).on("drag",function(l,c){c.point.x=a.xScale.invert(l.x),c.point.y=a.yScale.invert(l.y),b(),r.dirty=!0}).on("end",function(){e.select(this).attr("cursor","move")})),x=u.selectAll("text.label").data(m,l=>l.id).join("text").attr("class","label").attr("text-anchor","middle").attr("font-family","serif").attr("font-size","18px").attr("font-style","italic").attr("fill","#333").style("text-shadow",[[-1,0,2.5],[1,0,2.5],[0,1,2.5],[0,-1,2.5]].map(([l,c,y])=>`${l}px ${c}px ${y}px white`).join(", ")).text(l=>l.label);function b(){const[l,c]=a.xRange,[y,g]=a.yRange;s.attr("x",Math.min(l,c)).attr("y",Math.min(y,g)).attr("width",Math.abs(c-l)).attr("height",Math.abs(g-y)),v.attr("cx",p=>a.xScale(p.point.x)).attr("cy",p=>a.yScale(p.point.y)),x.attr("x",p=>a.xScale(p.point.x)+8).attr("y",p=>a.yScale(p.point.y)+18)}return b(),t.addEventListener("update",b),{svg:i,defs:n,clipRect:s,clippedGroup:u,circleData:m,circles:v,labels:x,updatePositions:b}},inputs:["d3","stack","controlPoints","axes","regl"],outputs:["svg","defs","clipRect","clippedGroup","circleData","circles","labels","updatePositions"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});d({root:document.getElementById("cell-11"),expanded:[],variables:[]},{id:11,body:e=>({regl:e.elements.regl.value}),inputs:["stack"],outputs:["regl"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});d({root:document.getElementById("cell-12"),expanded:[],variables:[]},{id:12,body:async(e,t,o)=>{const{createPolarDomainColoringShader:a}=await f(()=>import("./domain-coloring-tVXqCKP-.js"),[]).then(i=>{if(!("createPolarDomainColoringShader"in i))throw new SyntaxError("export 'createPolarDomainColoringShader' not found");return i}),r=e({vert:`
    precision highp float;
    attribute vec2 uv;
    varying vec2 z;
    uniform mat4 viewInverse;
    void main () {
      z = (viewInverse * vec4(uv, 0, 1)).xy;
      gl_Position = vec4(uv, 0, 1);
    }`,frag:`
    #extension GL_OES_standard_derivatives : enable
    precision highp float;
    varying vec2 z;
    uniform vec2 a, m, b;
    uniform float pixelRatio;

    vec2 cmul(vec2 a, vec2 b) { return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }
    vec2 cdiv(vec2 a, vec2 b) { return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / dot(b, b); }
    vec2 f(vec2 z) { return cdiv(cmul(z - a, b - m), cmul(z - b, a - m)); }

    ${a()}

    void main () {
      vec2 w = f(z);

      gl_FragColor = domainColoring(
        vec4(w, fwidth(w) * pixelRatio),
        vec2(2.0, 2.0),    // steps
        vec2(0.1),         // scale
        vec2(0.1, 0.1),    // gridOpacity
        vec2(0.35, 0.15),  // shadingOpacity
        0.25,              // lineWidth
        0.4,               // lineFeather
        vec3(0),           // gridColor
        4.0                // contrastPower
      );
    }`,uniforms:{viewInverse:e.prop("viewInverse"),pixelRatio:e.context("pixelRatio"),a:e.prop("a"),m:e.prop("m"),b:e.prop("b")},attributes:{uv:[-4,-4,4,-4,0,4]},depth:{enable:!1},scissor:{enable:!0,box:t(o)},viewport:t(o),count:3});return{createPolarDomainColoringShader:a,drawGradient:r}},inputs:["regl","reglAxesViewport","axes"],outputs:["createPolarDomainColoringShader","drawGradient"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});d({root:document.getElementById("cell-14"),expanded:[],variables:[]},{id:14,body:(e,t,o,a,r)=>{e.dirty=!0;let i=e.frame(()=>{try{if(!e.dirty)return;t({viewInverse:o.viewInverse,a:[a.a.x,a.a.y],m:[a.m.x,a.m.y],b:[a.b.x,a.b.y]}),e.dirty=!1}catch{i?.cancel(),i=void 0}});return r.then(()=>i?.cancel()),{loop:i}},inputs:["regl","drawGradient","axes","controlPoints","invalidation"],outputs:["loop"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});d({root:document.getElementById("cell-15"),expanded:[],variables:[]},{id:15,body:async()=>{const{collapseCodeBlocks:e}=await f(()=>import("./collapsible-code-B4YhJ-0K.js"),[]).then(t=>{if(!("collapseCodeBlocks"in t))throw new SyntaxError("export 'collapseCodeBlocks' not found");return t});return e({maxHeight:600}),{collapseCodeBlocks:e}},inputs:[],outputs:["collapseCodeBlocks"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});
