async function A({device:e,pipeline:l,bindGroupLayout:m,terrainData:t,tileX:i,tileY:B,tileZ:b,tileSize:r=512}){const o=r+2;if(t.length!==o*o)throw new Error(`Terrain data size mismatch: expected ${o}Ã—${o}, got ${t.length}`);const u=e.createBuffer({size:t.byteLength,label:"Terrain buffer",usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Float32Array(u.getMappedRange()).set(t),u.unmap();const c=new Uint32Array([i,B,b,0]),s=e.createBuffer({size:c.byteLength,label:"Normal map uniforms",usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Uint32Array(s.getMappedRange()).set(c),s.unmap();const f=r*r*4*Float32Array.BYTES_PER_ELEMENT,p=e.createBuffer({size:f,label:"Normal map output",usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),d=e.createBindGroup({layout:m,label:"Normal map bind group",entries:[{binding:0,resource:{buffer:s}},{binding:1,resource:{buffer:u}},{binding:2,resource:{buffer:p}}]}),g=e.createCommandEncoder({label:"Normal map encoder"}),n=g.beginComputePass({label:"Normal map compute pass"});n.setPipeline(l),n.setBindGroup(0,d);const U=Math.ceil(r/16),P=Math.ceil(r/16);n.dispatchWorkgroups(U,P),n.end();const a=e.createBuffer({size:f,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,label:"Normal map staging buffer"});g.copyBufferToBuffer(p,0,a,0,f),e.queue.submit([g.finish()]),await a.mapAsync(GPUMapMode.READ);const y=new Float32Array(a.getMappedRange()).slice();return a.unmap(),u.destroy(),s.destroy(),p.destroy(),a.destroy(),y}export{A as computeNormalMap};
