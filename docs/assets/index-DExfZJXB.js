const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/pipeline-B5gOFiyC.js","assets/fft-CcaOZiHL.js"])))=>i.map(i=>d[i]);
import{d as c,_ as z}from"./index-ByB2dbry.js";c({root:document.getElementById("cell-1"),expanded:[],variables:[]},{id:1,body:(t,e)=>t`
This notebook implements on the GPU a two-dimensional solution of the [Kuramoto-Sivashinsky equation](https://encyclopediaofmath.org/wiki/Kuramoto-Sivashinsky_equation) (KSE),

${e.block`u_t + \frac{1}{2}|\nabla u|^2 + \nabla^2 u + \nabla^4 u = 0.`}

The KSE arises in a number of contexts and was rediscovered by Kuramoto while researching diffusion-induced flame front instabilities.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});c({root:document.getElementById("cell-2"),expanded:[],variables:[]},{id:2,body:(t,e)=>t`The KSE is one of the simplest partial differential equations to show complicated dynamics, displaying chaotic behavior as the size of the domain increases. Observe that if ${e`\nu_1`} or ${e`\nu_2`}, which represent the size of a wavelength relative to the size of the domain, are greater than one, the chaotic behavior disappears along the short dimension and the solution essentially becomes a one-dimensional solution.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});c({root:document.getElementById("cell-10"),expanded:[],variables:[]},{id:10,body:(t,e,a,n,i)=>{const o=[t,t/e],r=[Math.pow(Math.PI/o[0],2),Math.pow(Math.PI/o[1],2)];return a(n`We solve the problem in the doubly periodic domain, ${i`[0, ${o[0].toFixed(1)}] \times [0, ${o[1].toFixed(1)}]`}.

The factors ${i`\nu_1`} and ${i`\nu_2`} describe the length scale. Chaotic behavior happens when they are very small, while fundamental changes in the type of behavior happen when they are closer to the order of unity.
- ${i`\nu_1 = (\pi/L_x)^2 = ${r[0].toFixed(6)}`}
- ${i`\nu_2 = (\pi/L_y)^2 = ${r[1].toFixed(6)}`}`),{L:o,nu:r}},inputs:["Lx","aspectRatio","display","md","tex"],outputs:["L","nu"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-3"),expanded:[],variables:[]},{id:3,body:(t,e,a)=>{const n=t.limits.maxComputeWorkgroupSizeX,i=[32,64,128,256,512,1024],o=i.filter(f=>{if(f<=n)return!0;const p=f/n;return Number.isInteger(p)&&(p&p-1)===0}),r=o.map(f=>`${f}×${f}`),s=512,d=e.select(r,{value:`${s}×${s}`,label:"Grid size, N"}),u=a(d);return{maxWorkgroupSize:n,allSizes:i,validSizes:o,gridSizeOptions:r,defaultN:s,NInput:d,NString:u}},inputs:["device","Inputs","view"],outputs:["maxWorkgroupSize","allSizes","validSizes","gridSizeOptions","defaultN","NInput","NString"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-11"),expanded:[],variables:[]},{id:11,body:t=>({N:parseInt(t.split("×")[0])}),inputs:["NString"],outputs:["N"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-4"),expanded:[],variables:[]},{id:4,body:(t,e,a,n,i)=>{const o=t/2,r=e.range([1,o],{step:.1,transform:Math.log,value:Math.min(64,o),label:a`Domain size, ${n`L_x`}`}),s=i(r),d=e.range([1,10],{step:.01,value:1,transform:Math.log,label:a`Aspect ratio, ${n`L_x / L_y`}`}),u=i(d),f=e.range([1,8],{step:1,value:1,label:"Initial condition periods, n"}),l=i(f);return{maxLx:o,LxInput:r,Lx:s,aspectRatioInput:d,aspectRatio:u,nInput:f,n:l}},inputs:["N","Inputs","html","tex","view"],outputs:["maxLx","LxInput","Lx","aspectRatioInput","aspectRatio","nInput","n"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-6"),expanded:[],variables:[]},{id:6,body:(t,e)=>{const a=t.toggle({label:"Simulate",value:["Simulate"]}),n=e(a),i=t.button("Restart"),o=e(i);return{simulateInput:a,simulate:n,restartInput:i,restart:o}},inputs:["Inputs","view"],outputs:["simulateInput","simulate","restartInput","restart"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-7"),expanded:[],variables:[]},{id:7,body:(t,e,a,n,i,o,r)=>{function s(l){const{totalW:p,totalH:w,Lx:v,Ly:B}=l,m=t.plot({width:p,height:w,marginTop:e.top,marginRight:e.right,marginBottom:e.bottom,marginLeft:e.left,style:{background:"transparent"},x:{domain:[0,v],label:"x"},y:{domain:[0,B],label:"y"},marks:[]});return m.style.position="absolute",m.style.left="0",m.style.top="0",m.style.pointerEvents="none",m}let d=s(a(n,1,64));i.appendChild(d);function u(l){const p=s(l);d.replaceWith(p),d=p}const f=o`<figure style="display: flex; justify-content: center; margin: 0;">${i}</figure>`;return r(f),{createPlotOverlay:s,plotOverlay:d,updatePlotOverlay:u,figure:f}},inputs:["Plot","margins","resizeCanvas","width","container","html","display"],outputs:["createPlotOverlay","plotOverlay","updatePlotOverlay","figure"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-8"),expanded:[],variables:[]},{id:8,body:(t,e)=>{t(e)},inputs:["display","statusEl"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-9"),expanded:[],variables:[]},{id:9,body:(t,e)=>{const a=t.range([0,1],{step:.01,value:.5,label:"Contrast"}),n=e(a),i=t.select(["Viridis","Magma","Inferno","Plasma","Cividis","Greys"],{value:"Magma",label:"Colorscale"}),o=e(i),r=t.toggle({label:"Invert colorscale",value:!0}),s=e(r);return{contrastInput:a,contrast:n,colorscaleNameInput:i,colorscaleName:o,invertInput:r,invert:s}},inputs:["Inputs","view"],outputs:["contrastInput","contrast","colorscaleNameInput","colorscaleName","invertInput","invert"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-13"),expanded:[],variables:[]},{id:13,body:(t,e)=>t`The equation is solved in the spatial frequency domain, with the exception of the nonlinear term ${e`\frac{1}{2}|\nabla u|^2`} which requires computing the gradient while transforming back to the spatial domain, then squaring, then transforming back to the frequency domain.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});c({root:document.getElementById("cell-14"),expanded:[],variables:[]},{id:14,body:(t,e)=>t`A few implementation notes:

- Equation (F.10) seems to be missing a factor of ${e`dt`} in the biharmonic term.
- Since all terms include derivatives, the offset of ${e`u`} has no effect and can simply be removed by zeroing out the mean (zero-wavenumber) component on every update.
- The multi-step method is initialized with the same values for both previous steps, rather than implementing a special Backward Euler initialization step.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});c({root:document.getElementById("cell-15"),expanded:[],variables:[]},{id:15,body:(t,e)=>t`The domain has size ${e`[0, 2 L_x] \times [0, 2 L_y]`}, but the equation is solved in the domain ${e`[0, 2\pi] \times [0, 2\pi]`} via the rescaling in Chapter 9 of Kalogirou's thesis,

${e.block`x \rarr \frac{L_x}{\pi} x, \;\;\; y \rarr \frac{L_y}{\pi} y, \;\;\; t \rarr \left(\frac{L_x}{\pi}\right)^2 t.`}

along with the factors ${e`\nu_1 = \left(\frac{\pi}{L_x}\right)^2`} and ${e`\nu_2 = \left(\frac{\pi}{L_y}\right)^2`}.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});c({root:document.getElementById("cell-16"),expanded:[],variables:[]},{id:16,body:(t,e)=>t`From Appendix F on page 227, the full second order spatial frequency domain update equation for solution ${e`\hat{V}`} at step ${e`n+2`} as a function of the data from previous steps ${e`n+1`} and ${e`n`} is

${e.block`\begin{aligned}
\hat{V}^{n + 2}_{k_1, k_2} =& \frac{1}{\xi_{k_1, k_2}} \left[ (2 + 2c\,dt) \hat{V}^{n+1}_{k_1,k_2} - \left(\frac{1}{2} + c\,dt\right) \hat{V}^n_{k_1,k_2} \right. \\
& + 2dt \left( \hat{A}^{n+1}_{k_1,k_2} + \frac{\nu_2}{\nu_1} \hat{B}^{n+1}_{k_1,k_2} \right) \\
& - \left. dt \left( \hat{A}^{n}_{k_1,k_2} + \frac{\nu_2}{\nu_1} \hat{B}^{n}_{k_1,k_2} \right) \right]
\end{aligned}`}

where

${e.block`\begin{aligned}
\hat{A}_{k_1,k_2} &= -\mathscr{F}\left(\frac{1}{2}\left(\frac{\partial v}{\partial x}\right)^2\right), \\
\hat{B}_{k_1,k_2} &= -\mathscr{F}\left(\frac{1}{2}\left(\frac{\partial v}{\partial y}\right)^2\right)
\end{aligned}`}

where ${e`\mathscr{F}(\cdot)`} represents the spatial Fourier Transform and ${e`v`} is the spatial domain solution.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});c({root:document.getElementById("cell-17"),expanded:[],variables:[]},{id:17,body:(t,e)=>t`Finally,

${e.block`\begin{aligned}
\xi_{k_1,k_2} =& \frac{3}{2} + c\,dt - dt\left(k_1^2 + \frac{\nu_1}{\nu_2} k_2^2 \right) \\
& + \nu_1\,dt\left(k_1^2 + \frac{\nu_2}{\nu_1} k_2^2\right)^2,
\end{aligned}`}

using the definition ${e`c = 1 + \frac{1}{\nu_1}`}.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});c({root:document.getElementById("cell-18"),expanded:[],variables:[]},{id:18,body:(t,e)=>t`At first this update equation seems imposing, but if ${e`k_1`} and ${e`k_2`} refer to a particular wavenumber then the above is a simple algebraic expression for each grid point, independent of all others. The only exceptions are the expressions for ${e`\hat{A}_{k_1,k_2}`} and ${e`\hat{B}_{k_1,k_2}`}, which represent the solution, differentiated in the frequency domain via multiplication by ${e`ik_x`} and ${e`ik_y`}, inverse-FFT'd into the spatial domain, squared, and then FFT'd back into the spatial frequency domain. From there, the rest is tedious but straightforward shuffling of buffers.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});c({root:document.getElementById("cell-19"),expanded:[],variables:[]},{id:19,body:(t,e)=>t`## WebGPU implementation

One might hope GPU programming is plug and play. In practice, there's a lot that can go wrong.

The first hurdle is simply getting the FFT right. WebGPU lacks a built-in FFT library, meaning you must roll your own using compute shaders. This notebook uses the [Cooley-Tukey](https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm) radix-2 decimation-in-time algorithm, which requires a bit-reversal permutation at the input followed by ${e`\log_2 N`} stages of butterfly operations. For grid sizes larger than the device's maximum workgroup size (often 256), a hierarchical four-step FFT decomposes the transform into smaller pieces. Even then, getting the indexing, normalization, and twiddle factors all correct takes real effort. If there's any upside, it's that errors tend to be spectacular; it either works or it clearly doesn't.

Once the FFT works, you have to get all the wavenumbers right. Wavenumber layout in a discrete Fourier transform is not intuitive. The first half contains positive frequencies, but the second half contains negative frequencies in reverse order. Miss a sign or an off-by-one error and the derivatives blow up quickly.

Another subtle issue is that taking the complex FFT of real-valued data introduces numerical drift. The imaginary part should be exactly zero, but floating point errors slowly leak energy into it. Left unchecked, this can cause the solution to diverge. The workaround is to add an extra pass after each time step that extracts just the real part before transforming back. It adds cost, but it stabilizes the simulation. A properly-implemented real-valued transform like the Hartley transform would avoid this issue entirely.

Finally, this simulation relies on a healthy dose of *not overthinking it*. The BDF2 method technically requires a special first-order initialization step, but reusing the initial condition for both previous time levels works fine. The uniform buffer management could be more careful about GPU resource lifetimes, but letting them garbage collect naturally is simpler and hasn't caused problems. Sometimes the pragmatic solution is the right one.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});c({root:document.getElementById("cell-20"),expanded:[],variables:[]},{id:20,body:async t=>{const{createWebGPUContext:e}=await z(()=>import("./webgpu-context-BoQcYhON.js"),[]).then(o=>{if(!("createWebGPUContext"in o))throw new SyntaxError("export 'createWebGPUContext' not found");return o}),a=await e(),n=a.device,i=navigator.gpu.getPreferredCanvasFormat();return t.then(()=>n.destroy()),{createWebGPUContext:e,context:a,device:n,canvasFormat:i}},inputs:["invalidation"],outputs:["createWebGPUContext","context","device","canvasFormat"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-21"),expanded:[],variables:[]},{id:21,body:async()=>{const[{createKSPipelines:t},{executeFFT2D:e}]=await Promise.all([z(()=>import("./pipeline-B5gOFiyC.js"),__vite__mapDeps([0,1])).then(a=>{if(!("createKSPipelines"in a))throw new SyntaxError("export 'createKSPipelines' not found");return a}),z(()=>import("./fft-CcaOZiHL.js"),[]).then(a=>{if(!("executeFFT2D"in a))throw new SyntaxError("export 'executeFFT2D' not found");return a})]);return{createKSPipelines:t,executeFFT2D:e}},inputs:[],outputs:["createKSPipelines","executeFFT2D"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-22"),expanded:[],variables:[]},{id:22,body:(t,e)=>{const a=t,n=a*a*2*4,i=a*a*4*4,o=Math.ceil(a/16),r=e.STORAGE|e.COPY_SRC|e.COPY_DST,s=[2*Math.PI/a,2*Math.PI/a];return{gridN:a,vec2Size:n,vec4Size:i,workgroups:o,bufferUsage:r,dx:s}},inputs:["N","GPUBufferUsage"],outputs:["gridN","vec2Size","vec4Size","workgroups","bufferUsage","dx"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-23"),expanded:[],variables:[]},{id:23,body:async(t,e,a,n,i,o,r)=>{const s=await n(i,o,t);function d(u,f,l,p){r({device:i,pipelines:s.fft,input:u,output:f,temp:l,N:t,forward:p,splitNormalization:!0})}return{pipelines:s,runFFT2D:d}},inputs:["gridN","vec2Size","dx","createKSPipelines","device","canvasFormat","executeFFT2D"],outputs:["pipelines","runFFT2D"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-24"),expanded:[],variables:[]},{id:24,body:(t,e,a,n)=>{const i=[0,1,2].map(B=>t.createBuffer({label:`Vhat[${B}]`,size:e,usage:a})),o=[0,1].map(B=>t.createBuffer({label:`ABhat[${B}]`,size:n,usage:a})),r=t.createBuffer({label:"V",size:e,usage:a}),s=[0,1].map(B=>t.createBuffer({label:`temp[${B}]`,size:e,usage:a})),d=t.createBuffer({label:"tempVec4",size:n,usage:a}),u=t.createBuffer({label:"VxVy",size:e,usage:a}),f=t.createBuffer({label:"A",size:e,usage:a}),l=t.createBuffer({label:"B",size:e,usage:a}),p=t.createBuffer({label:"Ahat",size:e,usage:a}),w=t.createBuffer({label:"Bhat",size:e,usage:a}),v=t.createBuffer({label:"Vreal",size:e,usage:a});return{Vhat:i,ABhat:o,V:r,temp:s,tempVec4:d,VxVy:u,A:f,B:l,Ahat:p,Bhat:w,Vreal:v}},inputs:["device","vec2Size","bufferUsage","vec4Size"],outputs:["Vhat","ABhat","V","temp","tempVec4","VxVy","A","B","Ahat","Bhat","Vreal"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-25"),expanded:[],variables:[]},{id:25,body:(t,e,a,n)=>{const i=t.createBuffer({size:16,usage:e.UNIFORM|e.COPY_DST}),o=t.createBuffer({size:16,usage:e.UNIFORM|e.COPY_DST});{const p=new ArrayBuffer(16);new Uint32Array(p,0,2).set([a,a]),new Float32Array(p,8,2).set(n),t.queue.writeBuffer(o,0,p)}const r=t.createBuffer({size:32,usage:e.UNIFORM|e.COPY_DST}),s=t.createBuffer({size:8,usage:e.UNIFORM|e.COPY_DST});t.queue.writeBuffer(s,0,new Uint32Array([a,a]));const d=t.createBuffer({size:8,usage:e.UNIFORM|e.COPY_DST});t.queue.writeBuffer(d,0,new Uint32Array([a,a]));const u=t.createBuffer({size:8,usage:e.UNIFORM|e.COPY_DST});t.queue.writeBuffer(u,0,new Uint32Array([a,a]));const f=t.createBuffer({size:8,usage:e.UNIFORM|e.COPY_DST});t.queue.writeBuffer(f,0,new Uint32Array([a,a]));const l=t.createBuffer({size:32,usage:e.UNIFORM|e.COPY_DST});return{initParamsBuffer:i,diffParamsBuffer:o,bdfParamsBuffer:r,extractRealParamsBuffer:s,extractMixedDerivativesParamsBuffer:d,computeABParamsBuffer:u,packABhatParamsBuffer:f,visParamsBuffer:l}},inputs:["device","GPUBufferUsage","N","dx"],outputs:["initParamsBuffer","diffParamsBuffer","bdfParamsBuffer","extractRealParamsBuffer","extractMixedDerivativesParamsBuffer","computeABParamsBuffer","packABhatParamsBuffer","visParamsBuffer"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-26"),expanded:[],variables:[]},{id:26,body:(t,e,a)=>{function n(s){const d=new Uint8Array(1024);for(let u=0;u<256;u++){const f=u/255,l=t.rgb(s(f));d[u*4]=Math.round(l.r),d[u*4+1]=Math.round(l.g),d[u*4+2]=Math.round(l.b),d[u*4+3]=255}return d}const i={Viridis:n(t.interpolateViridis),Magma:n(t.interpolateMagma),Inferno:n(t.interpolateInferno),Plasma:n(t.interpolatePlasma),Cividis:n(t.interpolateCividis),Greys:n(t.interpolateGreys)},o=e.createTexture({size:[256,1],format:"rgba8unorm",usage:a.TEXTURE_BINDING|a.COPY_DST}),r=e.createSampler({magFilter:"linear",minFilter:"linear"});return e.queue.writeTexture({texture:o},i.Magma,{bytesPerRow:256*4},[256,1]),{generateColorscale:n,colorscaleData:i,colorscaleTexture:o,colorscaleSampler:r}},inputs:["d3","device","GPUTextureUsage"],outputs:["generateColorscale","colorscaleData","colorscaleTexture","colorscaleSampler"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-27"),expanded:[],variables:[]},{id:27,body:(t,e,a,n)=>{const i={top:5,right:5,bottom:25,left:35},o=t`<div style="position: relative;"></div>`,r=document.createElement("canvas");r.style.position="absolute",r.style.visibility="hidden";const s=r.getContext("webgpu");function d(u,f,l){const p=window.devicePixelRatio||1,w=l/f;let v,B;const m=u-i.left-i.right;f>=1?(v=m,B=Math.floor(m/f)):(B=m,v=Math.floor(m*f));const k=v+i.left+i.right,C=B+i.top+i.bottom;return o.style.width=`${k}px`,o.style.height=`${C}px`,r.style.left=`${i.left}px`,r.style.top=`${i.top}px`,r.style.width=`${v}px`,r.style.height=`${B}px`,r.width=Math.floor(v*p),r.height=Math.floor(B*p),s.configure({device:e,format:a,alphaMode:"opaque"}),{totalW:k,totalH:C,canvasW:v,canvasH:B,Lx:l,Ly:w}}return d(n,1,64),o.appendChild(r),{margins:i,container:o,canvas:r,gpuContext:s,resizeCanvas:d}},inputs:["html","device","canvasFormat","width"],outputs:["margins","container","canvas","gpuContext","resizeCanvas"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-28"),expanded:[],variables:[]},{id:28,body:(t,e,a,n,i,o,r,s)=>{const d=i(t,e,a);return o(d),r(),s.style.visibility="visible",{dims:d}},inputs:["width","aspectRatio","Lx","initComplete","resizeCanvas","updatePlotOverlay","render","canvas"],outputs:["dims"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-29"),expanded:[],variables:[]},{id:29,body:()=>({simState:{timeLevel:0,time:0,stepCount:0},simParams:{Lx:64,aspectRatio:1,n:1,range:14,colorscaleName:"Magma",invert:!1}}),inputs:[],outputs:["simState","simParams"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-30"),expanded:[],variables:[]},{id:30,body:(t,e,a,n,i,o,r)=>{r.Lx=t,r.aspectRatio=e,r.n=a,r.contrast=n,r.colorscaleName=i,r.invert=o},inputs:["Lx","aspectRatio","n","contrast","colorscaleName","invert","simParams"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-31"),expanded:[],variables:[]},{id:31,body:(t,e,a,n,i,o,r,s,d,u,f,l,p,w,v,B,m,k,C,O,E,R,T,$,D,L,q,G,S,N,W,V)=>{function F(){const g=t.Lx,x=[g,g/t.aspectRatio],_=[Math.pow(Math.PI/x[0],2),Math.pow(Math.PI/x[1],2)],b=.18*_[0];return{L:x,nu:_,dt:b,dx:e,N:a}}function P(g){const{nu:x,dt:_}=F();if(g!==void 0){const I=new ArrayBuffer(16);new Uint32Array(I,0,2).set([a,a]),new Float32Array(I,8,1).set([g]),n.queue.writeBuffer(i,0,I)}const b=new ArrayBuffer(32);new Uint32Array(b,0,2).set([a,a]),new Float32Array(b,8,2).set(e),new Float32Array(b,16,1).set([_]),new Float32Array(b,24,2).set(x),n.queue.writeBuffer(o,0,b)}function M(){const g=new ArrayBuffer(16);new Uint32Array(g,0,2).set([a,a]),new Float32Array(g,8,1).set([t.contrast/(1-t.contrast)]),new Uint32Array(g,12,1).set([t.invert?1:0]),n.queue.writeBuffer(r,0,g);const x=s[t.colorscaleName];x&&n.queue.writeTexture({texture:d},x,{bytesPerRow:256*4},[256,1])}async function K(g){await n.queue.onSubmittedWorkDone(),P(g);const x=n.createBindGroup({layout:u.bindGroupLayouts.initialize,entries:[{binding:0,resource:{buffer:f}},{binding:1,resource:{buffer:i}}]}),_=n.createCommandEncoder(),b=_.beginComputePass();b.setPipeline(u.initialize),b.setBindGroup(0,x),b.dispatchWorkgroups(l,l),b.end(),n.queue.submit([_.finish()]),p(f,w[0],v,!0);const I=n.createCommandEncoder();I.copyBufferToBuffer(w[0],0,w[1],0,B),n.queue.submit([I.finish()]),await n.queue.onSubmittedWorkDone(),m.timeLevel=1,m.time=0,m.stepCount=0}function A(g,x){const _=w[g],b=k[x],I=n.createBindGroup({layout:u.bindGroupLayouts.differentiate,entries:[{binding:0,resource:{buffer:_}},{binding:1,resource:{buffer:C}},{binding:2,resource:{buffer:O}}]});let h=n.createCommandEncoder(),y=h.beginComputePass();y.setPipeline(u.differentiate),y.setBindGroup(0,I),y.dispatchWorkgroups(l,l),y.end(),n.queue.submit([h.finish()]);const j=n.createBindGroup({layout:u.bindGroupLayouts.extractMixedDerivatives,entries:[{binding:0,resource:{buffer:C}},{binding:1,resource:{buffer:E}},{binding:2,resource:{buffer:R}}]});h=n.createCommandEncoder(),y=h.beginComputePass(),y.setPipeline(u.extractMixedDerivatives),y.setBindGroup(0,j),y.dispatchWorkgroups(l,l),y.end(),n.queue.submit([h.finish()]),p(E,E,v,!1);const X=n.createBindGroup({layout:u.bindGroupLayouts.computeAB,entries:[{binding:0,resource:{buffer:E}},{binding:1,resource:{buffer:T}},{binding:2,resource:{buffer:$}},{binding:3,resource:{buffer:D}}]});h=n.createCommandEncoder(),y=h.beginComputePass(),y.setPipeline(u.computeAB),y.setBindGroup(0,X),y.dispatchWorkgroups(l,l),y.end(),n.queue.submit([h.finish()]),p(T,L,v,!0),p($,q,v,!0);const J=n.createBindGroup({layout:u.bindGroupLayouts.packABhat,entries:[{binding:0,resource:{buffer:L}},{binding:1,resource:{buffer:q}},{binding:2,resource:{buffer:b}},{binding:3,resource:{buffer:G}}]});h=n.createCommandEncoder(),y=h.beginComputePass(),y.setPipeline(u.packABhat),y.setBindGroup(0,J),y.dispatchWorkgroups(l,l),y.end(),n.queue.submit([h.finish()])}async function Y(){P();const g=(m.timeLevel-1+3)%3,x=m.timeLevel%3,_=(m.timeLevel+1)%3;A(g,0),A(x,1);const b=n.createBindGroup({layout:u.bindGroupLayouts.bdfUpdate,entries:[{binding:0,resource:{buffer:w[g]}},{binding:1,resource:{buffer:w[x]}},{binding:2,resource:{buffer:k[0]}},{binding:3,resource:{buffer:k[1]}},{binding:4,resource:{buffer:w[_]}},{binding:5,resource:{buffer:o}}]});let I=n.createCommandEncoder(),h=I.beginComputePass();h.setPipeline(u.bdfUpdate),h.setBindGroup(0,b),h.dispatchWorkgroups(l,l),h.end(),n.queue.submit([I.finish()]),p(w[_],f,v,!1);const y=n.createBindGroup({layout:u.bindGroupLayouts.extractReal,entries:[{binding:0,resource:{buffer:f}},{binding:1,resource:{buffer:S}},{binding:2,resource:{buffer:N}}]});I=n.createCommandEncoder(),h=I.beginComputePass(),h.setPipeline(u.extractReal),h.setBindGroup(0,y),h.dispatchWorkgroups(l,l),h.end(),n.queue.submit([I.finish()]),p(S,w[_],v,!0),await n.queue.onSubmittedWorkDone(),m.timeLevel=(m.timeLevel+1)%3,m.time+=F().dt,m.stepCount++}function H(){M();const g=w[m.timeLevel%3];p(g,f,v,!1);const x=n.createBindGroup({layout:u.bindGroupLayouts.visualize,entries:[{binding:0,resource:{buffer:f}},{binding:1,resource:{buffer:r}},{binding:2,resource:d.createView()},{binding:3,resource:W}]}),_=n.createCommandEncoder(),b=_.beginRenderPass({colorAttachments:[{view:V.getCurrentTexture().createView(),loadOp:"clear",storeOp:"store",clearValue:{r:0,g:0,b:0,a:1}}]});b.setPipeline(u.visualize),b.setBindGroup(0,x),b.draw(6),b.end(),n.queue.submit([_.finish()])}return{getParams:F,updateUniforms:P,updateVisUniforms:M,initialize:K,computeNonlinearTo:A,step:Y,render:H}},inputs:["simParams","dx","N","device","initParamsBuffer","bdfParamsBuffer","visParamsBuffer","colorscaleData","colorscaleTexture","pipelines","V","workgroups","runFFT2D","Vhat","temp","vec2Size","simState","ABhat","tempVec4","diffParamsBuffer","VxVy","extractMixedDerivativesParamsBuffer","A","B","computeABParamsBuffer","Ahat","Bhat","packABhatParamsBuffer","Vreal","extractRealParamsBuffer","colorscaleSampler","gpuContext"],outputs:["getParams","updateUniforms","updateVisUniforms","initialize","computeNonlinearTo","step","render"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-32"),expanded:[],variables:[]},{id:32,body:async(t,e,a,n)=>(await a(t),n(),{initComplete:{n:t,restart:e}}),inputs:["n","restart","initialize","render"],outputs:["initComplete"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-33"),expanded:[],variables:[]},{id:33,body:(t,e,a,n,i)=>{let o=null,r=!1;async function s(){if(!r)try{if(n){for(let d=0;d<2;d++)await t();e()}o=requestAnimationFrame(s)}catch(d){r=!0,console.error("Animation loop error:",d)}}return o=requestAnimationFrame(s),i.then(()=>{r=!0,o!==null&&(cancelAnimationFrame(o),o=null)}),{animFrameId:o,hasError:r,animationLoop:s}},inputs:["step","render","initComplete","simulate","invalidation"],outputs:["animFrameId","hasError","animationLoop"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-34"),expanded:[],variables:[]},{id:34,body:(t,e,a,n,i)=>{i()},inputs:["contrast","colorscaleName","invert","initComplete","render"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});c({root:document.getElementById("cell-35"),expanded:[],variables:[]},{id:35,body:(t,e,a)=>{const n=t`<p><em>t = <span id="sim-time">0</span>, step = <span id="sim-step">0</span></em></p>`;let i=null;function o(){const r=document.getElementById("sim-time"),s=document.getElementById("sim-step");r&&(r.textContent=e.time.toFixed(4)),s&&(s.textContent=e.stepCount),i=requestAnimationFrame(o)}return i=requestAnimationFrame(o),a.then(()=>{i!==null&&(cancelAnimationFrame(i),i=null)}),{statusEl:n,statusFrameId:i,updateStatus:o}},inputs:["html","simState","invalidation"],outputs:["statusEl","statusFrameId","updateStatus"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});
