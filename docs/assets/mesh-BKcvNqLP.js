class L{constructor(){this.positions=new Float32Array(0),this.vertexCount=0,this._positionCapacity=0,this.neighbors=new Int32Array(0),this.edges=new Uint32Array(0),this.edgeCount=0,this._edgeCapacity=0,this._faces=null}static fromJSON(s){const e=new L,{vertices:t,edges:i}=s;e._ensureVertexCapacity(t.length),e._ensureEdgeCapacity(i.length);for(const n of t)e._addVertexInternal(n[0],n[1],n[2]);for(const n of i)e._addEdgeInternal(n[0],n[1]);return e}toJSON(){const s=[];for(let t=0;t<this.vertexCount;t++){const i=t*3;s.push([this.positions[i],this.positions[i+1],this.positions[i+2]])}const e=[];for(let t=0;t<this.edgeCount;t++){const i=t*2;e.push([this.edges[i],this.edges[i+1]])}return{vertices:s,edges:e}}clone(){return L.fromJSON(this.toJSON())}_ensureVertexCapacity(s){if(s<=this._positionCapacity)return;const e=Math.max(s,this._positionCapacity*2,64),t=new Float32Array(e*3);this.positions.length>0&&t.set(this.positions),this.positions=t;const i=new Int32Array(e*3);i.fill(-1),this.neighbors.length>0&&i.set(this.neighbors),this.neighbors=i,this._positionCapacity=e}_ensureEdgeCapacity(s){if(s<=this._edgeCapacity)return;const e=Math.max(s,this._edgeCapacity*2,64),t=new Uint32Array(e*2);this.edges.length>0&&t.set(this.edges),this.edges=t,this._edgeCapacity=e}_addVertexInternal(s,e,t){this._ensureVertexCapacity(this.vertexCount+1);const i=this.vertexCount,n=i*3;return this.positions[n]=s,this.positions[n+1]=e,this.positions[n+2]=t,this.neighbors[n]=-1,this.neighbors[n+1]=-1,this.neighbors[n+2]=-1,this.vertexCount++,i}_addEdgeInternal(s,e){this._ensureEdgeCapacity(this.edgeCount+1);const t=this.edgeCount,i=t*2;return this.edges[i]=s,this.edges[i+1]=e,this.edgeCount++,this._addNeighbor(s,e),this._addNeighbor(e,s),t}_addNeighbor(s,e){const t=s*3;for(let i=0;i<3;i++)if(this.neighbors[t+i]===-1)return this.neighbors[t+i]=e,!0;throw new Error(`Vertex ${s} already has 3 neighbors`)}_removeNeighbor(s,e){const t=s*3;for(let i=0;i<3;i++)if(this.neighbors[t+i]===e)return this.neighbors[t+i]=-1,this._compactNeighbors(s),!0;return!1}_compactNeighbors(s){const e=s*3,t=[this.neighbors[e],this.neighbors[e+1],this.neighbors[e+2]].filter(i=>i!==-1);this.neighbors[e]=t[0]??-1,this.neighbors[e+1]=t[1]??-1,this.neighbors[e+2]=t[2]??-1}addVertex(s,e,t){return this._faces=null,this._addVertexInternal(s,e,t)}getPosition(s,e=[0,0,0]){const t=s*3;return e[0]=this.positions[t],e[1]=this.positions[t+1],e[2]=this.positions[t+2],e}setPosition(s,e,t,i){const n=s*3;this.positions[n]=e,this.positions[n+1]=t,this.positions[n+2]=i}degree(s){const e=s*3;let t=0;return this.neighbors[e]!==-1&&t++,this.neighbors[e+1]!==-1&&t++,this.neighbors[e+2]!==-1&&t++,t}getNeighbors(s,e=[]){const t=s*3;return e.length=0,this.neighbors[t]!==-1&&e.push(this.neighbors[t]),this.neighbors[t+1]!==-1&&e.push(this.neighbors[t+1]),this.neighbors[t+2]!==-1&&e.push(this.neighbors[t+2]),e}getNeighbor(s,e){return this.neighbors[s*3+e]}deleteVertex(s){if(s<0||s>=this.vertexCount)return-1;this._faces=null;const e=s*3;let t=this.neighbors[e];const i=this.getNeighbors(s);for(const r of i)this._removeEdgeBetween(s,r);const n=this.vertexCount-1;if(s!==n){const r=n*3;this.positions[e]=this.positions[r],this.positions[e+1]=this.positions[r+1],this.positions[e+2]=this.positions[r+2],this.neighbors[e]=this.neighbors[r],this.neighbors[e+1]=this.neighbors[r+1],this.neighbors[e+2]=this.neighbors[r+2],this._remapVertex(n,s),t===n&&(t=s)}return this.vertexCount--,t>=this.vertexCount&&(t=-1),t}mergeVertices(s,e){if(s<0||s>=this.vertexCount||e<0||e>=this.vertexCount)return-1;if(s===e)return s;const t=this.getNeighbors(s),i=this.getNeighbors(e),n=t.includes(e),r=t.length,h=i.length;if((n?r+h-2:r+h)>3||t.filter(f=>f!==e&&i.includes(f)).length>0)return-1;this._faces=null,n&&this._removeEdgeBetween(s,e);const o=this.getNeighbors(e);for(const f of o)this._removeEdgeBetween(e,f),this._addEdgeInternal(s,f);const c=this.vertexCount-1;let u=s;if(e!==c){const f=e*3,a=c*3;this.positions[f]=this.positions[a],this.positions[f+1]=this.positions[a+1],this.positions[f+2]=this.positions[a+2],this.neighbors[f]=this.neighbors[a],this.neighbors[f+1]=this.neighbors[a+1],this.neighbors[f+2]=this.neighbors[a+2],this._remapVertex(c,e),s===c&&(u=e)}return this.vertexCount--,u}_removeEdgeBetween(s,e){for(let t=0;t<this.edgeCount;t++){const i=t*2,n=this.edges[i],r=this.edges[i+1];if(n===s&&r===e||n===e&&r===s){const h=this.edgeCount-1;t!==h&&(this.edges[i]=this.edges[h*2],this.edges[i+1]=this.edges[h*2+1]),this.edgeCount--;break}}this._removeNeighbor(s,e),this._removeNeighbor(e,s)}_remapVertex(s,e){for(let t=0;t<this.vertexCount;t++){const i=t*3;for(let n=0;n<3;n++)this.neighbors[i+n]===s&&(this.neighbors[i+n]=e)}for(let t=0;t<this.edgeCount;t++){const i=t*2;this.edges[i]===s&&(this.edges[i]=e),this.edges[i+1]===s&&(this.edges[i+1]=e)}}addEdge(s,e){return this.hasEdge(s,e)||this.degree(s)>=3||this.degree(e)>=3?-1:(this._faces=null,this._addEdgeInternal(s,e))}hasEdge(s,e){const t=s*3;return this.neighbors[t]===e||this.neighbors[t+1]===e||this.neighbors[t+2]===e}getEdge(s,e=[0,0]){const t=s*2;return e[0]=this.edges[t],e[1]=this.edges[t+1],e}deleteEdge(s){if(s<0||s>=this.edgeCount)return!1;this._faces=null;const e=s*2,t=this.edges[e],i=this.edges[e+1];this._removeNeighbor(t,i),this._removeNeighbor(i,t);const n=this.edgeCount-1;return s!==n&&(this.edges[e]=this.edges[n*2],this.edges[e+1]=this.edges[n*2+1]),this.edgeCount--,!0}collapseEdge(s){if(s<0||s>=this.edgeCount)return-1;const e=this.getEdge(s),t=e[0],i=e[1],n=this.degree(t),r=this.degree(i);if(n+r-2>3)return-1;const h=this.getNeighbors(t),d=this.getNeighbors(i);if(h.filter(l=>l!==i&&d.includes(l)).length>0)return-1;let o=-1;if(r===2){for(const l of d)if(l!==t){o=l;break}}if(o<0&&n===2){for(const l of h)if(l!==i){o=l;break}}let c=-1,u=-1;for(const l of d)l!==t&&(this.degree(l)===2&&c<0?c=l:this.degree(l)===1&&u<0&&(u=l));let f=-1,a=-1;for(const l of h)l!==i&&(this.degree(l)===2&&f<0?f=l:this.degree(l)===1&&a<0&&(a=l));this._faces=null;const N=this.getPosition(t),w=this.getPosition(i),g=(N[0]+w[0])/2,C=(N[1]+w[1])/2,E=(N[2]+w[2])/2,_=[...h.filter(l=>l!==i),...d.filter(l=>l!==t)];for(const l of h)this._removeEdgeBetween(t,l);for(const l of d)this._removeEdgeBetween(i,l);const m=this.vertexCount-1;let y=t;if(i!==m){t===m&&(y=i);const l=i*3,z=m*3;this.positions[l]=this.positions[z],this.positions[l+1]=this.positions[z+1],this.positions[l+2]=this.positions[z+2],this.neighbors[l]=this.neighbors[z],this.neighbors[l+1]=this.neighbors[z+1],this.neighbors[l+2]=this.neighbors[z+2],this._remapVertex(m,i);for(let $=0;$<_.length;$++)_[$]===m&&(_[$]=i)}this.vertexCount--,this.setPosition(y,g,C,E);const P=y*3;this.neighbors[P]=-1,this.neighbors[P+1]=-1,this.neighbors[P+2]=-1;let V=o;o===m&&i!==m&&(V=i);let x=c;c===m&&i!==m&&(x=i);let M=f;f===m&&i!==m&&(M=i);let B=u;u===m&&i!==m&&(B=i);let T=a;a===m&&i!==m&&(T=i);for(const l of _)l>=this.vertexCount||l!==y&&this._addEdgeInternal(y,l);if(V>=0&&V<this.vertexCount){const l=this.findEdge(y,V);if(l>=0)return l}if(x>=0&&x<this.vertexCount){const l=this.findEdge(y,x);if(l>=0)return l}if(M>=0&&M<this.vertexCount){const l=this.findEdge(y,M);if(l>=0)return l}if(B>=0&&B<this.vertexCount){const l=this.findEdge(y,B);if(l>=0)return l}if(T>=0&&T<this.vertexCount){const l=this.findEdge(y,T);if(l>=0)return l}const O=_.filter(l=>l<this.vertexCount&&l!==y);for(const l of O)if(this.degree(l)>1){const z=this.findEdge(y,l);if(z>=0)return z}if(O.length>0){const l=this.findEdge(y,O[0]);return l>=0?l:-1}return-1}extendVertex(s){if(s<0||s>=this.vertexCount)return-1;const e=this.degree(s);if(e>=3)return-1;this._faces=null;const t=this.getPosition(s),i=this.getNeighbors(s);let n,r,h;if(e===0)n=t[0]+1,r=t[1],h=t[2];else if(e===1){const o=this.getPosition(i[0]),c=t[0]-o[0],u=t[1]-o[1],f=t[2]-o[2];n=t[0]+c,r=t[1]+u,h=t[2]+f}else{let o=0,c=0,u=0;for(const N of i){const w=this.getPosition(N);o+=w[0]-t[0],c+=w[1]-t[1],u+=w[2]-t[2]}const f=Math.sqrt(o*o+c*c+u*u);f>1e-4&&(o/=f,c/=f,u/=f);let a=0;for(const N of i){const w=this.getPosition(N),g=w[0]-t[0],C=w[1]-t[1],E=w[2]-t[2];a+=Math.sqrt(g*g+C*C+E*E)}a/=i.length,n=t[0]-o*a,r=t[1]-c*a,h=t[2]-u*a}const d=this._addVertexInternal(n,r,h);return this._addEdgeInternal(s,d)}extendEdge(s){if(s<0||s>=this.edgeCount)return-1;const e=this.getEdge(s),t=e[0],i=e[1],n=this.degree(t),r=this.degree(i);let h,d;if(n===1)h=t,d=i;else if(r===1)h=i,d=t;else if(n===2)h=t,d=i;else if(r===2)h=i,d=t;else return-1;this._faces=null;const p=this.getPosition(h),o=this.getNeighbors(h),c=this.degree(h);let u,f,a;if(c===1){const g=this.getPosition(d),C=p[0]-g[0],E=p[1]-g[1],_=p[2]-g[2];u=p[0]+C,f=p[1]+E,a=p[2]+_}else{let g=0,C=0,E=0;for(const y of o){const P=this.getPosition(y);g+=P[0]-p[0],C+=P[1]-p[1],E+=P[2]-p[2]}const _=Math.sqrt(g*g+C*C+E*E);_>1e-4&&(g/=_,C/=_,E/=_);let m=0;for(const y of o){const P=this.getPosition(y),V=P[0]-p[0],x=P[1]-p[1],M=P[2]-p[2];m+=Math.sqrt(V*V+x*x+M*M)}m/=o.length,u=p[0]-g*m,f=p[1]-C*m,a=p[2]-E*m}const N=this._addVertexInternal(u,f,a);return this._addEdgeInternal(h,N)}splitEdge(s){if(s<0||s>=this.edgeCount)return-1;const e=this.getEdge(s),t=e[0],i=e[1];this._faces=null;const n=this.getPosition(t),r=this.getPosition(i),h=(n[0]+r[0])/2,d=(n[1]+r[1])/2,p=(n[2]+r[2])/2,o=this._addVertexInternal(h,d,p);this._removeEdgeBetween(t,i);const c=this._addEdgeInternal(t,o);return this._addEdgeInternal(o,i),c}addFaceOnEdge(s,e,t=null){if(s<0||s>=this.edgeCount||e<3||e>8)return!1;const i=this.getEdge(s),n=i[0],r=i[1],h=this.getPosition(n),d=this.getPosition(r),p=[d[0]-h[0],d[1]-h[1],d[2]-h[2]],o=Math.sqrt(p[0]**2+p[1]**2+p[2]**2);if(o<1e-4)return!1;const c=[p[0]/o,p[1]/o,p[2]/o];let u=t||this._inferFaceNormal(n,r,c);const f=[c[1]*u[2]-c[2]*u[1],c[2]*u[0]-c[0]*u[2],c[0]*u[1]-c[1]*u[0]],a=e,N=2*Math.PI/a,w=o/(2*Math.tan(Math.PI/a)),g=o/(2*Math.sin(Math.PI/a)),C=[(h[0]+d[0])/2,(h[1]+d[1])/2,(h[2]+d[2])/2],E=[C[0]+f[0]*w,C[1]+f[1]*w,C[2]+f[2]*w],_=[h[0]-E[0],h[1]-E[1],h[2]-E[2]],m=_[0]*f[0]+_[1]*f[1]+_[2]*f[2],y=_[0]*c[0]+_[1]*c[1]+_[2]*c[2],P=Math.atan2(y,m),V=[];for(let b=0;b<a;b++){const v=P+b*N;V.push([E[0]+g*(Math.cos(v)*f[0]+Math.sin(v)*c[0]),E[1]+g*(Math.cos(v)*f[1]+Math.sin(v)*c[1]),E[2]+g*(Math.cos(v)*f[2]+Math.sin(v)*c[2])])}const x={vertices:new Array(a),newVertexPositions:[],edgesToAdd:[]};x.vertices[0]=n,x.vertices[a-1]=r;const M=(b,v)=>{if(this.degree(b)<3)return-1;const A=this.getNeighbors(b),k=this.getPosition(b);let S=-1,q=-1/0;for(const j of A){if(j===v||v>=0&&this.getNeighbors(v).includes(j))continue;const Y=this.getPosition(j),Z=[Y[0]-k[0],Y[1]-k[1],Y[2]-k[2]],J=Z[0]*f[0]+Z[1]*f[1]+Z[2]*f[2];J>0&&J>q&&(q=J,S=j)}return S};let B=[n],T=n,O=r;for(;B.length<a-1;){const b=M(T,O);if(b<0)break;B.push(b),O=T,T=b}let l=[r];for(T=r,O=n;l.length<a-1;){const b=M(T,O);if(b<0)break;l.push(b),O=T,T=b}const z=new Set(B);for(const b of l)if(z.has(b)&&b!==n&&b!==r)break;a-l.length;for(let b=0;b<B.length&&b<a;b++)x.vertices[b]=B[b];for(let b=0;b<l.length&&a-1-b>=0;b++){const v=a-1-b;(x.vertices[v]===void 0||x.vertices[v]===l[b])&&(x.vertices[v]=l[b])}const $=B.length,D=a-l.length;for(let b=$;b<=D&&b<a-1;b++)if(x.vertices[b]===void 0){const v=-(x.newVertexPositions.length+1);x.newVertexPositions.push(V[b]),x.vertices[b]=v}const F={};for(let b=0;b<a-1;b++){const v=x.vertices[b],A=x.vertices[b+1],k=v>=0,S=A>=0;if(k&&S){if(!this.getNeighbors(v).includes(A)){const q=this.degree(v)+(F[v]||0),j=this.degree(A)+(F[A]||0);if(q>=3||j>=3)return!1;x.edgesToAdd.push([v,A]),F[v]=(F[v]||0)+1,F[A]=(F[A]||0)+1}}else{if(k){if(this.degree(v)+(F[v]||0)>=3)return!1;F[v]=(F[v]||0)+1}if(S){if(this.degree(A)+(F[A]||0)>=3)return!1;F[A]=(F[A]||0)+1}x.edgesToAdd.push([v,A])}}this._faces=null;const X={};for(let b=0;b<x.newVertexPositions.length;b++){const v=x.newVertexPositions[b],A=this._addVertexInternal(v[0],v[1],v[2]);X[-(b+1)]=A}for(let b=0;b<a;b++)x.vertices[b]<0&&(x.vertices[b]=X[x.vertices[b]]);for(const[b,v]of x.edgesToAdd){const A=b<0?X[b]:b,k=v<0?X[v]:v;this._addEdgeInternal(A,k)}return!0}_inferFaceNormal(s,e,t){const i=this.getPosition(s),n=this.getPosition(e),r=this.getNeighbors(s).filter(g=>g!==e),h=this.getNeighbors(e).filter(g=>g!==s),d=r.filter(g=>h.includes(g)),p=[(i[0]+n[0])/2,(i[1]+n[1])/2,(i[2]+n[2])/2];if(d.length>0){const g=d[0],C=this.getPosition(g),E=[n[0]-i[0],n[1]-i[1],n[2]-i[2]],_=[C[0]-i[0],C[1]-i[1],C[2]-i[2]],m=[E[1]*_[2]-E[2]*_[1],E[2]*_[0]-E[0]*_[2],E[0]*_[1]-E[1]*_[0]],y=Math.sqrt(m[0]**2+m[1]**2+m[2]**2);if(y>1e-4)return[-m[0]/y,-m[1]/y,-m[2]/y]}const o=[];for(const g of r)o.push(this.getPosition(g));for(const g of h)o.push(this.getPosition(g));if(o.length>0){let g=[0,0,0];for(const E of o){const _=[E[0]-p[0],E[1]-p[1],E[2]-p[2]],m=[t[1]*_[2]-t[2]*_[1],t[2]*_[0]-t[0]*_[2],t[0]*_[1]-t[1]*_[0]];g[0]+=m[0],g[1]+=m[1],g[2]+=m[2]}const C=Math.sqrt(g[0]**2+g[1]**2+g[2]**2);if(C>1e-4)return[g[0]/C,g[1]/C,g[2]/C]}const c=Math.abs(t[0]),u=Math.abs(t[1]),f=Math.abs(t[2]);let a;c<=u&&c<=f?a=[1,0,0]:u<=f?a=[0,1,0]:a=[0,0,1];const N=[t[1]*a[2]-t[2]*a[1],t[2]*a[0]-t[0]*a[2],t[0]*a[1]-t[1]*a[0]],w=Math.sqrt(N[0]**2+N[1]**2+N[2]**2);return[N[0]/w,N[1]/w,N[2]/w]}stoneWales(s){if(s<0||s>=this.edgeCount)return-1;const e=this.getEdge(s),t=e[0],i=e[1];if(this.degree(t)!==3||this.degree(i)!==3)return-1;const n=this.getNeighbors(t).filter(M=>M!==i),r=this.getNeighbors(i).filter(M=>M!==t);if(n.length!==2||r.length!==2)return-1;const h=n[0],d=n[1],p=r[0],o=r[1],c=this.getPosition(t),u=this.getPosition(i),f=this.getPosition(h);this.getPosition(d);const a=this.getPosition(p),N=this.getPosition(o),w=[u[0]-c[0],u[1]-c[1],u[2]-c[2]],g=[c[0]-f[0],c[1]-f[1],c[2]-f[2]],C=[w[1]*g[2]-w[2]*g[1],w[2]*g[0]-w[0]*g[2],w[0]*g[1]-w[1]*g[0]],E=[C[1]*w[2]-C[2]*w[1],C[2]*w[0]-C[0]*w[2],C[0]*w[1]-C[1]*w[0]],_=[a[0]-u[0],a[1]-u[1],a[2]-u[2]],m=[N[0]-u[0],N[1]-u[1],N[2]-u[2]],y=_[0]*E[0]+_[1]*E[1]+_[2]*E[2],P=m[0]*E[0]+m[1]*E[1]+m[2]*E[2];let V,x;return y>P?(V=h,x=p):(V=h,x=o),this._removeEdgeBetween(t,V),this._removeEdgeBetween(i,x),this._addEdgeInternal(t,x),this._addEdgeInternal(i,V),this._faces=null,this.findEdge(t,i)}findEdge(s,e){for(let t=0;t<this.edgeCount;t++){const i=t*2,n=this.edges[i],r=this.edges[i+1];if(n===s&&r===e||n===e&&r===s)return t}return-1}collapseVertex(s){if(this.degree(s)!==2)return s;this._faces=null;const e=this.neighbors[s*3],t=this.neighbors[s*3+1];this.deleteVertex(s);let i=e,n=t;const r=this.vertexCount;return e===r&&(i=s<r?s:e),t===r&&(n=s<r?s:t),e===this.vertexCount&&s<this.vertexCount&&(i=s),t===this.vertexCount&&s<this.vertexCount&&(n=s),i>=0&&n>=0&&i<this.vertexCount&&n<this.vertexCount&&this.addEdge(i,n),i>=0&&i<this.vertexCount?i:-1}splitVertex(s){if(this.degree(s)!==2)return s;this._faces=null;const e=this.neighbors[s*3],t=this.getPosition(s),i=this.getPosition(e),n=this.addVertex(.5*(t[0]+i[0]),.5*(t[1]+i[1]),.5*(t[2]+i[2]));return this._removeEdgeBetween(s,e),this._addEdgeInternal(s,n),this._addEdgeInternal(n,e),n}explodeVertex(s){const e=this.getNeighbors(s);if(e.length<=1)return s;this._faces=null;const t=this.getPosition(s);for(let i=1;i<e.length;i++){const n=e[i],r=this.addVertex(t[0],t[1],t[2]);this._removeEdgeBetween(s,n),this._addEdgeInternal(r,n)}return s}computeCentroid(s=[0,0,0]){s[0]=0,s[1]=0,s[2]=0;for(let e=0;e<this.vertexCount;e++){const t=e*3;s[0]+=this.positions[t],s[1]+=this.positions[t+1],s[2]+=this.positions[t+2]}return this.vertexCount>0&&(s[0]/=this.vertexCount,s[1]/=this.vertexCount,s[2]/=this.vertexCount),s}translate(s,e,t){for(let i=0;i<this.vertexCount;i++){const n=i*3;this.positions[n]+=s,this.positions[n+1]+=e,this.positions[n+2]+=t}}center(){const s=this.computeCentroid();this.translate(-s[0],-s[1],-s[2])}_findAllCycles(s=8){const e=new Set,t=this;function i(n){const r=Math.min(...n),h=n.indexOf(r),d=[...n.slice(h),...n.slice(0,h)],p=[d[0],...d.slice(1).reverse()],o=d.join(","),c=p.join(",");return o<c?o:c}for(let n=0;n<this.vertexCount;n++){let r=function(h,d,p){if(!(d.length>s))for(const o of t.getNeighbors(h))o===n&&d.length>=3?e.add(i(d)):o>n&&!p.has(o)&&(p.add(o),d.push(o),r(o,d,p),d.pop(),p.delete(o))};r(n,[n],new Set([n]))}return[...e].map(n=>n.split(",").map(Number))}extractAllFaces(s=8){const e=this._findAllCycles(s);e.sort((n,r)=>n.length-r.length);const t=new Map,i=[];for(const n of e){let r=!0;const h=[];for(let d=0;d<n.length;d++){const p=n[d],o=n[(d+1)%n.length],c=p<o?`${p},${o}`:`${o},${p}`;if(h.push(c),(t.get(c)||0)>=2){r=!1;break}}if(r){i.push(n);for(const d of h)t.set(d,(t.get(d)||0)+1)}}return i}extractFaces(){return this._faces!==null?this._faces:(this._faces=this.extractAllFaces(8),this._faces)}_computeSignedArea(s){if(s.length<3)return 0;let e=0,t=0,i=0;for(const g of s){const C=g*3;e+=this.positions[C],t+=this.positions[C+1],i+=this.positions[C+2]}e/=s.length,t/=s.length,i/=s.length;let n=0,r=0,h=0;const d=s.length;for(let g=0;g<d;g++){const C=s[g],E=s[(g+1)%d],_=C*3,m=E*3,y=this.positions[_],P=this.positions[_+1],V=this.positions[_+2],x=this.positions[m],M=this.positions[m+1],B=this.positions[m+2];n+=(P-M)*(V+B),r+=(V-B)*(y+x),h+=(y-x)*(P+M)}let p=0,o=0,c=0;for(let g=0;g<this.vertexCount;g++){const C=g*3;p+=this.positions[C],o+=this.positions[C+1],c+=this.positions[C+2]}p/=this.vertexCount,o/=this.vertexCount,c/=this.vertexCount;const u=e-p,f=t-o,a=i-c,N=n*u+r*f+h*a,w=Math.sqrt(n*n+r*r+h*h)*.5;return N>=0?w:-w}computeFaceNormals(){const s=this.extractFaces();if(s.length===0)return[];const e=[];for(const o of s)e.push(this._computeFaceNormal(o));const t=new Map;for(let o=0;o<s.length;o++){const c=s[o];for(let u=0;u<c.length;u++){const f=c[u],a=c[(u+1)%c.length],N=f<a?`${f},${a}`:`${a},${f}`;t.has(N)||t.set(N,[]),t.get(N).push({faceIndex:o,v1:f,v2:a})}}const i=new Array(s.length).fill(!1),n=new Array(s.length).fill(!1),r=[0];for(i[0]=!0;r.length>0;){const o=r.shift(),c=s[o];for(let u=0;u<c.length;u++){const f=c[u],a=c[(u+1)%c.length],N=f<a?`${f},${a}`:`${a},${f}`,w=t.get(N)||[];for(const g of w){if(g.faceIndex===o||i[g.faceIndex])continue;i[g.faceIndex]=!0,r.push(g.faceIndex);const C=f===c[u]&&a===c[(u+1)%c.length];s[g.faceIndex];const E=g.v1===f&&g.v2===a;C===E?n[o]?n[g.faceIndex]=!1:n[g.faceIndex]=!0:n[g.faceIndex]=n[o]}}}for(let o=0;o<e.length;o++)n[o]&&(e[o][0]=-e[o][0],e[o][1]=-e[o][1],e[o][2]=-e[o][2]);const h=this.computeCentroid();let d=0,p=0;for(let o=0;o<s.length;o++){const c=s[o];let u=0,f=0,a=0;for(const E of c){const _=E*3;u+=this.positions[_],f+=this.positions[_+1],a+=this.positions[_+2]}u/=c.length,f/=c.length,a/=c.length;const N=u-h[0],w=f-h[1],g=a-h[2];e[o][0]*N+e[o][1]*w+e[o][2]*g>0?d++:p++}if(p>d)for(const o of e)o[0]=-o[0],o[1]=-o[1],o[2]=-o[2];return e}_computeFaceNormal(s){let e=0,t=0,i=0;const n=s.length;for(let h=0;h<n;h++){const d=s[h],p=s[(h+1)%n],o=d*3,c=p*3,u=this.positions[o],f=this.positions[o+1],a=this.positions[o+2],N=this.positions[c],w=this.positions[c+1],g=this.positions[c+2];e+=(f-w)*(a+g),t+=(a-g)*(u+N),i+=(u-N)*(f+w)}const r=Math.sqrt(e*e+t*t+i*i);return r>1e-4?[e/r,t/r,i/r]:[0,1,0]}computeVertexNormals(){const s=this.extractFaces(),e=this.computeFaceNormals(),t=new Float32Array(this.vertexCount*3);for(let i=0;i<s.length;i++){const n=s[i],r=e[i];for(const h of n){const d=h*3;t[d]+=r[0],t[d+1]+=r[1],t[d+2]+=r[2]}}for(let i=0;i<this.vertexCount;i++){const n=i*3,r=t[n],h=t[n+1],d=t[n+2],p=Math.sqrt(r*r+h*h+d*d);p>1e-4&&(t[n]=r/p,t[n+1]=h/p,t[n+2]=d/p)}return t}forEachEdge(s){for(let e=0;e<this.edgeCount;e++){const t=e*2;s(this.edges[t],this.edges[t+1],e)}}forEachAngle(s){for(let e=0;e<this.vertexCount;e++){const t=e*3,i=this.neighbors[t],n=this.neighbors[t+1],r=this.neighbors[t+2];i!==-1&&n!==-1&&s(e,i,n),n!==-1&&r!==-1&&s(e,n,r),r!==-1&&i!==-1&&s(e,r,i)}}getTorsionVertices(s){const e=s*2,t=this.edges[e],i=this.edges[e+1];if(this.degree(t)<3||this.degree(i)<3)return null;const n=this.getNeighbors(t).filter(h=>h!==i),r=this.getNeighbors(i).filter(h=>h!==t);return n.length!==2||r.length!==2?null:{a:t,b:i,c:n[0],d:n[1],e:r[0],f:r[1]}}}export{L as Mesh,L as default};
