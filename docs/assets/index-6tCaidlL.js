import{d as r,_ as W}from"./index-ByB2dbry.js";r({root:document.getElementById("cell-2"),expanded:[],variables:[]},{id:2,body:async()=>({d3:await W(()=>import("https://cdn.jsdelivr.net/npm/d3@7/+esm"),[])}),inputs:[],outputs:["d3"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});r({root:document.getElementById("cell-4"),expanded:[],variables:[]},{id:4,body:()=>({points:[[0,0],[1,4],[2,0],[3,0],[4,2],[5,4]]}),inputs:[],outputs:["points"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});r({root:document.getElementById("cell-5"),expanded:[],variables:[]},{id:5,body:(n,t)=>({show:n(t.checkbox(["Nearest","B-spline","Hermite","Monotonic","derivatives"],{value:["Nearest","B-spline","Hermite","Monotonic"]}))}),inputs:["view","Inputs"],outputs:["show"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});r({root:document.getElementById("cell-6"),expanded:[],variables:[]},{id:6,body:()=>({height:400}),inputs:[],outputs:["height"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});r({root:document.getElementById("cell-7"),expanded:[],variables:[]},{id:7,body:()=>{function n(t,f,l=200){const a=new Array(l);for(let i=0;i<l;i++)a[i]=t+(f-t)*i/(l-1);return a}return{linspace:n}},inputs:[],outputs:["linspace"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});r({root:document.getElementById("cell-8"),expanded:[],variables:[]},{id:8,body:()=>{function n(t){return[1/6*(1-t)**3,1/6*(3*t**3-6*t**2+4),1/6*(-3*t**3+3*t**2+3*t+1),1/6*t**3]}return{bsplineBasis:n}},inputs:[],outputs:["bsplineBasis"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});r({root:document.getElementById("cell-9"),expanded:[],variables:[]},{id:9,body:()=>{function n(t){return[1/2*(-(t**3)+2*t**2-t),1/2*(3*t**3-5*t**2+2),1/2*(-3*t**3+4*t**2+t),1/2*(t**3-t**2)]}return{hermiteBasis:n}},inputs:[],outputs:["hermiteBasis"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});r({root:document.getElementById("cell-10"),expanded:[],variables:[]},{id:10,body:()=>({monotoneCubic:function(){function t(l){return l<0?-1:1}function f(l,a,i){var d=a-l,u=i-a;return(t(d)+t(u))*Math.min(Math.abs(d),Math.abs(u),.25*Math.abs(d+u))}return function(a,i,d,u,h){let y=f(a,i,d),x=f(i,d,u),v=d-i;return i+y*h+(3*v-2*y-x)*h**2+(y+x-2*v)*h**3}}()}),inputs:[],outputs:["monotoneCubic"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});r({root:document.getElementById("cell-11"),expanded:[],variables:[]},{id:11,body:(n,t,f,l,a,i,d,u,h,y,x)=>{{let w=function(){E(),I();const e=s.selectAll("g").data(n);e.enter().append("g").call(o=>o.append("circle").attr("r",30).attr("fill","none")).call(o=>o.append("circle").attr("r",0).attr("stroke","black").attr("stroke-width",1.5).transition().duration(750).ease(t.easeElastic).attr("r",5)).merge(e).attr("transform",o=>`translate(${p(o[0])},${m(o[1])})`).select("circle:last-child").attr("fill",o=>o===v?"lightblue":"black"),e.exit().remove()},E=function(){~a.indexOf("Nearest")&&(s.select("path.nearest1").datum(n.map(e=>[[e[0]-.5,e[1]],[e[0]+.5,e[1]]]).flat()).attr("d",t.line().x(e=>p(e[0])).y(e=>m(e[1])).defined(e=>!!e)),s.select("path.nearest2").datum(n.map(e=>[[e[0]-.5,e[1]],[e[0]+.5,e[1]]]).map(e=>[e,null]).flat().flat()).attr("d",t.line().x(e=>p(e[0])).y(e=>m(e[1])).defined(e=>!!e)))},k=function(e,o){const c=n,b=[-1,0,1,2].map($=>Math.min(Math.max(0,Math.floor(e+$)),n.length-1)),g=o((e+1)%1);return g[0]*c[b[0]][1]+g[1]*c[b[1]][1]+g[2]*c[b[2]][1]+g[3]*c[b[3]][1]},B=function(e,o){const c=n,b=[-1,0,1,2].map(g=>Math.min(Math.max(0,Math.floor(e+g)),n.length-1));return i(c[b[0]][1],c[b[1]][1],c[b[2]][1],c[b[3]][1],(e+1)%1)},_=function(e,o,c=.01){return(e(o+c)-e(o-c))/(2*c)},I=function(){~a.indexOf("B-spline")&&(s.select("path.cubicspline").datum(d(...p.domain())).attr("d",t.line().x(e=>p(e)).y(e=>m(k(e,u)))),s.select("path.cubicspline-slope").datum(d(...p.domain())).attr("d",t.line().x(e=>p(e)).y(e=>m(_(o=>k(o,u),e))))),~a.indexOf("Monotonic")&&(s.select("path.monotone").datum(d(...p.domain())).attr("d",t.line().x(e=>p(e)).y(e=>m(B(e)))),s.select("path.monotone-slope").datum(d(...p.domain())).attr("d",t.line().x(e=>p(e)).y(e=>m(_(o=>B(o),e))))),~a.indexOf("Hermite")&&(s.select("path.cubic").datum(d(...p.domain())).attr("d",t.line().x(e=>p(e)).y(e=>m(k(e,h)))),s.select("path.cubic-slope").datum(d(...p.domain())).attr("d",t.line().x(e=>p(e)).y(e=>m(_(o=>k(o,h),e)))))},M=function(e){return e.sourceEvent.target.__data__},C=function({subject:e}){v=e,w()},T=function(e){e.subject[1]=m.invert(e.y),w()},v=n[0];const p=t.scaleLinear().domain([-.5,5.5]).range([0,f]),m=t.scaleLinear().domain([-2,5]).range([l,0]),s=t.create("svg").attr("viewBox",[-14,0,f+28,l]).attr("tabindex",1).attr("pointer-events","all").call(t.drag().subject(M).on("start",C).on("drag",T));s.append("rect").attr("fill","none").attr("width",f).attr("height",l),s.append("path").attr("class","nearest1").attr("fill","none").attr("stroke","grey").attr("stroke-dasharray","4 4").attr("stroke-width",1),s.append("path").attr("class","nearest2").attr("fill","none").attr("stroke","black").attr("stroke-width",2),s.append("path").attr("class","cubic").attr("fill","none").attr("stroke","#38f").attr("stroke-width",3),s.append("path").attr("class","monotone").attr("fill","none").attr("stroke","#3d8").attr("stroke-width",3),s.append("path").attr("class","cubicspline").attr("fill","none").attr("stroke","#f38").attr("stroke-width",3),~a.indexOf("derivatives")&&(s.append("path").attr("class","axis").attr("fill","none").attr("stroke","gray").attr("stroke-dasharray","2 2").attr("stroke-width",2).datum([[-10,0],[10,0]]).attr("d",t.line().x(e=>p(e[0])).y(e=>m(e[1]))),s.append("path").attr("class","cubic-slope").attr("fill","none").attr("stroke","#38f").attr("stroke-dasharray","2 2").attr("stroke-width",2),s.append("path").attr("class","monotone-slope").attr("fill","none").attr("stroke","#3d8").attr("stroke-dasharray","2 2").attr("stroke-width",2),s.append("path").attr("class","cubicspline-slope").attr("fill","none").attr("stroke","#f38").attr("stroke-dasharray","2 2").attr("stroke-width",2)),w(),y(x`
<figure style="max-width:100%">
  ${s.node()}
  <figcaption>Three styles of cubic interpolation: <span style="color:#f38">cubic basis</span> which undershoots the data, <span style="color:#38f">Hermite</span> which overshoots the data, and <span style="color:#3d8">monotone cubic</span> which clips the slopes of Hermite interpolation to enforce monotonicity and offer a compromise.</figcaption>
</figure>
`)}},inputs:["points","d3","width","height","show","monotoneCubic","linspace","bsplineBasis","hermiteBasis","display","html"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});r({root:document.getElementById("cell-12"),expanded:[],variables:[]},{id:12,body:(n,t)=>n`Cubic basis spline interpolation uses data as spline control points. A simple method for computing it is repeated linear interpolation, referred to as [De Casteljau's algorithm](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm). Since the weight of points in each linear interpolation is in the range ${t`[0, 1]`}, the weight of points in the repeated sequence of linear interpolations must also be in the range ${t`[0, 1]`}. This form lends itself well to efficient interpolation using built-in linear filtering capability of GPU hardware. This method is described in *[GPU Gems Chapter 20: Fast Third-Order Texture Filtering](https://developer.nvidia.com/gpugems/gpugems2/part-iii-high-quality-rendering/chapter-20-fast-third-order-texture-filtering)* and tested out in the notebook [Bicubic Texture Interpolation using Linear Filtering](https://rreusser.github.io/notebooks/bicubic-texture-interpolation-using-linear-filtering/).`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});r({root:document.getElementById("cell-13"),expanded:[],variables:[]},{id:13,body:(n,t)=>n`The four basis function weights in the interval ${t`[0, 1]`} are`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});r({root:document.getElementById("cell-14"),expanded:[],variables:[]},{id:14,body:(n,t)=>n(t.block`f(u) = \frac{1}{6}
\begin{bmatrix}
(1-u)^3 \\
3u^3 - 6u^2 + 4 \\
-3u^3 + 3u^2 + 3u + 1 \\
u^3
\end{bmatrix}`),inputs:["display","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});r({root:document.getElementById("cell-15"),expanded:[],variables:[]},{id:15,body:(n,t,f,l,a)=>{{const i=n(0,1,101).map(d=>{const u=t(d);return{u:d,b0:u[0],b1:u[1],b2:u[2],b3:u[3]}});f(l`<figure>
  ${a.plot({width:384,height:256,grid:!0,x:{domain:[0,1]},y:{domain:[-.1,1]},marks:[a.ruleX([0,1]),a.ruleY([0]),a.line(i,{x:"u",y:"b0",stroke:"#d38",strokeWidth:2}),a.line(i,{x:"u",y:"b1",stroke:"#8d3",strokeWidth:2}),a.line(i,{x:"u",y:"b2",stroke:"#38d",strokeWidth:2}),a.line(i,{x:"u",y:"b3",stroke:"#d83",strokeWidth:2})]})}
  <figcaption>Basis functions for B-spline interpolation. Note the maximum value of 2/3, which results in undershoot.</figcaption>
  </figure>`)}},inputs:["linspace","bsplineBasis","display","html","Plot"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});r({root:document.getElementById("cell-17"),expanded:[],variables:[]},{id:17,body:(n,t)=>n`The four basis function weights in the interval ${t`[0, 1]`} are`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});r({root:document.getElementById("cell-18"),expanded:[],variables:[]},{id:18,body:(n,t)=>n(t`f(u) = \frac{1}{2}
\begin{bmatrix}
-u^3 + 2u^2 - u \\
3u^3 - 5u^2 + 2 \\
-3u^3 + 4u^2 + u \\
u^3 - u^2
\end{bmatrix}`),inputs:["display","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});r({root:document.getElementById("cell-19"),expanded:[],variables:[]},{id:19,body:(n,t,f,l,a)=>{{const i=n(0,1,101).map(d=>{const u=t(d);return{u:d,b0:u[0],b1:u[1],b2:u[2],b3:u[3]}});f(l`<figure>${a.plot({width:384,height:256,grid:!0,x:{domain:[0,1]},y:{domain:[-.1,1]},marks:[a.ruleX([0,1]),a.ruleY([0]),a.line(i,{x:"u",y:"b0",stroke:"#d38",strokeWidth:2}),a.line(i,{x:"u",y:"b1",stroke:"#8d3",strokeWidth:2}),a.line(i,{x:"u",y:"b2",stroke:"#38d",strokeWidth:2}),a.line(i,{x:"u",y:"b3",stroke:"#d83",strokeWidth:2})]})}
  <figcaption>Basis functions for Hermite interpolation. Note the slightly negative weights which result in overshoot.</figcaption>
  </figure>`)}},inputs:["linspace","hermiteBasis","display","html","Plot"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});r({root:document.getElementById("cell-21"),expanded:[],variables:[]},{id:21,body:(n,t)=>n(t`
\begin{aligned}
s_0 &= f_1 - f_0 \\
s_1 &= f_2 - f_1 \\
f'_1 &= (\operatorname{sign}(s_0) + \operatorname{sign}(s_1))
\operatorname{min}\left(\left|s_0\right|, \left|s_1\right|, \left|\frac{s_0 + s_1}{4}\right|\right)
\end{aligned}`),inputs:["display","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});r({root:document.getElementById("cell-22"),expanded:[],variables:[]},{id:22,body:(n,t)=>n(t`
\begin{aligned}
\Delta &= f_2 - f_1 \\
f(u) &= f_1 + f'_1 u + (3\Delta - 2f'_1 - f'_2) u^2 + (f'_1 + f'_2 - 2\Delta) u^3
\end{aligned}`),inputs:["display","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});
