class L{constructor(){this.positions=new Float32Array(0),this.vertexCount=0,this._positionCapacity=0,this.neighbors=new Int32Array(0),this.edges=new Uint32Array(0),this.edgeCount=0,this._edgeCapacity=0,this._faces=null}static fromJSON(s){const e=new L,{vertices:t,edges:i}=s;e._ensureVertexCapacity(t.length),e._ensureEdgeCapacity(i.length);for(const n of t)e._addVertexInternal(n[0],n[1],n[2]);for(const n of i)e._addEdgeInternal(n[0],n[1]);return e}toJSON(){const s=[];for(let t=0;t<this.vertexCount;t++){const i=t*3;s.push([this.positions[i],this.positions[i+1],this.positions[i+2]])}const e=[];for(let t=0;t<this.edgeCount;t++){const i=t*2;e.push([this.edges[i],this.edges[i+1]])}return{vertices:s,edges:e}}clone(){return L.fromJSON(this.toJSON())}_ensureVertexCapacity(s){if(s<=this._positionCapacity)return;const e=Math.max(s,this._positionCapacity*2,64),t=new Float32Array(e*3);this.positions.length>0&&t.set(this.positions),this.positions=t;const i=new Int32Array(e*3);i.fill(-1),this.neighbors.length>0&&i.set(this.neighbors),this.neighbors=i,this._positionCapacity=e}_ensureEdgeCapacity(s){if(s<=this._edgeCapacity)return;const e=Math.max(s,this._edgeCapacity*2,64),t=new Uint32Array(e*2);this.edges.length>0&&t.set(this.edges),this.edges=t,this._edgeCapacity=e}_addVertexInternal(s,e,t){this._ensureVertexCapacity(this.vertexCount+1);const i=this.vertexCount,n=i*3;return this.positions[n]=s,this.positions[n+1]=e,this.positions[n+2]=t,this.neighbors[n]=-1,this.neighbors[n+1]=-1,this.neighbors[n+2]=-1,this.vertexCount++,i}_addEdgeInternal(s,e){this._ensureEdgeCapacity(this.edgeCount+1);const t=this.edgeCount,i=t*2;return this.edges[i]=s,this.edges[i+1]=e,this.edgeCount++,this._addNeighbor(s,e),this._addNeighbor(e,s),t}_addNeighbor(s,e){const t=s*3;for(let i=0;i<3;i++)if(this.neighbors[t+i]===-1)return this.neighbors[t+i]=e,!0;throw new Error(`Vertex ${s} already has 3 neighbors`)}_removeNeighbor(s,e){const t=s*3;for(let i=0;i<3;i++)if(this.neighbors[t+i]===e)return this.neighbors[t+i]=-1,this._compactNeighbors(s),!0;return!1}_compactNeighbors(s){const e=s*3,t=[this.neighbors[e],this.neighbors[e+1],this.neighbors[e+2]].filter(i=>i!==-1);this.neighbors[e]=t[0]??-1,this.neighbors[e+1]=t[1]??-1,this.neighbors[e+2]=t[2]??-1}addVertex(s,e,t){return this._faces=null,this._addVertexInternal(s,e,t)}getPosition(s,e=[0,0,0]){const t=s*3;return e[0]=this.positions[t],e[1]=this.positions[t+1],e[2]=this.positions[t+2],e}setPosition(s,e,t,i){const n=s*3;this.positions[n]=e,this.positions[n+1]=t,this.positions[n+2]=i}degree(s){const e=s*3;let t=0;return this.neighbors[e]!==-1&&t++,this.neighbors[e+1]!==-1&&t++,this.neighbors[e+2]!==-1&&t++,t}getNeighbors(s,e=[]){const t=s*3;return e.length=0,this.neighbors[t]!==-1&&e.push(this.neighbors[t]),this.neighbors[t+1]!==-1&&e.push(this.neighbors[t+1]),this.neighbors[t+2]!==-1&&e.push(this.neighbors[t+2]),e}getNeighbor(s,e){return this.neighbors[s*3+e]}deleteVertex(s){if(s<0||s>=this.vertexCount)return-1;this._faces=null;const e=s*3;let t=this.neighbors[e];const i=this.getNeighbors(s);for(const o of i)this._removeEdgeBetween(s,o);const n=this.vertexCount-1;if(s!==n){const o=n*3;this.positions[e]=this.positions[o],this.positions[e+1]=this.positions[o+1],this.positions[e+2]=this.positions[o+2],this.neighbors[e]=this.neighbors[o],this.neighbors[e+1]=this.neighbors[o+1],this.neighbors[e+2]=this.neighbors[o+2],this._remapVertex(n,s),t===n&&(t=s)}return this.vertexCount--,t>=this.vertexCount&&(t=-1),t}mergeVertices(s,e){if(s<0||s>=this.vertexCount||e<0||e>=this.vertexCount)return-1;if(s===e)return s;const t=this.getNeighbors(s),i=this.getNeighbors(e),n=t.includes(e),o=t.length,h=i.length;if((n?o+h-2:o+h)>3||t.filter(u=>u!==e&&i.includes(u)).length>0)return-1;this._faces=null,n&&this._removeEdgeBetween(s,e);const c=this.getNeighbors(e);for(const u of c)this._removeEdgeBetween(e,u),this._addEdgeInternal(s,u);const l=this.vertexCount-1;let _=s;if(e!==l){const u=e*3,d=l*3;this.positions[u]=this.positions[d],this.positions[u+1]=this.positions[d+1],this.positions[u+2]=this.positions[d+2],this.neighbors[u]=this.neighbors[d],this.neighbors[u+1]=this.neighbors[d+1],this.neighbors[u+2]=this.neighbors[d+2],this._remapVertex(l,e),s===l&&(_=e)}return this.vertexCount--,_}_removeEdgeBetween(s,e){for(let t=0;t<this.edgeCount;t++){const i=t*2,n=this.edges[i],o=this.edges[i+1];if(n===s&&o===e||n===e&&o===s){const h=this.edgeCount-1;t!==h&&(this.edges[i]=this.edges[h*2],this.edges[i+1]=this.edges[h*2+1]),this.edgeCount--;break}}this._removeNeighbor(s,e),this._removeNeighbor(e,s)}_remapVertex(s,e){for(let t=0;t<this.vertexCount;t++){const i=t*3;for(let n=0;n<3;n++)this.neighbors[i+n]===s&&(this.neighbors[i+n]=e)}for(let t=0;t<this.edgeCount;t++){const i=t*2;this.edges[i]===s&&(this.edges[i]=e),this.edges[i+1]===s&&(this.edges[i+1]=e)}}addEdge(s,e){return this.hasEdge(s,e)||this.degree(s)>=3||this.degree(e)>=3?-1:(this._faces=null,this._addEdgeInternal(s,e))}hasEdge(s,e){const t=s*3;return this.neighbors[t]===e||this.neighbors[t+1]===e||this.neighbors[t+2]===e}getEdge(s,e=[0,0]){const t=s*2;return e[0]=this.edges[t],e[1]=this.edges[t+1],e}deleteEdge(s){if(s<0||s>=this.edgeCount)return!1;this._faces=null;const e=s*2,t=this.edges[e],i=this.edges[e+1];this._removeNeighbor(t,i),this._removeNeighbor(i,t);const n=this.edgeCount-1;return s!==n&&(this.edges[e]=this.edges[n*2],this.edges[e+1]=this.edges[n*2+1]),this.edgeCount--,!0}collapseEdge(s){if(s<0||s>=this.edgeCount)return-1;const e=this.getEdge(s),t=e[0],i=e[1],n=this.degree(t),o=this.degree(i);if(n+o-2>3)return-1;const h=this.getNeighbors(t),f=this.getNeighbors(i);if(h.filter(r=>r!==i&&f.includes(r)).length>0)return-1;let c=-1;if(o===2){for(const r of f)if(r!==t){c=r;break}}if(c<0&&n===2){for(const r of h)if(r!==i){c=r;break}}let l=-1,_=-1;for(const r of f)r!==t&&(this.degree(r)===2&&l<0?l=r:this.degree(r)===1&&_<0&&(_=r));let u=-1,d=-1;for(const r of h)r!==i&&(this.degree(r)===2&&u<0?u=r:this.degree(r)===1&&d<0&&(d=r));this._faces=null;const V=this.getPosition(t),N=this.getPosition(i),a=(V[0]+N[0])/2,b=(V[1]+N[1])/2,w=(V[2]+N[2])/2,E=[...h.filter(r=>r!==i),...f.filter(r=>r!==t)];for(const r of h)this._removeEdgeBetween(t,r);for(const r of f)this._removeEdgeBetween(i,r);const C=this.vertexCount-1;let P=t;if(i!==C){t===C&&(P=i);const r=i*3,O=C*3;this.positions[r]=this.positions[O],this.positions[r+1]=this.positions[O+1],this.positions[r+2]=this.positions[O+2],this.neighbors[r]=this.neighbors[O],this.neighbors[r+1]=this.neighbors[O+1],this.neighbors[r+2]=this.neighbors[O+2],this._remapVertex(C,i);for(let q=0;q<E.length;q++)E[q]===C&&(E[q]=i)}this.vertexCount--,this.setPosition(P,a,b,w);const y=P*3;this.neighbors[y]=-1,this.neighbors[y+1]=-1,this.neighbors[y+2]=-1;let x=c;c===C&&i!==C&&(x=i);let v=l;l===C&&i!==C&&(v=i);let M=u;u===C&&i!==C&&(M=i);let B=_;_===C&&i!==C&&(B=i);let T=d;d===C&&i!==C&&(T=i);for(const r of E)r>=this.vertexCount||r!==P&&this._addEdgeInternal(P,r);if(x>=0&&x<this.vertexCount){const r=this.findEdge(P,x);if(r>=0)return r}if(v>=0&&v<this.vertexCount){const r=this.findEdge(P,v);if(r>=0)return r}if(M>=0&&M<this.vertexCount){const r=this.findEdge(P,M);if(r>=0)return r}if(B>=0&&B<this.vertexCount){const r=this.findEdge(P,B);if(r>=0)return r}if(T>=0&&T<this.vertexCount){const r=this.findEdge(P,T);if(r>=0)return r}const k=E.filter(r=>r<this.vertexCount&&r!==P);for(const r of k)if(this.degree(r)>1){const O=this.findEdge(P,r);if(O>=0)return O}if(k.length>0){const r=this.findEdge(P,k[0]);return r>=0?r:-1}return-1}extendVertex(s){if(s<0||s>=this.vertexCount)return-1;const e=this.degree(s);if(e>=3)return-1;this._faces=null;const t=this.getPosition(s),i=this.getNeighbors(s);let n,o,h;if(e===0)n=t[0]+1,o=t[1],h=t[2];else if(e===1){const c=this.getPosition(i[0]),l=t[0]-c[0],_=t[1]-c[1],u=t[2]-c[2];n=t[0]+l,o=t[1]+_,h=t[2]+u}else{let c=0,l=0,_=0;for(const V of i){const N=this.getPosition(V);c+=N[0]-t[0],l+=N[1]-t[1],_+=N[2]-t[2]}const u=Math.sqrt(c*c+l*l+_*_);u>1e-4&&(c/=u,l/=u,_/=u);let d=0;for(const V of i){const N=this.getPosition(V),a=N[0]-t[0],b=N[1]-t[1],w=N[2]-t[2];d+=Math.sqrt(a*a+b*b+w*w)}d/=i.length,n=t[0]-c*d,o=t[1]-l*d,h=t[2]-_*d}const f=this._addVertexInternal(n,o,h);return this._addEdgeInternal(s,f)}extendEdge(s){if(s<0||s>=this.edgeCount)return-1;const e=this.getEdge(s),t=e[0],i=e[1],n=this.degree(t),o=this.degree(i);let h,f;if(n===1)h=t,f=i;else if(o===1)h=i,f=t;else if(n===2)h=t,f=i;else if(o===2)h=i,f=t;else return-1;this._faces=null;const p=this.getPosition(h),c=this.getNeighbors(h),l=this.degree(h);let _,u,d;if(l===1){const a=this.getPosition(f),b=p[0]-a[0],w=p[1]-a[1],E=p[2]-a[2];_=p[0]+b,u=p[1]+w,d=p[2]+E}else{let a=0,b=0,w=0;for(const P of c){const y=this.getPosition(P);a+=y[0]-p[0],b+=y[1]-p[1],w+=y[2]-p[2]}const E=Math.sqrt(a*a+b*b+w*w);E>1e-4&&(a/=E,b/=E,w/=E);let C=0;for(const P of c){const y=this.getPosition(P),x=y[0]-p[0],v=y[1]-p[1],M=y[2]-p[2];C+=Math.sqrt(x*x+v*v+M*M)}C/=c.length,_=p[0]-a*C,u=p[1]-b*C,d=p[2]-w*C}const V=this._addVertexInternal(_,u,d);return this._addEdgeInternal(h,V)}splitEdge(s){if(s<0||s>=this.edgeCount)return-1;const e=this.getEdge(s),t=e[0],i=e[1];this._faces=null;const n=this.getPosition(t),o=this.getPosition(i),h=(n[0]+o[0])/2,f=(n[1]+o[1])/2,p=(n[2]+o[2])/2,c=this._addVertexInternal(h,f,p);this._removeEdgeBetween(t,i);const l=this._addEdgeInternal(t,c);return this._addEdgeInternal(c,i),l}addFaceOnEdge(s,e,t=null){if(s<0||s>=this.edgeCount||e<3||e>8)return!1;const i=this.getEdge(s),n=i[0],o=i[1],h=this.getPosition(n),f=this.getPosition(o),p=[f[0]-h[0],f[1]-h[1],f[2]-h[2]],c=Math.sqrt(p[0]**2+p[1]**2+p[2]**2);if(c<1e-4)return!1;const l=[p[0]/c,p[1]/c,p[2]/c];let _=t||this._inferFaceNormal(n,o,l);const u=[l[1]*_[2]-l[2]*_[1],l[2]*_[0]-l[0]*_[2],l[0]*_[1]-l[1]*_[0]],d=e,V=2*Math.PI/d,N=c/(2*Math.tan(Math.PI/d)),a=c/(2*Math.sin(Math.PI/d)),b=[(h[0]+f[0])/2,(h[1]+f[1])/2,(h[2]+f[2])/2],w=[b[0]+u[0]*N,b[1]+u[1]*N,b[2]+u[2]*N],E=[h[0]-w[0],h[1]-w[1],h[2]-w[2]],C=E[0]*u[0]+E[1]*u[1]+E[2]*u[2],P=E[0]*l[0]+E[1]*l[1]+E[2]*l[2],y=Math.atan2(P,C),x=[];for(let g=0;g<d;g++){const m=y+g*V;x.push([w[0]+a*(Math.cos(m)*u[0]+Math.sin(m)*l[0]),w[1]+a*(Math.cos(m)*u[1]+Math.sin(m)*l[1]),w[2]+a*(Math.cos(m)*u[2]+Math.sin(m)*l[2])])}const v={vertices:new Array(d),newVertexPositions:[],edgesToAdd:[]};v.vertices[0]=n,v.vertices[d-1]=o;const M=(g,m)=>{if(this.degree(g)<3)return-1;const A=this.getNeighbors(g),z=this.getPosition(g);let X=-1,S=-1/0;for(const j of A){if(j===m||m>=0&&this.getNeighbors(m).includes(j))continue;const Z=this.getPosition(j),$=[Z[0]-z[0],Z[1]-z[1],Z[2]-z[2]],J=$[0]*u[0]+$[1]*u[1]+$[2]*u[2];J>0&&J>S&&(S=J,X=j)}return X};let B=[n],T=n,k=o;for(;B.length<d-1;){const g=M(T,k);if(g<0)break;B.push(g),k=T,T=g}let r=[o];for(T=o,k=n;r.length<d-1;){const g=M(T,k);if(g<0)break;r.push(g),k=T,T=g}const O=new Set(B);for(const g of r)if(O.has(g)&&g!==n&&g!==o)break;d-r.length;for(let g=0;g<B.length&&g<d;g++)v.vertices[g]=B[g];for(let g=0;g<r.length&&d-1-g>=0;g++){const m=d-1-g;(v.vertices[m]===void 0||v.vertices[m]===r[g])&&(v.vertices[m]=r[g])}const q=B.length,D=d-r.length;for(let g=q;g<=D&&g<d-1;g++)if(v.vertices[g]===void 0){const m=-(v.newVertexPositions.length+1);v.newVertexPositions.push(x[g]),v.vertices[g]=m}const F={};for(let g=0;g<d-1;g++){const m=v.vertices[g],A=v.vertices[g+1],z=m>=0,X=A>=0;if(z&&X){if(!this.getNeighbors(m).includes(A)){const S=this.degree(m)+(F[m]||0),j=this.degree(A)+(F[A]||0);if(S>=3||j>=3)return!1;v.edgesToAdd.push([m,A]),F[m]=(F[m]||0)+1,F[A]=(F[A]||0)+1}}else{if(z){if(this.degree(m)+(F[m]||0)>=3)return!1;F[m]=(F[m]||0)+1}if(X){if(this.degree(A)+(F[A]||0)>=3)return!1;F[A]=(F[A]||0)+1}v.edgesToAdd.push([m,A])}}this._faces=null;const Y={};for(let g=0;g<v.newVertexPositions.length;g++){const m=v.newVertexPositions[g],A=this._addVertexInternal(m[0],m[1],m[2]);Y[-(g+1)]=A}for(let g=0;g<d;g++)v.vertices[g]<0&&(v.vertices[g]=Y[v.vertices[g]]);for(const[g,m]of v.edgesToAdd){const A=g<0?Y[g]:g,z=m<0?Y[m]:m;this._addEdgeInternal(A,z)}return!0}_inferFaceNormal(s,e,t){const i=this.getPosition(s),n=this.getPosition(e),o=this.getNeighbors(s).filter(a=>a!==e),h=this.getNeighbors(e).filter(a=>a!==s),f=o.filter(a=>h.includes(a)),p=[(i[0]+n[0])/2,(i[1]+n[1])/2,(i[2]+n[2])/2];if(f.length>0){const a=f[0],b=this.getPosition(a),w=[n[0]-i[0],n[1]-i[1],n[2]-i[2]],E=[b[0]-i[0],b[1]-i[1],b[2]-i[2]],C=[w[1]*E[2]-w[2]*E[1],w[2]*E[0]-w[0]*E[2],w[0]*E[1]-w[1]*E[0]],P=Math.sqrt(C[0]**2+C[1]**2+C[2]**2);if(P>1e-4)return[-C[0]/P,-C[1]/P,-C[2]/P]}const c=[];for(const a of o)c.push(this.getPosition(a));for(const a of h)c.push(this.getPosition(a));if(c.length>0){let a=[0,0,0];for(const w of c){const E=[w[0]-p[0],w[1]-p[1],w[2]-p[2]],C=[t[1]*E[2]-t[2]*E[1],t[2]*E[0]-t[0]*E[2],t[0]*E[1]-t[1]*E[0]];a[0]+=C[0],a[1]+=C[1],a[2]+=C[2]}const b=Math.sqrt(a[0]**2+a[1]**2+a[2]**2);if(b>1e-4)return[a[0]/b,a[1]/b,a[2]/b]}const l=Math.abs(t[0]),_=Math.abs(t[1]),u=Math.abs(t[2]);let d;l<=_&&l<=u?d=[1,0,0]:_<=u?d=[0,1,0]:d=[0,0,1];const V=[t[1]*d[2]-t[2]*d[1],t[2]*d[0]-t[0]*d[2],t[0]*d[1]-t[1]*d[0]],N=Math.sqrt(V[0]**2+V[1]**2+V[2]**2);return[V[0]/N,V[1]/N,V[2]/N]}stoneWales(s){if(s<0||s>=this.edgeCount)return-1;const e=this.getEdge(s),t=e[0],i=e[1];if(this.degree(t)!==3||this.degree(i)!==3)return-1;const n=this.getNeighbors(t).filter(M=>M!==i),o=this.getNeighbors(i).filter(M=>M!==t);if(n.length!==2||o.length!==2)return-1;const h=n[0],f=n[1],p=o[0],c=o[1],l=this.getPosition(t),_=this.getPosition(i),u=this.getPosition(h);this.getPosition(f);const d=this.getPosition(p),V=this.getPosition(c),N=[_[0]-l[0],_[1]-l[1],_[2]-l[2]],a=[l[0]-u[0],l[1]-u[1],l[2]-u[2]],b=[N[1]*a[2]-N[2]*a[1],N[2]*a[0]-N[0]*a[2],N[0]*a[1]-N[1]*a[0]],w=[b[1]*N[2]-b[2]*N[1],b[2]*N[0]-b[0]*N[2],b[0]*N[1]-b[1]*N[0]],E=[d[0]-_[0],d[1]-_[1],d[2]-_[2]],C=[V[0]-_[0],V[1]-_[1],V[2]-_[2]],P=E[0]*w[0]+E[1]*w[1]+E[2]*w[2],y=C[0]*w[0]+C[1]*w[1]+C[2]*w[2];let x,v;return P>y?(x=h,v=p):(x=h,v=c),this._removeEdgeBetween(t,x),this._removeEdgeBetween(i,v),this._addEdgeInternal(t,v),this._addEdgeInternal(i,x),this._faces=null,this.findEdge(t,i)}findEdge(s,e){for(let t=0;t<this.edgeCount;t++){const i=t*2,n=this.edges[i],o=this.edges[i+1];if(n===s&&o===e||n===e&&o===s)return t}return-1}collapseVertex(s){if(this.degree(s)!==2)return s;this._faces=null;const e=this.neighbors[s*3],t=this.neighbors[s*3+1];this.deleteVertex(s);let i=e,n=t;const o=this.vertexCount;return e===o&&(i=s<o?s:e),t===o&&(n=s<o?s:t),e===this.vertexCount&&s<this.vertexCount&&(i=s),t===this.vertexCount&&s<this.vertexCount&&(n=s),i>=0&&n>=0&&i<this.vertexCount&&n<this.vertexCount&&this.addEdge(i,n),i>=0&&i<this.vertexCount?i:-1}splitVertex(s){if(this.degree(s)!==2)return s;this._faces=null;const e=this.neighbors[s*3],t=this.getPosition(s),i=this.getPosition(e),n=this.addVertex(.5*(t[0]+i[0]),.5*(t[1]+i[1]),.5*(t[2]+i[2]));return this._removeEdgeBetween(s,e),this._addEdgeInternal(s,n),this._addEdgeInternal(n,e),n}explodeVertex(s){const e=this.getNeighbors(s);if(e.length<=1)return s;this._faces=null;const t=this.getPosition(s);for(let i=1;i<e.length;i++){const n=e[i],o=this.addVertex(t[0],t[1],t[2]);this._removeEdgeBetween(s,n),this._addEdgeInternal(o,n)}return s}computeCentroid(s=[0,0,0]){s[0]=0,s[1]=0,s[2]=0;for(let e=0;e<this.vertexCount;e++){const t=e*3;s[0]+=this.positions[t],s[1]+=this.positions[t+1],s[2]+=this.positions[t+2]}return this.vertexCount>0&&(s[0]/=this.vertexCount,s[1]/=this.vertexCount,s[2]/=this.vertexCount),s}translate(s,e,t){for(let i=0;i<this.vertexCount;i++){const n=i*3;this.positions[n]+=s,this.positions[n+1]+=e,this.positions[n+2]+=t}}center(){const s=this.computeCentroid();this.translate(-s[0],-s[1],-s[2])}_findAllCycles(s=8){const e=new Set,t=this;function i(n){const o=Math.min(...n),h=n.indexOf(o),f=[...n.slice(h),...n.slice(0,h)],p=[f[0],...f.slice(1).reverse()],c=f.join(","),l=p.join(",");return c<l?c:l}for(let n=0;n<this.vertexCount;n++){let o=function(h,f,p){if(!(f.length>s))for(const c of t.getNeighbors(h))c===n&&f.length>=3?e.add(i(f)):c>n&&!p.has(c)&&(p.add(c),f.push(c),o(c,f,p),f.pop(),p.delete(c))};o(n,[n],new Set([n]))}return[...e].map(n=>n.split(",").map(Number))}extractAllFaces(s=8){const e=this._findAllCycles(s);e.sort((n,o)=>n.length-o.length);const t=new Map,i=[];for(const n of e){let o=!0;const h=[];for(let f=0;f<n.length;f++){const p=n[f],c=n[(f+1)%n.length],l=p<c?`${p},${c}`:`${c},${p}`;if(h.push(l),(t.get(l)||0)>=2){o=!1;break}}if(o){i.push(n);for(const f of h)t.set(f,(t.get(f)||0)+1)}}return i}extractFaces(){return this._faces!==null?this._faces:(this._faces=this.extractAllFaces(8),this._faces)}_computeSignedArea(s){if(s.length<3)return 0;let e=0,t=0,i=0;for(const a of s){const b=a*3;e+=this.positions[b],t+=this.positions[b+1],i+=this.positions[b+2]}e/=s.length,t/=s.length,i/=s.length;let n=0,o=0,h=0;const f=s.length;for(let a=0;a<f;a++){const b=s[a],w=s[(a+1)%f],E=b*3,C=w*3,P=this.positions[E],y=this.positions[E+1],x=this.positions[E+2],v=this.positions[C],M=this.positions[C+1],B=this.positions[C+2];n+=(y-M)*(x+B),o+=(x-B)*(P+v),h+=(P-v)*(y+M)}let p=0,c=0,l=0;for(let a=0;a<this.vertexCount;a++){const b=a*3;p+=this.positions[b],c+=this.positions[b+1],l+=this.positions[b+2]}p/=this.vertexCount,c/=this.vertexCount,l/=this.vertexCount;const _=e-p,u=t-c,d=i-l,V=n*_+o*u+h*d,N=Math.sqrt(n*n+o*o+h*h)*.5;return V>=0?N:-N}forEachEdge(s){for(let e=0;e<this.edgeCount;e++){const t=e*2;s(this.edges[t],this.edges[t+1],e)}}forEachAngle(s){for(let e=0;e<this.vertexCount;e++){const t=e*3,i=this.neighbors[t],n=this.neighbors[t+1],o=this.neighbors[t+2];i!==-1&&n!==-1&&s(e,i,n),n!==-1&&o!==-1&&s(e,n,o),o!==-1&&i!==-1&&s(e,o,i)}}getTorsionVertices(s){const e=s*2,t=this.edges[e],i=this.edges[e+1];if(this.degree(t)<3||this.degree(i)<3)return null;const n=this.getNeighbors(t).filter(h=>h!==i),o=this.getNeighbors(i).filter(h=>h!==t);return n.length!==2||o.length!==2?null:{a:t,b:i,c:n[0],d:n[1],e:o[0],f:o[1]}}}export{L as Mesh,L as default};
