function P(r){const{faces:n,vertices:t,normals:c,uvs:o}=r,e={vertices:new Float32Array(n.length*3),count:n.length};c&&(e.normals=new Float32Array(n.length*3)),o&&(e.uvs=new Float32Array(n.length*2));for(let s=0;s<n.length;s++){const v=n[s]*3;if(e.vertices[s*3]=t[v],e.vertices[s*3+1]=t[v+1],e.vertices[s*3+2]=t[v+2],c&&(e.normals[s*3]=c[v],e.normals[s*3+1]=c[v+1],e.normals[s*3+2]=c[v+2]),o){const m=n[s]*2;e.uvs[s*2]=o[m],e.uvs[s*2+1]=o[m+1]}}return e}function z(r,n,t={},{vec3:c}){const o=[],e=[];r=r||{};const s=!!t.computeNormals,v=!!t.computeUvs,m=!!t.unwrapV,[d,b]=Array.isArray(t.divisions)?t.divisions:[t.divisions||30,t.divisions||30],U=n.boundary[0]==="closed",V=n.boundary[1]==="closed"&&!m,l=U?d:d+1,I=V?b:b+1,x=l*I,j=r.vertices=r.vertices||new Float32Array(x*3),y=r.faces=r.faces||new Uint32Array(d*b*6),g=s?r.normals=r.normals||new Float32Array(x*3):null,B=v?r.uvs=r.uvs||new Float32Array(x*2):null,O=s?n.evaluator([1,0]):null,C=s?n.evaluator([0,1]):null,A=n.domain;for(let u=0;u<l;u++){const a=A[0][0]+(A[0][1]-A[0][0])*u/d;for(let i=0;i<I;i++){const f=A[1][0]+(A[1][1]-A[1][0])*i/b,w=3*(u+l*i);if(n.evaluate(o,a,f),j[w]=o[0],j[w+1]=o[1],j[w+2]=o[2],s&&(O(o,a,f),C(e,a,f),c.normalize(o,c.cross(o,o,e)),g[w]=o[0],g[w+1]=o[1],g[w+2]=o[2]),v){const N=2*(u+l*i);B[N]=a,B[N+1]=f}}}let F=0;for(let u=0;u<d;u++){let a=u+1;U&&(a=a%d);for(let i=0;i<b;i++){let f=i+1;V&&(f=f%b),y[F++]=u+l*i,y[F++]=a+l*i,y[F++]=a+l*f,y[F++]=u+l*i,y[F++]=a+l*f,y[F++]=u+l*f}}return r}function S(r,n,t={}){const c={};return n.vertices&&(c.vertices=r.buffer(n.vertices)),n.normals&&(c.normals=r.buffer(n.normals)),n.uvs&&(c.uvs=r.buffer(n.uvs)),Object.assign(c,{count:n.vertices.length/3},t)}export{S as createBuffers,z as meshNurbsSurface,P as unindex};
