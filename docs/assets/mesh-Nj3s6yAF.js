class V{constructor(){this.positions=new Float32Array(0),this.vertexCount=0,this._positionCapacity=0,this.neighbors=new Int32Array(0),this.edges=new Uint32Array(0),this.edgeCount=0,this._edgeCapacity=0,this._faces=null}static fromJSON(t){const s=new V,{vertices:i,edges:e}=t;s._ensureVertexCapacity(i.length),s._ensureEdgeCapacity(e.length);for(const n of i)s._addVertexInternal(n[0],n[1],n[2]);for(const n of e)s._addEdgeInternal(n[0],n[1]);return s}toJSON(){const t=[];for(let i=0;i<this.vertexCount;i++){const e=i*3;t.push([this.positions[e],this.positions[e+1],this.positions[e+2]])}const s=[];for(let i=0;i<this.edgeCount;i++){const e=i*2;s.push([this.edges[e],this.edges[e+1]])}return{vertices:t,edges:s}}clone(){return V.fromJSON(this.toJSON())}_ensureVertexCapacity(t){if(t<=this._positionCapacity)return;const s=Math.max(t,this._positionCapacity*2,64),i=new Float32Array(s*3);this.positions.length>0&&i.set(this.positions),this.positions=i;const e=new Int32Array(s*3);e.fill(-1),this.neighbors.length>0&&e.set(this.neighbors),this.neighbors=e,this._positionCapacity=s}_ensureEdgeCapacity(t){if(t<=this._edgeCapacity)return;const s=Math.max(t,this._edgeCapacity*2,64),i=new Uint32Array(s*2);this.edges.length>0&&i.set(this.edges),this.edges=i,this._edgeCapacity=s}_addVertexInternal(t,s,i){this._ensureVertexCapacity(this.vertexCount+1);const e=this.vertexCount,n=e*3;return this.positions[n]=t,this.positions[n+1]=s,this.positions[n+2]=i,this.neighbors[n]=-1,this.neighbors[n+1]=-1,this.neighbors[n+2]=-1,this.vertexCount++,e}_addEdgeInternal(t,s){this._ensureEdgeCapacity(this.edgeCount+1);const i=this.edgeCount,e=i*2;return this.edges[e]=t,this.edges[e+1]=s,this.edgeCount++,this._addNeighbor(t,s),this._addNeighbor(s,t),i}_addNeighbor(t,s){const i=t*3;for(let e=0;e<3;e++)if(this.neighbors[i+e]===-1)return this.neighbors[i+e]=s,!0;throw new Error(`Vertex ${t} already has 3 neighbors`)}_removeNeighbor(t,s){const i=t*3;for(let e=0;e<3;e++)if(this.neighbors[i+e]===s)return this.neighbors[i+e]=-1,this._compactNeighbors(t),!0;return!1}_compactNeighbors(t){const s=t*3,i=[this.neighbors[s],this.neighbors[s+1],this.neighbors[s+2]].filter(e=>e!==-1);this.neighbors[s]=i[0]??-1,this.neighbors[s+1]=i[1]??-1,this.neighbors[s+2]=i[2]??-1}addVertex(t,s,i){return this._faces=null,this._addVertexInternal(t,s,i)}getPosition(t,s=[0,0,0]){const i=t*3;return s[0]=this.positions[i],s[1]=this.positions[i+1],s[2]=this.positions[i+2],s}setPosition(t,s,i,e){const n=t*3;this.positions[n]=s,this.positions[n+1]=i,this.positions[n+2]=e}degree(t){const s=t*3;let i=0;return this.neighbors[s]!==-1&&i++,this.neighbors[s+1]!==-1&&i++,this.neighbors[s+2]!==-1&&i++,i}getNeighbors(t,s=[]){const i=t*3;return s.length=0,this.neighbors[i]!==-1&&s.push(this.neighbors[i]),this.neighbors[i+1]!==-1&&s.push(this.neighbors[i+1]),this.neighbors[i+2]!==-1&&s.push(this.neighbors[i+2]),s}getNeighbor(t,s){return this.neighbors[t*3+s]}deleteVertex(t){if(t<0||t>=this.vertexCount)return-1;this._faces=null;const s=t*3;let i=this.neighbors[s];const e=this.getNeighbors(t);for(const o of e)this._removeEdgeBetween(t,o);const n=this.vertexCount-1;if(t!==n){const o=n*3;this.positions[s]=this.positions[o],this.positions[s+1]=this.positions[o+1],this.positions[s+2]=this.positions[o+2],this.neighbors[s]=this.neighbors[o],this.neighbors[s+1]=this.neighbors[o+1],this.neighbors[s+2]=this.neighbors[o+2],this._remapVertex(n,t),i===n&&(i=t)}return this.vertexCount--,i>=this.vertexCount&&(i=-1),i}_removeEdgeBetween(t,s){for(let i=0;i<this.edgeCount;i++){const e=i*2,n=this.edges[e],o=this.edges[e+1];if(n===t&&o===s||n===s&&o===t){const h=this.edgeCount-1;i!==h&&(this.edges[e]=this.edges[h*2],this.edges[e+1]=this.edges[h*2+1]),this.edgeCount--;break}}this._removeNeighbor(t,s),this._removeNeighbor(s,t)}_remapVertex(t,s){for(let i=0;i<this.vertexCount;i++){const e=i*3;for(let n=0;n<3;n++)this.neighbors[e+n]===t&&(this.neighbors[e+n]=s)}for(let i=0;i<this.edgeCount;i++){const e=i*2;this.edges[e]===t&&(this.edges[e]=s),this.edges[e+1]===t&&(this.edges[e+1]=s)}}addEdge(t,s){return this.hasEdge(t,s)||this.degree(t)>=3||this.degree(s)>=3?-1:(this._faces=null,this._addEdgeInternal(t,s))}hasEdge(t,s){const i=t*3;return this.neighbors[i]===s||this.neighbors[i+1]===s||this.neighbors[i+2]===s}getEdge(t,s=[0,0]){const i=t*2;return s[0]=this.edges[i],s[1]=this.edges[i+1],s}collapseVertex(t){if(this.degree(t)!==2)return t;this._faces=null;const s=this.neighbors[t*3],i=this.neighbors[t*3+1];this.deleteVertex(t);let e=s,n=i;const o=this.vertexCount;return s===o&&(e=t<o?t:s),i===o&&(n=t<o?t:i),s===this.vertexCount&&t<this.vertexCount&&(e=t),i===this.vertexCount&&t<this.vertexCount&&(n=t),e>=0&&n>=0&&e<this.vertexCount&&n<this.vertexCount&&this.addEdge(e,n),e>=0&&e<this.vertexCount?e:-1}splitVertex(t){if(this.degree(t)!==2)return t;this._faces=null;const s=this.neighbors[t*3],i=this.getPosition(t),e=this.getPosition(s),n=this.addVertex(.5*(i[0]+e[0]),.5*(i[1]+e[1]),.5*(i[2]+e[2]));return this._removeEdgeBetween(t,s),this._addEdgeInternal(t,n),this._addEdgeInternal(n,s),n}explodeVertex(t){const s=this.getNeighbors(t);if(s.length<=1)return t;this._faces=null;const i=this.getPosition(t);for(let e=1;e<s.length;e++){const n=s[e],o=this.addVertex(i[0],i[1],i[2]);this._removeEdgeBetween(t,n),this._addEdgeInternal(o,n)}return t}computeCentroid(t=[0,0,0]){t[0]=0,t[1]=0,t[2]=0;for(let s=0;s<this.vertexCount;s++){const i=s*3;t[0]+=this.positions[i],t[1]+=this.positions[i+1],t[2]+=this.positions[i+2]}return this.vertexCount>0&&(t[0]/=this.vertexCount,t[1]/=this.vertexCount,t[2]/=this.vertexCount),t}translate(t,s,i){for(let e=0;e<this.vertexCount;e++){const n=e*3;this.positions[n]+=t,this.positions[n+1]+=s,this.positions[n+2]+=i}}center(){const t=this.computeCentroid();this.translate(-t[0],-t[1],-t[2])}_computeCoreVertices(){const t=new Int32Array(this.vertexCount);for(let e=0;e<this.vertexCount;e++)t[e]=this.degree(e);let s=!0;for(;s;){s=!1;for(let e=0;e<this.vertexCount;e++)if(t[e]===1){t[e]=0;for(const n of this.getNeighbors(e))t[n]>0&&(t[n]--,s=!0)}}const i=new Set;for(let e=0;e<this.vertexCount;e++)t[e]>=2&&i.add(e);return i}extractAllFaces(){const t=this._computeCoreVertices();if(t.size===0)return[];const s=this._buildRotationSystem(t),i=[],e=new Set;for(let n=0;n<this.edgeCount;n++){const o=this.edges[n*2],h=this.edges[n*2+1];if(!(!t.has(o)||!t.has(h)))for(const[g,u]of[[o,h],[h,o]]){const d=`${g},${u}`;if(e.has(d))continue;const c=this._walkFace(g,u,s);if(c&&c.length>=3&&c.length<=12){i.push(c);for(let r=0;r<c.length;r++){const p=c[r],b=c[(r+1)%c.length];e.add(`${p},${b}`)}}}}return i}_buildRotationSystem(t){const s=this.computeCentroid(),i=new Map;for(const e of t){const n=this.getNeighbors(e).filter(f=>t.has(f));if(n.length<=2){i.set(e,n);continue}const o=this.getPosition(e),h=[o[0]-s[0],o[1]-s[1],o[2]-s[2]],g=Math.sqrt(h[0]**2+h[1]**2+h[2]**2);g>1e-10&&(h[0]/=g,h[1]/=g,h[2]/=g);const u=this.getPosition(n[0]),d=[u[0]-o[0],u[1]-o[1],u[2]-o[2]],c=d[0]*h[0]+d[1]*h[1]+d[2]*h[2],r=[d[0]-c*h[0],d[1]-c*h[1],d[2]-c*h[2]],p=Math.sqrt(r[0]**2+r[1]**2+r[2]**2);p>1e-10&&(r[0]/=p,r[1]/=p,r[2]/=p);const b=[h[1]*r[2]-h[2]*r[1],h[2]*r[0]-h[0]*r[2],h[0]*r[1]-h[1]*r[0]],_=n.map(f=>{const a=this.getPosition(f),l=[a[0]-o[0],a[1]-o[1],a[2]-o[2]],y=l[0]*r[0]+l[1]*r[1]+l[2]*r[2],C=l[0]*b[0]+l[1]*b[1]+l[2]*b[2];return{n:f,angle:Math.atan2(C,y)}}).sort((f,a)=>f.angle-a.angle);i.set(e,_.map(f=>f.n))}return i}_walkFace(t,s,i){const n=[t];let o=t,h=s;for(let g=0;g<12;g++){if(h===t)return n;n.push(h);const u=this._cyclicNext(h,o,i);if(u===-1||u!==t&&n.includes(u))return null;o=h,h=u}return null}_cyclicNext(t,s,i){const e=i.get(t);if(!e||e.length===0)return-1;if(e.length===1)return e[0];const n=e.indexOf(s);return n===-1?e[0]:e[(n+1)%e.length]}_canonicalFaceKey(t){if(t.length===0)return"";let s=t[0],i=0;for(let g=1;g<t.length;g++)t[g]<s&&(s=t[g],i=g);const e=[...t.slice(i),...t.slice(0,i)],n=[e[0],...e.slice(1).reverse()],o=e.join(","),h=n.join(",");return o<h?o:h}extractFaces(){return this._faces!==null?this._faces:(this._faces=this.extractAllFaces(),this._faces)}_computeSignedArea(t){if(t.length<3)return 0;let s=0,i=0,e=0;for(const a of t){const l=a*3;s+=this.positions[l],i+=this.positions[l+1],e+=this.positions[l+2]}s/=t.length,i/=t.length,e/=t.length;let n=0,o=0,h=0;const g=t.length;for(let a=0;a<g;a++){const l=t[a],y=t[(a+1)%g],C=l*3,m=y*3,w=this.positions[C],E=this.positions[C+1],N=this.positions[C+2],x=this.positions[m],v=this.positions[m+1],A=this.positions[m+2];n+=(E-v)*(N+A),o+=(N-A)*(w+x),h+=(w-x)*(E+v)}let u=0,d=0,c=0;for(let a=0;a<this.vertexCount;a++){const l=a*3;u+=this.positions[l],d+=this.positions[l+1],c+=this.positions[l+2]}u/=this.vertexCount,d/=this.vertexCount,c/=this.vertexCount;const r=s-u,p=i-d,b=e-c,_=n*r+o*p+h*b,f=Math.sqrt(n*n+o*o+h*h)*.5;return _>=0?f:-f}forEachEdge(t){for(let s=0;s<this.edgeCount;s++){const i=s*2;t(this.edges[i],this.edges[i+1],s)}}forEachAngle(t){for(let s=0;s<this.vertexCount;s++){const i=s*3,e=this.neighbors[i],n=this.neighbors[i+1],o=this.neighbors[i+2];e!==-1&&n!==-1&&t(s,e,n),n!==-1&&o!==-1&&t(s,n,o),o!==-1&&e!==-1&&t(s,o,e)}}getTorsionVertices(t){const s=t*2,i=this.edges[s],e=this.edges[s+1];if(this.degree(i)<3||this.degree(e)<3)return null;const n=this.getNeighbors(i).filter(h=>h!==e),o=this.getNeighbors(e).filter(h=>h!==i);return n.length!==2||o.length!==2?null:{a:i,b:e,c:n[0],d:n[1],e:o[0],f:o[1]}}}export{V as Mesh,V as default};
