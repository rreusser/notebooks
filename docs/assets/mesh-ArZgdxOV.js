class p{constructor(){this.positions=new Float32Array(0),this.vertexCount=0,this._positionCapacity=0,this.neighbors=new Int32Array(0),this.edges=new Uint32Array(0),this.edgeCount=0,this._edgeCapacity=0,this._faces=null}static fromJSON(t){const s=new p,{vertices:i,edges:e}=t;s._ensureVertexCapacity(i.length),s._ensureEdgeCapacity(e.length);for(const n of i)s._addVertexInternal(n[0],n[1],n[2]);for(const n of e)s._addEdgeInternal(n[0],n[1]);return s}toJSON(){const t=[];for(let i=0;i<this.vertexCount;i++){const e=i*3;t.push([this.positions[e],this.positions[e+1],this.positions[e+2]])}const s=[];for(let i=0;i<this.edgeCount;i++){const e=i*2;s.push([this.edges[e],this.edges[e+1]])}return{vertices:t,edges:s}}clone(){return p.fromJSON(this.toJSON())}_ensureVertexCapacity(t){if(t<=this._positionCapacity)return;const s=Math.max(t,this._positionCapacity*2,64),i=new Float32Array(s*3);this.positions.length>0&&i.set(this.positions),this.positions=i;const e=new Int32Array(s*3);e.fill(-1),this.neighbors.length>0&&e.set(this.neighbors),this.neighbors=e,this._positionCapacity=s}_ensureEdgeCapacity(t){if(t<=this._edgeCapacity)return;const s=Math.max(t,this._edgeCapacity*2,64),i=new Uint32Array(s*2);this.edges.length>0&&i.set(this.edges),this.edges=i,this._edgeCapacity=s}_addVertexInternal(t,s,i){this._ensureVertexCapacity(this.vertexCount+1);const e=this.vertexCount,n=e*3;return this.positions[n]=t,this.positions[n+1]=s,this.positions[n+2]=i,this.neighbors[n]=-1,this.neighbors[n+1]=-1,this.neighbors[n+2]=-1,this.vertexCount++,e}_addEdgeInternal(t,s){this._ensureEdgeCapacity(this.edgeCount+1);const i=this.edgeCount,e=i*2;return this.edges[e]=t,this.edges[e+1]=s,this.edgeCount++,this._addNeighbor(t,s),this._addNeighbor(s,t),i}_addNeighbor(t,s){const i=t*3;for(let e=0;e<3;e++)if(this.neighbors[i+e]===-1)return this.neighbors[i+e]=s,!0;throw new Error(`Vertex ${t} already has 3 neighbors`)}_removeNeighbor(t,s){const i=t*3;for(let e=0;e<3;e++)if(this.neighbors[i+e]===s)return this.neighbors[i+e]=-1,this._compactNeighbors(t),!0;return!1}_compactNeighbors(t){const s=t*3,i=[this.neighbors[s],this.neighbors[s+1],this.neighbors[s+2]].filter(e=>e!==-1);this.neighbors[s]=i[0]??-1,this.neighbors[s+1]=i[1]??-1,this.neighbors[s+2]=i[2]??-1}addVertex(t,s,i){return this._faces=null,this._addVertexInternal(t,s,i)}getPosition(t,s=[0,0,0]){const i=t*3;return s[0]=this.positions[i],s[1]=this.positions[i+1],s[2]=this.positions[i+2],s}setPosition(t,s,i,e){const n=t*3;this.positions[n]=s,this.positions[n+1]=i,this.positions[n+2]=e}degree(t){const s=t*3;let i=0;return this.neighbors[s]!==-1&&i++,this.neighbors[s+1]!==-1&&i++,this.neighbors[s+2]!==-1&&i++,i}getNeighbors(t,s=[]){const i=t*3;return s.length=0,this.neighbors[i]!==-1&&s.push(this.neighbors[i]),this.neighbors[i+1]!==-1&&s.push(this.neighbors[i+1]),this.neighbors[i+2]!==-1&&s.push(this.neighbors[i+2]),s}getNeighbor(t,s){return this.neighbors[t*3+s]}deleteVertex(t){if(t<0||t>=this.vertexCount)return-1;this._faces=null;const s=t*3;let i=this.neighbors[s];const e=this.getNeighbors(t);for(const o of e)this._removeEdgeBetween(t,o);const n=this.vertexCount-1;if(t!==n){const o=n*3;this.positions[s]=this.positions[o],this.positions[s+1]=this.positions[o+1],this.positions[s+2]=this.positions[o+2],this.neighbors[s]=this.neighbors[o],this.neighbors[s+1]=this.neighbors[o+1],this.neighbors[s+2]=this.neighbors[o+2],this._remapVertex(n,t),i===n&&(i=t)}return this.vertexCount--,i>=this.vertexCount&&(i=-1),i}_removeEdgeBetween(t,s){for(let i=0;i<this.edgeCount;i++){const e=i*2,n=this.edges[e],o=this.edges[e+1];if(n===t&&o===s||n===s&&o===t){const r=this.edgeCount-1;i!==r&&(this.edges[e]=this.edges[r*2],this.edges[e+1]=this.edges[r*2+1]),this.edgeCount--;break}}this._removeNeighbor(t,s),this._removeNeighbor(s,t)}_remapVertex(t,s){for(let i=0;i<this.vertexCount;i++){const e=i*3;for(let n=0;n<3;n++)this.neighbors[e+n]===t&&(this.neighbors[e+n]=s)}for(let i=0;i<this.edgeCount;i++){const e=i*2;this.edges[e]===t&&(this.edges[e]=s),this.edges[e+1]===t&&(this.edges[e+1]=s)}}addEdge(t,s){return this.hasEdge(t,s)||this.degree(t)>=3||this.degree(s)>=3?-1:(this._faces=null,this._addEdgeInternal(t,s))}hasEdge(t,s){const i=t*3;return this.neighbors[i]===s||this.neighbors[i+1]===s||this.neighbors[i+2]===s}getEdge(t,s=[0,0]){const i=t*2;return s[0]=this.edges[i],s[1]=this.edges[i+1],s}collapseVertex(t){if(this.degree(t)!==2)return t;this._faces=null;const s=this.neighbors[t*3],i=this.neighbors[t*3+1];this.deleteVertex(t);let e=s,n=i;const o=this.vertexCount;return s===o&&(e=t<o?t:s),i===o&&(n=t<o?t:i),s===this.vertexCount&&t<this.vertexCount&&(e=t),i===this.vertexCount&&t<this.vertexCount&&(n=t),e>=0&&n>=0&&e<this.vertexCount&&n<this.vertexCount&&this.addEdge(e,n),e>=0&&e<this.vertexCount?e:-1}splitVertex(t){if(this.degree(t)!==2)return t;this._faces=null;const s=this.neighbors[t*3],i=this.getPosition(t),e=this.getPosition(s),n=this.addVertex(.5*(i[0]+e[0]),.5*(i[1]+e[1]),.5*(i[2]+e[2]));return this._removeEdgeBetween(t,s),this._addEdgeInternal(t,n),this._addEdgeInternal(n,s),n}explodeVertex(t){const s=this.getNeighbors(t);if(s.length<=1)return t;this._faces=null;const i=this.getPosition(t);for(let e=1;e<s.length;e++){const n=s[e],o=this.addVertex(i[0],i[1],i[2]);this._removeEdgeBetween(t,n),this._addEdgeInternal(o,n)}return t}computeCentroid(t=[0,0,0]){t[0]=0,t[1]=0,t[2]=0;for(let s=0;s<this.vertexCount;s++){const i=s*3;t[0]+=this.positions[i],t[1]+=this.positions[i+1],t[2]+=this.positions[i+2]}return this.vertexCount>0&&(t[0]/=this.vertexCount,t[1]/=this.vertexCount,t[2]/=this.vertexCount),t}translate(t,s,i){for(let e=0;e<this.vertexCount;e++){const n=e*3;this.positions[n]+=t,this.positions[n+1]+=s,this.positions[n+2]+=i}}center(){const t=this.computeCentroid();this.translate(-t[0],-t[1],-t[2])}_findAllCycles(t=8){const s=new Set,i=this;function e(n){const o=Math.min(...n),r=n.indexOf(o),h=[...n.slice(r),...n.slice(0,r)],c=[h[0],...h.slice(1).reverse()],g=h.join(","),l=c.join(",");return g<l?g:l}for(let n=0;n<this.vertexCount;n++){let o=function(r,h,c){if(!(h.length>t))for(const g of i.getNeighbors(r))g===n&&h.length>=3?s.add(e(h)):g>n&&!c.has(g)&&(c.add(g),h.push(g),o(g,h,c),h.pop(),c.delete(g))};o(n,[n],new Set([n]))}return[...s].map(n=>n.split(",").map(Number))}extractAllFaces(t=8){const s=this._findAllCycles(t);s.sort((n,o)=>n.length-o.length);const i=new Map,e=[];for(const n of s){let o=!0;const r=[];for(let h=0;h<n.length;h++){const c=n[h],g=n[(h+1)%n.length],l=c<g?`${c},${g}`:`${g},${c}`;if(r.push(l),(i.get(l)||0)>=2){o=!1;break}}if(o){e.push(n);for(const h of r)i.set(h,(i.get(h)||0)+1)}}return e}extractFaces(){return this._faces!==null?this._faces:(this._faces=this.extractAllFaces(8),this._faces)}_computeSignedArea(t){if(t.length<3)return 0;let s=0,i=0,e=0;for(const a of t){const d=a*3;s+=this.positions[d],i+=this.positions[d+1],e+=this.positions[d+2]}s/=t.length,i/=t.length,e/=t.length;let n=0,o=0,r=0;const h=t.length;for(let a=0;a<h;a++){const d=t[a],P=t[(a+1)%h],f=d*3,u=P*3,C=this.positions[f],_=this.positions[f+1],y=this.positions[f+2],m=this.positions[u],E=this.positions[u+1],V=this.positions[u+2];n+=(_-E)*(y+V),o+=(y-V)*(C+m),r+=(C-m)*(_+E)}let c=0,g=0,l=0;for(let a=0;a<this.vertexCount;a++){const d=a*3;c+=this.positions[d],g+=this.positions[d+1],l+=this.positions[d+2]}c/=this.vertexCount,g/=this.vertexCount,l/=this.vertexCount;const w=s-c,N=i-g,A=e-l,x=n*w+o*N+r*A,b=Math.sqrt(n*n+o*o+r*r)*.5;return x>=0?b:-b}forEachEdge(t){for(let s=0;s<this.edgeCount;s++){const i=s*2;t(this.edges[i],this.edges[i+1],s)}}forEachAngle(t){for(let s=0;s<this.vertexCount;s++){const i=s*3,e=this.neighbors[i],n=this.neighbors[i+1],o=this.neighbors[i+2];e!==-1&&n!==-1&&t(s,e,n),n!==-1&&o!==-1&&t(s,n,o),o!==-1&&e!==-1&&t(s,o,e)}}getTorsionVertices(t){const s=t*2,i=this.edges[s],e=this.edges[s+1];if(this.degree(i)<3||this.degree(e)<3)return null;const n=this.getNeighbors(i).filter(r=>r!==e),o=this.getNeighbors(e).filter(r=>r!==i);return n.length!==2||o.length!==2?null:{a:i,b:e,c:n[0],d:n[1],e:o[0],f:o[1]}}}export{p as Mesh,p as default};
