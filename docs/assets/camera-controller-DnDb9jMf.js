function ut(s,m={}){const e={center:m.center?[...m.center]:[0,0,0],distance:m.distance||10,phi:m.phi||0,theta:m.theta||.3,fov:m.fov||Math.PI/4,near:m.near||.1,far:m.far||1e3},P=m.rotateSpeed||.01,W=m.zoomSpeed||.001,k=m.panSpeed||1,i=new Float32Array(16),h=new Float32Array(16),U=new Float32Array(16);let Y=!0,Z=!1,y=null,C=0,v=0,R=0,T=0,L=0,X=0,b=0,x=[0,0,0],F=0,q=0,K=0;function ht(t){const{phi:n,theta:a,distance:o,center:c,fov:d,near:M,far:f}=e,r=c[0]+o*Math.cos(a)*Math.cos(n),l=c[1]+o*Math.sin(a),u=c[2]+o*Math.cos(a)*Math.sin(n);let g=c[0]-r,p=c[1]-l,w=c[2]-u;const I=Math.sqrt(g*g+p*p+w*w);g/=I,p/=I,w/=I;let E=p*0-w*1,D=w*0-g*0,S=g*1-p*0;const z=Math.sqrt(E*E+D*D+S*S);z>1e-4&&(E/=z,D/=z,S/=z);const nt=D*w-S*p,ot=S*g-E*w,ct=E*p-D*g;i[0]=E,i[1]=nt,i[2]=-g,i[3]=0,i[4]=D,i[5]=ot,i[6]=-p,i[7]=0,i[8]=S,i[9]=ct,i[10]=-w,i[11]=0,i[12]=-(E*r+D*l+S*u),i[13]=-(nt*r+ot*l+ct*u),i[14]=g*r+p*l+w*u,i[15]=1;const at=1/Math.tan(d/2),st=1/(M-f);h[0]=at/t,h[1]=0,h[2]=0,h[3]=0,h[4]=0,h[5]=at,h[6]=0,h[7]=0,h[8]=0,h[9]=0,h[10]=(M+f)*st,h[11]=-1,h[12]=0,h[13]=0,h[14]=M*f*st*2,h[15]=0;for(let A=0;A<4;A++)for(let j=0;j<4;j++){let it=0;for(let B=0;B<4;B++)it+=h[A+B*4]*i[B+j*4];U[A+j*4]=it}}function H(t,n){const{phi:a,theta:o,distance:c}=e,d=Math.sin(a),M=-Math.cos(a),f=-Math.sin(o)*Math.cos(a),r=Math.cos(o),l=-Math.sin(o)*Math.sin(a),u=c*k;e.center[0]-=t*d*u,e.center[0]+=n*f*u,e.center[1]+=n*r*u,e.center[2]-=t*M*u,e.center[2]+=n*l*u}function G(t){t.preventDefault(),C=t.clientX,v=t.clientY,y=t.altKey?"zoom":t.ctrlKey||t.metaKey?"pivot":t.shiftKey||t.button===2?"pan":"rotate",R=t.clientX,T=t.clientY,L=e.phi,X=e.theta,b=e.distance,x=[...e.center],Z=!0,s.style.cursor="grabbing",window.addEventListener("mousemove",V),window.addEventListener("mouseup",_)}function V(t){if(!Z)return;const n=t.clientX-C,a=t.clientY-v;if(C=t.clientX,v=t.clientY,y==="rotate")e.phi+=n*P,e.theta=Math.max(-Math.PI/2+.01,Math.min(Math.PI/2-.01,e.theta+a*P));else if(y==="pan"){const o=s.getBoundingClientRect();H(n/o.height,a/o.height)}else if(y==="zoom"){const o=t.clientY-T;e.distance=Math.max(e.near*10,b*Math.exp(-o*W*5));const c=s.getBoundingClientRect(),d=(R-c.left-c.width/2)/c.height,M=(T-c.top-c.height/2)/c.height,r=(1-e.distance/b)*b*k,l=Math.sin(L),u=-Math.cos(L),g=-Math.sin(X)*Math.cos(L),p=Math.cos(X),w=-Math.sin(X)*Math.sin(L);e.center[0]=x[0]+r*(d*l-M*g),e.center[1]=x[1]+r*(-M*p),e.center[2]=x[2]+r*(d*u-M*w)}else if(y==="pivot"){const{distance:o,fov:c}=e,d=x[0]+o*Math.cos(X)*Math.cos(L),M=x[1]+o*Math.sin(X),f=x[2]+o*Math.cos(X)*Math.sin(L),r=s.getBoundingClientRect(),l=Math.tan(c/2),u=r.height/2,g=r.left+r.width/2,p=r.top+r.height/2,w=Math.atan((t.clientX-g)*l/u)-Math.atan((R-g)*l/u),I=Math.atan((p-t.clientY)*l/u)-Math.atan((p-T)*l/u);e.phi=L-w/Math.cos(X),e.theta=Math.max(-Math.PI/2+.01,Math.min(Math.PI/2-.01,X+I)),e.center[0]=d-o*Math.cos(e.theta)*Math.cos(e.phi),e.center[1]=M-o*Math.sin(e.theta),e.center[2]=f-o*Math.cos(e.theta)*Math.sin(e.phi)}Y=!0}function _(){Z=!1,y=null,s.style.cursor="grab",window.removeEventListener("mousemove",V),window.removeEventListener("mouseup",_)}function J(t){t.preventDefault();const n=s.getBoundingClientRect(),a=(t.clientX-n.left-n.width/2)/n.height,o=(t.clientY-n.top-n.height/2)/n.height,c=1+t.deltaY*W,d=e.distance;e.distance=Math.max(e.near*10,d*c);const f=1-e.distance/d;H(-a*f,-o*f),Y=!0}function N(t){if(t.preventDefault(),t.touches.length===1)Z=!0,y="rotate",C=t.touches[0].clientX,v=t.touches[0].clientY;else if(t.touches.length===2){const n=t.touches[1].clientX-t.touches[0].clientX,a=t.touches[1].clientY-t.touches[0].clientY;F=Math.sqrt(n*n+a*a),q=(t.touches[0].clientX+t.touches[1].clientX)/2,K=(t.touches[0].clientY+t.touches[1].clientY)/2}}function O(t){if(t.preventDefault(),t.touches.length===1&&Z){const n=t.touches[0].clientX-C,a=t.touches[0].clientY-v;C=t.touches[0].clientX,v=t.touches[0].clientY,e.phi+=n*P,e.theta=Math.max(-Math.PI/2+.01,Math.min(Math.PI/2-.01,e.theta+a*P)),Y=!0}else if(t.touches.length===2){const n=t.touches[1].clientX-t.touches[0].clientX,a=t.touches[1].clientY-t.touches[0].clientY,o=Math.sqrt(n*n+a*a),c=(t.touches[0].clientX+t.touches[1].clientX)/2,d=(t.touches[0].clientY+t.touches[1].clientY)/2;if(F>0){const M=F/o;e.distance*=M,e.distance=Math.max(e.near*10,e.distance);const f=s.getBoundingClientRect(),r=(c-q)/f.height,l=(d-K)/f.height;H(r,l),Y=!0}F=o,q=c,K=d}}function Q(){Z=!1,y=null,F=0}function $(t){t.preventDefault()}const tt=m.wheel!==!1,et=m.touch!==!1;s.style.cursor="grab",s.addEventListener("mousedown",G),tt&&s.addEventListener("wheel",J,{passive:!1}),et&&(s.addEventListener("touchstart",N,{passive:!1}),s.addEventListener("touchmove",O,{passive:!1}),s.addEventListener("touchend",Q)),s.addEventListener("contextmenu",$);function rt(){s.removeEventListener("mousedown",G),tt&&s.removeEventListener("wheel",J),et&&(s.removeEventListener("touchstart",N),s.removeEventListener("touchmove",O),s.removeEventListener("touchend",Q)),s.removeEventListener("contextmenu",$),window.removeEventListener("mousemove",V),window.removeEventListener("mouseup",_)}return{state:e,get dirty(){return Y},taint(){Y=!0},update(t){ht(t);const n=Y;return Y=!1,{view:i,projection:h,projectionView:U,dirty:n}},destroy:rt}}export{ut as createCameraController,ut as default};
