import{_ as x,d as i}from"./index-Bvdv0JJ6.js";(window.location.hostname==="localhost"||window.location.hostname.match(/127\.0\.0\.1/))&&x(async()=>{const{main:t}=await import("./index-Bvdv0JJ6.js").then(e=>e.i);return{main:t}},[]).then(({main:t})=>{window.__observableRuntime=t,console.log("[DebugClient] Runtime module exposed as window.__observableRuntime"),x(()=>import("./debug-client-BJyqFSh-.js"),[])});i({root:document.getElementById("cell-73"),expanded:[],variables:[]},{id:73,body:(t,e)=>t`Consider measuring the performance of an algorithm before and after some changes, say ${e`t_{\text{before},i}`} and ${e`t_{\text{after},i}.`} The Wilcoxon signed-rank test proceeds in several steps.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});i({root:document.getElementById("cell-69"),expanded:[],variables:[]},{id:69,body:(t,e)=>t`1. **Calculate differences**. For each test case ${e`i`}, compute the difference

    ${e.block`d_i = t_{\text{after},i} - t_{\text{before},i},`}

    where positive values indicate the algorithm got slower, negative values indicate it got faster.
`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});i({root:document.getElementById("cell-70"),expanded:[],variables:[]},{id:70,body:(t,e)=>t`2. **Rank the absolute differences**. Ignore the signs temporarily and rank the absolute differences ${e`|d_i|`} from smallest (rank 1) to largest (rank ${e`n`}). If there are ties, assign each tied value the average of the ranks they would have received.
`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});i({root:document.getElementById("cell-71"),expanded:[],variables:[]},{id:71,body:(t,e)=>t`3. **Apply signs to ranks**. Restore the signs from the original differences to the ranks. This gives us signed ranks ${e`R_i`}.
`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});i({root:document.getElementById("cell-72"),expanded:[],variables:[]},{id:72,body:(t,e)=>t`4. **Sum ranks by sign**. Calculate:
    - ${e`W^+ = \sum_{i: d_i > 0} R_i`} (sum of ranks where algorithm got slower)
    - ${e`W^- = \sum_{i: d_i < 0} |R_i|`} (sum of absolute ranks where algorithm got faster)

    Note that ${e`W^+ + W^- = \frac{n(n+1)}{2}`}, the sum of all ranks from 1 to ${e`n`}.
`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});i({root:document.getElementById("cell-7"),expanded:[],variables:[]},{id:7,body:(t,e)=>t`5. **Test Statistic and Null Hypothesis**. The test statistic is ${e`W = \min(W^+, W^-)`}. Under the null hypothesis that there's no systematic difference (the median difference is zero), we expect ${e`W^+`} and ${e`W^-`} to be roughly equal. A small value of ${e`W`} indicates one-sided behavior.

    For large samples (${e`n > 10`}), ${e`W`} is approximately normally distributed with
    ${e.block`\text{mean} = \mu_W = \frac{n(n+1)}{4}`}
    ${e.block`\text{variance} = \sigma^2_W = \frac{n(n+1)(2n+1)}{24}`}

    We can compute a z-score,
    ${e.block`z = \frac{W - \mu_W}{\sigma_W}`}
    and derive a p-value from the standard normal distribution.

   A [**continuity correction**](https://www.mathspanda.com/A2FM/Lessons/Normal_approximations_with_Wilcoxon_tests_LESSON.pdf) accounts for approximating a discrete distribution (integer ranks) with a continuous distribution (normal). Since ${e`W`} can only take integer values, we adjust by 0.5 in the direction of the mean, which improves the accuracy of the p-value for small to moderate sample sizes.

   I sorta get the reasoning, but the precise reasoning is a bit fuzzy to me. At the end of the day, we use the adjusted equation,

    ${e.block` z = \frac{W - \mu_W + \frac{1}{2} \text{sgn}(W - \mu_W)}{\sigma_W}.`}`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});i({root:document.getElementById("cell-90"),expanded:[],variables:[]},{id:90,body:(t,e)=>t`6. **P-value**. Finally, we compute a [“two-tailed” p-value](https://stats.oarc.ucla.edu/other/mult-pkg/faq/general/faq-what-are-the-differences-between-one-tailed-and-two-tailed-tests/) using the normal CDF function. After reading the above reference and working out a line or two of algebra, we end up with
    ${e.block`p = 1 - \text{erf}(|z|).`}`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});i({root:document.getElementById("cell-3"),expanded:[],variables:[]},{id:3,body:()=>{function t(e,n,a,o,u,r=42){let l=r;const f=()=>(l=(l*1664525+1013904223)%4294967296,l/4294967296),m=()=>{const d=f(),p=f();return Math.sqrt(-2*Math.log(d))*Math.cos(2*Math.PI*p)},c=[];for(let d=0;d<e;d++){const p=n+f()*(a-n),b=p*o,h=p+m()*b,g=p*(1+u)+m()*b;c.push({id:`test_${d+1}`,baselineTime:p,timeBefore:Math.max(.1,h),timeAfter:Math.max(.1,g)})}return c}return{generatePerformanceData:t}},inputs:[],outputs:["generatePerformanceData"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});i({root:document.getElementById("cell-5"),expanded:[],variables:[]},{id:5,body:()=>{function t(n){const a=n.map(s=>({diff:s.timeAfter-s.timeBefore,absDiff:Math.abs(s.timeAfter-s.timeBefore),id:s.id})).filter(s=>s.diff!==0);if(a.length===0)return{error:"All differences are zero"};const o=[...a].sort((s,y)=>s.absDiff-y.absDiff),u=[];let r=0;for(;r<o.length;){let s=r;for(;s<o.length&&o[s].absDiff===o[r].absDiff;)s++;const y=(r+1+s)/2;for(let v=r;v<s;v++)u.push({...o[v],rank:y});r=s}let l=0,f=0;u.forEach(s=>{s.diff>0?l+=s.rank:f+=s.rank});const m=Math.min(l,f),c=u.length,d=c*(c+1)/4,p=c*(c+1)*(2*c+1)/24,b=Math.sqrt(p),h=(m-d+.5*Math.sign(m-d))/b,g=2*(1-e(Math.abs(h)));return{n:c,wPlus:l,wMinus:f,W:m,zScore:h,pValue:g,ranks:u,significant:g<.05}}function e(n){const a=1/(1+.2316419*Math.abs(n)),u=.3989423*Math.exp(-n*n/2)*a*(.3193815+a*(-.3565638+a*(1.781478+a*(-1.821256+a*1.330274))));return n>0?1-u:u}return{wilcoxonSignedRank:t,normalCDF:e}},inputs:[],outputs:["wilcoxonSignedRank","normalCDF"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});i({root:document.getElementById("cell-16"),expanded:[],variables:[]},{id:16,body:(t,e)=>{const n=t(e.range([5,50],{label:"Test cases",step:1,value:20})),a=t(e.range([-.2,.2],{label:"True change",step:.01,value:.05})),o=t(e.range([0,.5],{label:"Noise level, σ",step:.01,value:.15}));return{numTestCases:n,truePerformanceChange:a,noiseLevel:o,seed:42}},inputs:["view","Inputs"],outputs:["numTestCases","truePerformanceChange","noiseLevel","seed"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});i({root:document.getElementById("cell-75"),expanded:[],variables:[]},{id:75,body:t=>{const e=document.getElementById("cell-16");if(e){let n=e,a=!1;const o=document.createElement("div");e.parentNode.insertBefore(o,e);const u=()=>{const r=window.pageYOffset||document.documentElement.scrollTop,l=n.offsetTop;r>l&&!a?(n=o,a=!0,e.getBoundingClientRect(),o.style.height=`${e.offsetHeight}px`,o.style.display="block",e.style.position="fixed",e.style.top="0",e.style.left="0",e.style.right="0",e.style.width="100%",e.style.maxWidth="640px",e.style.padding="0 10px 10px 10px",e.style.margin="0 auto",e.style.zIndex="1000",e.style.backgroundColor="var(--theme-background, white)",e.style.boxShadow="0 2px 8px rgba(0,0,0,0.1)"):r<=l&&a&&(n=e,a=!1,o.style.display="none",e.style.position="",e.style.top="",e.style.left="",e.style.right="",e.style.width="",e.style.zIndex="",e.style.margin="",e.style.padding="",e.style.backgroundColor="",e.style.boxShadow="")};window.addEventListener("scroll",u,{passive:!0}),t.then(()=>{window.removeEventListener("scroll",u),o.remove(),a&&(e.style.position="",e.style.top="",e.style.left="",e.style.right="",e.style.width="",e.style.zIndex="",e.style.backgroundColor="",e.style.boxShadow="")})}return{controlsCell:e}},inputs:["invalidation"],outputs:["controlsCell"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});i({root:document.getElementById("cell-34"),expanded:[],variables:[]},{id:34,body:(t,e,n,a,o,u)=>{const f=t(e,10,100,n,a,o),m=u(f),c=f.map(d=>({id:d.id,before:d.timeBefore,after:d.timeAfter,difference:d.timeAfter-d.timeBefore,percentChange:(d.timeAfter-d.timeBefore)/d.timeBefore*100}));return{baselineTimeMin:10,baselineTimeMax:100,testData:f,testResult:m,chartData:c}},inputs:["generatePerformanceData","numTestCases","noiseLevel","truePerformanceChange","seed","wilcoxonSignedRank"],outputs:["baselineTimeMin","baselineTimeMax","testData","testResult","chartData"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});i({root:document.getElementById("cell-37"),expanded:[],variables:[]},{id:37,body:(t,e,n)=>{const a=t.map(o=>({"Test Case":o.id,"Before (ms)":o.before.toFixed(2),"After (ms)":o.after.toFixed(2),"Difference (ms)":o.difference.toFixed(2)}));return e(n.table(a,{width:"100%",maxHeight:200})),{dataTable:a}},inputs:["chartData","display","Inputs"],outputs:["dataTable"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});i({root:document.getElementById("cell-76"),expanded:[],variables:[]},{id:76,body:(t,e,n)=>{t(e.plot({height:400,marginLeft:60,marginBottom:60,x:{label:"Time Before (ms)",grid:!0},y:{label:"Time After (ms)",grid:!0},marks:[e.line([[0,0],[120,120]],{stroke:"#ccc",strokeDasharray:"4 4"}),e.dot(n,{x:"before",y:"after",fill:a=>a.after>a.before?"#e74c3c":"#2ecc71",r:5,title:a=>`${a.id}
Before: ${a.before.toFixed(2)}ms
After: ${a.after.toFixed(2)}ms
Change: ${a.percentChange.toFixed(1)}%`}),e.link(n,{x1:"before",y1:"before",x2:"before",y2:"after",stroke:a=>a.after>a.before?"#e74c3c":"#2ecc71",strokeOpacity:.3,strokeWidth:1})],caption:"Each point shows before/after performance. Points above the diagonal line indicate performance degradation (slower)."}))},inputs:["display","Plot","chartData"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});i({root:document.getElementById("cell-30"),expanded:[],variables:[]},{id:30,body:t=>({rankedTable:t.ranks.sort((n,a)=>n.rank-a.rank).map(n=>({"Test Case":n.id,"Difference (ms)":n.diff.toFixed(3),"Absolute Difference":n.absDiff.toFixed(3),Rank:n.rank,Sign:n.diff>0?"+":"−"}))}),inputs:["testResult"],outputs:["rankedTable"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});i({root:document.getElementById("cell-31"),expanded:[],variables:[]},{id:31,body:(t,e,n)=>{t(e.table(n,{width:"100%",maxHeight:200}))},inputs:["display","Inputs","rankedTable"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});i({root:document.getElementById("cell-38"),expanded:[],variables:[]},{id:38,body:(t,e,n)=>t`**Sample size (${e`n`}):** ${n.n} paired observations<br>
**Sum of positive ranks (${e`W^+`}):** ${n.wPlus.toFixed(1)} (cases where algorithm got slower)<br>
**Sum of negative ranks (${e`W^−`}):** ${n.wMinus.toFixed(1)} (cases where algorithm got faster)<br>
**Test statistic (${e`W`}):** ${n.W.toFixed(1)}`,inputs:["md","tex","testResult"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});i({root:document.getElementById("cell-63"),expanded:[],variables:[]},{id:63,body:(t,e)=>t`For reasonably large samples (${e`n > 10`}), the test statistic ${e`W`} is approximately normally distributed. We can compute the expected value and standard deviation under the null hypothesis (no systematic change):`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});i({root:document.getElementById("cell-64"),expanded:[],variables:[]},{id:64,body:t=>{const e=t.n*(t.n+1)/4,n=t.n*(t.n+1)*(2*t.n+1)/24,a=Math.sqrt(n);return{expectedW:e,varianceW:n,stdDevW:a}},inputs:["testResult"],outputs:["expectedW","varianceW","stdDevW"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});i({root:document.getElementById("cell-81"),expanded:[],variables:[]},{id:81,body:(t,e,n,a)=>t`**Expected value:** ${e`\mu_W = \frac{n(n+1)}{4} = \frac{${n.n} \cdot ${n.n+1}}{4} = ${a.toFixed(2)}`}`,inputs:["md","tex","testResult","expectedW"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});i({root:document.getElementById("cell-82"),expanded:[],variables:[]},{id:82,body:(t,e,n,a)=>t`**Variance:** ${e`\sigma^2_W = \frac{n(n+1)(2n+1)}{24} = \frac{${n.n} \cdot ${n.n+1} \cdot ${2*n.n+1}}{24} = ${a.toFixed(2)}`}`,inputs:["md","tex","testResult","varianceW"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});i({root:document.getElementById("cell-83"),expanded:[],variables:[]},{id:83,body:(t,e,n)=>t`**Standard deviation:** ${e`\sigma_W = \sqrt{\sigma^2_W} = ${n.toFixed(2)}`}`,inputs:["md","tex","stdDevW"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});i({root:document.getElementById("cell-84"),expanded:[],variables:[]},{id:84,body:(t,e,n,a,o)=>t`**Z-score (with continuity correction):**

${e.block`
\begin{aligned}
z &= \frac{W - \mu_W + \frac{1}{2} \text{sgn}(W - \mu_W)}{\sigma_W} \\
  &= \frac{${n.W.toFixed(1)} - ${a.toFixed(2)} + ${(.5*Math.sign(n.W-a)).toFixed(1)}}{${o.toFixed(2)}} \\
  &= ${n.zScore.toFixed(3)}
\end{aligned}`}`,inputs:["md","tex","testResult","expectedW","stdDevW"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});i({root:document.getElementById("cell-66"),expanded:[],variables:[]},{id:66,body:(t,e,n,a)=>t`${e.wPlus>e.wMinus?n`${a`W^+ > W^-,`} so the algorithm appears to have <strong>degraded</strong>.`:n`${a`W^+ \leq W^-,`} so the algorithm appears to have <strong>improved</strong>.`}

**Z-score:** ${e.zScore.toFixed(3)}<br>
**P-value:** ${e.pValue.toFixed(4)}<br>
**Conclusion:** ${e.significant?"p < 0.05, so the difference is **statistically significant**.":"p ≥ 0.05, so the difference is **not statistically significant**."}`,inputs:["md","testResult","html","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});
