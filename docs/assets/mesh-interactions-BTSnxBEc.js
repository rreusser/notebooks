import{vec3 as o,mat4 as a}from"https://cdn.jsdelivr.net/npm/gl-matrix@3.4.3/+esm";class g{constructor(e,t,s,r={}){this.element=e,this.mesh=t,this.camera=s,this.projectionView=r.projectionView,this.selectedVertexIndex=-1,this.hoverVertexIndex=-1,this.activeVertexIndex=-1,this.isDragging=!1,this.dragMode=null,this.initialMousePos=[0,0],this.currentMousePos=[0,0],this.previousMousePos=[0,0],this.deadZoneRadius=5,this.exitedDeadZone=!1,this.candidateEdge=null,this.dirty=!0,this.onChange=r.onChange||(()=>{}),this._onMouseDown=this._onMouseDown.bind(this),this._onMouseMove=this._onMouseMove.bind(this),this._onMouseUp=this._onMouseUp.bind(this),this._onWheel=this._onWheel.bind(this),this._onKeyDown=this._onKeyDown.bind(this),this._onKeyUp=this._onKeyUp.bind(this),this._setup()}_setup(){const e=this.element;e.tabIndex=1,e.style.outline="none",e.style.cursor="grab",e.addEventListener("mousedown",this._onMouseDown),e.addEventListener("mousemove",this._onMouseMove),e.addEventListener("wheel",this._onWheel,{passive:!1}),e.addEventListener("keydown",this._onKeyDown),e.addEventListener("keyup",this._onKeyUp)}destroy(){const e=this.element;e.removeEventListener("mousedown",this._onMouseDown),e.removeEventListener("mousemove",this._onMouseMove),e.removeEventListener("wheel",this._onWheel),e.removeEventListener("keydown",this._onKeyDown),e.removeEventListener("keyup",this._onKeyUp),window.removeEventListener("mousemove",this._onMouseMove),window.removeEventListener("mouseup",this._onMouseUp)}_getMousePos(e,t=[0,0]){const s=this.element.getBoundingClientRect();return t[0]=e.clientX-s.left,t[1]=e.clientY-s.top,t}_insideDeadZone(){const e=this.currentMousePos[0]-this.initialMousePos[0],t=this.currentMousePos[1]-this.initialMousePos[1];return Math.sqrt(e*e+t*t)<this.deadZoneRadius}_getClosestVertex(e,t){const s=this.mesh,r=this.projectionView,n=this.element.offsetWidth,h=this.element.offsetHeight,i=o.create();let d=-1,u=1/0;for(let c=0;c<s.vertexCount;c++){const m=s.getPosition(c);if(o.transformMat4(i,m,r),i[2]<-1||i[2]>1)continue;const v=(.5+.5*i[0])*n,V=(.5-.5*i[1])*h,x=e-v,l=t-V,M=Math.sqrt(x*x+l*l);M<u&&(u=M,d=c)}return{index:d,distance:u}}_onMouseDown(e){this._getMousePos(e,this.initialMousePos),this.currentMousePos[0]=this.initialMousePos[0],this.currentMousePos[1]=this.initialMousePos[1],this.previousMousePos[0]=this.initialMousePos[0],this.previousMousePos[1]=this.initialMousePos[1],this.exitedDeadZone=!1;const t=this._getClosestVertex(this.initialMousePos[0],this.initialMousePos[1]);t.index>=0&&t.distance<25?(this.selectedVertexIndex>=0&&this.selectedVertexIndex!==t.index&&(this.candidateEdge=[this.selectedVertexIndex,t.index]),this.activeVertexIndex=t.index,this.selectedVertexIndex=t.index,this.dragMode="vertex",this.element.style.cursor="move"):(this.dragMode=e.shiftKey?"pan":"rotate",this.element.style.cursor="grabbing"),this.isDragging=!0,this.dirty=!0,window.addEventListener("mousemove",this._onMouseMove),window.addEventListener("mouseup",this._onMouseUp)}_onMouseMove(e){if(this.previousMousePos[0]=this.currentMousePos[0],this.previousMousePos[1]=this.currentMousePos[1],this._getMousePos(e,this.currentMousePos),!this.isDragging){const t=this._getClosestVertex(this.currentMousePos[0],this.currentMousePos[1]),s=t.index>=0&&t.distance<25?t.index:-1;s!==this.hoverVertexIndex&&(this.hoverVertexIndex=s,this.element.style.cursor=s>=0?"move":"grab",this.dirty=!0);return}!this.exitedDeadZone&&!this._insideDeadZone()&&(this.exitedDeadZone=!0),this.dragMode==="vertex"&&this.exitedDeadZone?this._dragVertex():this.dragMode==="rotate"?this._rotateCamera():this.dragMode==="pan"&&this._panCamera()}_onMouseUp(e){if(window.removeEventListener("mousemove",this._onMouseMove),window.removeEventListener("mouseup",this._onMouseUp),this._getMousePos(e,this.currentMousePos),!this.exitedDeadZone&&this._insideDeadZone()){const t=this._getClosestVertex(this.currentMousePos[0],this.currentMousePos[1]);this.dragMode==="vertex"?t.index>=0&&t.distance<25?(this.candidateEdge&&this.mesh.addEdge(this.candidateEdge[0],this.candidateEdge[1]),this.selectedVertexIndex=t.index):this.selectedVertexIndex>=0&&this._spawnVertex():t.index>=0&&t.distance<25?this.selectedVertexIndex=t.index:this.selectedVertexIndex>=0?this._spawnVertex():this.selectedVertexIndex=-1}this.isDragging=!1,this.dragMode=null,this.activeVertexIndex=-1,this.candidateEdge=null,this.element.style.cursor=this.hoverVertexIndex>=0?"move":"grab",this.dirty=!0,this.onChange()}_onWheel(e){e.preventDefault(),this.camera.zoom(e.deltaY*.03),this.dirty=!0}_onKeyDown(e){switch(e.code){case"Space":case"Backspace":e.preventDefault();break}}_onKeyUp(e){switch(e.code){case"Backspace":if(this.selectedVertexIndex>=0){const t=this.mesh.deleteVertex(this.selectedVertexIndex);this.selectedVertexIndex=t,this.hoverVertexIndex=-1,this.activeVertexIndex=-1,this.dirty=!0,e.preventDefault()}break;case"Space":this.selectedVertexIndex=-1,this.activeVertexIndex=-1,this.dirty=!0,e.preventDefault();break;case"KeyC":if(this.selectedVertexIndex>=0){const t=this.mesh.collapseVertex(this.selectedVertexIndex);this.selectedVertexIndex=t,this.hoverVertexIndex=-1,this.activeVertexIndex=-1,this.dirty=!0,e.preventDefault()}break;case"KeyS":if(this.selectedVertexIndex>=0){const t=this.mesh.splitVertex(this.selectedVertexIndex);this.selectedVertexIndex=t,this.hoverVertexIndex=-1,this.activeVertexIndex=-1,this.dirty=!0,e.preventDefault()}break;case"KeyE":if(this.selectedVertexIndex>=0){const t=this.mesh.explodeVertex(this.selectedVertexIndex);this.selectedVertexIndex=t,this.hoverVertexIndex=-1,this.activeVertexIndex=-1,this.dirty=!0,e.preventDefault()}break;case"KeyA":if(this.selectedVertexIndex>=0){const t=this.mesh.getPosition(this.selectedVertexIndex);o.copy(this.camera.center,t)}else{const t=this.mesh.computeCentroid();o.copy(this.camera.center,t)}this.dirty=!0;break}this.onChange()}_dragVertex(){const e=this.element.offsetWidth,t=this.element.offsetHeight,s=this.projectionView,r=this.mesh.getPosition(this.activeVertexIndex),n=o.create();o.transformMat4(n,r,s),n[0]=2*this.currentMousePos[0]/e-1,n[1]=1-2*this.currentMousePos[1]/t;const h=a.create();a.invert(h,s);const i=o.create();o.transformMat4(i,n,h),this.mesh.setPosition(this.activeVertexIndex,i[0],i[1],i[2]),this.dirty=!0}_rotateCamera(){const e=this.element.offsetWidth,t=this.element.offsetHeight;this.camera.rotate([-(this.previousMousePos[0]/e-.5),-(this.previousMousePos[1]/t-.5)],[-(this.currentMousePos[0]/e-.5),-(this.currentMousePos[1]/t-.5)]),this.dirty=!0}_panCamera(){const e=this.element.offsetWidth,t=this.element.offsetHeight,s=this.currentMousePos[0]-this.previousMousePos[0],r=this.currentMousePos[1]-this.previousMousePos[1];this.camera.pan([s/e,r/t]),this.dirty=!0}_spawnVertex(){if(this.mesh.degree(this.selectedVertexIndex)>=3)return;const e=this.element.offsetWidth,t=this.element.offsetHeight,s=this.projectionView,r=this.mesh.getPosition(this.selectedVertexIndex),n=o.create();o.transformMat4(n,r,s),n[0]=2*this.currentMousePos[0]/e-1,n[1]=1-2*this.currentMousePos[1]/t;const h=a.create();a.invert(h,s);const i=o.create();o.transformMat4(i,n,h);const d=this.mesh.addVertex(i[0],i[1],i[2]);this.mesh.addEdge(this.selectedVertexIndex,d),this.selectedVertexIndex=d,this.dirty=!0}}export{g as MeshInteractions,g as default};
