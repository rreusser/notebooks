import{d as l,_ as m}from"./index-ByB2dbry.js";l({root:document.getElementById("cell-2"),expanded:[],variables:[]},{id:2,body:async()=>{const[{createWebGPUContext:t},{createCameraController:e},{expandable:r},{createFrameLoop:o},{meshFromFunction:n},{surfaceShaderCode:i,oitShaderCode:s,oitCompositeShaderCode:g,peelShaderCode:y,peelCompositeShaderCode:b,dualPeelShaderCode:P},{createRenderer:E},{createOITDiagram:v,createPeelDiagram:w,createDualPeelDiagram:c}]=await Promise.all([m(()=>import("./webgpu-canvas-C7AS78hn.js"),[]).then(a=>{if(!("createWebGPUContext"in a))throw new SyntaxError("export 'createWebGPUContext' not found");return a}),m(()=>import("./camera-controller-DnDb9jMf.js"),[]).then(a=>{if(!("createCameraController"in a))throw new SyntaxError("export 'createCameraController' not found");return a}),m(()=>import("./expandable-BCrxs32f.js"),[]).then(a=>{if(!("expandable"in a))throw new SyntaxError("export 'expandable' not found");return a}),m(()=>import("./frame-loop-QkwpdSbZ.js"),[]).then(a=>{if(!("createFrameLoop"in a))throw new SyntaxError("export 'createFrameLoop' not found");return a}),m(()=>import("./mesh-X0SgNrl1.js"),[]).then(a=>{if(!("meshFromFunction"in a))throw new SyntaxError("export 'meshFromFunction' not found");return a}),m(()=>import("./shaders-y8iABGvG.js"),[]).then(a=>{if(!("surfaceShaderCode"in a))throw new SyntaxError("export 'surfaceShaderCode' not found");if(!("oitShaderCode"in a))throw new SyntaxError("export 'oitShaderCode' not found");if(!("oitCompositeShaderCode"in a))throw new SyntaxError("export 'oitCompositeShaderCode' not found");if(!("peelShaderCode"in a))throw new SyntaxError("export 'peelShaderCode' not found");if(!("peelCompositeShaderCode"in a))throw new SyntaxError("export 'peelCompositeShaderCode' not found");if(!("dualPeelShaderCode"in a))throw new SyntaxError("export 'dualPeelShaderCode' not found");return a}),m(()=>import("./renderer-BxhcWSnB.js"),[]).then(a=>{if(!("createRenderer"in a))throw new SyntaxError("export 'createRenderer' not found");return a}),m(()=>import("./diagrams-c598qhCU.js"),[]).then(a=>{if(!("createOITDiagram"in a))throw new SyntaxError("export 'createOITDiagram' not found");if(!("createPeelDiagram"in a))throw new SyntaxError("export 'createPeelDiagram' not found");if(!("createDualPeelDiagram"in a))throw new SyntaxError("export 'createDualPeelDiagram' not found");return a})]);return{createWebGPUContext:t,createCameraController:e,expandable:r,createFrameLoop:o,meshFromFunction:n,surfaceShaderCode:i,oitShaderCode:s,oitCompositeShaderCode:g,peelShaderCode:y,peelCompositeShaderCode:b,dualPeelShaderCode:P,createRenderer:E,createOITDiagram:v,createPeelDiagram:w,createDualPeelDiagram:c}},inputs:[],outputs:["createWebGPUContext","createCameraController","expandable","createFrameLoop","meshFromFunction","surfaceShaderCode","oitShaderCode","oitCompositeShaderCode","peelShaderCode","peelCompositeShaderCode","dualPeelShaderCode","createRenderer","createOITDiagram","createPeelDiagram","createDualPeelDiagram"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});l({root:document.getElementById("cell-4"),expanded:[],variables:[]},{id:4,body:async t=>{const{device:e,canvasFormat:r}=await t();return{device:e,canvasFormat:r}},inputs:["createWebGPUContext"],outputs:["device","canvasFormat"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});l({root:document.getElementById("cell-5"),expanded:[],variables:[]},{id:5,body:(t,e,r,o)=>{const n=t`<div id="surface-controls" class="controls-panel"></div>`;function i(u){return n.appendChild(u),e.input(u)}const s=r.select(["Fake transparency","Weighted blended OIT","Depth peeling","Dual depth peeling"],{label:"Method",value:"Dual depth peeling"}),g=i(s),y=i(r.range([0,1],{label:"Surface opacity",value:.85,step:.01})),b=i(r.range([0,1],{label:"Grid opacity",value:.4,step:.01})),P=i(r.range([0,1],{label:"Cartoon edge opacity",value:1,step:.01})),E=.5,v=2,w=r.checkbox(["Solid surface pass","Fake transparency pass"],{value:["Solid surface pass","Fake transparency pass"]}),c=t`<div>${w}</div>`;n.appendChild(c);const a=e.input(w),_=r.range([1,8],{label:"Peel layers",value:4,step:1}),C=t`<div>${_}</div>`;n.appendChild(C);const T=e.input(_),L=i(r.toggle({label:"Animate",value:!1}));function D(){const u=s.value;for(const h of c.querySelectorAll("input"))h.disabled=u!=="Fake transparency";c.style.opacity=u==="Fake transparency"?"":"0.5";const S=u!=="Depth peeling"&&u!=="Dual depth peeling";for(const h of C.querySelectorAll("input"))h.disabled=S;C.style.opacity=S?"0.5":""}return s.addEventListener("input",D),D(),o(n),{controlsContainer:n,ctrl:i,methodInput:s,method:g,opacity:y,gridOpacity:b,cartoonEdgeOpacity:P,gridWidth:E,cartoonEdgeWidth:v,passesInput:w,passesWrapper:c,passes:a,peelLayersInput:_,peelLayersWrapper:C,peelLayers:T,animate:L,updateDisabled:D}},inputs:["html","Generators","Inputs","display"],outputs:["controlsContainer","ctrl","methodInput","method","opacity","gridOpacity","cartoonEdgeOpacity","gridWidth","cartoonEdgeWidth","passesInput","passesWrapper","passes","peelLayersInput","peelLayersWrapper","peelLayers","animate","updateDisabled"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});l({root:document.getElementById("cell-6"),expanded:[],variables:[]},{id:6,body:()=>({state:{initialized:!1,canvas:null,gpuContext:null,camera:null,frame:null,dirty:!0,expandedState:{expanded:!1},renderer:null,renderParams:{method:"Fake transparency",opacity:.85,passes:["Solid surface pass","Fake transparency pass"],peelLayers:4,gridOpacity:.4,gridWidth:.5,cartoonEdgeWidth:2.5,cartoonEdgeOpacity:1,animate:!1}}}),inputs:[],outputs:["state"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});l({root:document.getElementById("cell-7"),expanded:[],variables:[]},{id:7,body:(t,e,r,o,n,i,s,g,y,b)=>{t.renderParams.method=e,t.renderParams.opacity=r,t.renderParams.passes=o,t.renderParams.peelLayers=n,t.renderParams.gridOpacity=i,t.renderParams.gridWidth=s,t.renderParams.cartoonEdgeWidth=g,t.renderParams.cartoonEdgeOpacity=y,t.renderParams.animate=b,t.dirty=!0},inputs:["state","method","opacity","passes","peelLayers","gridOpacity","gridWidth","cartoonEdgeWidth","cartoonEdgeOpacity","animate"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});l({root:document.getElementById("cell-8"),expanded:[],variables:[]},{id:8,body:(t,e,r,o,n,i,s,g,y,b,P,E,v,w,c,a,_,C,T,L)=>{const D=t((d,p)=>[d,p],{resolution:[151,151],uDomain:[0,1.5],vDomain:[-Math.PI,Math.PI],uPeriodic:!1,vPeriodic:!0});if(!e.initialized){const d=document.createElement("canvas");d.id="surface-canvas",d.style.width="100%",d.style.height="100%";const p=d.getContext("webgpu");p.configure({device:r,format:o,alphaMode:"opaque"}),e.canvas=d,e.gpuContext=p,e.camera=n(d,{distance:4,phi:.4,theta:.2}),e.renderer=i(r,o,{surface:s,oit:g,oitComposite:y,peel:b,peelComposite:P,dualPeel:E}),e.renderer.initMesh(D),e.initialized=!0}const u=e.canvas,S=e.gpuContext,h=e.camera,z=e.renderer,f=v`<div id="surface-container" style="position: relative; width: 100%; height: 100%;"></div>`;f.appendChild(u);const O=v`<figcaption>${e.renderParams.method}</figcaption>`,F=()=>{const d=f.getBoundingClientRect();if(d.width===0||d.height===0)return;const p=devicePixelRatio,x=Math.floor(d.width*p),I=Math.floor(d.height*p);(u.width!==x||u.height!==I)&&(u.width=x,u.height=I,S.configure({device:r,format:o,alphaMode:"opaque"}),e.dirty=!0,h.taint())},W=new w(F);W.observe(f);let k=!0;const R=new c(d=>{k=d[0].intersectionRatio>0});R.observe(f),e.frame&&(e.frame.cancel(),e.frame=null),h.taint();const $=performance.now();e.frame=a(d=>{if(!k)return;const p=u.width,x=u.height;if(p===0||x===0)return;z.render(S,e.renderParams,h,p,x,d,$,e.dirty)&&(O.textContent=e.renderParams.method,e.dirty=!1)}),_.then(()=>{e.frame&&(e.frame.cancel(),e.frame=null),W.disconnect(),R.disconnect()});const A=v`
  <figure id="main-figure" style="max-width: 100%; margin: 0; height: 100%;">
${f}
${O}
  </figure>
`,B=Math.min(C,640),M=Math.round(Math.max(500,B*.7));return T(L(A,{wide:!0,width:B,height:M,controls:"#surface-controls",state:e.expandedState,onResize:(d,p,x,I)=>{f.style.width=`${p}px`,f.style.height=`${x}px`,O.style.display=I?"none":"block",F()}})),{mesh:D,canvas:u,gpuContext:S,camera:h,renderer:z,container:f,figcaption:O,resizeCanvas:F,resizeObserver:W,visible:k,intersectionObserver:R,startTime:$,figure:A,figureWidth:B,figureHeight:M}},inputs:["meshFromFunction","state","device","canvasFormat","createCameraController","createRenderer","surfaceShaderCode","oitShaderCode","oitCompositeShaderCode","peelShaderCode","peelCompositeShaderCode","dualPeelShaderCode","html","ResizeObserver","IntersectionObserver","createFrameLoop","invalidation","width","display","expandable"],outputs:["mesh","canvas","gpuContext","camera","renderer","container","figcaption","resizeCanvas","resizeObserver","visible","intersectionObserver","startTime","figure","figureWidth","figureHeight"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});l({root:document.getElementById("cell-9"),expanded:[],variables:[]},{id:9,body:(t,e)=>t`## Fake Transparency

The constant-width gridlines are adapted from [glsl-solid-wireframe](https://github.com/rreusser/glsl-solid-wireframe). You can use the approach to draw any sort of gridlines on any sort of surface. Or [to draw 2D contours in a fragment shader](https://observablehq.com/@rreusser/contour-plots-with-d3-regl-and-observable?collection=@rreusser/webgl).

The cartoon edges use the same underlying trick as the gridlines. The quantity ${e`|\mathbf{n} \cdot \mathbf{v}|`}, the absolute dot product of the surface normal with the view direction, goes to zero at silhouette edges where the surface turns away from the camera. Near such a zero-crossing any smooth scalar field is approximately linear, so dividing by its screen-space gradient magnitude (via \`fwidth\`) yields a first-order estimate of the distance to the zero-crossing measured in pixels. Applying a \`smoothstep\` threshold to this ratio produces a band of constant pixel width, regardless of depth, perspective, or how sharply the surface curves. The silhouette line stays the same number of pixels wide everywhere on the surface. One downside is that it requires a moderately high-resolution mesh since the derivative is evaluated per-triangle and can't smooth over abrupt normal changes.

At a strictly subjective level, I find this pretty tolerable for illustrating mathematical surfaces, where the goal is not so much physically accurate representation of objects but instead the communication of structure.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});l({root:document.getElementById("cell-10"),expanded:[],variables:[]},{id:10,body:(t,e)=>t`## Weighted Blended Order-Independent Transparency

The fake transparency approach above is a practical hack, but it isn't true transparency. For a more principled approach, we can use *weighted blended order-independent transparency* (WBOIT), as described by [McGuire and Bavoil (2013)](http://jcgt.org/published/0002/02/09/).

The idea is to render all transparent geometry in a single pass to two render targets. The first target accumulates premultiplied color weighted by a depth-dependent function. The second target tracks the total transmittance (the product of all ${e`(1 - \alpha)`} terms). A final compositing pass combines these two buffers to produce the blended result.

The weighting function is the key ingredient. Surfaces closer to the camera receive higher weight so that nearer geometry contributes more to the final color, roughly approximating correct depth ordering without actually sorting anything. The function used here is ${e`w(z, \alpha) = \alpha \cdot \max(10^{-2},\; 3 \times 10^{3} \cdot (1 - z_{\mathrm{ndc}})^3)`}, where ${e`z_{\mathrm{ndc}}`} is the normalized device coordinate depth.

The blend modes for the two targets are additive accumulation for color/weight and multiplicative accumulation for revealage. Then the compositing pass reconstructs the final pixel color as

${e.block`C_{\text{final}} = \frac{C_{\text{accum}}.\text{rgb}}{\max(C_{\text{accum}}.a,\; 10^{-4})} \cdot (1 - R) + C_{\text{bg}} \cdot R`}

where ${e`R`} is the revealage value.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});l({root:document.getElementById("cell-11"),expanded:[],variables:[]},{id:11,body:(t,e,r)=>{const o=t.range([0,1],{label:"Opacity",value:.85,step:.01}),n=t.range([0,1],{label:"Depth spread",value:1,step:.01});e(o),e(n);const i=r.input(o),s=r.input(n);return{oitDiagramInput:o,oitDepthSpreadInput:n,oitDiagramOpacity:i,oitDepthSpread:s}},inputs:["Inputs","display","Generators"],outputs:["oitDiagramInput","oitDepthSpreadInput","oitDiagramOpacity","oitDepthSpread"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});l({root:document.getElementById("cell-12"),expanded:[],variables:[]},{id:12,body:(t,e,r,o,n)=>{t(e`<figure style="max-width: 640px;">
  ${r(o,n)}
  <figcaption>Five sample fragments processed by OIT. Nearer fragments receive higher depth-based weights, substituting for explicit sorting.</figcaption>
</figure>`)},inputs:["display","html","createOITDiagram","oitDiagramOpacity","oitDepthSpread"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});l({root:document.getElementById("cell-14"),expanded:[],variables:[]},{id:14,body:(t,e,r)=>{const o=t.range([0,5],{label:"Peel layers",value:4,step:1}),n=t.range([0,1],{label:"Surface opacity",value:.85,step:.01});e(o),e(n);const i=r.input(o),s=r.input(n);return{peelDiagramInput:o,peelOpacityInput:n,peelDiagramLayers:i,peelDiagramOpacity:s}},inputs:["Inputs","display","Generators"],outputs:["peelDiagramInput","peelOpacityInput","peelDiagramLayers","peelDiagramOpacity"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});l({root:document.getElementById("cell-15"),expanded:[],variables:[]},{id:15,body:(t,e,r,o,n)=>{t(e`<figure style="max-width: 640px;">
  ${r(o,n)}
  <figcaption>Each pass captures the nearest remaining fragment. Layers are then composited back to front with alpha blending. Swatch opacity in the blend column reflects each layer's effective contribution to the final result.</figcaption>
</figure>`)},inputs:["display","html","createPeelDiagram","peelDiagramOpacity","peelDiagramLayers"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});l({root:document.getElementById("cell-16"),expanded:[],variables:[]},{id:16,body:(t,e)=>t`## Dual Depth Peeling

Standard front-to-back depth peeling captures one layer per pass, so rendering N layers requires N full geometry passes. Dual depth peeling, introduced by [Bavoil and Myers (2008)](https://developer.download.nvidia.com/SDK/10/opengl/src/dual_depth_peeling/doc/DualDepthPeeling.pdf), halves the number of geometry passes by capturing both the nearest and farthest surviving fragments in each pass.

The technique works by maintaining a "dual depth" buffer that stores two depth values per pixel. Through MAX blending of ${e`(-z, z)`}, the buffer simultaneously captures the minimum depth (nearest fragment) in one channel and the maximum depth (farthest fragment) in the other. Each pass renders to three targets: the dual depth buffer, a front color buffer that accumulates the nearest fragment's contribution via under (front-to-back) blending, and a back color buffer that accumulates the farthest fragment's contribution via over (back-to-front) blending.

The first pass operates over all fragments. Each subsequent pass reads the previous dual depth buffer and discards any fragment whose depth falls at or outside the previous near/far boundaries, peeling inward from both sides simultaneously. After N passes, up to 2N layers have been captured. Compositing proceeds from back to front: back layers from the outermost pass through the innermost, then front layers from the innermost pass through the outermost.

Within each pass, the front and back colors are approximations since hardware blending processes fragments in arbitrary order rather than strict depth order. The approximation converges to exact results as the number of passes increases and fewer fragments compete within each peeling interval.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});l({root:document.getElementById("cell-17"),expanded:[],variables:[]},{id:17,body:(t,e,r)=>{const o=t.range([0,5],{label:"Peel layers",value:4,step:1}),n=t.range([0,1],{label:"Surface opacity",value:.85,step:.01});e(o),e(n);const i=r.input(o),s=r.input(n);return{dualPeelDiagramInput:o,dualPeelOpacityInput:n,dualPeelDiagramLayers:i,dualPeelDiagramOpacity:s}},inputs:["Inputs","display","Generators"],outputs:["dualPeelDiagramInput","dualPeelOpacityInput","dualPeelDiagramLayers","dualPeelDiagramOpacity"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});l({root:document.getElementById("cell-18"),expanded:[],variables:[]},{id:18,body:(t,e,r,o,n)=>{t(e`<figure style="max-width: 640px;">
  ${r(o,n)}
  <figcaption>Each pass captures the nearest and farthest remaining fragments simultaneously, peeling inward from both sides. Swatch opacity in the blend column reflects each layer's effective contribution.</figcaption>
</figure>`)},inputs:["display","html","createDualPeelDiagram","dualPeelDiagramOpacity","dualPeelDiagramLayers"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});
