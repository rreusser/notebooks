import{d as A,_ as V}from"./index-ByB2dbry.js";A({root:document.getElementById("cell-4"),expanded:[],variables:[]},{id:4,body:(l,e)=>{const n=l`<figure id="figure1" style="width: 100%; max-width: none;">
  <div id="figure1-canvas" style="position: relative; overflow: hidden; width: 100%; max-width: 500px; height: 300px; margin: 0 auto;"></div>
  <figcaption>Not an actual scan of a knee, but the below the knee (BK) scans users process tend to look very similar and tend to enter the system in no particular orientation.</figcaption>
</figure>`;return e(n),{figure1Container:n}},inputs:["html","display"],outputs:["figure1Container"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});A({root:document.getElementById("cell-6"),expanded:[],variables:[]},{id:6,body:(l,e)=>{const n=l`<figure id="figure2" style="width: 100%; max-width: none;">
  <div id="figure2-canvas" style="position: relative; overflow: hidden; width: 100%; max-width: 500px; height: 400px; margin: 0 auto;"></div>
  <figcaption>Orienting a scan by the longest axis isn't entirely without merit, but it's not very robust.</figcaption>
</figure>`;return e(n),{figure2Container:n}},inputs:["html","display"],outputs:["figure2Container"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});A({root:document.getElementById("cell-8"),expanded:[],variables:[]},{id:8,body:(l,e)=>{const n=l`<figure id="figure3" style="text-align: center;">
  <div style="display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 1rem;">
    <div id="figure3-canvas" style="position: relative; overflow: hidden; width: 100%; max-width: 350px; height: 350px;"></div>
    <div id="figure3-controls" style="text-align: left; width: 100%; max-width: 280px;"></div>
  </div>
  <figcaption>We'd like it if our algorithm always picked the axis of the cylinder, but the longest axis doesn't accomplish that.</figcaption>
</figure>`;return e(n),{figure3Container:n}},inputs:["html","display"],outputs:["figure3Container"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});A({root:document.getElementById("cell-10"),expanded:[],variables:[]},{id:10,body:(l,e)=>{const n=l`<figure id="figure6" style="width: 100%; max-width: none;">
  <div id="figure6-canvas" style="position: relative; overflow: hidden; width: 100%; max-width: 500px; height: 400px; margin: 0 auto;"></div>
  <figcaption>As an educated guess, we instead aim to find an <span style="color:#cc334b">alignment axis</span> as perpendicular as possible to the <span style="color:#384e73">surface normal vectors</span>.</figcaption>
</figure>`;return e(n),{figure6Container:n}},inputs:["html","display"],outputs:["figure6Container"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});A({root:document.getElementById("cell-11"),expanded:[],variables:[]},{id:11,body:(l,e)=>l`## As perpendicular as possible

The statement above is a mouthful which requires a bit of unpacking. If we're going to tackle this as a minimization problem, we at least know we'll need to roll up the ideas above into an objective function.

Let's start with the dot products. Recall the dot product between vectors ${e`\vec{a}`} and ${e`\vec{b}`} is equal to
${e.block`\vec{a} \cdot \vec{b} = a b \cos \theta,`}
where ${e`a`} and ${e`b`} are the magnitudes of the two vectors, respectively, and ${e`\theta`} is the angle between them. All we really need to know here is that if two vectors are perpendicular, their dot product is zero.

We can talk about a single surface normal vector, but somehow we need to aggregate information across all faces. Let's call a surface normal vector of the ${e`i^{th}`} mesh face ${e`\vec{n}_i`} and a candidate axis of alignment ${e`\vec{\xi}`} (the Greek letter "xi", pronounced "*ksee*", which I'm selecting because it's fun to write, isn't likely to get confused with anything, and is fun to call "tornado" instead). My supposition is that if we dot the two, square the result, sum over the faces and call it ${e`f(\vec{\xi})`}, i.e.
${e.block`f(\vec{\xi}) = \sum_{i = 1}^{n_{faces}} \left(\vec{\xi} \cdot \vec{n}_i\right)^2,`}
then the best alignment is the one which minimizes ${e`f(\vec{\xi})`}.

We might have a reasonable objective function here, but to see why it feels like it should work, consider a cylinder. The axis of the cylinder is always perpendicular to the surface normal vectors. Assuming for simplicity that the vectors are all normalized, then the magnitudes drop out and ${e`f(\vec{\xi}) = \sum \cos^2(90^\circ) = \sum 0 = 0`}. The axis of a cylinder minimizes ${e`f(\vec{\xi})`} even when it's not the longest axis, thus fixing the failed sanity check above. (If you want to be fancy, I think you could say we're solving the same principal axis problem but in the tangent space instead, though I don't think that interpretation is likely to help most people.)

(Why the square? On a strictly mathematical basis, the dot product may be either positive or negative which would cause the minimization to diverge to ${e`-\infty`}. The square keeps ${e`f(\vec{\xi})`} non-negative so that we can meaningfully minimize it.)`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});A({root:document.getElementById("cell-12"),expanded:[],variables:[]},{id:12,body:(l,e,n)=>{const w=l`<figure id="figure4" style="width: 100%; max-width: none;">
  <div id="figure4-canvas" style="position: relative; overflow: hidden; width: 100%; max-width: 500px; height: 350px; margin: 0 auto;"></div>
  <figcaption>The surface normal vectors of a cylinder are everywhere perpendicular to its axis so that ${e`f(\vec{\xi}) = 0`}. A cylinder passes the test!</figcaption>
</figure>`;return n(w),{figure4Container:w}},inputs:["html","tex","display"],outputs:["figure4Container"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});A({root:document.getElementById("cell-13"),expanded:[],variables:[]},{id:13,body:(l,e)=>l`A bit more precisely, if the faces comprising the mesh aren't uniformly distributed, the sum will be biased toward clusters of vertices and their associated normals. Instead of a sum over normal vectors ${e`\vec{n}_i`}, what we really want is an area-weighted sum. In fact what we *really* want is just an integral over the surface (call it ${e`S`}) with respect to the differential area vector (call it ${e`d\vec{A}`}). We define ${e`d\vec{A} \equiv \vec{n} dA`} as parallel to the surface normal but with magnitude equal to the area of a differential surface element. The continuous limit of ${e`f(\vec{\xi})`} is then
${e.block`f(\vec{\xi}) = \int_S \left(\vec{\xi} \cdot d\vec{A}\right)^2.`}

While we're being precise, we assumed implicitly that the axis of alignment was a nonzero vector, but let's now make that explicit in order to avoid the trivial solution ${e`\vec{\xi} = \vec{0} = (0, 0, 0)`} which *always* minimizes ${e`f(\vec{\xi}) = 0`}. Constraining ${e`\vec{\xi}`} to be a unit vector will do just fine.

Fully stating our problem, we want to find the argument ${e`\vec{\xi}`} which minimizes ${e`f(\vec{\xi})`} subject to the constraint that ${e`\vec{\xi}`} is a unit vector:
${e.block`\begin{array}{l} \begin{array}{c} \phantom{\small{0}} \\ \mathrm{argmin} \\ \small{\vec{\xi} \in \mathbb{R}^3} \end{array} \displaystyle \! \! \int_S \left(\vec{\xi} \cdot d\vec{A}\right)^2 \\ \phantom{\small 0} \\ \;\; \mathrm{subject\;to} \;\; |\vec{\xi}| = 1.\end{array}`}

For piecewise constant faces with surface normal ${e`d\vec{A}_i`} (magnitude equal to the face's area, recall), we can recast this as a discrete summation and arrive at our final problem statement,
${e.block`\begin{array}{l} \begin{array}{c} \phantom{\small{0}} \\ \mathrm{argmin} \\ \small{\vec{\xi} \in \mathbb{R}^3} \end{array} \displaystyle \! \! \sum \limits_{i = 1}^{n_{faces}} \left(\xi_x dA_{i, x} + \xi_y dA_{i, y} + \xi_z dA_{i, z}\right)^2 \\ \phantom{\small 0} \\ \;\; \mathrm{subject\; to} \; \xi_x^2 + \xi_y^2 + \xi_z^2 = 1.\end{array}`}

As for the areas, Eric Arnebäck has a nice article about [Computing the Area of a Convex Polygon](https://erkaman.github.io/posts/area_convex_polygon.html). It covers triangles. And for you geometry sorcerers and sorceresses, the answer is yes. We're fitting an ellipsoid now. The rest of the article is me realizing I'm looking for an ellipsoid.

## Computing it

The problem above is a [constrained optimization problem](https://en.wikipedia.org/wiki/Constrained_optimization). Those can be a bit challenging to solve since you often only want to explore the solution space in directions which keep the constraints satisfied. It took me a while to recall, but if I learned one thing about constrained optimization in engineering (sadly I didn't learn much more), I learned that [the method of Lagrange multipliers](https://en.wikipedia.org/wiki/Lagrange_multiplier) exists to transform constrained optimization problems into unconstrained problems. The method works like this. Instead solving the problem
${e.block`\begin{array}{l}\mathrm{minimize} \; f(\vec{\xi}) \\ \mathrm{subject\;to} \; g(\vec{\xi}) = \vec{0},\end{array}`}
we solve the problem
${e.block`\mathrm{minimize} \; \mathcal{L}(\vec{\xi}, \lambda) = f(\vec{\xi}) - \lambda \cdot g(\vec{\xi})`}
where ${e`\lambda`} is an auxiliary parameter (the "Lagrange multiplier") that drives objective function toward satisfying the constraint. With just a bit of handwaving, we can demonstrate that setting the partial derivatives of ${e`\mathcal{L}`} equal to zero yields
${e.block`0 = \frac{\partial \mathcal{L}(\vec{\xi}, \lambda)}{\partial \lambda} = - g(\vec{\xi})`}
${e.block`0 = g(\vec{\xi})`}
which confirms the constraint is satisfied, and
${e.block`\vec{0} = \nabla \mathcal{L}(\vec{\xi}, \lambda) = \nabla f(\vec{\xi}) - \lambda \nabla g(\vec{\xi})`}
${e.block`\nabla f(\vec{\xi})  = \lambda \nabla g(\vec{\xi}) = \vec{0},`}
with the final leap of faith equality to zero taken since ${e`g(\vec{\xi}) = 0`} is a [stationary point](https://en.wikipedia.org/wiki/Stationary_point). This step then enforces the original objective function, though I haven't adequately justified it here. [Wikipedia actually has a pretty good explanation](https://en.wikipedia.org/wiki/Lagrange_multiplier) which I'd be foolish to try to outdo.

It only takes the tiniest modification to state our problem in the canonical form of a Lagrange-multiplier-ready problem,
${e.block`\begin{array}{l} \begin{array}{c} \phantom{\small{0}} \\ \mathrm{argmin} \\ \small{\vec{\xi} \in \mathbb{R}^3} \end{array} \displaystyle \! \! \sum \limits_{i = 1}^{n_{faces}} \left(\xi_x dA_{i, x} + \xi_y dA_{i, y} + \xi_z dA_{i, z}\right)^2 \\ \phantom{\small 0} \\ \;\; \mathrm{subject\;to} \; g(\vec{\xi}) = \xi_x^2 + \xi_y^2 + \xi_z^2 - 1 = 0.\end{array}`}
Applying the method, we arrive at the unconstrained problem
${e.block`\begin{array}{c} \phantom{\small{0}} \\ \small{\phantom{0}} \\ \mathrm{argmin} \\ \small{\vec{\xi} \in \mathbb{R}^3} \\ \small{\lambda \in \mathbb{R}} \end{array} \displaystyle \! \! \sum \limits_{i = 1}^{n_{faces}} \left(\xi_x dA_{i, x} + \xi_y dA_{i, y} + \xi_z dA_{i, z}\right)^2 - \lambda(\xi_x^2 + \xi_y^2 + \xi_z^2 - 1).`}

Taking the partial derivatives with respect to ${e`\xi_x`}, ${e`\xi_y`}, and ${e`\xi_z`} as well as ${e`\lambda`} and equating to zero isn't particularly tedious. The result is a system of four simultaneous equations,
${e.block`\left\{\begin{array}{l}
0 = \xi_x \sum dA_{i,x} dA_{i,x} + \xi_y \sum dA_{i,y} dA_{i,x} + \xi_z \sum dA_{i,z} dA_{i,x}  - \lambda \xi_x \\
0 = \xi_x \sum dA_{i,x} dA_{i,y} + \xi_y \sum dA_{i,y} dA_{i,y} + \xi_z \sum dA_{i,z} dA_{i,y} - \lambda \xi_y  \\
0 = \xi_x \sum dA_{i,x} dA_{i,z} + \xi_y \sum dA_{i,y} dA_{i,z} + \xi_z \sum dA_{i,z} dA_{i,z} - \lambda \xi_z  \\
0 = \xi_x^2 + \xi_y^2  + \xi_z^2 - 1 \end{array}\right.`}

It suddenly feels hopeless, especially since the fourth equation is a bit nonlinear in ${e`\vec{\xi}`}. Let's cut down on the visual noise by defining
${e.block`A_{xy} = \sum \limits_{i = 1}^{n_{faces}} dA_{i, x} dA_{i, y}`}
as well as the analogous definitions for all pairwise combinations of axes. With these definitions, the above equation looks a bit more manageable, yielding
${e.block`\left\{\begin{array}{l}
0 = \xi_x A_{xx} + \xi_y A_{yx} + \xi_z A_{zx} - \lambda \xi_x \\
0 = \xi_x A_{xy} + \xi_y A_{yy} + \xi_z A_{zy} - \lambda \xi_y \\
0 = \xi_x A_{xz} + \xi_y A_{yz} + \xi_z A_{zz} - \lambda \xi_z \\
0 = \xi_x^2 + \xi_y^2  + \xi_z^2 - 1. \end{array}\right.`}

Neglecting the last equation for a moment, we can state the first three as a matrix multiplication,
${e.block`
\left[\begin{array}{ccc}
A_{xx} & A_{yx} & A_{zx} \\
A_{xy} & A_{yy} & A_{zy} \\
A_{xz} & A_{yz} & A_{zz} \\
\end{array}\right]
\left[\begin{array}{c}\xi_x \\ \xi_y \\ \xi_z \end{array}\right] = \lambda
\left[\begin{array}{c}\xi_x \\ \xi_y \\ \xi_z \end{array}\right].
`}

This is just the standard form of an [eigenvalue problem](https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors),
${e.block`\mathbf{A} \vec{\xi} = \lambda \vec{\xi},`}
and what's more, its eigenvectors ${e`\vec{\xi}`} are normalized by convention, which implicitly satisfies the constraint ${e`|\vec{\xi}| = 1`}. Eigenvalues are simple and easy to compute, [even in JavaScript](https://github.com/mljs/matrix). We've solved it! Upon solving, we get three eigenvalues and corresponding unit eigenvectors which are identically the model axes and associated inverse strengths along the respective eigenvectors.

As a final bonus, recall—or discover today!—that [the eigenvalues of a symmetric positive-definite matrix are real and orthogonal](https://en.wikipedia.org/wiki/Positive-definite_matrix#Characterizations), i.e. mutually perpendicular. And there are three of them. So we don't just get unit vectors out of this, we get a three dimensional rotation matrix which can be applied directly to the model.

## Does it work?

Wonderfully! Robustly! Efficiently! The only nontrivial numerical part is the eigenvalue computation, but it's only a small 3x3 matrix you can farm out to any old numerical library.

The main caveat is that eigenvalues are only unique up to a sign so that we need to check for reflections and apply some slightly ad-hoc heuristics to disambiguate the sign. In particular, I'm just using the total summed area vector to see if we can put the open end in a consistent direction. There's room for improvement.

You can see the final result below. Note that the two remaining axes also align the knee!

**Update:** Eric Arnebäck [asked about noise](https://twitter.com/erkaman2/status/1024296231508602881). I've added a noise slider below and have removed a square root in the scaling so that the magnitudes are a bit more separated. The noise is not IID noise so take it with a grain of salt, but it hopefully gives some indication of the approach's ability to reject noise.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});A({root:document.getElementById("cell-14"),expanded:[],variables:[]},{id:14,body:(l,e)=>{const n=l`<figure id="figure5" style="text-align: center;">
  <div style="display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 1rem;">
    <div id="figure5-canvas" style="position: relative; overflow: hidden; width: 100%; max-width: 400px; height: 500px;"></div>
    <div id="figure5-controls" style="text-align: left; width: 100%; max-width: 300px;"></div>
  </div>
  <figcaption>Adjust the sliders and observe the effect it has upon the computed alignment.</figcaption>
</figure>`;return e(n),{figure5Container:n}},inputs:["html","display"],outputs:["figure5Container"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});A({root:document.getElementById("cell-16"),expanded:[],variables:[]},{id:16,body:async()=>{const[{default:l},{default:e},{mat4:n,vec3:w},{default:k},{createDrawMesh:C},{createDrawVectors:_},{createDrawNormals:I},{unindex:y,meshNurbsSurface:f,createBuffers:z},{calculatePrincipalAxesAndCentroid:x},{angleNormals:u}]=await Promise.all([V(()=>import("./nurbs-GsC3AlCU.js"),[]).then(t=>{if(!("default"in t))throw new SyntaxError("export 'default' not found");return t}),V(()=>import("./regl-camera-DlsONIBa.js"),[]).then(t=>{if(!("default"in t))throw new SyntaxError("export 'default' not found");return t}),V(()=>import("./gl-matrix-Bl54U4qm.js"),[]).then(t=>{if(!("mat4"in t))throw new SyntaxError("export 'mat4' not found");if(!("vec3"in t))throw new SyntaxError("export 'vec3' not found");return t}),V(()=>import("https://cdn.jsdelivr.net/npm/regl@2.1.1/+esm"),[]).then(t=>{if(!("default"in t))throw new SyntaxError("export 'default' not found");return t}),V(()=>import("./draw-mesh-BOAdl92J.js"),[]).then(t=>{if(!("createDrawMesh"in t))throw new SyntaxError("export 'createDrawMesh' not found");return t}),V(()=>import("./draw-vectors-BUcwfLZo.js"),[]).then(t=>{if(!("createDrawVectors"in t))throw new SyntaxError("export 'createDrawVectors' not found");return t}),V(()=>import("./draw-normals-C8AEa9KU.js"),[]).then(t=>{if(!("createDrawNormals"in t))throw new SyntaxError("export 'createDrawNormals' not found");return t}),V(()=>import("./mesh-utils-BZLFy5bM.js"),[]).then(t=>{if(!("unindex"in t))throw new SyntaxError("export 'unindex' not found");if(!("meshNurbsSurface"in t))throw new SyntaxError("export 'meshNurbsSurface' not found");if(!("createBuffers"in t))throw new SyntaxError("export 'createBuffers' not found");return t}),V(()=>import("./calculate-principal-axes-BIc5AAw1.js"),[]).then(t=>{if(!("calculatePrincipalAxesAndCentroid"in t))throw new SyntaxError("export 'calculatePrincipalAxesAndCentroid' not found");return t}),V(()=>import("./angle-normals-B00PxL35.js"),[]).then(t=>{if(!("angleNormals"in t))throw new SyntaxError("export 'angleNormals' not found");return t})]);function i(t,h=8e-4){let c=window.scrollY;window.addEventListener("scroll",()=>{const d=t.element;if(!d)return;const p=d.getBoundingClientRect();if(p.top<window.innerHeight&&p.bottom>0){const r=window.scrollY-c;t.state.dtheta+=r*h,t.taint()}c=window.scrollY})}return{nurbs:l,createCamera:e,mat4:n,vec3:w,createREGL:k,createDrawMesh:C,createDrawVectors:_,createDrawNormals:I,unindex:y,meshNurbsSurface:f,createBuffers:z,calculatePrincipalAxesAndCentroid:x,angleNormals:u,addScrollRotation:i}},inputs:[],outputs:["nurbs","createCamera","mat4","vec3","createREGL","createDrawMesh","createDrawVectors","createDrawNormals","unindex","meshNurbsSurface","createBuffers","calculatePrincipalAxesAndCentroid","angleNormals","addScrollRotation"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});A({root:document.getElementById("cell-17"),expanded:[],variables:[]},{id:17,body:(l,e,n,w,k,C,_,I,y,f,z)=>{{const x=document.getElementById("figure1-canvas"),u=e({container:x,pixelRatio:Math.min(window.devicePixelRatio,2),extensions:["oes_element_index_uint","oes_standard_derivatives"],attributes:{antialias:!0,preserveDrawingBuffer:!0}}),i=n(u),t=w(u,{center:[0,0,0],distance:2.6,theta:1,phi:.6,damping:0,noScroll:!0,noZoom:!0});k(t);const h=C({points:[{y:-1,r1:1e-4,r2:1e-4,x:.2,rot:-.2},{y:-1,r1:.45,r2:.45,x:.2,rot:-.2},{y:-.3,r1:.55,r2:.55,x:.1,rot:-.1},{y:.1,r1:.69,r2:.65,x:-.05,rot:0},{y:.4,r1:.75,r2:.7,x:.05,rot:.2},{y:.8,r1:.8,r2:.9,x:.3,rot:.5}].map(o=>[[o.x+o.r1,o.y-o.rot*o.r1,0],[o.x,o.y,o.r2],[o.x-o.r1,o.y+o.rot*o.r1,0],[o.x,o.y,-o.r2]]),boundary:["clamped","closed"],degree:[3,4]}),c=_.create();_.rotate(c,c,-Math.PI*.5,[0,1,0]),_.rotate(c,c,Math.PI,[-1,1,-.5]),h.transform(c);const d=I({},h,{computeNormals:!0,computeUvs:!0,divisions:[50,70],unwrapV:!0},{vec3:y}),p=f(u,z(d),{borderWidth:1.5,borderColor:[.1,.2,.3,1]});u.frame(()=>{t(()=>{u.clear({color:[1,1,1,1],depth:1}),i(p)})})}},inputs:["figure1Container","createREGL","createDrawMesh","createCamera","addScrollRotation","nurbs","mat4","meshNurbsSurface","vec3","createBuffers","unindex"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});A({root:document.getElementById("cell-18"),expanded:[],variables:[]},{id:18,body:(l,e,n,w,k,C,_,I,y,f,z)=>{{const x=document.getElementById("figure2-canvas"),u=e({container:x,pixelRatio:Math.min(window.devicePixelRatio,2),extensions:["oes_element_index_uint","oes_standard_derivatives","angle_instanced_arrays"],attributes:{antialias:!0,preserveDrawingBuffer:!0}}),i=n(u),t=w(u),h=k(u,{center:[.1,.1,0],distance:4,theta:1,phi:.3,damping:0,noScroll:!0,noZoom:!0});C(h);const c=_({points:[{y:-1,r1:1e-4,r2:1e-4,x:.05,rot:-.2},{y:-1,r1:.45,r2:.45,x:.05,rot:-.2},{y:-.3,r1:.55,r2:.55,x:-.05,rot:-.1},{y:.1,r1:.69,r2:.65,x:-.2,rot:0},{y:.4,r1:.75,r2:.7,x:-.1,rot:.2},{y:.8,r1:.8,r2:.9,x:.15,rot:.5}].map(r=>[[r.x+r.r1,r.y-r.rot*r.r1,0],[r.x,r.y,r.r2],[r.x-r.r1,r.y+r.rot*r.r1,0],[r.x,r.y,-r.r2]]),boundary:["clamped","closed"],degree:[3,4]}),d=I({},c,{computeNormals:!0,computeUvs:!0,divisions:[50,70],unwrapV:!0},{vec3:y}),p=f(u,z(d),{borderWidth:1.5,borderColor:[.1,.2,.3,1]}),o={vertices:u.buffer([0,-1.4,0,0,1.4,0]),count:1,lineWidth:2,lineColor:[.8,.2,.3,1],arrowheadWidth:12,arrowheadLength:24,depth:!0};u.frame(()=>{h(()=>{u.clear({color:[1,1,1,1],depth:1}),i(p),t(o)})})}},inputs:["figure2Container","createREGL","createDrawMesh","createDrawVectors","createCamera","addScrollRotation","nurbs","meshNurbsSurface","vec3","createBuffers","unindex"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});A({root:document.getElementById("cell-19"),expanded:[],variables:[]},{id:19,body:(l,e,n,w,k,C,_,I,y,f,z,x)=>{{let W=function(D,S,N){return I({points:[{y:-D*.5,r1:S,r2:N,x:0,rot:0},{y:D*.5,r1:S,r2:N,x:0,rot:0}].map(s=>[[s.x+s.r1,s.y-s.rot*s.r1,0],[s.x,s.y,s.r2],[s.x-s.r1,s.y+s.rot*s.r1,0],[s.x,s.y,-s.r2]]),boundary:["clamped","closed"],degree:[1,4]})},$=function(D,S,N){return D>S&&D>N?new Float32Array([0,-1,0,0,1,0]):S>N?new Float32Array([-1,0,0,1,0,0]):new Float32Array([0,0,-1,0,0,1])},O=function(){const D=t.value,S=h.value,N=c.value;M=W(D,S,N),L=y(L,M,{computeNormals:!0,computeUvs:!0,divisions:[1,50],unwrapV:!0},{vec3:f});const s=x(L);a.vertices(s.vertices),a.normals(s.normals),a.uvs(s.uvs),U($(D,S,N))};const u=document.getElementById("figure3-canvas"),i=document.getElementById("figure3-controls"),t=e.range([.1,1.3],{value:.3,step:.01,label:"Length"}),h=e.range([.1,1.3],{value:.7,step:.01,label:"Width"}),c=e.range([.1,1.3],{value:.5,step:.01,label:"Depth"});i.appendChild(t),i.appendChild(h),i.appendChild(c);const d=n({container:u,pixelRatio:Math.min(window.devicePixelRatio,2),extensions:["oes_element_index_uint","oes_standard_derivatives","angle_instanced_arrays"],attributes:{antialias:!0,preserveDrawingBuffer:!0}}),p=w(d),o=k(d),r=C(d,{center:[0,0,0],distance:2.5,theta:.8,phi:.4,damping:0,noScroll:!0,noZoom:!0});_(r);let M=W(.3,.7,.5),L=y({},M,{computeNormals:!0,computeUvs:!0,divisions:[1,50],unwrapV:!0},{vec3:f});const a=z(d,x(L),{borderWidth:1.5,borderColor:[.1,.2,.3,1],drawOpenEdges:!0}),U=d.buffer($(.3,.7,.5)),R={vertices:U,count:1,lineWidth:1.5,lineColor:[.8,.2,.3,1],depth:!0};t.addEventListener("input",O),h.addEventListener("input",O),c.addEventListener("input",O),d.frame(()=>{r(()=>{d.clear({color:[1,1,1,1],depth:1}),p(a),o(R)})})}},inputs:["figure3Container","Inputs","createREGL","createDrawMesh","createDrawVectors","createCamera","addScrollRotation","nurbs","meshNurbsSurface","vec3","createBuffers","unindex"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});A({root:document.getElementById("cell-20"),expanded:[],variables:[]},{id:20,body:(l,e,n,w,k,C,_,I,y,f,z,x)=>{{const u=document.getElementById("figure4-canvas"),i=e({container:u,pixelRatio:Math.min(window.devicePixelRatio,2),extensions:["oes_element_index_uint","oes_standard_derivatives","angle_instanced_arrays"],attributes:{antialias:!0,preserveDrawingBuffer:!0}}),t=n(i),h=w(i),c=k(i),d=C(i,{center:[0,.2,0],distance:3,theta:.3+Math.PI/2,phi:.5,damping:0,noScroll:!0,noZoom:!0});_(d);const p=I({points:[{y:-.2,r1:.9,r2:.9,x:0,rot:0},{y:.2,r1:.9,r2:.9,x:0,rot:0}].map(a=>[[a.x+a.r1,a.y-a.rot*a.r1,0],[a.x,a.y,a.r2],[a.x-a.r1,a.y+a.rot*a.r1,0],[a.x,a.y,-a.r2]]),boundary:["clamped","closed"],degree:[1,4]}),o=y({},p,{computeNormals:!0,computeUvs:!0,divisions:[1,50],unwrapV:!0},{vec3:f}),r=z(i,x(o),{borderWidth:1.5,borderColor:[.1,.2,.3,1],drawOpenEdges:!0}),W=y({},p,{computeNormals:!0,divisions:[2,9]},{vec3:f}),$=x(W),M={vertices:i.buffer($.vertices),normals:i.buffer($.normals),count:$.vertices.length/3,lineWidth:1,arrowheadLength:7,arrowheadWidth:4,scale:.2,lineColor:[.22,.31,.45,1]},L={vertices:i.buffer([0,-1.1,0,0,1.1,0]),count:1,lineWidth:2,lineColor:[.8,.2,.3,1],arrowheadWidth:15,arrowheadLength:30,depth:!0};i.frame(()=>{d(()=>{i.clear({color:[1,1,1,1],depth:1}),t(r),h(L),c(M)})})}},inputs:["figure4Container","createREGL","createDrawMesh","createDrawVectors","createDrawNormals","createCamera","addScrollRotation","nurbs","meshNurbsSurface","vec3","createBuffers","unindex"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});A({root:document.getElementById("cell-21"),expanded:[],variables:[]},{id:21,body:(l,e,n,w,k,C,_,I,y,f,z,x)=>{{const u=document.getElementById("figure6-canvas"),i=e({container:u,pixelRatio:Math.min(window.devicePixelRatio,2),extensions:["oes_element_index_uint","oes_standard_derivatives","angle_instanced_arrays"],attributes:{antialias:!0,preserveDrawingBuffer:!0}}),t=n(i),h=w(i),c=k(i),d=C(i,{center:[.1,-.1,0],distance:4,theta:1,phi:.3,damping:0,noScroll:!0,noZoom:!0});_(d);const p=I({points:[{y:-1,r1:1e-4,r2:1e-4,x:.05,rot:-.2},{y:-1,r1:.45,r2:.45,x:.05,rot:-.2},{y:-.3,r1:.55,r2:.55,x:-.05,rot:-.1},{y:.1,r1:.69,r2:.65,x:-.2,rot:0},{y:.4,r1:.75,r2:.7,x:-.1,rot:.2},{y:.8,r1:.8,r2:.9,x:.15,rot:.5}].map(a=>[[a.x+a.r1,a.y-a.rot*a.r1,0],[a.x,a.y,a.r2],[a.x-a.r1,a.y+a.rot*a.r1,0],[a.x,a.y,-a.r2]]),boundary:["clamped","closed"],degree:[3,4]}),o=y({},p,{computeNormals:!0,computeUvs:!0,divisions:[50,70],unwrapV:!0},{vec3:f}),r=z(i,x(o),{borderWidth:1.5,borderColor:[.1,.2,.3,1]}),W=y({},p,{computeNormals:!0,divisions:[6,9]},{vec3:f}),$=x(W),M={vertices:i.buffer($.vertices),normals:i.buffer($.normals),count:$.vertices.length/3,lineWidth:1,arrowheadLength:7,arrowheadWidth:4,scale:.2,lineColor:[.22,.31,.45,1]},L={vertices:i.buffer([0,-1.4,0,0,1.4,0]),count:1,lineWidth:2.5,lineColor:[.8,.2,.3,1],arrowheadWidth:10,arrowheadLength:20,depth:!0};i.frame(()=>{d(()=>{i.clear({color:[1,1,1,1],depth:1}),t(r),h(L),c(M)})})}},inputs:["figure6Container","createREGL","createDrawMesh","createDrawVectors","createDrawNormals","createCamera","addScrollRotation","nurbs","meshNurbsSurface","vec3","createBuffers","unindex"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});A({root:document.getElementById("cell-22"),expanded:[],variables:[]},{id:22,body:(l,e,n,w,k,C,_,I,y,f,z,x,u,i)=>{{let L=function(B,b,P){const E=B*1.5*P;return I({points:[{y:-1*P,r1:1e-4,r2:1e-4,x:.05*E,rot:-.2*E},{y:-1*P,r1:.45*b,r2:.45*b,x:.05*E,rot:-.2*E},{y:-.3*P,r1:.55*b,r2:.55*b,x:-.05*E,rot:-.1*E},{y:.1*P,r1:.69*b,r2:.65*b,x:-.2*E,rot:0*E},{y:.4*P,r1:.75*b,r2:.7*b,x:-.1*E,rot:.2*E},{y:.8*P,r1:.8*b,r2:.9*b,x:.15*E,rot:.5*E}].map(m=>[[m.x+m.r1,m.y-m.rot*m.r1,1e-4],[m.x,m.y,m.r2],[m.x-m.r1,m.y+m.rot*m.r1,0],[m.x,m.y,-m.r2]]),boundary:["clamped","closed"],degree:[3,4]})},a=function(){let B=0,b=0;for(;B===0;)B=Math.random();for(;b===0;)b=Math.random();return Math.sqrt(-2*Math.log(B))*Math.cos(2*Math.PI*b)},s=function(){const B=c.value,b=d.value,P=p.value,E=o.value;U=L(B,b,P),R=y(R,U,{computeNormals:!0,computeUvs:!0,divisions:[50,70],unwrapV:!1},{vec3:f});const m=new Float32Array(R.vertices.length);for(let G=0;G<m.length;G++)m[G]=R.vertices[G]+O[G]*E;const H=u(R.faces,m),J={faces:R.faces,vertices:m,count:R.faces.length/3},F=i([J],{vec3:f}),v=F.matrix,g=F.centroid;let T=Math.pow(F.strengths[0],2),j=Math.pow(F.strengths[1],2),q=Math.pow(F.strengths[2],2);const Z=Math.max(T,j,q);T*=-1.4/Z,j*=-1.4/Z,q*=-1.4/Z,S([g[0]-v[0]*T,g[1]-v[1]*T,g[2]-v[2]*T,g[0]+v[0]*T,g[1]+v[1]*T,g[2]+v[2]*T,g[0]-v[4]*j,g[1]-v[5]*j,g[2]-v[6]*j,g[0]+v[4]*j,g[1]+v[5]*j,g[2]+v[6]*j,g[0]-v[8]*q,g[1]-v[9]*q,g[2]-v[10]*q,g[0]+v[8]*q,g[1]+v[9]*q,g[2]+v[10]*q]);const Y=x({...R,vertices:m,normals:H});D.vertices(Y.vertices),D.normals(Y.normals),D.uvs(Y.uvs)};const t=document.getElementById("figure5-canvas"),h=document.getElementById("figure5-controls"),c=e.range([0,1],{value:.5,step:.01,label:"Curvature"}),d=e.range([.5,1.3],{value:1,step:.01,label:"Radius"}),p=e.range([.3,1.2],{value:1,step:.01,label:"Length"}),o=e.range([0,1],{value:.1,step:.01,label:"Noise"});h.appendChild(c),h.appendChild(d),h.appendChild(p),h.appendChild(o);const r=n({container:t,pixelRatio:Math.min(window.devicePixelRatio,2),extensions:["oes_element_index_uint","oes_standard_derivatives","angle_instanced_arrays"],attributes:{antialias:!0,preserveDrawingBuffer:!0}}),W=w(r),$=k(r),M=C(r,{center:[.1,.1,0],distance:4.2,theta:.3+Math.PI/2,phi:.3,damping:0,noScroll:!0,noZoom:!0});_(M,-8e-4);let U=L(.5,1,1),R=y({},U,{computeNormals:!0,computeUvs:!0,divisions:[50,70],unwrapV:!1},{vec3:f});const O=new Float32Array(R.vertices.length);for(let B=0;B<O.length;B++)O[B]=a()*.02;const D=z(r,x(R),{borderWidth:1.5,borderColor:[.1,.2,.3,1]}),S=r.buffer(new Float32Array(18)),N={vertices:S,count:3,lineWidth:1.5,lineColor:[.8,.2,.3,1],depth:!0};s(),c.addEventListener("input",s),d.addEventListener("input",s),p.addEventListener("input",s),o.addEventListener("input",s),r.frame(()=>{M(()=>{r.clear({color:[1,1,1,1],depth:1}),W(D),$(N)})})}},inputs:["figure5Container","Inputs","createREGL","createDrawMesh","createDrawVectors","createCamera","addScrollRotation","nurbs","meshNurbsSurface","vec3","createBuffers","unindex","angleNormals","calculatePrincipalAxesAndCentroid"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});
