import{d as M,_ as z}from"./index-ByB2dbry.js";M({root:document.getElementById("cell-4"),expanded:[],variables:[]},{id:4,body:(u,a)=>u`In this post, we play a topological game called *eversion*. Our objective is simple: turn a sphere inside out without cutting or creasing it. We consider a sphere, though a torus is also an [interesting challenge](https://www.youtube.com/watch?v=kQcy5DvpvlM).

That a sphere (specifically the two-sphere ${a`S^2`} embedded in three dimensional space ${a`\mathbb{R}^3`}) can be turned inside out was proved by Stephen Smale in 1957. However the proof is a proof of existence, offering no particular guidance for those hoping to perform the feat.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});M({root:document.getElementById("cell-7"),expanded:[],variables:[]},{id:7,body:async()=>{const[{createWebGPUContext:u},{createCameraController:a},{createRenderer:r},{createFrameLoop:x},{peelShaderCode:g,peelCompositeShaderCode:E},{createSequencer:H,linear:$}]=await Promise.all([z(()=>import("./webgpu-canvas-C7AS78hn.js"),[]).then(t=>{if(!("createWebGPUContext"in t))throw new SyntaxError("export 'createWebGPUContext' not found");return t}),z(()=>import("./camera-controller-DnDb9jMf.js"),[]).then(t=>{if(!("createCameraController"in t))throw new SyntaxError("export 'createCameraController' not found");return t}),z(()=>import("./renderer-BbrsRPdW.js"),[]).then(t=>{if(!("createRenderer"in t))throw new SyntaxError("export 'createRenderer' not found");return t}),z(()=>import("./frame-loop-QkwpdSbZ.js"),[]).then(t=>{if(!("createFrameLoop"in t))throw new SyntaxError("export 'createFrameLoop' not found");return t}),z(()=>import("./shaders-CQUk8GZv.js"),[]).then(t=>{if(!("peelShaderCode"in t))throw new SyntaxError("export 'peelShaderCode' not found");if(!("peelCompositeShaderCode"in t))throw new SyntaxError("export 'peelCompositeShaderCode' not found");return t}),z(()=>import("./sequencer-C3jnWiGv.js"),[]).then(t=>{if(!("createSequencer"in t))throw new SyntaxError("export 'createSequencer' not found");if(!("linear"in t))throw new SyntaxError("export 'linear' not found");return t})]),{device:P,canvasFormat:W}=await u();return{createWebGPUContext:u,createCameraController:a,createRenderer:r,createFrameLoop:x,peelShaderCode:g,peelCompositeShaderCode:E,createSequencer:H,linear:$,device:P,canvasFormat:W,shaderCodes:{peel:g,peelComposite:E}}},inputs:[],outputs:["createWebGPUContext","createCameraController","createRenderer","createFrameLoop","peelShaderCode","peelCompositeShaderCode","createSequencer","linear","device","canvasFormat","shaderCodes"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});M({root:document.getElementById("cell-8"),expanded:[],variables:[]},{id:8,body:async(u,a,r,x,g,E,H,$,P,W,q)=>{await new Promise(t=>setTimeout(t,100));{let S=function(){const f=b.getBoundingClientRect(),n=b.offsetHeight-window.innerHeight;return n<=0?0:Math.max(0,Math.min(1,-f.top/n))},B=function(){const f=b.getBoundingClientRect(),n=f.top<=0,T=f.bottom>=window.innerHeight;return n&&T?(l.classList.add("is-fixed"),l.classList.remove("is-bottom")):n&&!T?(l.classList.remove("is-fixed"),l.classList.add("is-bottom")):(l.classList.remove("is-fixed"),l.classList.remove("is-bottom")),f.top<window.innerHeight&&f.bottom>0},I=function(){p.width=Math.floor(h.offsetWidth*y),p.height=Math.floor(h.offsetHeight*y),v.taint(),_=!0};const t=.6666666666666666,e=1,c=u({section:[{t:0,value:10}],shittyEversion:[{t:0,value:0}],color:[{t:e+0,value:0},{t:e+6,value:1,ease:a}],strips:[{t:0,value:0}],n:[{t:e+0,value:2}],posClip:[{t:e+0,value:1}],negClip:[{t:e+0,value:1}],stereo:[{t:e+.5,value:1}],fatEdge:[{t:e,value:0}],rotation:[{t:e-3,value:0},{t:e+0,value:0},{t:e+5.5,value:0},{t:e+9,value:0}],translation:[{t:e+0,value:.5},{t:e+.7,value:1.4},{t:e+2,value:1},{t:e+4,value:1},{t:e+5.3,value:1.4},{t:e+6,value:.5}],scale:[{t:e+0,value:1.5/Math.pow(t,.5)},{t:e+1,value:.6},{t:e+1.5,value:.7},{t:e+4.5,value:.7},{t:e+5,value:.6},{t:e+6,value:1.5/Math.pow(t,.5)}],limit:[{t:0,value:0}],t:[{t:e+0,value:1/t},{t:e+2,value:1/t},{t:e+4,value:-1/t},{t:e+6,value:-1/t}],alpha:[{t:e+0,value:1e-5},{t:e+1,value:1},{t:e+5,value:1},{t:e+6,value:1e-5}],beta:[{t:e+0,value:1},{t:e+1,value:1/20},{t:e+5,value:1/20},{t:e+6,value:1}],q:[{t:e+0,value:t}],eta:[{t:e+0,value:1}],xi:[{t:e+0,value:0},{t:e+2,value:1},{t:e+4,value:1},{t:e+5,value:0},{t:e+6,value:0}],lambda:[{t:e+0,value:0},{t:e+2,value:1},{t:e+4,value:1},{t:e+6,value:0}],omega:[{t:e+0,value:2}],Qinv:[{t:e+0,value:1/t}]}),i=8,w=[{text:"We start with a sphere.",left:"10%",bottom:"10%"},{text:"We push on one pole to form an indentation.",right:"10%",bottom:"10%"},{text:"And add a bit of twist.",left:"10%",bottom:"30%"},{text:"Here's where the magic happens. We swap the inner and outer shells, being very careful not to introduce any creases.",right:"5%",bottom:"10%"},{text:"Don't worry! We'll look at this step more carefully below.",right:"5%",bottom:"10%"},{text:"Upon removing the indentation, we find the inside of the sphere has become the outside!",left:"10%",bottom:"10%"},{text:"",left:"10%",bottom:"10%"},{text:"",left:"10%",bottom:"10%"}],b=r`<div class="scrollyteller" id="scrollyteller-1"></div>`,l=r`<div class="scrollyteller__background"></div>`,h=r`<div class="scrollyteller__fixed-content" id="eversion-canvas-1"></div>`,L=r`<div class="scrollyteller__foreground"></div>`;for(let f=0;f<i;f++){const n=w[f],T=r`<div class="scrollyteller__frame">
      ${n.text?Object.assign(r`<div class="scrollyteller__caption" style="
        ${n.left?`left: ${n.left};`:""}
        ${n.right?`right: ${n.right};`:""}
        ${n.top?`top: ${n.top};`:""}
        ${n.bottom?`bottom: ${n.bottom};`:""}
      "></div>`,{innerHTML:n.text}):""}
    </div>`;L.appendChild(T)}l.appendChild(h),b.appendChild(l),b.appendChild(L),x(b),await new Promise(f=>setTimeout(f,100));const p=document.createElement("canvas");p.style.cssText="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; cursor: grab;",h.appendChild(p);const y=Math.min(1.5,window.devicePixelRatio);p.width=Math.floor(h.offsetWidth*y),p.height=Math.floor(h.offsetHeight*y);const o=p.getContext("webgpu");o.configure({device:g,format:E});const v=H(p,{distance:6,near:.1,far:10,theta:.7,phi:.1,wheel:!1,touch:!1}),C=$(g,E,P);let _=!0,d=0;const R=W(()=>{if(!B())return;const n=S(),T=Math.abs(n-d)>1e-4;d+=(n-d)*.1,c.setPosition(d*i);const A=c.getState(),V=p.offsetWidth/p.offsetHeight,F=V>1?1:V;if(!_&&!v.dirty&&!T)return;const m=p.width,s=p.height,k={...A,scale:A.scale*F,near:.1,far:10,pixelRatio:y,opacity:.85,peelLayers:4};C.render(o,k,v,m,s),_=!1});window.addEventListener("resize",I),q.then(()=>{R.cancel(),window.removeEventListener("resize",I),v.destroy()})}},inputs:["createSequencer","linear","html","display","device","canvasFormat","createCameraController","createRenderer","shaderCodes","createFrameLoop","invalidation"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});M({root:document.getElementById("cell-9"),expanded:[],variables:[]},{id:9,body:(u,a)=>u`Success! But that all happened very quickly. What happens at the top is clearly the key. In some sense, we do simply push one end of the sphere right through the other, but we need some clever tricks to keep the hole at the top smooth.

Bednorz and Bednorz break down the method as follows. As long as nothing topologically interesting happens at the poles of the sphere, we can simply remove them from the equation and focus on a cylindrical band around the equator. All that's left then is to manipulate the cylindrical band carefully and replace the poles at the end of the process.

The key element of their method is a family of *[ruled surfaces](https://mathworld.wolfram.com/RuledSurface.html)*, or surfaces swept out by a straight line moving through space, which accomplish this task. They propose a family parameterized by time ${a`t`}. They're careful to prove the surface remains smooth during the process, but we'll remain content to get to our destination and visually check the smoothness along the way.

They propose the family of ruled surfaces given by the equations

${a.block`
\begin{aligned}
x &= t \cos \phi + p \sin (n - 1) \phi - h \sin \phi \\
y &= t \sin \phi + p \cos (n - 1) \phi + h \cos \phi \\
z &= h \sin n \phi - (t / n) \cos n \phi - qth.
\end{aligned}
`}

The variable ${a`\phi`} parameterizes the polar angle of the cylinder from ${a`-\pi`} to ${a`\pi`} while ${a`h`} parameterizes the vertical dimension of the cylinder. They suggest ${a`q = 2/3`} and ${a`p = 1 - |qt|`}.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});M({root:document.getElementById("cell-10"),expanded:[],variables:[]},{id:10,body:(u,a,r)=>{const x=u.range([-1.5,1.5],{value:1.5,step:.01,label:"t"}),g=u.range([2,4],{value:2,step:1,label:"n"});return a(r`<div>${x}${g}</div>`),{tSlider:x,nSlider:g}},inputs:["Inputs","display","html"],outputs:["tSlider","nSlider"],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});M({root:document.getElementById("cell-11"),expanded:[],variables:[]},{id:11,body:async(u,a,r,x,g,E,H,$,P,W,q)=>{await new Promise(t=>setTimeout(t,100));{let C=function(){i.width=Math.floor(c.offsetWidth*w),i.height=Math.floor(c.offsetHeight*w),L.taint(),y=!0};const t=.6666666666666666,e=u`<figure class="surface-figure" style="width: 100%; height: min(90vw, 700px); position: relative;">
    <div id="surface-canvas-container" style="position: absolute; top: 0; left: 0; width: 100%; height: calc(100% - 40px);"></div>
    <figcaption style="position: absolute; bottom: 10px; left: 0; right: 0;">The proposed cylindrical ruled surface.</figcaption>
  </figure>`;a(e),await new Promise(_=>setTimeout(_,100));const c=e.querySelector("#surface-canvas-container"),i=document.createElement("canvas");i.style.cssText="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; cursor: grab;",c.appendChild(i);const w=Math.min(1.5,window.devicePixelRatio),b=c.offsetWidth||600,l=c.offsetHeight||500;i.width=Math.floor(b*w),i.height=Math.floor(l*w);const h=i.getContext("webgpu");h.configure({device:r,format:x});const L=g(i,{distance:6,near:.1,far:100,theta:.4,phi:.1,wheel:!1}),p=E(r,x,H);let y=!0;const o={section:10,shittyEversion:0,strips:0,n:2,posClip:.5,negClip:.5,stereo:0,fatEdge:0,rotation:0,translation:0,scale:.45,t:1/t-1e-4,alpha:1,beta:1/20,q:t,eta:1,xi:0,lambda:1,omega:2,Qinv:1/t,opacity:.85,peelLayers:4};$.addEventListener("input",()=>{o.t=$.value,y=!0}),P.addEventListener("input",()=>{o.n=P.value,o.n===2?(o.scale=.45,o.posClip=.5,o.negClip=.5):o.n===3?(o.scale=.6,o.posClip=.4,o.negClip=.4):(o.scale=.75,o.posClip=.3,o.negClip=.3),y=!0});const v=W(()=>{const _=i.offsetWidth/i.offsetHeight,d=_>1?1:_;if(!y&&!L.dirty)return;const S=i.width,B=i.height,R={...o,scale:o.scale*d,near:.1,far:100,pixelRatio:w,opacity:o.opacity,peelLayers:o.peelLayers};p.render(h,R,L,S,B),y=!1});window.addEventListener("resize",C),q.then(()=>{v.cancel(),window.removeEventListener("resize",C),L.destroy()})}},inputs:["html","display","device","canvasFormat","createCameraController","createRenderer","shaderCodes","tSlider","nSlider","createFrameLoop","invalidation"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});M({root:document.getElementById("cell-12"),expanded:[],variables:[]},{id:12,body:(u,a)=>u`Adjust the time parameter ${a`t`} and observe the shape of the surface. There are two particular things to note. First, the surface always remains smooth, despite self-intersections, and second, the top and bottom of the edges of the cylinder swap places (with a bit of rotation which doesn't trouble us) as we move from ${a`t = -1.5`} to ${a`t = 1.5`}.

Note also that although we'll visualize eversion with ${a`n = 2`}, the eversion also works for values greater than two.

Of course we want to evert a full sphere and not just a cylindrical band, so the remainder of their paper focuses on using stereographic projections to smoothly close the caps of the cylindrical band and maintain the topology of the sphere during the entire process. The full eversion is illustrated above, but let's now step back through it, taking a bit more care to focus on the region of interest.`,inputs:["md","tex"],outputs:[],output:void 0,assets:void 0,autodisplay:!0,autoview:!1,automutable:void 0});M({root:document.getElementById("cell-13"),expanded:[],variables:[]},{id:13,body:async(u,a,r,x,g,E,H,$,P,W,q)=>{await new Promise(t=>setTimeout(t,100));{let T=function(){const m=o.getBoundingClientRect(),s=o.offsetHeight-window.innerHeight;return s<=0?0:Math.max(0,Math.min(1,-m.top/s))},A=function(){const m=o.getBoundingClientRect(),s=m.top<=0,k=m.bottom>=window.innerHeight;return s&&k?(v.classList.add("is-fixed"),v.classList.remove("is-bottom")):s&&!k?(v.classList.remove("is-fixed"),v.classList.add("is-bottom")):(v.classList.remove("is-fixed"),v.classList.remove("is-bottom")),m.top<window.innerHeight&&m.bottom>0},F=function(){d.width=Math.floor(C.offsetWidth*S),d.height=Math.floor(C.offsetHeight*S),R.taint(),f=!0};const t=.6666666666666666,e=1,c=e+2,i=c+1,w=c+7,b=w+2,l=b+2,h=l+2,L=u({color:[{t:e+0,value:0},{t:e+6,value:1,ease:a}],n:[{t:e+0,value:2}],strips:[{t:0,value:0}],rotation:[{t:e-3,value:0},{t:e+0,value:0},{t:c+6,value:0},{t:c+9,value:0}],section:[{t:0,value:10}],translation:[{t:e+.5,value:1},{t:c,value:0},{t:l,value:0},{t:h-.5,value:1}],scale:[{t:e+1,value:.5},{t:c,value:.4},{t:l,value:.4},{t:h-1,value:.5}],stereo:[{t:e+.75,value:1},{t:c,value:0},{t:l,value:0},{t:h-.75,value:1}],posClip:[{t:e+.25,value:1},{t:e+1.25,value:.5},{t:h-1,value:.5},{t:h+.5,value:1}],negClip:[{t:e+0,value:1},{t:e+1,value:.5},{t:h-1.5,value:.5},{t:h+0,value:1}],fatEdge:[{t:c+.25,value:0},{t:c+.5,value:1},{t:l-.5,value:1},{t:l+.25,value:0}],shittyEversion:[{t:i,value:0},{t:i+1,value:1},{t:i+2,value:1},{t:i+3,value:0}],t:[{t:w,value:1/t},{t:b,value:-1/t},{t:l,value:-1/t}],alpha:[{t:e,value:1}],beta:[{t:e,value:1/20}],q:[{t:e+0,value:t}],eta:[{t:e+0,value:1}],xi:[{t:w+0,value:1},{t:w+1,value:0},{t:b+1,value:0},{t:l+0,value:0}],lambda:[{t:i+4,value:0},{t:w-1,value:1},{t:b,value:1},{t:l,value:0}],omega:[{t:e+0,value:2}],Qinv:[{t:e+0,value:1/t}]}),p=17,y=[{text:"We start again, this time with our perturbed sphere.",left:"10%",bottom:"10%"},{text:"We restrict our attention to the cylindrical band separating the inner and outer shells.",right:"10%",bottom:"40%"},{text:"As long as we keep the surface smooth and don't twist the edges since we still have the rest of the sphere attached, we can distort the surface however we'd like.",left:"10%",bottom:"30%"},{text:'To perform the eversion, we must swap the <span style="color:blue">upper</span> and <span style="color:red">lower</span> edges of this cylinder.',right:"5%",bottom:"10%"},{text:"",left:"10%",bottom:"10%"},{text:`Recall that we can't just translate one end past the other without getting stuck with a <span style="color:red">cusp</span> which violates our smoothness rule.`,left:"5%",top:"10%"},{text:"",left:"10%",bottom:"10%"},{text:"Let's try again.",left:"5%",bottom:"10%"},{text:"",left:"10%",bottom:"10%"},{text:"To avoid the cusp, we distort the cylinder into the above ruled surface with which we can smoothly swap the upper and lower edges.",left:"10%",bottom:"50%"},{text:"We carefully slide one end past the other.",left:"10%",bottom:"10%"},{text:"",left:"10%",bottom:"10%"},{text:"And remove the twist.",left:"10%",bottom:"10%"},{text:"",left:"10%",bottom:"10%"},{text:"Restoring the poles which have been unaffected by the process, we confirm we've successfully turned our sphere inside out!",left:"10%",bottom:"10%"},{text:"",left:"10%",bottom:"10%"},{text:"",left:"10%",bottom:"10%"}],o=r`<div class="scrollyteller" id="scrollyteller-2"></div>`,v=r`<div class="scrollyteller__background"></div>`,C=r`<div class="scrollyteller__fixed-content" id="eversion-canvas-2"></div>`,_=r`<div class="scrollyteller__foreground"></div>`;for(let m=0;m<p;m++){const s=y[m],k=r`<div class="scrollyteller__frame">
      ${s.text?Object.assign(r`<div class="scrollyteller__caption" style="${s.left?`left: ${s.left};`:""}${s.right?`right: ${s.right};`:""}${s.top?`top: ${s.top};`:""}${s.bottom?`bottom: ${s.bottom};`:""}"></div>`,{innerHTML:s.text}):""}
    </div>`;_.appendChild(k)}v.appendChild(C),o.appendChild(v),o.appendChild(_),x(o),await new Promise(m=>setTimeout(m,100));const d=document.createElement("canvas");d.style.cssText="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; cursor: grab;",C.appendChild(d);const S=Math.min(1.5,window.devicePixelRatio);d.width=Math.floor(C.offsetWidth*S),d.height=Math.floor(C.offsetHeight*S);const B=d.getContext("webgpu");B.configure({device:g,format:E});const R=H(d,{distance:6,near:.1,far:10,theta:.4,phi:.1,wheel:!1,touch:!1}),I=$(g,E,P);let f=!0,n=0;const V=W(()=>{if(!A())return;const s=T(),k=Math.abs(s-n)>1e-4;n+=(s-n)*.1,L.setPosition(n*p);const O=L.getState(),D=d.offsetWidth/d.offsetHeight,j=D>1?1:D;if(!f&&!R.dirty&&!k)return;const Q=d.width,U=d.height,G={...O,scale:O.scale*j,near:.1,far:10,pixelRatio:S,opacity:.85,peelLayers:4};I.render(B,G,R,Q,U),f=!1});window.addEventListener("resize",F),q.then(()=>{V.cancel(),window.removeEventListener("resize",F),R.destroy()})}},inputs:["createSequencer","linear","html","display","device","canvasFormat","createCameraController","createRenderer","shaderCodes","createFrameLoop","invalidation"],outputs:[],output:void 0,assets:void 0,autodisplay:!1,autoview:void 0,automutable:void 0});
