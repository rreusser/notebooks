import{packLSAOUniforms as _}from"./lsao-pipeline-DMZya29M.js";async function C(U){const{device:r,pipeline:A,bindGroupLayout:h,targetData:l,parentLevels:c,levelInfo:B,tileSize:n,pixelSize:y,workgroupSize:z=128,directions:s=[[1,0],[-1,0],[0,1],[0,-1]]}=U,E=1,u=c.length;if(u<1||u>4)throw new Error(`numLevels must be 1-4, got ${u}`);const g=n+2*E,S=n*n;if(l.length!==g*g)throw new Error(`Target data size mismatch: expected ${g}Ã—${g}, got ${l.length}`);for(let e=0;e<u;e++){const t=B[e].bufferSize*B[e].bufferSize;if(c[e].length!==t)throw new Error(`Parent level ${e} size mismatch: expected ${t}, got ${c[e].length}`)}const p=r.createBuffer({size:l.byteLength,label:"Target terrain buffer",usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Float32Array(p.getMappedRange()).set(l),p.unmap();const a=[];for(let e=0;e<4;e++)if(e<u){const t=c[e],f=r.createBuffer({size:t.byteLength,label:`Parent level ${e} buffer`,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Float32Array(f.getMappedRange()).set(t),f.unmap(),a.push(f)}else{const f=r.createBuffer({size:256*Float32Array.BYTES_PER_ELEMENT,label:`Parent level ${e} buffer (dummy)`,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Float32Array(f.getMappedRange()).fill(0),f.unmap(),a.push(f)}const o=r.createBuffer({size:S*Float32Array.BYTES_PER_ELEMENT,label:"AO output buffer",usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Float32Array(o.getMappedRange()).fill(0),o.unmap();const d=256,P=r.createBuffer({size:d*s.length,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),G=1/s.length;for(let e=0;e<s.length;e++){const t=_({tileSize:[n,n],step:s[e],buffer:E,pixelSize:y,normalization:G,levels:B});r.queue.writeBuffer(P,e*d,t)}const T=r.createBindGroup({layout:h,label:"Multi-level LSAO bind group",entries:[{binding:0,resource:{buffer:P,offset:0,size:d}},{binding:1,resource:{buffer:p}},{binding:2,resource:{buffer:o}},{binding:3,resource:{buffer:a[0]}},{binding:4,resource:{buffer:a[1]}},{binding:5,resource:{buffer:a[2]}},{binding:6,resource:{buffer:a[3]}}]}),b=r.createCommandEncoder({label:"LSAO encoder"});b.clearBuffer(o);const m=b.beginComputePass({label:"LSAO compute pass"});m.setPipeline(A);const M=-u,O=Math.floor(n*(1+Math.pow(2,Math.abs(M)))),w=Math.ceil(O/z);for(let e=0;e<s.length;e++)m.setBindGroup(0,T,[e*d]),m.dispatchWorkgroups(w);m.end();const i=r.createBuffer({size:S*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,label:"Staging buffer"});b.copyBufferToBuffer(o,0,i,0,S*Float32Array.BYTES_PER_ELEMENT),r.queue.submit([b.finish()]),await r.queue.onSubmittedWorkDone(),await i.mapAsync(GPUMapMode.READ);const R=new Float32Array(i.getMappedRange()).slice();return i.unmap(),p.destroy(),a.forEach(e=>e.destroy()),o.destroy(),P.destroy(),i.destroy(),R}export{C as computeLSAO};
