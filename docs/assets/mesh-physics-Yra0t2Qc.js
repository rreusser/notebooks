class F{constructor(s){this.mesh=s,this.gradient=null,this.k=1,this.l0=1,this.theta0=150,this.kBend=.3,this.kTorsion=.1,this.gamma=.1,this.frozenVertex=-1,this.frozenVertex2=-1}_ensureGradient(){const s=this.mesh.vertexCount*3;(!this.gradient||this.gradient.length<s)&&(this.gradient=new Float64Array(Math.max(s,256))),this.gradient.fill(0,0,this.mesh.vertexCount*3)}iterate(){this.mesh.vertexCount!==0&&(this._ensureGradient(),this.k>0&&this._computeAxialGradient(),this.kBend>0&&this._computeDihedralGradient(),this.kTorsion>0&&this._computeTorsionalGradient(),this._applyGradient())}_computeAxialGradient(){const s=this.mesh,e=s.positions,o=this.gradient,a=this.k,r=this.l0;for(let n=0;n<s.edgeCount;n++){const c=n*2,t=s.edges[c],i=s.edges[c+1],d=t*3,h=i*3,l=e[d]-e[h],u=e[d+1]-e[h+1],v=e[d+2]-e[h+2],b=Math.sqrt(l*l+u*u+v*v);if(b<1e-10)continue;const f=a*(1-r/b),G=f*l,V=f*u,q=f*v;o[d]+=G,o[d+1]+=V,o[d+2]+=q,o[h]-=G,o[h+1]-=V,o[h+2]-=q}}_computeDihedralGradient(){const s=this.mesh;s.positions,this.gradient;const e=this.kBend*this.l0*this.l0,o=Math.cos(this.theta0*Math.PI/180);for(let a=0;a<s.vertexCount;a++){const r=a*3,n=s.neighbors[r],c=s.neighbors[r+1],t=s.neighbors[r+2];n!==-1&&c!==-1&&this._accumulateDihedralGradient(a,n,c,e,o),c!==-1&&t!==-1&&this._accumulateDihedralGradient(a,c,t,e,o),t!==-1&&n!==-1&&this._accumulateDihedralGradient(a,t,n,e,o)}}_accumulateDihedralGradient(s,e,o,a,r){const n=this.mesh.positions,c=this.gradient,t=s*3,i=e*3,d=o*3,h=n[i]-n[t],l=n[i+1]-n[t+1],u=n[i+2]-n[t+2],v=n[d]-n[t],b=n[d+1]-n[t+1],f=n[d+2]-n[t+2],G=Math.sqrt(h*h+l*l+u*u),V=Math.sqrt(v*v+b*b+f*f);if(G<1e-10||V<1e-10)return;const k=(h*v+l*b+u*f)/(G*V),y=a*2*(k-r)/(G*V),z=G/V;let m=y*(v-k/z*h),_=y*(b-k/z*l),g=y*(f-k/z*u),B=y*(h-k*z*v),A=y*(l-k*z*b),E=y*(u-k*z*f);c[t]-=m+B,c[t+1]-=_+A,c[t+2]-=g+E,c[i]+=m,c[i+1]+=_,c[i+2]+=g,c[d]+=B,c[d+1]+=A,c[d+2]+=E}_computeTorsionalGradient(){const s=this.mesh;for(let e=0;e<s.edgeCount;e++){const o=s.getTorsionVertices(e);o&&this._accumulateTorsionalGradient(o)}}_accumulateTorsionalGradient(s){const{a:e,b:o,c:a,d:r,e:n,f:c}=s,t=this.mesh.positions,i=this.gradient,d=this.kTorsion*this.l0*this.l0,h=e*3,l=o*3,u=a*3,v=r*3,b=n*3,f=c*3,G=[t[h],t[h+1],t[h+2]],V=[t[l],t[l+1],t[l+2]],q=[t[u],t[u+1],t[u+2]],k=[t[v],t[v+1],t[v+2]],y=[t[b],t[b+1],t[b+2]],z=[t[f],t[f+1],t[f+2]],m=this._unitVector(G,V),_=this._unitVector(q,k),g=this._unitVector(y,z);if(!m||!_||!g)return;const B=m.len,A=_.len,E=g.len,T=this._dot(_.v,g.v),p=this._dot(m.v,g.v),x=this._dot(m.v,_.v),P=(T-x*p)*d,M=[m.v[0]*(-2*x*p)+_.v[0]*p+g.v[0]*x,m.v[1]*(-2*x*p)+_.v[1]*p+g.v[1]*x,m.v[2]*(-2*x*p)+_.v[2]*p+g.v[2]*x];this._scaleVec(M,-2*P/B);const C=[_.v[0]*(T-p*x)-g.v[0]+m.v[0]*p,_.v[1]*(T-p*x)-g.v[1]+m.v[1]*p,_.v[2]*(T-p*x)-g.v[2]+m.v[2]*p];this._scaleVec(C,-2*P/A);const D=[g.v[0]*(T-x*p)-_.v[0]+m.v[0]*x,g.v[1]*(T-x*p)-_.v[1]+m.v[1]*x,g.v[2]*(T-x*p)-_.v[2]+m.v[2]*x];this._scaleVec(D,-2*P/E),i[h]+=M[0],i[h+1]+=M[1],i[h+2]+=M[2],i[l]-=M[0],i[l+1]-=M[1],i[l+2]-=M[2],i[u]+=C[0],i[u+1]+=C[1],i[u+2]+=C[2],i[v]-=C[0],i[v+1]-=C[1],i[v+2]-=C[2],i[b]+=D[0],i[b+1]+=D[1],i[b+2]+=D[2],i[f]-=D[0],i[f+1]-=D[1],i[f+2]-=D[2]}_unitVector(s,e){const o=e[0]-s[0],a=e[1]-s[1],r=e[2]-s[2],n=Math.sqrt(o*o+a*a+r*r);return n<1e-10?null:{v:[o/n,a/n,r/n],len:n}}_dot(s,e){return s[0]*e[0]+s[1]*e[1]+s[2]*e[2]}_scaleVec(s,e){s[0]*=e,s[1]*=e,s[2]*=e}_applyGradient(){const s=this.mesh,e=s.positions,o=this.gradient,a=this.gamma;for(let r=0;r<s.vertexCount;r++){if(r===this.frozenVertex||r===this.frozenVertex2)continue;const n=r*3;e[n]-=o[n]*a,e[n+1]-=o[n+1]*a,e[n+2]-=o[n+2]*a}}computeEdgeStrain(s){const e=this.mesh,o=s*2,a=e.edges[o],r=e.edges[o+1],n=a*3,c=r*3,t=e.positions,i=t[n]-t[c],d=t[n+1]-t[c+1],h=t[n+2]-t[c+2];return Math.sqrt(i*i+d*d+h*h)/this.l0-1}}export{F as MeshPhysics,F as default};
